{"version":3,"file":"CustomVisuals.js","sources":["webpack:///webpack/bootstrap 7cb12f289ad18bd92435","webpack:///./src/Clients/CustomVisuals/module.ts","webpack:///./src/Clients/CustomVisuals \\.less$","webpack:///./src/Clients/CustomVisuals/styles/styles.less","webpack:///./src/Clients/CustomVisuals/visuals/asterPlot/visual/styles/asterPlot.less","webpack:///./src/Clients/CustomVisuals/visuals/bulletChart/visual/styles/bulletChart.less","webpack:///./src/Clients/CustomVisuals/visuals/chicletSlicer/visual/styles/chicletSlicer.less","webpack:///./src/Clients/CustomVisuals/visuals/chordChart/visual/styles/chordChart.less","webpack:///./src/Clients/CustomVisuals/visuals/dotPlot/visual/styles/dotPlot.less","webpack:///./src/Clients/CustomVisuals/visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less","webpack:///./src/Clients/CustomVisuals/visuals/forceGraph/visual/styles/forceGraph.less","webpack:///./src/Clients/CustomVisuals/visuals/gantt/visual/styles/gantt.less","webpack:///./src/Clients/CustomVisuals/visuals/globeMap/visual/styles/globeMap.less","webpack:///./src/Clients/CustomVisuals/visuals/histogram/visual/styles/histogram.less","webpack:///./src/Clients/CustomVisuals/visuals/lineDotChart/visual/styles/lineDotChart.less","webpack:///./src/Clients/CustomVisuals/visuals/mekkoChart/visual/styles/mekkoChart.less","webpack:///./src/Clients/CustomVisuals/visuals/radarChart/visual/styles/radarChart.less","webpack:///./src/Clients/CustomVisuals/visuals/sankeyDiagram/visual/styles/sankeyDiagram.less","webpack:///./src/Clients/CustomVisuals/visuals/streamGraph/visual/styles/streamGraph.less","webpack:///./src/Clients/CustomVisuals/visuals/sunburst/visual/styles/sunburst.less","webpack:///./src/Clients/CustomVisuals/visuals/timeline/visual/styles/timeline.less","webpack:///./src/Clients/CustomVisuals/visuals/tornadoChart/visual/styles/tornadoChart.less","webpack:///./src/Clients/CustomVisuals/visuals/wordCloud/visual/styles/wordCloud.less","webpack:///./src/Clients/CustomVisuals/visuals/asterPlot/visual/asterPlot.ts","webpack:///./src/Clients/CustomVisuals/visuals/tornadoChart/visual/tornadoChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/mekkoChart/visual/mekkoChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/sankeyDiagram/visual/sankeyDiagram.ts","webpack:///./src/Clients/CustomVisuals/visuals/bulletChart/visual/bulletChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/wordCloud/visual/wordCloud.ts","webpack:///./src/Clients/CustomVisuals/visuals/chicletSlicer/visual/chicletSlicer.ts","webpack:///./src/Clients/CustomVisuals/visuals/chordChart/visual/chordChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/enhancedScatterChart/visual/enhancedScatterChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/globeMap/visual/globeMap.ts","webpack:///./src/Clients/CustomVisuals/visuals/radarChart/visual/radarChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/histogram/visual/histogram.ts","webpack:///./src/Clients/CustomVisuals/visuals/dotPlot/visual/dotPlot.ts","webpack:///./src/Clients/CustomVisuals/visuals/forceGraph/visual/forceGraph.ts","webpack:///./src/Clients/CustomVisuals/visuals/gantt/visual/gantt.ts","webpack:///./src/Clients/CustomVisuals/visuals/timeline/visual/timeline.ts","webpack:///./src/Clients/CustomVisuals/visuals/streamGraph/visual/streamGraph.ts","webpack:///./src/Clients/CustomVisuals/visuals/lineDotChart/visual/lineDotChart.ts","webpack:///./src/Clients/CustomVisuals/visuals/sunburst/visual/sunburst.ts","webpack:///./src/Clients/CustomVisuals/plugins.ts","webpack:///./src/Clients/CustomVisuals/services/customVisualPluginService.ts"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7cb12f289ad18bd92435\n **/","/// <reference path=\"./_references.ts\"/>\r\n\r\nwindow.jsCommon = window.jsCommon || {};\r\nwindow.powerbi = window.powerbi || {};\r\nwindow.debug = window.debug || {};\r\nwindow.InJs = window.InJs || {};\r\n\r\n// require(\"../Visuals/module.ts\");\r\n// require(\"../VisualsCommon/module.ts\");\r\n// require(\"../VisualsContracts/module.ts\");\r\n// require(\"../VisualsData/module.ts\");\r\n\r\nrequireAll(require.context(\"./\", true, /\\.less$/));\r\n\r\nrequire(\"./visuals/asterPlot/visual/asterPlot.ts\");\r\nrequire(\"./visuals/tornadoChart/visual/tornadoChart.ts\");\r\nrequire(\"./visuals/mekkoChart/visual/mekkoChart.ts\");\r\nrequire(\"./visuals/sankeyDiagram/visual/sankeyDiagram.ts\");\r\nrequire(\"./visuals/bulletChart/visual/bulletChart.ts\");\r\nrequire(\"./visuals/wordCloud/visual/wordCloud.ts\");\r\nrequire(\"./visuals/chicletSlicer/visual/chicletSlicer.ts\");\r\nrequire(\"./visuals/chordChart/visual/chordChart.ts\");\r\nrequire(\"./visuals/enhancedScatterChart/visual/enhancedScatterChart.ts\");\r\nrequire(\"./visuals/globeMap/visual/globeMap.ts\");\r\nrequire(\"./visuals/radarChart/visual/radarChart.ts\");\r\nrequire(\"./visuals/histogram/visual/histogram.ts\");\r\nrequire(\"./visuals/dotPlot/visual/dotPlot.ts\");\r\nrequire(\"./visuals/forceGraph/visual/forceGraph.ts\");\r\nrequire(\"./visuals/gantt/visual/gantt.ts\");\r\nrequire(\"./visuals/timeline/visual/timeline.ts\");\r\nrequire(\"./visuals/streamGraph/visual/streamGraph.ts\");\r\nrequire(\"./visuals/lineDotChart/visual/lineDotChart.ts\");\r\nrequire(\"./visuals/sunburst/visual/sunburst.ts\");\r\nrequire(\"./plugins.ts\");\r\nrequire(\"./services/customVisualPluginService.ts\");\r\n\r\nfunction requireAll(requireContext) {\r\n  return requireContext.keys().map(requireContext);\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/module.ts\n **/","var map = {\n\t\"./styles/styles.less\": 15,\n\t\"./visuals/asterPlot/visual/styles/asterPlot.less\": 17,\n\t\"./visuals/bulletChart/visual/styles/bulletChart.less\": 18,\n\t\"./visuals/chicletSlicer/visual/styles/chicletSlicer.less\": 19,\n\t\"./visuals/chordChart/visual/styles/chordChart.less\": 20,\n\t\"./visuals/dotPlot/visual/styles/dotPlot.less\": 21,\n\t\"./visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less\": 22,\n\t\"./visuals/forceGraph/visual/styles/forceGraph.less\": 23,\n\t\"./visuals/gantt/visual/styles/gantt.less\": 24,\n\t\"./visuals/globeMap/visual/styles/globeMap.less\": 25,\n\t\"./visuals/histogram/visual/styles/histogram.less\": 26,\n\t\"./visuals/lineDotChart/visual/styles/lineDotChart.less\": 27,\n\t\"./visuals/mekkoChart/visual/styles/mekkoChart.less\": 28,\n\t\"./visuals/radarChart/visual/styles/radarChart.less\": 29,\n\t\"./visuals/sankeyDiagram/visual/styles/sankeyDiagram.less\": 30,\n\t\"./visuals/streamGraph/visual/styles/streamGraph.less\": 31,\n\t\"./visuals/sunburst/visual/styles/sunburst.less\": 32,\n\t\"./visuals/timeline/visual/styles/timeline.less\": 33,\n\t\"./visuals/tornadoChart/visual/styles/tornadoChart.less\": 34,\n\t\"./visuals/wordCloud/visual/styles/wordCloud.less\": 35\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 14;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals \\.less$\n ** module id = 14\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/styles/styles.less\n ** module id = 15\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/asterPlot/visual/styles/asterPlot.less\n ** module id = 17\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/bulletChart/visual/styles/bulletChart.less\n ** module id = 18\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/chicletSlicer/visual/styles/chicletSlicer.less\n ** module id = 19\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/chordChart/visual/styles/chordChart.less\n ** module id = 20\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/dotPlot/visual/styles/dotPlot.less\n ** module id = 21\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less\n ** module id = 22\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/forceGraph/visual/styles/forceGraph.less\n ** module id = 23\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/gantt/visual/styles/gantt.less\n ** module id = 24\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/globeMap/visual/styles/globeMap.less\n ** module id = 25\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/histogram/visual/styles/histogram.less\n ** module id = 26\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/lineDotChart/visual/styles/lineDotChart.less\n ** module id = 27\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/mekkoChart/visual/styles/mekkoChart.less\n ** module id = 28\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/radarChart/visual/styles/radarChart.less\n ** module id = 29\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/sankeyDiagram/visual/styles/sankeyDiagram.less\n ** module id = 30\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/streamGraph/visual/styles/streamGraph.less\n ** module id = 31\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/sunburst/visual/styles/sunburst.less\n ** module id = 32\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/timeline/visual/styles/timeline.less\n ** module id = 33\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/tornadoChart/visual/styles/tornadoChart.less\n ** module id = 34\n ** module chunks = 0\n **/","// removed by extract-text-webpack-plugin\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/Clients/CustomVisuals/visuals/wordCloud/visual/styles/wordCloud.less\n ** module id = 35\n ** module chunks = 0\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ArcDescriptor = D3.Layout.ArcDescriptor;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n    import ValueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    const AsterPlotVisualClassName: string = 'asterPlot';\r\n    const AsterPlotLegendObjectName: string = 'legend';\r\n    const AsterDefaultOuterLineThickness: number = 1;\r\n    const AsterDefaultLabelFill: Fill = { solid: { color: '#333' } };\r\n    const AsterDefaultLegendFontSize: number = 8;\r\n    const AsterRadiusRatio: number = 0.9;\r\n    const AsterConflictRatio = 0.9;\r\n    const MaxPrecision: number = 17;\r\n\r\n    export interface AsterData {\r\n        dataPoints: AsterDataPoint[];\r\n        highlightedDataPoints?: AsterDataPoint[];\r\n        legendData: LegendData;\r\n        valueFormatter: IValueFormatter;\r\n        legendSettings: AsterPlotLegendSettings;\r\n        labelSettings: VisualDataLabelsSettings;\r\n        showOuterLine: boolean;\r\n        outerLineThickness: number;\r\n    }\r\n\r\n    export interface AsterPlotLegendSettings {\r\n        show: boolean;\r\n        position: string;\r\n        showTitle: boolean;\r\n        labelColor: string;\r\n        titleText: string;\r\n        fontSize: number;\r\n    }\r\n\r\n    export interface AsterArcDescriptor extends ArcDescriptor {\r\n        isLabelHasConflict?: boolean;\r\n    }\r\n\r\n    export interface AsterDataPoint extends SelectableDataPoint {\r\n        color: string;\r\n        sliceHeight: number;\r\n        sliceWidth: number;\r\n        label: string;\r\n        highlight?: boolean;\r\n        tooltipInfo: TooltipDataItem[];\r\n        labelFontSize: string;\r\n    }\r\n\r\n    export interface AsterPlotBehaviorOptions {\r\n        selection: D3.Selection;\r\n        highlightedSelection: D3.Selection;\r\n        clearCatcher: D3.Selection;\r\n        interactivityService: IInteractivityService;\r\n    }\r\n\r\n    class AsterPlotWebBehavior implements IInteractiveBehavior {\r\n        private selection: D3.Selection;\r\n        private highlightedSelection: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private interactivityService: IInteractivityService;\r\n\r\n        public bindEvents(options: AsterPlotBehaviorOptions, selectionHandler: ISelectionHandler) {\r\n            this.selection = options.selection;\r\n            this.highlightedSelection = options.highlightedSelection;\r\n            this.clearCatcher = options.clearCatcher;\r\n            this.interactivityService = options.interactivityService;\r\n\r\n            this.selection.on('click', (d, i: number) => {\r\n                selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\r\n            });\r\n\r\n            if (this.highlightedSelection)\r\n                this.highlightedSelection.on('click', (d, i: number) => {\r\n                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);\r\n                });\r\n\r\n            this.clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            let hasHighlights = this.interactivityService.hasSelection();\r\n            this.selection.style(\"fill-opacity\", (d) => {\r\n                return ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);\r\n            });\r\n        }\r\n    }\r\n\r\n    export class AsterPlotWarning implements IVisualWarning {\r\n        private message: string;\r\n        constructor(message: string) {\r\n            this.message = message;\r\n        }\r\n\r\n        public get code(): string {\r\n            return \"AsterPlotWarning\";\r\n        }\r\n\r\n        public getMessages(resourceProvider: jsCommon.IStringResourceProvider): IVisualErrorMessage {\r\n            return {\r\n                message: this.message,\r\n                title: resourceProvider.get(\"\"),\r\n                detail: resourceProvider.get(\"\")\r\n            };\r\n        }\r\n    }\r\n\r\n    export class AsterPlot implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    displayName: 'Category',\r\n                    name: 'Category',\r\n                    kind: powerbi.VisualDataRoleKind.Grouping,\r\n                },\r\n                {\r\n                    displayName: 'Y Axis',\r\n                    name: 'Y',\r\n                    kind: powerbi.VisualDataRoleKind.Measure,\r\n                },\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Y': { max: 2 } }\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        select: [{ bind: { to: 'Y' } }]\r\n                    },\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                legend: {\r\n                    displayName: 'Legend',\r\n                    description: 'Display legend options',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: 'Position',\r\n                            description: 'Select the location for the legend',\r\n                            type: { enumeration: legendPosition.type }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: 'Title',\r\n                            description: 'Display a title for legend symbols',\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: 'Legend Name',\r\n                            description: 'Title text',\r\n                            type: { text: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                label: {\r\n                    displayName: 'Center Label',\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: 'Fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: 'Detail Labels',\r\n                    properties: {\r\n                        show: {\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: 'Display Units',\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: 'Decimal Places',\r\n                            placeHolderText: 'Auto',\r\n                            type: { numeric: true },\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } },\r\n                        },\r\n                    },\r\n                },\r\n                outerLine: {\r\n                    displayName: 'Outer line',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        thickness: {\r\n                            displayName: 'Thickness',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            supportsHighlight: true,\r\n        };\r\n\r\n        private static Properties: any = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\r\n            },\r\n            dataPoint: {\r\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\r\n            },\r\n            legend: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'show' },\r\n                position: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'position' },\r\n                showTitle: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'showTitle' },\r\n                titleText: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'titleText' },\r\n                labelColor: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'labelColor' },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: AsterPlotLegendObjectName, propertyName: 'fontSize' },\r\n            },\r\n            label: {\r\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'label', propertyName: 'fill' },\r\n            },\r\n            labels: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\r\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\r\n                labelDisplayUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelDisplayUnits' },\r\n                labelPrecision: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelPrecision' },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\r\n            },\r\n            outerLine: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'outerLine', propertyName: 'show' },\r\n                thickness: <DataViewObjectPropertyIdentifier>{ objectName: 'outerLine', propertyName: 'thickness' },\r\n            }\r\n        };\r\n\r\n        private static AsterSlice: ClassAndSelector = createClassAndSelector('asterSlice');\r\n        private static AsterHighlightedSlice: ClassAndSelector = createClassAndSelector('asterHighlightedSlice');\r\n        private static OuterLine: ClassAndSelector = createClassAndSelector('outerLine');\r\n        private static labelGraphicsContextClass: ClassAndSelector = createClassAndSelector('labels');\r\n        private static linesGraphicsContextClass: ClassAndSelector = createClassAndSelector('lines');\r\n        private static CenterLabelClass: ClassAndSelector = createClassAndSelector('centerLabel');\r\n        private static CenterTextFontHeightCoefficient = 0.4;\r\n        private static CenterTextFontWidthCoefficient = 1.9;\r\n\r\n        private margin: IMargin = {\r\n            top: 10,\r\n            right: 10,\r\n            bottom: 15,\r\n            left: 10\r\n        };\r\n\r\n        private svg: D3.Selection;\r\n        private mainGroupElement: D3.Selection;\r\n        private mainLabelsElement: D3.Selection;\r\n        private centerText: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private colors: IDataColorPalette;\r\n        private dataView: DataView;\r\n        private hostService: IVisualHostServices;\r\n        private interactivityService: IInteractivityService;\r\n        private legend: ILegend;\r\n        private data: AsterData;\r\n        private currentViewport: IViewport;\r\n        private behavior: IInteractiveBehavior;\r\n        private hasHighlights: boolean;\r\n\r\n        private getDefaultAsterData(): AsterData {\r\n            return <AsterData>{\r\n                dataPoints: [],\r\n                highlightedDataPoints: [],\r\n                legendData: <LegendData>{\r\n                    dataPoints: [],\r\n                    title: null,\r\n                    fontSize: AsterDefaultLegendFontSize,\r\n                    labelColor: LegendData.DefaultLegendLabelFillColor\r\n                },\r\n                legendSettings: {\r\n                    show: false,\r\n                    position: 'Top',\r\n                    showTitle: true,\r\n                    labelColor: LegendData.DefaultLegendLabelFillColor,\r\n                    titleText: '',\r\n                    fontSize: AsterDefaultLegendFontSize,\r\n                },\r\n                valueFormatter: null,\r\n                labelSettings: {\r\n                    show: false,\r\n                    displayUnits: 0,\r\n                    precision: dataLabelUtils.defaultLabelPrecision,\r\n                    labelColor: dataLabelUtils.defaultLabelColor,\r\n                    fontSize: dataLabelUtils.DefaultFontSizeInPt,\r\n                },\r\n                showOuterLine: false,\r\n                outerLineThickness: AsterDefaultOuterLineThickness,\r\n            };\r\n        }\r\n\r\n        public converter(dataView: DataView, colors: IDataColorPalette): AsterData {\r\n            let asterDataResult: AsterData = this.getDefaultAsterData();\r\n            if (!this.dataViewContainsCategory(dataView) || dataView.categorical.categories.length !== 1)\r\n                return asterDataResult;\r\n\r\n            let catDv: DataViewCategorical = dataView.categorical;\r\n            let cat = catDv.categories[0];\r\n            let catSource = cat.source;\r\n            let catValues = cat.values;\r\n            let values = catDv.values;\r\n            let catObjects: DataViewObjects[] = cat.objects;\r\n            let colorHelper: ColorHelper = new ColorHelper(colors, AsterPlot.Properties.dataPoint.fill);\r\n\r\n            let hasHighlights: boolean = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);\r\n\r\n            if (dataView.metadata || dataView.metadata.objects) {\r\n                let objects: DataViewObjects = dataView.metadata.objects;\r\n                asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings);\r\n                this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings);\r\n                asterDataResult.showOuterLine = DataViewObjects.getValue<boolean>(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine);\r\n                asterDataResult.outerLineThickness = DataViewObjects.getValue<number>(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);\r\n            }\r\n\r\n            let labelSettings: VisualDataLabelsSettings = asterDataResult.labelSettings;\r\n            if (!catValues || catValues.length < 1 || !values || values.length < 1)\r\n                return asterDataResult;\r\n\r\n            let formatStringProp = AsterPlot.Properties.general.formatString;\r\n            let maxValue: number = Math.max(d3.min(values[0].values));\r\n            let minValue: number = Math.min(0, d3.min(values[0].values));\r\n            let labelFormatter: IValueFormatter = ValueFormatter.create({\r\n                format: ValueFormatter.getFormatString(values[0].source, formatStringProp),\r\n                precision: labelSettings.precision,\r\n                value: (labelSettings.displayUnits === 0) && (maxValue != null) ? maxValue : labelSettings.displayUnits,\r\n            });\r\n            let categorySourceFormatString = valueFormatter.getFormatString(catSource, formatStringProp);\r\n            let fontSizeInPx: string = PixelConverter.fromPoint(labelSettings.fontSize);\r\n\r\n            for (let i = 0; i < catValues.length; i++) {\r\n                let formattedCategoryValue = valueFormatter.format(catValues[i], categorySourceFormatString);\r\n                let currentValue = values[0].values[i];\r\n\r\n                let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(\r\n                    formatStringProp,\r\n                    catDv,\r\n                    formattedCategoryValue,\r\n                    currentValue,\r\n                    null,\r\n                    null,\r\n                    0);\r\n\r\n                if (values.length > 1) {\r\n                    let toolTip: TooltipDataItem = TooltipBuilder.createTooltipInfo(\r\n                        formatStringProp,\r\n                        catDv,\r\n                        formattedCategoryValue,\r\n                        values[1].values[i],\r\n                        null,\r\n                        null,\r\n                        1)[1];\r\n                    if (toolTip)\r\n                        tooltipInfo.push(toolTip);\r\n\r\n                    currentValue += values[1].values[i];\r\n                }\r\n\r\n                let identity: DataViewScopeIdentity = cat.identity[i];\r\n                let color: string = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key);\r\n                let selector: SelectionId = SelectionId.createWithId(identity);\r\n                let sliceWidth: number = Math.max(0, values.length > 1 ? values[1].values[i] : 1);\r\n\r\n                asterDataResult.dataPoints.push({\r\n                    sliceHeight: values[0].values[i] - minValue,\r\n                    sliceWidth: sliceWidth,\r\n                    label: labelFormatter.format(currentValue),\r\n                    color: color,\r\n                    identity: selector,\r\n                    selected: false,\r\n                    tooltipInfo: tooltipInfo,\r\n                    labelFontSize: fontSizeInPx,\r\n                    highlight: false,\r\n                });\r\n                \r\n                // Handle legend data\r\n                if (asterDataResult.legendSettings.show)\r\n                    asterDataResult.legendData.dataPoints.push({\r\n                        label: catValues[i],\r\n                        color: color,\r\n                        icon: LegendIcon.Box,\r\n                        selected: false,\r\n                        identity: selector\r\n                    });\r\n                \r\n                // Handle highlights\r\n                if (hasHighlights) {\r\n                    let highlightIdentity: SelectionId = SelectionId.createWithHighlight(selector);\r\n                    let notNull: boolean = values[0].highlights[i] != null;\r\n                    currentValue = notNull ? values[0].highlights[i] : 0;\r\n\r\n                    tooltipInfo = TooltipBuilder.createTooltipInfo(\r\n                        formatStringProp,\r\n                        catDv,\r\n                        formattedCategoryValue,\r\n                        currentValue,\r\n                        null,\r\n                        null,\r\n                        0);\r\n\r\n                    if (values.length > 1) {\r\n                        let toolTip: TooltipDataItem = TooltipBuilder.createTooltipInfo(\r\n                            formatStringProp,\r\n                            catDv,\r\n                            formattedCategoryValue,\r\n                            values[1].highlights[i],\r\n                            null,\r\n                            null,\r\n                            1)[1];\r\n                        if (toolTip)\r\n                            tooltipInfo.push(toolTip);\r\n\r\n                        currentValue += values[1].highlights[i] !== null ? values[1].highlights[i] : 0;\r\n                    }\r\n\r\n                    asterDataResult.highlightedDataPoints.push({\r\n                        sliceHeight: notNull ? values[0].highlights[i] - minValue : null,\r\n                        sliceWidth: Math.max(0, (values.length > 1 && values[1].highlights[i] !== null) ? values[1].highlights[i] : sliceWidth),\r\n                        label: labelFormatter.format(currentValue),\r\n                        color: color,\r\n                        identity: highlightIdentity,\r\n                        selected: false,\r\n                        tooltipInfo: tooltipInfo,\r\n                        labelFontSize: fontSizeInPx,\r\n                        highlight: true,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return asterDataResult;\r\n        }\r\n\r\n        private dataViewContainsCategory(dataView: DataView) {\r\n            return dataView &&\r\n                dataView.categorical &&\r\n                dataView.categorical.values &&\r\n                dataView.categorical.categories &&\r\n                dataView.categorical.categories[0];\r\n        }\r\n\r\n        private getLabelSettings(objects: DataViewObjects, labelSettings: VisualDataLabelsSettings): VisualDataLabelsSettings {\r\n            let asterPlotLabelsProperties = AsterPlot.Properties;\r\n            let precision = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);\r\n            labelSettings.precision = precision === undefined ? precision : Math.min(precision, MaxPrecision);\r\n            labelSettings.show = DataViewObjects.getValue<boolean>(objects, asterPlotLabelsProperties.labels.show, labelSettings.show);\r\n            labelSettings.fontSize = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize);\r\n            labelSettings.displayUnits = DataViewObjects.getValue<number>(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);\r\n            let colorHelper: ColorHelper = new ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);\r\n            labelSettings.labelColor = colorHelper.getColorForMeasure(objects, \"\");\r\n\r\n            return labelSettings;\r\n        }\r\n\r\n        private updateLegendSettings(objects: DataViewObjects, catSource: DataViewMetadataColumn, legendSettings: AsterPlotLegendSettings): void {\r\n            let legendProperties = AsterPlot.Properties.legend;\r\n\r\n            legendSettings.show = DataViewObjects.getValue<boolean>(objects, legendProperties.show, legendSettings.show);\r\n            legendSettings.position = DataViewObjects.getValue<string>(objects, legendProperties.position, legendSettings.position);\r\n            legendSettings.showTitle = DataViewObjects.getValue<boolean>(objects, legendProperties.showTitle, legendSettings.showTitle);\r\n            let titleText = DataViewObjects.getValue<string>(objects, legendProperties.titleText, '');\r\n            legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText;\r\n            legendSettings.labelColor = <string>DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor);\r\n            legendSettings.fontSize = DataViewObjects.getValue<number>(objects, legendProperties.fontSize, legendSettings.fontSize);\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            this.hostService = options.host;\r\n            let element: JQuery = options.element;\r\n            let svg: D3.Selection = this.svg = d3.select(element.get(0))\r\n                .append('svg')\r\n                .classed(AsterPlotVisualClassName, true)\r\n                .style('position', 'absolute');\r\n\r\n            this.colors = options.style.colorPalette.dataColors;\r\n            this.mainGroupElement = svg.append('g');\r\n            this.mainLabelsElement = svg.append('g');\r\n            this.behavior = new AsterPlotWebBehavior();\r\n            this.clearCatcher = appendClearCatcher(this.mainGroupElement);\r\n            let interactivity = options.interactivity;\r\n            this.interactivityService = createInteractivityService(this.hostService);\r\n            this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options.dataViews || !options.dataViews[0]) return; // or clear the view, display an error, etc.\r\n\r\n            let duration = options.suppressAnimations ? 0 : AnimatorCommon.MinervaAnimationDuration;\r\n\r\n            this.currentViewport = {\r\n                height: Math.max(0, options.viewport.height),\r\n                width: Math.max(0, options.viewport.width)\r\n            };\r\n\r\n            let dataView: DataView = this.dataView = options.dataViews[0];\r\n            let convertedData: AsterData = this.data = this.converter(dataView, this.colors);\r\n\r\n            if (!convertedData || !convertedData.dataPoints || convertedData.dataPoints.length === 0) {\r\n                this.clearData();\r\n                return;\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(convertedData.dataPoints);\r\n                this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints);\r\n            }\r\n\r\n            this.renderLegend(convertedData);\r\n            this.updateViewPortAccordingToLegend();\r\n\r\n            this.svg\r\n                .attr({\r\n                    height: Math.max(0, this.currentViewport.height),\r\n                    width: Math.max(0, this.currentViewport.width)\r\n                });\r\n\r\n            let margin: IMargin = this.margin;\r\n            let transformX: number = (this.currentViewport.width - margin.left) / 2;\r\n            let transformY: number = (this.currentViewport.height - margin.top) / 2;\r\n            this.mainGroupElement.attr('transform', SVGUtil.translate(transformX, transformY));\r\n            this.mainLabelsElement.attr('transform', SVGUtil.translate(transformX, transformY));\r\n            \r\n            // Move back the clearCatcher\r\n            this.clearCatcher.attr('transform', SVGUtil.translate(-transformX, -transformY));\r\n            \r\n            // Clear previous data\r\n            this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove();\r\n            this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove();\r\n            dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\r\n\r\n            let dataPoints = convertedData.dataPoints;\r\n            if (!dataPoints || dataPoints.length === 0)\r\n                return;\r\n\r\n            let selection: D3.UpdateSelection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);\r\n            let highlightedSelection: D3.UpdateSelection;\r\n\r\n            if (this.hasHighlights)\r\n                highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, true);\r\n\r\n            let interactivityService = this.interactivityService;\r\n\r\n            if (interactivityService) {\r\n                let behaviorOptions: AsterPlotBehaviorOptions = {\r\n                    selection: selection,\r\n                    highlightedSelection: highlightedSelection,\r\n                    clearCatcher: this.clearCatcher,\r\n                    interactivityService: this.interactivityService,\r\n                };\r\n                interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);\r\n            }\r\n        }\r\n\r\n        private renderArcsAndLabels(dataPoints: AsterDataPoint[], duration: number, labelSettings: VisualDataLabelsSettings, isHighlight: boolean = false): D3.UpdateSelection {\r\n            let margin: IMargin = this.margin;\r\n            let width: number = this.currentViewport.width - margin.left - margin.right;\r\n            let height: number = this.currentViewport.height - margin.top - margin.bottom;\r\n            let radius: number = Math.min(width, height) / 2;\r\n            let innerRadius: number = 0.3 * (labelSettings.show ? radius * AsterRadiusRatio : radius);\r\n            let maxScore: number = d3.max(dataPoints, d => d.sliceHeight);\r\n            let totalWeight: number = d3.sum(dataPoints, d => d.sliceWidth);\r\n            let hasSelection: boolean = this.interactivityService && this.interactivityService.hasSelection();\r\n            let hasHighlights: boolean = this.hasHighlights;\r\n\r\n            let pie: D3.Layout.PieLayout = d3.layout.pie()\r\n                .sort(null)\r\n                .value(d => (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight);\r\n\r\n            let arc: D3.Svg.Arc = d3.svg.arc()\r\n                .innerRadius(innerRadius)\r\n                .outerRadius(d => {\r\n                    let height: number = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore;\r\n                    //The chart should shrink if data labels are on\r\n                    let heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);\r\n                    // Prevent from data to be inside the inner radius\r\n                    return Math.max(heightIsLabelsOn, innerRadius);\r\n                });\r\n\r\n            let arcDescriptorDataPoints: ArcDescriptor[] = pie(dataPoints);\r\n            let classSelector: ClassAndSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice;\r\n\r\n            let selection = this.mainGroupElement.selectAll(classSelector.selector)\r\n                .data(arcDescriptorDataPoints, (d, idx) => d.data ? d.data.identity.getKey() : idx);\r\n\r\n            selection.enter()\r\n                .append('path')\r\n                .attr('stroke', '#333')\r\n                .classed(classSelector.class, true);\r\n\r\n            selection\r\n                .attr('fill', d => d.data.color)\r\n                .style(\"fill-opacity\", (d) => ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights))\r\n                .transition().duration(duration)\r\n                .attrTween('d', function (data) {\r\n                    if (!this.oldData) {\r\n                        this.oldData = data;\r\n                        return () => arc(data);\r\n                    }\r\n\r\n                    let interpolation = d3.interpolate(this.oldData, data);\r\n                    this.oldData = interpolation(0);\r\n                    return (x) => arc(interpolation(x));\r\n                });\r\n\r\n            selection\r\n                .exit()\r\n                .remove();\r\n\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.data.tooltipInfo);\r\n            \r\n            // Draw data labels only if they are on and there are no highlights or there are highlights and this is the highlighted data labels\r\n            if (labelSettings.show && (!hasHighlights || (hasHighlights && isHighlight))) {\r\n                let labelRadCalc = (d: AsterDataPoint) => {\r\n                    let height: number = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;\r\n                    return Math.max(height, innerRadius);\r\n                };\r\n                let labelArc = d3.svg.arc()\r\n                    .innerRadius(d => labelRadCalc(d.data))\r\n                    .outerRadius(d => labelRadCalc(d.data));\r\n\r\n                let lineRadCalc = (d: AsterDataPoint) => {\r\n                    let height: number = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;\r\n                    height = innerRadius + height * AsterRadiusRatio;\r\n                    return Math.max(height, innerRadius);\r\n                };\r\n                let outlineArc = d3.svg.arc()\r\n                    .innerRadius(d => lineRadCalc(d.data))\r\n                    .outerRadius(d => lineRadCalc(d.data));\r\n\r\n                let layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);\r\n                this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);\r\n            }\r\n            else\r\n                dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\r\n            \r\n            // Draw center text and outline once for original data points\r\n            if (!isHighlight) {\r\n                this.drawCenterText(innerRadius);\r\n                this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints);\r\n            }\r\n\r\n            return selection;\r\n        }\r\n\r\n        private getLabelLayout(labelSettings: VisualDataLabelsSettings, arc: D3.Svg.Arc, viewport: IViewport): ILabelLayout {\r\n            let midAngle = function (d: ArcDescriptor) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\r\n            let textProperties: TextProperties = {\r\n                fontFamily: dataLabelUtils.StandardFontFamily,\r\n                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),\r\n                text: '',\r\n            };\r\n            let isLabelsHasConflict = function (d: AsterArcDescriptor) {\r\n                let pos = arc.centroid(d);\r\n                textProperties.text = d.data.label;\r\n                let textWidth = TextMeasurementService.measureSvgTextWidth(textProperties);\r\n                let horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]);\r\n                let textHeight = TextMeasurementService.estimateSvgTextHeight(textProperties);\r\n                let verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);\r\n                d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels;\r\n                return d.isLabelHasConflict;\r\n            };\r\n\r\n            return {\r\n                labelText: (d: AsterArcDescriptor) => {\r\n                    textProperties.text = d.data.label;\r\n                    let pos = arc.centroid(d);\r\n                    let xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0];\r\n                    let spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);\r\n                    return TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);\r\n                },\r\n                labelLayout: {\r\n                    x: (d: AsterArcDescriptor) => {\r\n                        let pos = arc.centroid(d);\r\n                        textProperties.text = d.data.label;\r\n                        let xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];\r\n                        return xPos;\r\n                    },\r\n                    y: (d: AsterArcDescriptor) => {\r\n                        let pos = arc.centroid(d);\r\n                        let yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];\r\n                        return yPos;\r\n                    },\r\n                },\r\n                filter: (d: AsterArcDescriptor) => (d != null && !_.isEmpty(d.data.label)),\r\n                style: {\r\n                    'fill': labelSettings.labelColor,\r\n                    'font-size': textProperties.fontSize,\r\n                    'text-anchor': (d: AsterArcDescriptor) => midAngle(d) < Math.PI ? 'start' : 'end',\r\n                },\r\n            };\r\n        }\r\n\r\n        private drawLabels(data: ArcDescriptor[],\r\n            context: D3.Selection,\r\n            layout: ILabelLayout,\r\n            viewport: IViewport,\r\n            outlineArc: D3.Svg.Arc,\r\n            labelArc: D3.Svg.Arc): void {\r\n            \r\n            // Hide and reposition labels that overlap\r\n            let dataLabelManager = new DataLabelManager();\r\n            let filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, true /* addTransform */);\r\n\r\n            if (filteredData.length === 0) {\r\n                dataLabelUtils.cleanDataLabels(context, true);\r\n                return;\r\n            }\r\n            \r\n            // Draw labels\r\n            if (context.select(AsterPlot.labelGraphicsContextClass.selector).empty())\r\n                context.append('g').classed(AsterPlot.labelGraphicsContextClass.class, true);\r\n\r\n            let labels = context\r\n                .select(AsterPlot.labelGraphicsContextClass.selector)\r\n                .selectAll('.data-labels').data(filteredData, (d: ArcDescriptor) => d.data.identity.getKey());\r\n\r\n            labels.enter().append('text').classed('data-labels', true);\r\n\r\n            if (!labels)\r\n                return;\r\n\r\n            labels\r\n                .attr({ x: (d: LabelEnabledDataPoint) => d.labelX, y: (d: LabelEnabledDataPoint) => d.labelY, dy: '.35em' })\r\n                .text((d: LabelEnabledDataPoint) => d.labeltext)\r\n                .style(layout.style);\r\n\r\n            labels\r\n                .exit()\r\n                .remove();\r\n                \r\n            // Draw lines\r\n            if (context.select(AsterPlot.linesGraphicsContextClass.selector).empty())\r\n                context.append('g').classed(AsterPlot.linesGraphicsContextClass.class, true);\r\n\t\t\t\t\r\n            // Remove lines for null and zero values\r\n            filteredData = _.filter(filteredData, (d: ArcDescriptor) => d.data.sliceHeight !== null && d.data.sliceHeight !== 0);\r\n\r\n            let lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll('polyline')\r\n                .data(filteredData, (d: ArcDescriptor) => d.data.identity.getKey());\r\n\r\n            let labelLinePadding = 4;\r\n            let chartLinePadding = 1.02;\r\n\r\n            let midAngle = function (d: ArcDescriptor) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };\r\n\r\n            lines.enter()\r\n                .append('polyline')\r\n                .classed('line-label', true);\r\n\r\n            lines\r\n                .attr('points', function (d) {\r\n                    let textPoint = [d.labelX, d.labelY];\r\n                    textPoint[0] = textPoint[0] + ((midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding);\r\n                    let chartPoint = outlineArc.centroid(d);\r\n                    chartPoint[0] *= chartLinePadding;\r\n                    chartPoint[1] *= chartLinePadding;\r\n                    return [chartPoint, textPoint];\r\n                }).\r\n                style({\r\n                    'opacity': 0.5,\r\n                    'fill-opacity': 0,\r\n                    'stroke': (d: ArcDescriptor) => this.data.labelSettings.labelColor,\r\n                });\r\n\r\n            lines\r\n                .exit()\r\n                .remove();\r\n\r\n        }\r\n\r\n        private renderLegend(asterPlotData: AsterData): void {\r\n            if (!asterPlotData || !asterPlotData.legendData)\r\n                return;\r\n\r\n            let legendData: LegendData = asterPlotData.legendData;\r\n            let objects: DataViewObjects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null;\r\n            let legendObjectProperties: DataViewObject = DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});\r\n            if (legendObjectProperties) {\r\n                let legendSettings = asterPlotData.legendSettings;\r\n                \r\n                // Force update for title text\r\n                legendObjectProperties['titleText'] = legendSettings.titleText;\r\n                LegendData.update(legendData, legendObjectProperties);\r\n                this.legend.changeOrientation(LegendPosition[legendSettings.position]);\r\n            }\r\n\r\n            this.legend.drawLegend(legendData, _.clone(this.currentViewport));\r\n            Legend.positionChartArea(this.svg, this.legend);\r\n        }\r\n\r\n        private updateViewPortAccordingToLegend(): void {\r\n            let legendSettings = this.data.legendSettings;\r\n            if (!legendSettings || !legendSettings.show)\r\n                return;\r\n\r\n            let legendMargins: IViewport = this.legend.getMargins();\r\n            let legendPosition: LegendPosition = LegendPosition[legendSettings.position];\r\n\r\n            switch (legendPosition) {\r\n                case LegendPosition.Top:\r\n                case LegendPosition.TopCenter:\r\n                case LegendPosition.Bottom:\r\n                case LegendPosition.BottomCenter: {\r\n                    this.currentViewport.height -= legendMargins.height;\r\n                    break;\r\n                }\r\n                case LegendPosition.Left:\r\n                case LegendPosition.LeftCenter:\r\n                case LegendPosition.Right:\r\n                case LegendPosition.RightCenter: {\r\n                    this.currentViewport.width -= legendMargins.width;\r\n                    break;\r\n                }\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n\r\n        private drawOuterLine(innerRadius: number, radius: number, data: ArcDescriptor[]): void {\r\n            let mainGroup = this.mainGroupElement;\r\n            let outlineArc = d3.svg.arc()\r\n                .innerRadius(innerRadius)\r\n                .outerRadius(radius);\r\n            if (this.data.showOuterLine) {\r\n                let OuterThickness: string = this.data.outerLineThickness + 'px';\r\n                let outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);\r\n                outerLine.enter().append('path');\r\n                outerLine.attr(\"fill\", \"none\")\r\n                    .attr({\r\n                        'stroke': '#333',\r\n                        'stroke-width': OuterThickness,\r\n                        'd': outlineArc\r\n                    })\r\n                    .style('opacity', 1)\r\n                    .classed(AsterPlot.OuterLine.class, true);\r\n                outerLine.exit().remove();\r\n            }\r\n            else\r\n                mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();\r\n        }\r\n\r\n        private getCenterText(dataView: DataView): string {\r\n            if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values)\r\n                for (let column of dataView.metadata.columns)\r\n                    if (!column.isMeasure)\r\n                        return column.displayName;\r\n            return '';\r\n        }\r\n\r\n        private drawCenterText(innerRadius: number): void {\r\n            let text: string = this.getCenterText(this.dataView);\r\n\r\n            if (_.isEmpty(text)) {\r\n                this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();\r\n                return;\r\n            }\r\n\r\n            let centerTextProperties: TextProperties = {\r\n                fontFamily: dataLabelUtils.StandardFontFamily,\r\n                fontWeight: 'bold',\r\n                fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),\r\n                text: text\r\n            };\r\n\r\n            if (this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty())\r\n                this.centerText = this.mainGroupElement.append('text').classed(AsterPlot.CenterLabelClass.class, true);\r\n\r\n            this.centerText\r\n                .style({\r\n                    'line-height': 1,\r\n                    'font-weight': centerTextProperties.fontWeight,\r\n                    'font-size': centerTextProperties.fontSize,\r\n                    'fill': this.getLabelFill(this.dataView).solid.color\r\n                })\r\n                .attr({\r\n                    'dy': '0.35em',\r\n                    'text-anchor': 'middle'\r\n                })\r\n                .text(TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));\r\n        }\r\n\r\n        // This extracts fill color of the label from the DataView\r\n        private getLabelFill(dataView: DataView): Fill {\r\n            if (this.dataViewContainsObjects(dataView))\r\n                return DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill);\r\n\r\n            return AsterDefaultLabelFill;\r\n        }\r\n\r\n        private dataViewContainsObjects(dataView: DataView) {\r\n            return dataView && dataView.metadata && dataView.metadata.objects;\r\n        }\r\n\r\n        private enumerateLegend(instances: VisualObjectInstance[]) {\r\n            let legendSettings: AsterPlotLegendSettings = this.data.legendSettings;\r\n            let instance: VisualObjectInstance = {\r\n                selector: null,\r\n                objectName: AsterPlotLegendObjectName,\r\n                displayName: 'Legend',\r\n                properties: {\r\n                    show: legendSettings.show,\r\n                    position: legendSettings.position,\r\n                    showTitle: legendSettings.showTitle,\r\n                    titleText: legendSettings.titleText,\r\n                    labelColor: legendSettings.labelColor,\r\n                    fontSize: legendSettings.fontSize,\r\n                }\r\n            };\r\n\r\n            instances.push(instance);\r\n        }\r\n\r\n        private clearData(): void {\r\n            this.mainGroupElement.selectAll(\"path\").remove();\r\n            dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);\r\n            this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);\r\n        }\r\n\r\n        public onClearSelection(): void {\r\n            if (this.interactivityService)\r\n                this.interactivityService.clearSelection();\r\n        }\r\n\r\n        private enumerateLabels(instances: VisualObjectInstance[]): void {\r\n            let labelSettings = this.data.labelSettings;\r\n            let labels: VisualObjectInstance = {\r\n                objectName: 'labels',\r\n                displayName: 'Labels',\r\n                selector: null,\r\n                properties: {\r\n                    show: labelSettings.show,\r\n                    fontSize: labelSettings.fontSize,\r\n                    labelPrecision: labelSettings.precision,\r\n                    labelDisplayUnits: labelSettings.displayUnits,\r\n                    color: labelSettings.labelColor,\r\n                }\r\n            };\r\n            instances.push(labels);\r\n        }\r\n        \r\n        // This function retruns the values to be displayed in the property pane for each object.\r\n        // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\r\n        // validation and return other values/defaults\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            let instances: VisualObjectInstance[] = [];\r\n            if (!this.dataViewContainsCategory(this.dataView))\r\n                return instances;\r\n            switch (options.objectName) {\r\n                case AsterPlotLegendObjectName:\r\n                    if (this.data)\r\n                        this.enumerateLegend(instances);\r\n                    break;\r\n                case 'label':\r\n                    let label: VisualObjectInstance = {\r\n                        objectName: 'label',\r\n                        displayName: 'Label',\r\n                        selector: null,\r\n                        properties: {\r\n                            fill: this.getLabelFill(this.dataView)\r\n                        }\r\n                    };\r\n                    instances.push(label);\r\n                    break;\r\n                case 'labels':\r\n                    this.enumerateLabels(instances);\r\n                    break;\r\n                case 'outerLine':\r\n                    let outerLine: VisualObjectInstance = {\r\n                        objectName: 'outerLine',\r\n                        displayName: 'Outer Line',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.data.showOuterLine,\r\n                            thickness: this.data.outerLineThickness,\r\n                        }\r\n                    };\r\n                    instances.push(outerLine);\r\n                    break;\r\n            }\r\n\r\n            return instances;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/asterPlot/visual/asterPlot.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    export interface TornadoChartTextOptions {\r\n        fontFamily?: string;\r\n        fontSize?: number;\r\n        sizeUnit?: string;\r\n    }\r\n\r\n    export interface TornadoChartConstructorOptions {\r\n        svg?: D3.Selection;\r\n        animator?: IGenericAnimator;\r\n        margin?: IMargin;\r\n        columnPadding?: number;\r\n    }\r\n\r\n    export interface TornadoChartSeries {\r\n        fill: string;\r\n        name: string;\r\n        selectionId: SelectionId;\r\n        categoryAxisEnd: number;\r\n    }\r\n\r\n    export interface TornadoChartSettings {\r\n        labelOutsideFillColor: string;\r\n        categoriesFillColor: string;\r\n        labelSettings: VisualDataLabelsSettings;\r\n        showLegend?: boolean;\r\n        showCategories?: boolean;\r\n        legendFontSize?: number;\r\n        legendColor?: string;\r\n        labelValueFormatter?: IValueFormatter;\r\n    }\r\n\r\n    export interface TornadoChartDataView {\r\n        categories: TextData[];\r\n        series: TornadoChartSeries[];\r\n        settings: TornadoChartSettings;\r\n        legend: LegendData;\r\n        dataPoints: TornadoChartPoint[];\r\n        highlightedDataPoints?: TornadoChartPoint[];\r\n    }\r\n\r\n    export interface TornadoChartPoint extends SelectableDataPoint {\r\n        dx?: number;\r\n        dy?: number;\r\n        px?: number;\r\n        py?: number;\r\n        angle?: number;\r\n        width?: number;\r\n        height?: number;\r\n        label?: LabelData;\r\n        color: string;\r\n        tooltipData: TooltipDataItem[];\r\n        categoryIndex: number;\r\n        highlight?: boolean;\r\n        value: number;\r\n        minValue: number;\r\n        maxValue: number;\r\n        formatString: string;\r\n    }\r\n\r\n    export interface LabelData {\r\n        dx: number;\r\n        value: number | string;\r\n        source: number | string;\r\n        color: string;\r\n    }\r\n\r\n    export interface LineData {\r\n        x1: number;\r\n        y1: number;\r\n        x2: number;\r\n        y2: number;\r\n    }\r\n\r\n    export interface TextData {\r\n        text: string;\r\n        height: number;\r\n        width: number;\r\n        textProperties: TextProperties;\r\n    }\r\n\r\n    export interface TornadoBehaviorOptions {\r\n        columns: D3.Selection;\r\n        clearCatcher: D3.Selection;\r\n        interactivityService: IInteractivityService;\r\n    }\r\n\r\n    class TornadoWebBehavior implements IInteractiveBehavior {\r\n        private columns: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private interactivityService: IInteractivityService;\r\n\r\n        public bindEvents(options: TornadoBehaviorOptions, selectionHandler: ISelectionHandler) {\r\n            this.columns = options.columns;\r\n            this.clearCatcher = options.clearCatcher;\r\n            this.interactivityService = options.interactivityService;\r\n\r\n            this.columns.on('click', (d: SelectableDataPoint, i: number) => {\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n            });\r\n\r\n            this.clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            let hasHighlights = this.interactivityService.hasSelection();\r\n            this.columns.style(\"fill-opacity\", (d: TornadoChartPoint) => ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights));\r\n        }\r\n    }\r\n\r\n    class TornadoChartScrolling {\r\n        public isScrollable: boolean;\r\n        public scrollViewport: IViewport;\r\n\r\n        private static ScrollBarMinLength = 15;\r\n        private isYScrollBarVisible: boolean;\r\n        private brushGraphicsContextY: D3.Selection;\r\n        private scrollYBrush: D3.Svg.Brush = d3.svg.brush();\r\n\r\n        private getRoot: () => D3.Selection;\r\n        private getViewport: () => IViewport;\r\n\r\n        private get root(): D3.Selection {\r\n            return this.getRoot();\r\n        }\r\n\r\n        private get viewport(): IViewport {\r\n            return this.getViewport();\r\n        }\r\n\r\n        constructor(getRoot: () => D3.Selection, getViewport: () => IViewport, getMargin: () => IMargin, isScrollable: boolean) {\r\n            this.getRoot = getRoot;\r\n            this.getViewport = getViewport;\r\n            this.isScrollable = isScrollable;\r\n        }\r\n\r\n        public renderY(data: TornadoChartDataView, prefferedHeight: number, onScroll: () => {}): void {\r\n            this.isYScrollBarVisible = prefferedHeight > this.viewport.height\r\n                && this.viewport.height > 0\r\n                && this.viewport.width > 0;\r\n\r\n            this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');\r\n            this.updateScrollViewport();\r\n\r\n            if (!this.isYScrollBarVisible) {\r\n                onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);\r\n                return;\r\n            }\r\n\r\n            let scrollSpaceLength: number = this.viewport.height;\r\n            let extentData: any = this.getExtentData(prefferedHeight, scrollSpaceLength);\r\n\r\n            let onRender = (wheelDelta: number = 0) => {\r\n                let position: number[] = this.scrollYBrush.extent();\r\n                if (wheelDelta !== 0) {\r\n\r\n                    // Handle mouse wheel manually by moving the scrollbar half of its size\r\n                    let halfScrollsize: number = (position[1] - position[0]) / 2;\r\n                    position[0] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\r\n                    position[1] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;\r\n\r\n                    if (position[0] < 0) {\r\n                        let offset: number = 0 - position[0];\r\n                        position[0] += offset;\r\n                        position[1] += offset;\r\n                    }\r\n                    if (position[1] > scrollSpaceLength) {\r\n                        let offset: number = position[1] - scrollSpaceLength;\r\n                        position[0] -= offset;\r\n                        position[1] -= offset;\r\n                    }\r\n\r\n                    // Update the scroll bar accordingly and redraw\r\n                    this.scrollYBrush.extent(position);\r\n                    this.brushGraphicsContextY.select('.extent').attr('y', position[0]);\r\n                }\r\n                let scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);\r\n                onScroll.call(this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);\r\n                this.setScrollBarSize(this.brushGraphicsContextY, extentData.value[1], true);\r\n            };\r\n\r\n            let scrollYScale: D3.Scale.OrdinalScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);\r\n            this.scrollYBrush.y(scrollYScale).extent(extentData.value);\r\n\r\n            this.renderScrollbar(\r\n                this.scrollYBrush,\r\n                this.brushGraphicsContextY,\r\n                this.viewport.width,\r\n                onRender);\r\n\r\n            onRender();\r\n        }\r\n\r\n        private updateScrollViewport() {\r\n            this.scrollViewport = { height: this.viewport.height, width: this.viewport.width };\r\n\r\n            if (this.isYScrollBarVisible && this.isScrollable) {\r\n                this.scrollViewport.width -= TornadoChart.ScrollBarWidth;\r\n            }\r\n        }\r\n\r\n        private createOrRemoveScrollbar(isVisible, brushGraphicsContext, brushClass) {\r\n            if (isVisible && this.isScrollable) {\r\n                return brushGraphicsContext || this.root.append(\"g\").classed(brushClass, true);\r\n            }\r\n\r\n            return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;\r\n        }\r\n\r\n        private renderScrollbar(brush: D3.Svg.Brush,\r\n            brushGraphicsContext: D3.Selection,\r\n            brushX: number,\r\n            onRender: (number) => void): void {\r\n\r\n            brush.on(\"brush\", () => window.requestAnimationFrame(() => onRender(0)));\r\n            this.root.on('wheel', () => {\r\n                if (!this.isYScrollBarVisible) return;\r\n                let wheelEvent: any = d3.event; // Casting to any to avoid compilation errors\r\n                onRender(wheelEvent.deltaY);\r\n            });\r\n\r\n            brushGraphicsContext.attr({\r\n                \"transform\": visuals.SVGUtil.translate(brushX, 0),\r\n                \"drag-resize-disabled\": \"true\" /*disables resizing of the visual when dragging the scrollbar in edit mode*/\r\n            });\r\n\r\n            brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */\r\n            /* Disabling the zooming feature */\r\n            brushGraphicsContext.selectAll(\".resize\").remove();\r\n            brushGraphicsContext.select(\".background\").remove();\r\n            brushGraphicsContext.selectAll(\".extent\").style({\r\n                \"fill-opacity\": 0.125,\r\n                \"cursor\": \"default\",\r\n            });\r\n        }\r\n\r\n        private setScrollBarSize(brushGraphicsContext: D3.Selection, minExtent: number, isVertical: boolean): void {\r\n            brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"width\" : \"height\", TornadoChart.ScrollBarWidth);\r\n            brushGraphicsContext.selectAll(\"rect\").attr(isVertical ? \"height\" : \"width\", minExtent);\r\n        }\r\n\r\n        private getExtentData(svgLength: number, scrollSpaceLength: number): any {\r\n            let value: number = scrollSpaceLength * scrollSpaceLength / svgLength;\r\n\r\n            let scaleMultipler: number = TornadoChartScrolling.ScrollBarMinLength <= value\r\n                ? 1\r\n                : value / TornadoChartScrolling.ScrollBarMinLength;\r\n\r\n            value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);\r\n\r\n            let toScrollPosition = (extent: number[], scrollSpaceLength: number) => {\r\n                let scrollSize: number = extent[1] - extent[0];\r\n                let scrollPosition: number = extent[0] / (scrollSpaceLength - scrollSize);\r\n\r\n                scrollSize *= scaleMultipler;\r\n\r\n                let start: number = (scrollPosition * (scrollSpaceLength - scrollSize));\r\n                let end: number = (start + scrollSize);\r\n\r\n                return [start / scrollSpaceLength, end / scrollSpaceLength];\r\n            };\r\n\r\n            return { value: [0, value], toScrollPosition: toScrollPosition };\r\n        }\r\n\r\n        public clearData(): void {\r\n            if (this.brushGraphicsContextY)\r\n                this.brushGraphicsContextY.selectAll(\"*\").remove();\r\n        }\r\n    }\r\n\r\n    export class TornadoChartWarning implements IVisualWarning {\r\n        public get code(): string {\r\n            return \"TornadoChartWarning\";\r\n        }\r\n\r\n        public getMessages(resourceProvider: IStringResourceProvider): IVisualErrorMessage {\r\n            let message: string = \"This visual requires two distinct values to be returned for the Legend field.\",\r\n                titleKey: string = \"\",\r\n                detailKey: string = \"\",\r\n                visualMessage: IVisualErrorMessage;\r\n\r\n            visualMessage = {\r\n                message: message,\r\n                title: resourceProvider.get(titleKey),\r\n                detail: resourceProvider.get(detailKey)\r\n            };\r\n\r\n            return visualMessage;\r\n        }\r\n    }\r\n\r\n    export function getTornadoChartWarning(): IVisualWarning {\r\n        return new TornadoChartWarning();\r\n    }\r\n\r\n    export class TornadoChart implements IVisual {\r\n        private static ClassName: string = \"tornado-chart\";\r\n\r\n        private static Properties: any = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"formatString\"\r\n                }\r\n            },\r\n            labels: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"show\"\r\n                },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"fontSize\"\r\n                },\r\n                labelPrecision: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"labelPrecision\"\r\n                },\r\n                labelDisplayUnits: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"labelDisplayUnits\"\r\n                },\r\n                insideFill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"insideFill\"\r\n                },\r\n                outsideFill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"labels\",\r\n                    propertyName: \"outsideFill\"\r\n                }\r\n            },\r\n            dataPoint: {\r\n                fill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"dataPoint\",\r\n                    propertyName: \"fill\"\r\n                }\r\n            },\r\n            legend: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"legend\",\r\n                    propertyName: \"show\"\r\n                },\r\n                labelColor: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"legend\",\r\n                    propertyName: \"labelColor\"\r\n                },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"legend\",\r\n                    propertyName: \"fontSize\"\r\n                },\r\n            },\r\n            categories: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"categories\",\r\n                    propertyName: \"show\"\r\n                },\r\n                fill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"categories\",\r\n                    propertyName: \"fill\"\r\n                }\r\n            }\r\n        };\r\n\r\n        private static Columns: ClassAndSelector = {\r\n            \"class\": \"columns\",\r\n            selector: \".columns\"\r\n        };\r\n\r\n        private static Column: ClassAndSelector = {\r\n            \"class\": \"column\",\r\n            selector: \".column\"\r\n        };\r\n\r\n        private static Axes: ClassAndSelector = {\r\n            \"class\": \"axes\",\r\n            selector: \".axes\"\r\n        };\r\n\r\n        private static Axis: ClassAndSelector = {\r\n            \"class\": \"axis\",\r\n            selector: \".axis\"\r\n        };\r\n\r\n        private static Labels: ClassAndSelector = {\r\n            \"class\": \"labels\",\r\n            selector: \".labels\"\r\n        };\r\n\r\n        private static Label: ClassAndSelector = {\r\n            \"class\": \"label\",\r\n            selector: \".label\"\r\n        };\r\n\r\n        private static LabelTitle: ClassAndSelector = {\r\n            \"class\": \"label-title\",\r\n            selector: \".label-title\"\r\n        };\r\n\r\n        private static LabelText: ClassAndSelector = {\r\n            \"class\": \"label-text\",\r\n            selector: \".label-text\"\r\n        };\r\n\r\n        private static Categories: ClassAndSelector = {\r\n            \"class\": \"categories\",\r\n            selector: \".categories\"\r\n        };\r\n\r\n        private static Category: ClassAndSelector = {\r\n            \"class\": \"category\",\r\n            selector: \".category\"\r\n        };\r\n\r\n        private static CategoryTitle: ClassAndSelector = {\r\n            \"class\": \"category-title\",\r\n            selector: \".category-title\"\r\n        };\r\n\r\n        private static CategoryText: ClassAndSelector = {\r\n            \"class\": \"category-text\",\r\n            selector: \".category-text\"\r\n        };\r\n\r\n        private static MaxSeries: number = 2;\r\n        private static MaxPrecision: number = 17; // max number of decimals in float\r\n        private static LabelPadding: number = 2.5;\r\n        private static CategoryMinHeight: number = 25;\r\n        private static DefaultFontSize: number = 9;\r\n        private static DefaultLegendFontSize: number = 8;\r\n        private static HighlightedShapeFactor: number = 0.5;\r\n\r\n        public static ScrollBarWidth = 10;\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [{\r\n                name: \"Category\",\r\n                kind: VisualDataRoleKind.Grouping,\r\n                displayName: data.createDisplayNameGetter(\"Role_DisplayName_Group\")\r\n            }, {\r\n                    name: \"Series\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Legend')\r\n                }, {\r\n                    name: \"Values\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter(\"Role_DisplayName_Values\")\r\n                }],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { \"Category\": { max: 1 }, \"Values\": { min: 0, max: 1 }, \"Series\": { min: 0, max: 1 } },\r\n                    { \"Category\": { max: 1 }, \"Values\": { min: 2, max: 2 }, \"Series\": { max: 0 } }\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: {\r\n                            in: \"Category\"\r\n                        }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: \"Series\",\r\n                            select: [{ for: { in: \"Values\" } }],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        }\r\n                    }\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: 'General',\r\n                    properties: {\r\n                        formatString: {\r\n                            type: {\r\n                                formatting: {\r\n                                    formatString: true\r\n                                }\r\n                            },\r\n                        }\r\n                    }\r\n                },\r\n                dataPoint: {\r\n                    displayName: 'Data Colors',\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                categoryAxis: {\r\n                    displayName: 'X-Axis',\r\n                    properties: {\r\n                        end: {\r\n                            displayName: 'End',\r\n                            type: { numeric: true },\r\n                            suppressFormatPainterCopy: true,\r\n                        },\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: 'Data Labels',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: 'Decimal Places',\r\n                            placeHolderText: 'Auto',\r\n                            type: { numeric: true }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: 'Display Units',\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                        },\r\n                        insideFill: {\r\n                            displayName: 'Inside fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        outsideFill: {\r\n                            displayName: 'Outside fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                legend: {\r\n                    displayName: 'Legend',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: 'Position',\r\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\r\n                            type: { enumeration: legendPosition.type }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: 'Title',\r\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: 'Legend Name',\r\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\r\n                            type: { text: true }\r\n                        },\r\n                        labelColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'TextSize',\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    }\r\n                },\r\n                categories: {\r\n                    displayName: 'Group',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n            supportsHighlight: true,\r\n        };\r\n\r\n        private DefaultTornadoChartSettings: TornadoChartSettings = {\r\n            labelOutsideFillColor: dataLabelUtils.defaultLabelColor,\r\n            labelSettings: {\r\n                show: true,\r\n                precision: null,\r\n                fontSize: TornadoChart.DefaultFontSize,\r\n                displayUnits: 0,\r\n                labelColor: dataLabelUtils.defaultInsideLabelColor,\r\n            },\r\n            showCategories: true,\r\n            showLegend: true,\r\n            legendFontSize: TornadoChart.DefaultLegendFontSize,\r\n            legendColor: LegendData.DefaultLegendLabelFillColor,\r\n            categoriesFillColor: \"#777\"\r\n        };\r\n\r\n        private DefaultFillColors: string[] = [\r\n            \"purple\", \"teal\"\r\n        ];\r\n\r\n        private columnPadding: number = 5;\r\n        private leftLabelMargin: number = 4;\r\n        private durationAnimations: number;\r\n        private InnerTextHeightDelta: number = 2;\r\n        private textOptions: TornadoChartTextOptions = {};\r\n\r\n        private margin: IMargin = {\r\n            top: 10,\r\n            right: 5,\r\n            bottom: 10,\r\n            left: 10\r\n        };\r\n\r\n        private root: D3.Selection;\r\n        private svg: D3.Selection;\r\n        private main: D3.Selection;\r\n        private columns: D3.Selection;\r\n        private axes: D3.Selection;\r\n        private labels: D3.Selection;\r\n        private categories: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n\r\n        private legendObjectProperties: DataViewObject;\r\n        private legend: ILegend;\r\n        private hasDynamicSeries: boolean;\r\n        private hasHighlights: boolean;\r\n        private behavior: IInteractiveBehavior;\r\n        private colors: IDataColorPalette;\r\n        private interactivityService: IInteractivityService;\r\n        private animator: IGenericAnimator;\r\n        private hostService: IVisualHostServices;\r\n        private scrolling: TornadoChartScrolling;\r\n\r\n        private viewport: IViewport;\r\n        private tornadoChartDataView: TornadoChartDataView;\r\n        private defaultTornadoChartDataView: TornadoChartDataView;\r\n        private labelHeight: number;\r\n        private heightColumn: number = 0;\r\n        private widthLeftSection: number = 0;\r\n        private widthRightSection: number = 0;\r\n\r\n        constructor(tornadoChartConstructorOptions?: TornadoChartConstructorOptions) {\r\n            if (tornadoChartConstructorOptions) {\r\n                this.svg = tornadoChartConstructorOptions.svg || this.svg;\r\n                this.margin = tornadoChartConstructorOptions.margin || this.margin;\r\n                this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;\r\n                this.animator = tornadoChartConstructorOptions.animator;\r\n            }\r\n        }\r\n\r\n        public init(visualInitOptions: VisualInitOptions): void {\r\n            let style: IVisualStyle = visualInitOptions.style,\r\n                fontSize: string;\r\n\r\n            this.hostService = visualInitOptions.host;\r\n            let element: JQuery = visualInitOptions.element;\r\n            this.colors = style.colorPalette.dataColors;\r\n            let interactivity = visualInitOptions.interactivity;\r\n            this.interactivityService = createInteractivityService(this.hostService);\r\n\r\n            let root: D3.Selection;\r\n            if (this.svg)\r\n                this.root = root = this.svg;\r\n            else\r\n                this.root = root = d3.select(element.get(0))\r\n                    .append(\"svg\");\r\n\r\n            root\r\n                .classed(TornadoChart.ClassName, true)\r\n                .style('position', 'absolute');\r\n\r\n            fontSize = root.style(\"font-size\");\r\n\r\n            this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);\r\n            this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));\r\n            this.textOptions.fontFamily = root.style(\"font-family\");\r\n            this.scrolling = new TornadoChartScrolling(() => root, () => this.viewport, () => this.margin, true);\r\n            let main: D3.Selection = this.main = root.append(\"g\");\r\n            this.clearCatcher = appendClearCatcher(main);\r\n            this.columns = main\r\n                .append(\"g\")\r\n                .classed(TornadoChart.Columns.class, true);\r\n\r\n            this.axes = main\r\n                .append(\"g\")\r\n                .classed(TornadoChart.Axes.class, true);\r\n\r\n            this.labels = main\r\n                .append(\"g\")\r\n                .classed(TornadoChart.Labels.class, true);\r\n\r\n            this.categories = main\r\n                .append(\"g\")\r\n                .classed(TornadoChart.Categories.class, true);\r\n\r\n            this.behavior = new TornadoWebBehavior();\r\n            this.defaultTornadoChartDataView = {\r\n                categories: [],\r\n                series: [],\r\n                settings: null,\r\n                legend: null,\r\n                dataPoints: [],\r\n                highlightedDataPoints: [],\r\n            };\r\n\r\n            this.legend = createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);\r\n        }\r\n\r\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\r\n            if (!visualUpdateOptions ||\r\n                !visualUpdateOptions.dataViews ||\r\n                !visualUpdateOptions.dataViews[0]) {\r\n                return;\r\n            }\r\n\r\n            this.viewport = {\r\n                height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),\r\n                width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)\r\n            };\r\n\r\n            if (this.animator)\r\n                this.durationAnimations = AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);\r\n            else\r\n                this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250;\r\n\r\n            this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]);\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints);\r\n                this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints);\r\n            }\r\n\r\n            this.render();\r\n        }\r\n\r\n        private updateElements(): void {\r\n            let elementsTranslate: string = SVGUtil.translate(this.widthLeftSection, 0);\r\n\r\n            this.root.attr({\r\n                \"height\": this.viewport.height + this.margin.top + this.margin.bottom,\r\n                \"width\": this.viewport.width + this.margin.left + this.margin.right\r\n            });\r\n\r\n            this.columns\r\n                .attr(\"transform\", elementsTranslate);\r\n\r\n            this.labels\r\n                .attr(\"transform\", elementsTranslate);\r\n\r\n            this.axes\r\n                .attr(\"transform\", elementsTranslate);\r\n        }\r\n\r\n        public converter(dataView: DataView): TornadoChartDataView {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[0].source ||\r\n                !dataView.categorical.values ||\r\n                !dataView.categorical.values[0]) {\r\n                return this.defaultTornadoChartDataView;\r\n            }\r\n\r\n            let categorical: DataViewCategorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[] = categorical.categories || [];\r\n            let values: DataViewValueColumns = categorical.values;\r\n            if (values.length > TornadoChart.MaxSeries) {\r\n                this.hostService.setWarnings([getTornadoChartWarning()]);\r\n                return this.defaultTornadoChartDataView;\r\n            }\r\n            let category: DataViewCategoricalColumn = categories[0];\r\n            let categoryValues: number[] = category.values;\r\n            let categoryValuesLength: number = categoryValues.length;\r\n            let objects: DataViewObjects = this.getObjectsFromDataView(dataView);\r\n\r\n            let formatStringProp: DataViewObjectPropertyIdentifier = TornadoChart.Properties.general.formatString;\r\n            let valuesSourceFormatString: string = valueFormatter.getFormatString(values[0].source, formatStringProp);\r\n            let maxValue: number = d3.max(values[0].values);\r\n            let settings: TornadoChartSettings = this.parseSettings(objects, valuesSourceFormatString, maxValue);\r\n            this.hasDynamicSeries = !!values.source;\r\n            let hasHighlights: boolean = this.hasHighlights = !!(values.length > 0 && values[0].highlights);\r\n            this.labelHeight = TextMeasurementService.estimateSvgTextHeight({\r\n                fontFamily: dataLabelUtils.StandardFontFamily,\r\n                fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),\r\n            });\r\n\r\n            let series: TornadoChartSeries[] = [];\r\n            let dataPoints: TornadoChartPoint[] = [];\r\n            let highlightedDataPoints: TornadoChartPoint[] = [];\r\n            let categoriesLabels: TextData[] = [];\r\n\r\n            let groupedValues: DataViewValueColumnGroup[] = values.grouped ? values.grouped() : null;\r\n\r\n            // Parse category labels and compute maximum category length\r\n            let maxCategoryLength: number = 0;\r\n            let showCategories = settings.showCategories;\r\n            let categorySourceFormatString: string = valueFormatter.getFormatString(category.source, formatStringProp);\r\n            for (let i = 0; i < categoryValuesLength; i++) {\r\n                let formattedCategoryValue = valueFormatter.format(categoryValues[i], categorySourceFormatString);\r\n                let textData = this.getTextData(formattedCategoryValue, true);\r\n                categoriesLabels.push(textData);\r\n                if (showCategories && textData.width > maxCategoryLength)\r\n                    maxCategoryLength = textData.width;\r\n            }\r\n\r\n            let scrollBarWidth: number = (categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\r\n            this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;\r\n            let maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;\r\n            this.updateElements();\r\n\r\n            let minValue: number = Math.min(d3.min(values[0].values), 0);\r\n            if (values.length === TornadoChart.MaxSeries) {\r\n                minValue = d3.min([minValue, d3.min(values[1].values)]);\r\n                maxValue = d3.max([maxValue, d3.max(values[1].values)]);\r\n                maxColumnWidth = maxColumnWidth / TornadoChart.MaxSeries;\r\n            }\r\n\r\n            for (let seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {\r\n                let columnGroup: DataViewValueColumnGroup = groupedValues && groupedValues.length > seriesIndex \r\n                    && groupedValues[seriesIndex].values ? groupedValues[seriesIndex] : null;\r\n\r\n                let parsedSeries: TornadoChartSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, columnGroup);\r\n\r\n                series.push(parsedSeries);\r\n\r\n                let currentSeries = values[seriesIndex];\r\n                let measureName = currentSeries.source.queryName;\r\n\r\n                for (let i = 0; i < categoryValuesLength; i++) {\r\n                    let value = currentSeries.values[i] == null || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i];\r\n\r\n                    let identity = SelectionIdBuilder.builder()\r\n                        .withCategory(category, i)\r\n                        .withSeries(values, columnGroup)\r\n                        .withMeasure(measureName)\r\n                        .createSelectionId();\r\n\r\n                    let formattedCategoryValue = categoriesLabels[i].text;\r\n                    let tooltipInfo: TooltipDataItem[];\r\n                    tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);\r\n\r\n                    // Limit maximum value with what the user choose\r\n                    let currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue;\r\n                    let formatString = dataView.categorical.values[seriesIndex].source.format;\r\n\r\n                    dataPoints.push({\r\n                        value: value,\r\n                        minValue: minValue,\r\n                        maxValue: currentMaxValue,\r\n                        formatString: formatString,\r\n                        color: parsedSeries.fill,\r\n                        selected: false,\r\n                        identity: identity,\r\n                        tooltipData: tooltipInfo,\r\n                        categoryIndex: i,\r\n                    });\r\n\r\n                    if (hasHighlights) {\r\n                        let highlightIdentity = SelectionId.createWithHighlight(identity);\r\n                        let highlight = currentSeries.highlights[i];\r\n                        let highlightedValue = highlight != null ? highlight : 0;\r\n                        tooltipInfo = TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue);\r\n\r\n                        highlightedDataPoints.push({\r\n                            value: highlightedValue,\r\n                            minValue: minValue,\r\n                            maxValue: currentMaxValue,\r\n                            formatString: formatString,\r\n                            color: parsedSeries.fill,\r\n                            selected: false,\r\n                            identity: highlightIdentity,\r\n                            tooltipData: tooltipInfo,\r\n                            categoryIndex: i,\r\n                            highlight: true,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                categories: categoriesLabels,\r\n                series: series,\r\n                settings: settings,\r\n                legend: this.getLegendData(series),\r\n                dataPoints: dataPoints,\r\n                highlightedDataPoints: highlightedDataPoints,\r\n            };\r\n        }\r\n\r\n        private parseSettings(objects: DataViewObjects, formatString: string, value: number): TornadoChartSettings {\r\n            let precision: number = this.getPrecision(objects);\r\n\r\n            let displayUnits: number = DataViewObjects.getValue<number>(\r\n                objects,\r\n                TornadoChart.Properties.labels.labelDisplayUnits,\r\n                this.DefaultTornadoChartSettings.labelSettings.displayUnits);\r\n\r\n            let labelSettings = this.DefaultTornadoChartSettings.labelSettings;\r\n\r\n            let labelValueFormatter = valueFormatter.create({\r\n                format: formatString,\r\n                precision: precision,\r\n                value: (displayUnits === 0) && (value != null) ? value : displayUnits,\r\n            });\r\n\r\n            return {\r\n                labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),\r\n                labelSettings: {\r\n                    show: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.labels.show, labelSettings.show),\r\n                    precision: precision,\r\n                    fontSize: DataViewObjects.getValue<number>(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),\r\n                    displayUnits: displayUnits,\r\n                    labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects),\r\n                },\r\n                showCategories: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),\r\n                showLegend: DataViewObjects.getValue<boolean>(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),\r\n                legendFontSize: DataViewObjects.getValue<number>(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),\r\n                legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),\r\n                categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),\r\n                labelValueFormatter: labelValueFormatter\r\n            };\r\n        }\r\n\r\n        private getColor(properties: any, defaultColor: string, objects: DataViewObjects): string {\r\n            let colorHelper: ColorHelper = new ColorHelper(this.colors, properties, defaultColor);\r\n            return colorHelper.getColorForMeasure(objects, \"\");\r\n        }\r\n\r\n        private getPrecision(objects: DataViewObjects): number {\r\n            let precision: number = DataViewObjects.getValue<number>(\r\n                objects,\r\n                TornadoChart.Properties.labels.labelPrecision,\r\n                this.DefaultTornadoChartSettings.labelSettings.precision);\r\n\r\n            if (precision >= TornadoChart.MaxPrecision) {\r\n                return TornadoChart.MaxPrecision;\r\n            }\r\n\r\n            return precision;\r\n        }\r\n\r\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.objects) {\r\n                this.legendObjectProperties = {};\r\n                return null;\r\n            }\r\n\r\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\r\n\r\n            return dataView.metadata.objects;\r\n        }\r\n\r\n        /**\r\n         * Public for testability.\r\n         */\r\n        public parseSeries(dataViewValueColumns: DataViewValueColumns, index: number, isGrouped: boolean, columnGroup: DataViewValueColumnGroup): TornadoChartSeries {\r\n            let dataViewValueColumn: DataViewValueColumn = dataViewValueColumns ? dataViewValueColumns[index] : null,\r\n                source: DataViewMetadataColumn = dataViewValueColumn ? dataViewValueColumn.source : null,\r\n                identity: DataViewScopeIdentity = columnGroup ? columnGroup.identity : null,\r\n                queryName: string = source ? source.queryName : null;\r\n\r\n            let selectionId: SelectionId = identity\r\n                ? SelectionId.createWithId(identity)\r\n                : SelectionIdBuilder.builder()\r\n                    .withSeries(dataViewValueColumns, columnGroup)\r\n                    .withMeasure(queryName)\r\n                    .createSelectionId();\r\n\r\n            let objects: DataViewObjects,\r\n                categoryAxisObject: DataViewObject | DataViewObjectWithId[],\r\n                displayName: string = source ? source.groupName\r\n                    ? source.groupName : source.displayName\r\n                    : null;\r\n\r\n            if (isGrouped && columnGroup) {\r\n                categoryAxisObject = columnGroup.objects ? columnGroup.objects['categoryAxis'] : null;\r\n                objects = columnGroup.objects;\r\n            }\r\n            else if (source) {\r\n                objects = source.objects;\r\n                categoryAxisObject = objects ? objects['categoryAxis'] : null;\r\n            }\r\n\r\n            let color: string = this.getColor(\r\n                TornadoChart.Properties.dataPoint.fill,\r\n                this.DefaultFillColors[index],\r\n                objects);\r\n\r\n            let categoryAxisEnd: number = categoryAxisObject ? categoryAxisObject['end'] : null;\r\n\r\n            return <TornadoChartSeries>{\r\n                fill: color,\r\n                name: displayName,\r\n                selectionId: selectionId,\r\n                categoryAxisEnd: categoryAxisEnd,\r\n            };\r\n        }\r\n\r\n        private getLegendData(series: TornadoChartSeries[]): LegendData {\r\n            let legendDataPoints: LegendDataPoint[] = [];\r\n\r\n            if (this.hasDynamicSeries)\r\n                legendDataPoints = series.map((series: TornadoChartSeries) => {\r\n                    return <LegendDataPoint>{\r\n                        label: series.name,\r\n                        color: series.fill,\r\n                        icon: LegendIcon.Box,\r\n                        selected: false,\r\n                        identity: series.selectionId\r\n                    };\r\n                });\r\n\r\n            return {\r\n                dataPoints: legendDataPoints\r\n            };\r\n        }\r\n\r\n        private clearData(): void {\r\n            this.columns.selectAll(\"*\").remove();\r\n            this.axes.selectAll(\"*\").remove();\r\n            this.labels.selectAll(\"*\").remove();\r\n            this.categories.selectAll(\"*\").remove();\r\n            this.legend.drawLegend({ dataPoints: [] }, this.viewport);\r\n            this.scrolling.clearData();\r\n        }\r\n\r\n        public onClearSelection(): void {\r\n            if (this.interactivityService)\r\n                this.interactivityService.clearSelection();\r\n        }\r\n\r\n        private render(): void {\r\n            let tornadoChartDataView: TornadoChartDataView = this.tornadoChartDataView;\r\n            if (!tornadoChartDataView ||\r\n                !tornadoChartDataView.settings) {\r\n                this.clearData();\r\n                return;\r\n            }\r\n\r\n            this.renderLegend();\r\n\r\n            this.scrolling.renderY(\r\n                tornadoChartDataView,\r\n                tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight,\r\n                this.renderWithScrolling.bind(this));\r\n        }\r\n\r\n        private renderWithScrolling(tornadoChartDataView: TornadoChartDataView, scrollStart: number, scrollEnd: number): void {\r\n            if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings)\r\n                return;\r\n            let categoriesLength = tornadoChartDataView.categories.length;\r\n            let startIndex: number = scrollStart * categoriesLength;\r\n            let endIndex: number = scrollEnd * categoriesLength;\r\n\r\n            let startIndexRound: number = Math.floor(startIndex);\r\n            let endIndexRound: number = Math.floor(endIndex);\r\n\r\n            let maxValues: number = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);\r\n\r\n            if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {\r\n                if (startIndex - startIndexRound > endIndex - endIndexRound) {\r\n                    startIndexRound++;\r\n                }\r\n                else {\r\n                    endIndex--;\r\n                }\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints);\r\n                this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints);\r\n            }\r\n\r\n            let scrollBarWidth: number = (tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;\r\n\r\n            // Filter data according to the visible visual area\r\n            tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);\r\n            tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, (d: TornadoChartPoint) => d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound);\r\n            tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, (d: TornadoChartPoint) => d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound);\r\n\r\n            this.tornadoChartDataView = tornadoChartDataView;\r\n            this.computeHeightColumn();\r\n            this.renderMiddleSection(scrollBarWidth);\r\n            this.renderAxes();\r\n            this.renderCategories();\r\n        }\r\n\r\n        private updateViewport(): void {\r\n            let legendMargins: IViewport = this.legend.getMargins(),\r\n                legendPosition: LegendPosition;\r\n\r\n            legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\r\n\r\n            switch (legendPosition) {\r\n                case LegendPosition.Top:\r\n                case LegendPosition.TopCenter:\r\n                case LegendPosition.Bottom:\r\n                case LegendPosition.BottomCenter: {\r\n                    this.viewport.height -= legendMargins.height;\r\n\r\n                    break;\r\n                }\r\n                case LegendPosition.Left:\r\n                case LegendPosition.LeftCenter:\r\n                case LegendPosition.Right:\r\n                case LegendPosition.RightCenter: {\r\n                    this.viewport.width -= legendMargins.width;\r\n\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        private computeHeightColumn(): void {\r\n            let length: number = this.tornadoChartDataView.categories.length;\r\n            this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;\r\n        }\r\n\r\n        private renderMiddleSection(scrollBarWidth: number): void {\r\n            let tornadoChartDataView: TornadoChartDataView = this.tornadoChartDataView;\r\n            this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth);\r\n            this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);\r\n            let dataPointsWithHighlights: TornadoChartPoint[] = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);\r\n            this.renderColumns(dataPointsWithHighlights, tornadoChartDataView.series.length === 2);\r\n            this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);\r\n        }\r\n\r\n        /**\r\n         * Calculate the width, dx value and label info for every data point\r\n         */\r\n        private calculateDataPoints(dataPoints: TornadoChartPoint[], scrollBarWidth: number): void {\r\n            let maxColumnWidth: number = this.widthRightSection = (this.viewport.width - this.widthLeftSection - scrollBarWidth);\r\n            let categoriesLength: number = this.tornadoChartDataView.categories.length;\r\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings;\r\n            let hasHighlights: boolean = this.hasHighlights;\r\n            let heightColumn = Math.max(this.heightColumn, 0);\r\n            let py = heightColumn / 2;\r\n            let pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2;\r\n            let maxSeries: boolean = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;\r\n\r\n            if (maxSeries)\r\n                maxColumnWidth /= 2;\r\n\r\n            for (let i = 0; i < dataPoints.length; i++) {\r\n                let dataPoint = dataPoints[i];\r\n\r\n                let shiftToMiddle = i < categoriesLength && maxSeries;\r\n                let shiftToRight: boolean = i > categoriesLength - 1;\r\n                let widthOfColumn: number = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth);\r\n                let dx: number = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;\r\n                dx = Math.max(dx, 0);\r\n\r\n                let highlighted: boolean = hasHighlights && dataPoint.highlight;\r\n                let highlightOffset: number = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0;\r\n                let dy: number = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset;\r\n\r\n                let label: LabelData = this.getLabelData(\r\n                    dataPoint.value,\r\n                    dx,\r\n                    widthOfColumn,\r\n                    shiftToMiddle,\r\n                    dataPoint.formatString,\r\n                    settings);\r\n\r\n                dataPoint.dx = dx;\r\n                dataPoint.dy = dy;\r\n                dataPoint.px = widthOfColumn / 2;\r\n                dataPoint.py = highlighted ? pyHighlighted : py;\r\n                dataPoint.angle = shiftToMiddle ? 180 : 0;\r\n                dataPoint.width = widthOfColumn;\r\n                dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn;\r\n                dataPoint.label = label;\r\n            }\r\n        }\r\n\r\n        private renderColumns(columnsData: TornadoChartPoint[], selectSecondSeries: boolean = false): void {\r\n            let hasSelection: boolean = this.interactivityService && this.interactivityService.hasSelection();\r\n            let hasHighlights: boolean = this.hasHighlights;\r\n\r\n            let columnsSelection: D3.UpdateSelection = this.columns\r\n                .selectAll(TornadoChart.Column.selector)\r\n                .data(columnsData);\r\n\r\n            columnsSelection\r\n                .enter()\r\n                .append(\"svg:rect\")\r\n                .classed(TornadoChart.Column.class, true);\r\n\r\n            columnsSelection\r\n                .style(\"fill\", (p: TornadoChartPoint) => p.color)\r\n                .style(\"fill-opacity\", (p: TornadoChartPoint) => ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights))\r\n                .attr(\"transform\", (p: TornadoChartPoint) => SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle))\r\n                .attr(\"height\", (p: TornadoChartPoint) => p.height)\r\n                .attr(\"width\", (p: TornadoChartPoint) => p.width);\r\n\r\n            columnsSelection\r\n                .exit()\r\n                .remove();\r\n\r\n            let interactivityService = this.interactivityService;\r\n\r\n            if (interactivityService) {\r\n                interactivityService.applySelectionStateToData(columnsData);\r\n                let behaviorOptions: TornadoBehaviorOptions = {\r\n                    columns: columnsSelection,\r\n                    clearCatcher: this.clearCatcher,\r\n                    interactivityService: this.interactivityService,\r\n                };\r\n                interactivityService.bind(columnsData, this.behavior, behaviorOptions);\r\n            }\r\n\r\n            this.renderTooltip(columnsSelection);\r\n        }\r\n\r\n        private renderTooltip(selection: D3.UpdateSelection): void {\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\r\n                return (<TornadoChartPoint>tooltipEvent.data).tooltipData;\r\n            });\r\n        }\r\n\r\n        private getColumnWidth(value: number, minValue: number, maxValue: number, width: number): number {\r\n            if (minValue === maxValue) {\r\n                return width;\r\n            }\r\n            let columnWidth = width * (value - minValue) / (maxValue - minValue);\r\n\r\n            // In case the user specifies a custom category axis end we limit the\r\n            // column width to the maximum available width\r\n            return Math.max(0, Math.min(width, columnWidth));\r\n        }\r\n\r\n        private getLabelData(\r\n            value: number,\r\n            dxColumn: number,\r\n            columnWidth: number,\r\n            isColumnPositionLeft: boolean,\r\n            formatStringProp: string,\r\n            settings?: TornadoChartSettings): LabelData {\r\n\r\n            let dx: number,\r\n                tornadoChartSettings: TornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings,\r\n                labelSettings: VisualDataLabelsSettings = tornadoChartSettings.labelSettings,\r\n                fontSize: number = labelSettings.fontSize,\r\n                color: string = labelSettings.labelColor;\r\n\r\n            let maxOutsideLabelWidth = isColumnPositionLeft\r\n                ? dxColumn - this.leftLabelMargin\r\n                : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin);\r\n            let maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);\r\n\r\n            let textProperties: TextProperties = {\r\n                fontFamily: dataLabelUtils.StandardFontFamily,\r\n                fontSize: PixelConverter.fromPoint(fontSize),\r\n                text: tornadoChartSettings.labelValueFormatter.format(value)\r\n            };\r\n            let valueAfterValueFormatter: string = TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);\r\n            let textDataAfterValueFormatter: TextData = this.getTextData(valueAfterValueFormatter, true, false, fontSize);\r\n\r\n            if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {\r\n                dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;\r\n            } else {\r\n                if (isColumnPositionLeft) {\r\n                    dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;\r\n                } else {\r\n                    dx = dxColumn + columnWidth + this.leftLabelMargin;\r\n                }\r\n                color = tornadoChartSettings.labelOutsideFillColor;\r\n            }\r\n\r\n            return {\r\n                dx: dx,\r\n                source: value,\r\n                value: valueAfterValueFormatter,\r\n                color: color\r\n            };\r\n        }\r\n\r\n        private renderAxes(): void {\r\n            let linesData: LineData[],\r\n                axesSelection: D3.UpdateSelection,\r\n                axesElements: D3.Selection = this.main\r\n                    .select(TornadoChart.Axes.selector)\r\n                    .selectAll(TornadoChart.Axis.selector);\r\n\r\n            if (this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries) {\r\n                axesElements.remove();\r\n                return;\r\n            }\r\n\r\n            linesData = this.generateAxesData();\r\n\r\n            axesSelection = axesElements.data(linesData);\r\n\r\n            axesSelection\r\n                .enter()\r\n                .append(\"svg:line\")\r\n                .classed(TornadoChart.Axis.class, true);\r\n\r\n            axesSelection\r\n                .transition()\r\n                .duration(this.durationAnimations)\r\n                .attr(\"x1\", (data: LineData) => data.x1)\r\n                .attr(\"y1\", (data: LineData) => data.y1)\r\n                .attr(\"x2\", (data: LineData) => data.x2)\r\n                .attr(\"y2\", (data: LineData) => data.y2);\r\n\r\n            axesSelection\r\n                .exit()\r\n                .remove();\r\n        }\r\n\r\n        private generateAxesData(): LineData[] {\r\n            let x: number,\r\n                y1: number,\r\n                y2: number;\r\n\r\n            x = this.widthRightSection / 2;\r\n            y1 = 0;\r\n            y2 = this.scrolling.scrollViewport.height;\r\n\r\n            return [{\r\n                x1: x,\r\n                y1: y1,\r\n                x2: x,\r\n                y2: y2\r\n            }];\r\n        }\r\n\r\n        private renderLabels(dataPoints: TornadoChartPoint[], labelsSettings: VisualDataLabelsSettings): void {\r\n            let labelEnterSelection: D3.Selection,\r\n                labelSelection: D3.UpdateSelection = this.main\r\n                    .select(TornadoChart.Labels.selector)\r\n                    .selectAll(TornadoChart.Label.selector)\r\n                    .data(_.filter(dataPoints, (p: TornadoChartPoint) => p.label.dx >= 0));\r\n\r\n            // Check if labels can be displayed\r\n            if (!labelsSettings.show || this.labelHeight >= this.heightColumn) {\r\n                this.labels.selectAll(\"*\").remove();\r\n                return;\r\n            }\r\n\r\n            let fontSizeInPx: string = PixelConverter.fromPoint(labelsSettings.fontSize);\r\n            let labelYOffset: number = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta;\r\n            let categoriesLength: number = this.tornadoChartDataView.categories.length;\r\n\r\n            labelEnterSelection = labelSelection\r\n                .enter()\r\n                .append(\"g\");\r\n\r\n            labelEnterSelection\r\n                .append(\"svg:title\")\r\n                .classed(TornadoChart.LabelTitle.class, true);\r\n\r\n            labelEnterSelection\r\n                .append(\"svg:text\")\r\n                .attr(\"dy\", dataLabelUtils.DefaultDy)\r\n                .classed(TornadoChart.LabelText.class, true);\r\n\r\n            labelSelection\r\n                .attr(\"pointer-events\", \"none\")\r\n                .classed(TornadoChart.Label.class, true);\r\n\r\n            labelSelection\r\n                .select(TornadoChart.LabelTitle.selector)\r\n                .text((p: TornadoChartPoint) => p.label.source);\r\n\r\n            labelSelection\r\n                .attr(\"transform\", (p: TornadoChartPoint, index: number) => {\r\n                    let dy = (this.heightColumn + this.columnPadding) * (index % categoriesLength);\r\n                    return SVGUtil.translate(p.label.dx, dy + labelYOffset);\r\n                });\r\n\r\n            labelSelection\r\n                .select(TornadoChart.LabelText.selector)\r\n                .attr(\"fill\", (p: TornadoChartPoint) => p.label.color)\r\n                .attr(\"font-size\", (p: TornadoChartPoint) => fontSizeInPx)\r\n                .text((p: TornadoChartPoint) => p.label.value);\r\n\r\n            labelSelection\r\n                .exit()\r\n                .remove();\r\n        }\r\n\r\n        private renderCategories(): void {\r\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings,\r\n                color: string = settings.categoriesFillColor,\r\n                categoriesEnterSelection: D3.Selection,\r\n                categoriesSelection: D3.UpdateSelection,\r\n                categoryElements: D3.Selection = this.main\r\n                    .select(TornadoChart.Categories.selector)\r\n                    .selectAll(TornadoChart.Category.selector),\r\n                self: TornadoChart = this;\r\n\r\n            if (!settings.showCategories) {\r\n                categoryElements.remove();\r\n                return;\r\n            }\r\n\r\n            categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories);\r\n\r\n            categoriesEnterSelection = categoriesSelection\r\n                .enter()\r\n                .append(\"g\");\r\n\r\n            categoriesEnterSelection\r\n                .append(\"svg:title\")\r\n                .classed(TornadoChart.CategoryTitle.class, true);\r\n\r\n            categoriesEnterSelection\r\n                .append(\"svg:text\")\r\n                .classed(TornadoChart.CategoryText.class, true);\r\n\r\n            categoriesSelection\r\n                .attr(\"transform\", (text: string, index: number) => {\r\n                    let shift: number = (this.heightColumn + this.columnPadding) * index + this.heightColumn / 2,\r\n                        textData: TextData = this.getTextData(text, false, true);\r\n\r\n                    shift = shift + textData.height / 2 - this.InnerTextHeightDelta;\r\n\r\n                    return SVGUtil.translate(0, shift);\r\n                })\r\n                .classed(TornadoChart.Category.class, true);\r\n\r\n            categoriesSelection\r\n                .select(TornadoChart.CategoryTitle.selector)\r\n                .text((text: TextData) => text.text);\r\n\r\n            categoriesSelection\r\n                .select(TornadoChart.CategoryText.selector)\r\n                .attr(\"fill\", color)\r\n                .text((data: TextData) => {\r\n                    let textData: TextData = self.getTextData(data.text);\r\n\r\n                    return TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);\r\n                });\r\n\r\n            categoriesSelection\r\n                .exit()\r\n                .remove();\r\n        }\r\n\r\n        private renderLegend(): void {\r\n            let legend = this.tornadoChartDataView.legend;\r\n            if (!legend) {\r\n                return;\r\n            }\r\n            let settings: TornadoChartSettings = this.tornadoChartDataView.settings;\r\n\r\n            let legendData: LegendData = {\r\n                title: legend.title,\r\n                dataPoints: legend.dataPoints,\r\n                fontSize: settings.legendFontSize,\r\n                labelColor: settings.legendColor,\r\n            };\r\n\r\n            if (this.legendObjectProperties) {\r\n                let position: string;\r\n\r\n                LegendData.update(legendData, this.legendObjectProperties);\r\n\r\n                position = <string>this.legendObjectProperties[legendProps.position];\r\n\r\n                if (position) {\r\n                    this.legend.changeOrientation(LegendPosition[position]);\r\n                }\r\n            }\r\n\r\n            // Draw the legend on a viewport with the original height and width\r\n            let viewport: IViewport = {\r\n                height: this.viewport.height + this.margin.top + this.margin.bottom,\r\n                width: this.viewport.width + this.margin.left + this.margin.right,\r\n            };\r\n            this.legend.drawLegend(legendData, viewport);\r\n            Legend.positionChartArea(this.root, this.legend);\r\n\r\n            if (legendData.dataPoints.length > 0 && settings.showLegend)\r\n                this.updateViewport();\r\n        }\r\n\r\n        private getTextData(text: string, measureWidth: boolean = false, measureHeight: boolean = false, overrideFontSize?: number): TextData {\r\n            let width: number = 0,\r\n                height: number = 0,\r\n                fontSize: string,\r\n                textProperties: TextProperties;\r\n\r\n            text = text || \"\";\r\n\r\n            fontSize = overrideFontSize\r\n                ? PixelConverter.fromPoint(overrideFontSize)\r\n                : `${this.textOptions.fontSize}${this.textOptions.sizeUnit}`;\r\n\r\n            textProperties = {\r\n                text: text,\r\n                fontFamily: this.textOptions.fontFamily,\r\n                fontSize: fontSize\r\n            };\r\n\r\n            if (measureWidth) {\r\n                width = TextMeasurementService.measureSvgTextWidth(textProperties);\r\n            }\r\n\r\n            if (measureHeight) {\r\n                height = TextMeasurementService.estimateSvgTextHeight(textProperties);\r\n            }\r\n\r\n            return {\r\n                text: text,\r\n                width: width,\r\n                height: height,\r\n                textProperties: textProperties\r\n            };\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration = new ObjectEnumerationBuilder(),\r\n                settings: TornadoChartSettings;\r\n\r\n            if (!this.tornadoChartDataView ||\r\n                !this.tornadoChartDataView.settings) {\r\n                return [];\r\n            }\r\n\r\n            settings = this.tornadoChartDataView.settings;\r\n\r\n            switch (options.objectName) {\r\n                case \"dataPoint\": {\r\n                    this.enumerateDataPoint(enumeration);\r\n                    break;\r\n                }\r\n                case \"categoryAxis\": {\r\n                    this.enumerateCategoryAxis(enumeration);\r\n                    break;\r\n                }\r\n                case \"labels\": {\r\n                    let labelSettings = settings.labelSettings;\r\n                    let labels: VisualObjectInstance = {\r\n                        objectName: \"labels\",\r\n                        displayName: \"Labels\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: labelSettings.show,\r\n                            fontSize: labelSettings.fontSize,\r\n                            labelPrecision: labelSettings.precision,\r\n                            labelDisplayUnits: labelSettings.displayUnits,\r\n                            insideFill: labelSettings.labelColor,\r\n                            outsideFill: settings.labelOutsideFillColor\r\n                        }\r\n                    };\r\n\r\n                    enumeration.pushInstance(labels);\r\n                    break;\r\n                }\r\n                case \"legend\": {\r\n                    if (!this.hasDynamicSeries)\r\n                        return;\r\n\r\n                    let showTitle: boolean = true,\r\n                        titleText: string = \"\",\r\n                        legend: VisualObjectInstance;\r\n\r\n                    showTitle = DataViewObject.getValue<boolean>(\r\n                        this.legendObjectProperties,\r\n                        legendProps.showTitle,\r\n                        showTitle);\r\n\r\n                    titleText = DataViewObject.getValue<string>(\r\n                        this.legendObjectProperties,\r\n                        legendProps.titleText,\r\n                        titleText);\r\n\r\n                    legend = {\r\n                        objectName: \"legend\",\r\n                        displayName: \"Legend\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: settings.showLegend,\r\n                            position: LegendPosition[this.legend.getOrientation()],\r\n                            showTitle: showTitle,\r\n                            titleText: titleText,\r\n                            fontSize: settings.legendFontSize,\r\n                            labelColor: settings.legendColor,\r\n                        }\r\n                    };\r\n\r\n                    enumeration.pushInstance(legend);\r\n                    break;\r\n                }\r\n                case \"categories\": {\r\n                    let categories: VisualObjectInstance = {\r\n                        objectName: \"categories\",\r\n                        displayName: \"Categories\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: settings.showCategories,\r\n                            fill: settings.categoriesFillColor\r\n                        }\r\n                    };\r\n\r\n                    enumeration.pushInstance(categories);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private enumerateDataPoint(enumeration: ObjectEnumerationBuilder): void {\r\n            if (!this.tornadoChartDataView ||\r\n                !this.tornadoChartDataView.series) {\r\n                return;\r\n            }\r\n\r\n            let series: TornadoChartSeries[] = this.tornadoChartDataView.series;\r\n\r\n            for (let currentSeries of series) {\r\n                enumeration.pushInstance({\r\n                    objectName: \"dataPoint\",\r\n                    displayName: currentSeries.name,\r\n                    selector: ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), false),\r\n                    properties: {\r\n                        fill: { solid: { color: currentSeries.fill } }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        private enumerateCategoryAxis(enumeration: ObjectEnumerationBuilder): void {\r\n            if (!this.tornadoChartDataView || !this.tornadoChartDataView.series)\r\n                return;\r\n\r\n            let series: TornadoChartSeries[] = this.tornadoChartDataView.series;\r\n\r\n            for (let currentSeries of series) {\r\n                enumeration.pushInstance({\r\n                    objectName: \"categoryAxis\",\r\n                    displayName: currentSeries.name,\r\n                    selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,\r\n                    properties: {\r\n                        end: currentSeries.categoryAxisEnd,\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        public destroy(): void {\r\n            this.root = null;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/tornadoChart/visual/tornadoChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;\r\n    import ISize = shapes.ISize;\r\n\r\n    export const enum MekkoChartType {\r\n        HundredPercentStackedColumn,\r\n    }\r\n\r\n    export interface MekkoColumnChartDrawInfo /*extends ColumnChartDrawInfo*/ {\r\n        shapesSelection: D3.Selection;\r\n        viewport: IViewport;\r\n        axisOptions: MekkoColumnAxisOptions;\r\n\r\n        labelDataPoints: MekkoLabelDataPoint[];\r\n    }\r\n\r\n    export interface MekkoLabelDataPointsGroup/* extends LabelDataPointsGroup */ {\r\n        labelDataPoints: MekkoLabelDataPoint[];\r\n        maxNumberOfLabels: number;\r\n    }\r\n\r\n    export interface MekkoLabelParentRect {\r\n        /** The rectangle this data label belongs to */\r\n        rect: IRect;\r\n        /** The orientation of the parent rectangle */\r\n        orientation: NewRectOrientation;\r\n        /** Valid positions to place the label ordered by preference */\r\n        validPositions: RectLabelPosition[];\r\n    }\r\n\r\n    export interface MekkoLabelDataPoint/* extends LabelDataPoint*/ {\r\n        isParentRect?: boolean;\r\n        /** Text to be displayed in the label */\r\n        text: string;\r\n        /** The measured size of the text */\r\n        textSize: ISize;\r\n        /** Is data label preferred? Preferred labels will be rendered first */\r\n        isPreferred: boolean;\r\n        /** Color to use for the data label if drawn inside */\r\n        insideFill: string;\r\n        /** Color to use for the data label if drawn outside */\r\n        outsideFill: string;\r\n        /** Whether or not the data label has been rendered */\r\n        hasBeenRendered?: boolean;\r\n        /** Whether the parent type is a rectangle, point or polygon */\r\n        parentType: LabelDataPointParentType;\r\n        /** The parent geometry for the data label */\r\n        parentShape: MekkoLabelParentRect;//LabelParentRect | LabelParentPoint | LabelParentPolygon;\r\n        /** The identity of the data point associated with the data label */\r\n        identity: powerbi.visuals.SelectionId;\r\n        /** The font size of the data point associated with the data label */\r\n        fontSize?: number;\r\n        /** Second row of text to be displayed in the label, for additional information */\r\n        secondRowText?: string;\r\n        /** The calculated weight of the data point associated with the data label */\r\n        weight?: number;\r\n    }\r\n\r\n    export interface MekkoVisualRenderResult {\r\n        dataPoints: SelectableDataPoint[];\r\n        behaviorOptions: any;\r\n        labelDataPoints: MekkoLabelDataPoint[];\r\n        labelsAreNumeric: boolean;\r\n        labelDataPointGroups?: MekkoLabelDataPointsGroup[];\r\n    }\r\n\r\n    export interface MekkoCalculateScaleAndDomainOptions extends CalculateScaleAndDomainOptions {\r\n    }\r\n\r\n    export interface MekkoConstructorOptions {\r\n        chartType: MekkoChartType;\r\n        isScrollable?: boolean;\r\n        animator?: IGenericAnimator;\r\n        cartesianSmallViewPortProperties?: CartesianSmallViewPortProperties;\r\n        behavior?: IInteractiveBehavior;\r\n    }\r\n\r\n    export interface MekkoColumnChartData extends ColumnChartData {\r\n        borderSettings: MekkoBorderSettings;\r\n        categoriesWidth: number[];\r\n    }\r\n\r\n    export interface MekkoBorderSettings {\r\n        show: boolean;\r\n        color: any;\r\n        width: number;\r\n        maxWidth?: number;\r\n    }\r\n\r\n    export interface MekkoLabelSettings {\r\n       maxPrecision: number;\r\n       minPrecision: number;\r\n    }\r\n\r\n    export interface MekkoColumnAxisOptions extends ColumnAxisOptions {\r\n    }\r\n\r\n    export interface IMekkoColumnLayout extends IColumnLayout {\r\n        shapeBorder?: {\r\n            width: (d: ColumnChartDataPoint) => number;\r\n            x: (d: ColumnChartDataPoint) => number;\r\n            y: (d: ColumnChartDataPoint) => number;\r\n            height: (d: ColumnChartDataPoint) => number;\r\n        };\r\n        shapeXAxis?: {\r\n            width: (d: ColumnChartDataPoint) => number;\r\n            x: (d: ColumnChartDataPoint) => number;\r\n            y: (d: ColumnChartDataPoint) => number;\r\n            height: (d: ColumnChartDataPoint) => number;\r\n        };\r\n    }\r\n\r\n    export interface MekkoAxisRenderingOptions {\r\n        axisLabels: ChartAxesLabels;\r\n        legendMargin: number;\r\n        viewport: IViewport;\r\n        margin: IMargin;\r\n        hideXAxisTitle: boolean;\r\n        hideYAxisTitle: boolean;\r\n        hideY2AxisTitle?: boolean;\r\n        xLabelColor?: Fill;\r\n        yLabelColor?: Fill;\r\n        y2LabelColor?: Fill;\r\n    }\r\n\r\n    export interface MekkoDataPoints {\r\n        categoriesWidth: number[];\r\n        series: ColumnChartSeries[];\r\n        hasHighlights: boolean;\r\n        hasDynamicSeries: boolean;\r\n    }\r\n\r\n    export interface MekkoLegendDataPoint extends LegendDataPoint {\r\n        fontSize?: number;\r\n    }\r\n\r\n    export interface MekkoCreateAxisOptions extends CreateAxisOptions {\r\n        formatString: string;\r\n        is100Pct?: boolean;\r\n        shouldClamp?: boolean;\r\n        formatStringProp?: DataViewObjectPropertyIdentifier;\r\n    }\r\n\r\n    export interface MekkoColumnChartContext extends ColumnChartContext {\r\n        height: number;\r\n        width: number;\r\n        duration: number;\r\n        margin: IMargin;\r\n        mainGraphicsContext: D3.Selection;\r\n        labelGraphicsContext: D3.Selection;\r\n        layout: CategoryLayout;\r\n        animator: IColumnChartAnimator;\r\n        onDragStart?: (datum: ColumnChartDataPoint) => void;\r\n        interactivityService: IInteractivityService;\r\n        viewportHeight: number;\r\n        viewportWidth: number;\r\n        is100Pct: boolean;\r\n        hostService: IVisualHostServices;\r\n        isComboChart: boolean;\r\n    }\r\n\r\n    export class MekkoDataWrapper {\r\n        private data: CartesianData;\r\n        private isScalar: boolean;\r\n\r\n        public constructor(columnChartData: CartesianData, isScalar: boolean) {\r\n            this.data = columnChartData;\r\n            this.isScalar = isScalar;\r\n        }\r\n\r\n        public lookupXValue(index: number, type: ValueType): any {\r\n            debug.assertValue(this.data, 'this.data');\r\n\r\n            var isDateTime: boolean = AxisHelper.isDateTime(type);\r\n            if (isDateTime && this.isScalar) {\r\n                return new Date(index);\r\n            }\r\n\r\n            var data = this.data;\r\n            if (type.text) {\r\n                debug.assert(index < data.categories.length, 'category index out of range');\r\n                return data.categories[index];\r\n            }\r\n            else {\r\n                var firstSeries = data.series[0];\r\n                if (firstSeries) {\r\n                    var seriesValues = firstSeries.data;\r\n                    if (seriesValues) {\r\n                        if (this.data.hasHighlights) {\r\n                            index = index * 2;\r\n                        }\r\n                        var dataPoint = seriesValues[index];\r\n                        if (dataPoint) {\r\n                            if (isDateTime) {\r\n                                return new Date(dataPoint.categoryValue);\r\n                            }\r\n                            return dataPoint.categoryValue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n    }\r\n\r\n    export class MekkoColumnChartStrategy implements IMekkoColumnChartStrategy {\r\n        private static classes = {\r\n            item: <ClassAndSelector>createClassAndSelector('column'),\r\n            highlightItem: <ClassAndSelector>createClassAndSelector('highlightColumn')\r\n        };\r\n\r\n        private layout: IMekkoColumnLayout;\r\n        private data: MekkoColumnChartData;\r\n        private graphicsContext: MekkoColumnChartContext;\r\n        private width: number;\r\n        private height: number;\r\n        private margin: IMargin;\r\n        private xProps: IAxisProperties;\r\n        private yProps: IAxisProperties;\r\n        private categoryLayout: CategoryLayout;\r\n        private columnsCenters: number[];\r\n        private columnSelectionLineHandle: D3.Selection;\r\n        private animator: IColumnChartAnimator;\r\n        private interactivityService: IInteractivityService;\r\n        private viewportHeight: number;\r\n        private viewportWidth: number;\r\n\r\n        private static validLabelPositions = [1];\r\n\r\n        public setupVisualProps(columnChartProps: MekkoColumnChartContext): void {\r\n            this.graphicsContext = columnChartProps;\r\n            this.margin = columnChartProps.margin;\r\n            this.width = this.graphicsContext.width;\r\n            this.height = this.graphicsContext.height;\r\n            this.categoryLayout = columnChartProps.layout;\r\n            this.animator = columnChartProps.animator;\r\n            this.interactivityService = columnChartProps.interactivityService;\r\n            this.viewportHeight = columnChartProps.viewportHeight;\r\n            this.viewportWidth = columnChartProps.viewportWidth;\r\n        }\r\n\r\n        public setData(data: MekkoColumnChartData) {\r\n            this.data = data;\r\n        }\r\n\r\n        private static createFormatter(\r\n            scaleDomain: any[],\r\n            dataDomain: any[],\r\n            dataType,\r\n            isScalar: boolean,\r\n            formatString: string,\r\n            bestTickCount: number,\r\n            tickValues: any[],\r\n            getValueFn: any,\r\n            useTickIntervalForDisplayUnits: boolean = false): IValueFormatter {\r\n\r\n            var formatter: IValueFormatter;\r\n            if (dataType.dateTime) {\r\n                if (isScalar) {\r\n                    var value = new Date(scaleDomain[0]);\r\n                    var value2 = new Date(scaleDomain[1]);\r\n                    // datetime with only one value needs to pass the same value\r\n                    // (from the original dataDomain value, not the adjusted scaleDomain)\r\n                    // so formatting works correctly.\r\n                    if (bestTickCount === 1)\r\n                        value = value2 = new Date(dataDomain[0]);\r\n                    formatter = valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });\r\n                }\r\n                else {\r\n                    if (getValueFn == null) {\r\n                        debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');\r\n                    }\r\n                    var minDate: Date = getValueFn(0, dataType);\r\n                    var maxDate: Date = getValueFn(scaleDomain.length - 1, dataType);\r\n                    formatter = valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });\r\n                }\r\n            }\r\n            else {\r\n                if (getValueFn == null && !isScalar) {\r\n                    debug.assertFail('getValueFn must be supplied for ordinal tickValues');\r\n                }\r\n                if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {\r\n                    var domainMin = tickValues[1] - tickValues[0];\r\n                    var domainMax = 0; //force tickInterval to be used with display units\r\n                    formatter = valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });\r\n                }\r\n                else {\r\n                    // do not use display units, just the basic value formatter\r\n                    // datetime is handled above, so we are ordinal and either boolean, numeric, or text.\r\n                    formatter = valueFormatter.createDefaultFormatter(formatString, true);\r\n                }\r\n            }\r\n\r\n            return formatter;\r\n        }\r\n\r\n        /**\r\n         * Format the linear tick labels or the category labels.\r\n         */\r\n        private static formatAxisTickValues(\r\n            axis: D3.Svg.Axis,\r\n            tickValues: any[],\r\n            formatter: IValueFormatter,\r\n            dataType: ValueType,\r\n            isScalar: boolean,\r\n            getValueFn?: (index: number, type: ValueType) => any) {\r\n\r\n            var formattedTickValues = [];\r\n            if (formatter) {\r\n                // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.\r\n                if (getValueFn && !(dataType.numeric && isScalar)) {\r\n                    axis.tickFormat(d => formatter.format(getValueFn(d, dataType)));\r\n                    formattedTickValues = tickValues.map(d => formatter.format(getValueFn(d, dataType)));\r\n                }\r\n                else {\r\n                    axis.tickFormat(d => formatter.format(d));\r\n                    formattedTickValues = tickValues.map((d) => formatter.format(d));\r\n                }\r\n            }\r\n            else {\r\n                formattedTickValues = tickValues.map((d) => getValueFn(d, dataType));\r\n            }\r\n\r\n            return formattedTickValues;\r\n        }\r\n\r\n        /**\r\n         * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.\r\n         * @param options The properties used to create the axis.\r\n         */\r\n        private createAxis(options): IAxisProperties {\r\n            var pixelSpan = options.pixelSpan,\r\n                dataDomain = options.dataDomain,\r\n                metaDataColumn = options.metaDataColumn,\r\n                formatStringProp = options.formatStringProp,\r\n                outerPadding = options.outerPadding || 0,\r\n                isCategoryAxis = !!options.isCategoryAxis,\r\n                isScalar = !!options.isScalar,\r\n                isVertical = !!options.isVertical,\r\n                useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?\r\n                getValueFn = options.getValueFn,\r\n                categoryThickness = options.categoryThickness;\r\n\r\n            var formatString = valueFormatter.getFormatString(metaDataColumn, formatStringProp);\r\n            var dataType: ValueType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);\r\n            var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);\r\n\r\n            var scale = d3.scale.linear();\r\n            var scaleDomain = [0, 1];\r\n            var bestTickCount = dataDomain.length || 1;\r\n\r\n            var borderWidth: number = MekkoColumnChart.getBorderWidth(options.borderSettings);\r\n            var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);\r\n\r\n            if (chartWidth < MekkoChart.MinOrdinalRectThickness) {\r\n                chartWidth = MekkoChart.MinOrdinalRectThickness;\r\n            }\r\n\r\n            scale.domain(scaleDomain)\r\n                .range([0, chartWidth]);\r\n            var tickValues = dataDomain;\r\n\r\n            var formatter = MekkoColumnChartStrategy.createFormatter(\r\n                scaleDomain,\r\n                dataDomain,\r\n                dataType,\r\n                isScalar,\r\n                formatString,\r\n                bestTickCount,\r\n                tickValues,\r\n                getValueFn,\r\n                useTickIntervalForDisplayUnits);\r\n\r\n            // sets default orientation only, cartesianChart will fix y2 for comboChart\r\n            // tickSize(pixelSpan) is used to create gridLines\r\n            var axis = d3.svg.axis()\r\n                .scale(scale)\r\n                .tickSize(6, 0)\r\n                .orient(isVertical ? 'left' : 'bottom')\r\n                .ticks(bestTickCount)\r\n                .tickValues(dataDomain);\r\n\r\n            var formattedTickValues = [];\r\n            if (metaDataColumn) {\r\n                formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);\r\n            }\r\n\r\n            var xLabelMaxWidth;\r\n            // Use category layout of labels if specified, otherwise use scalar layout of labels\r\n            if (!isScalar && categoryThickness) {\r\n                xLabelMaxWidth = Math.max(1, categoryThickness - CartesianChart.TickLabelPadding * 2);\r\n            }\r\n            else {\r\n                // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan\r\n                // When there is > 1 ticks then we need to +1 so that their widths don't overlap\r\n                // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.\r\n                var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;\r\n                xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;\r\n                xLabelMaxWidth = Math.max(1, xLabelMaxWidth - CartesianChart.TickLabelPadding * 2);\r\n            }\r\n\r\n            return {\r\n                scale: scale,\r\n                axis: axis,\r\n                formatter: formatter,\r\n                values: formattedTickValues,\r\n                axisType: dataType,\r\n                axisLabel: null,\r\n                isCategoryAxis: isCategoryAxis,\r\n                xLabelMaxWidth: xLabelMaxWidth,\r\n                categoryThickness: categoryThickness,\r\n                outerPadding: outerPadding,\r\n                usingDefaultDomain: false,//scaleResult.usingDefaultDomain,\r\n                isLogScaleAllowed: isLogScaleAllowed\r\n            };\r\n        }\r\n\r\n        private getCategoryAxis(\r\n            data: MekkoColumnChartData,\r\n            size: number,\r\n            layout: CategoryLayout,\r\n            isVertical: boolean,\r\n            forcedXMin?: DataViewPropertyValue,\r\n            forcedXMax?: DataViewPropertyValue,\r\n            axisScaleType?: string): IAxisProperties {\r\n\r\n            var categoryThickness = layout.categoryThickness;\r\n            var isScalar: boolean  = layout.isScalar;\r\n            var outerPaddingRatio = layout.outerPaddingRatio;\r\n            var dw = new MekkoDataWrapper(data, isScalar);\r\n            var domain: number[] = [];\r\n\r\n            if (data.series &&\r\n                (data.series.length > 0) &&\r\n                data.series[0].data &&\r\n                (data.series[0].data.length > 0)\r\n            ) {\r\n                var domainDoubles = data.series[0].data.map((item: ColumnChartDataPoint) => {\r\n                    return item.originalPosition + (item.value / 2);\r\n                });\r\n\r\n                domain = domainDoubles.filter(function(item, pos) {\r\n                    return domainDoubles.indexOf(item) === pos;\r\n                });\r\n            }\r\n\r\n            var axisProperties: IAxisProperties = this.createAxis({\r\n                pixelSpan: size,\r\n                dataDomain: domain,\r\n                metaDataColumn: data.categoryMetadata,\r\n                formatStringProp: columnChartProps.general.formatString,\r\n                outerPadding: categoryThickness * outerPaddingRatio,\r\n                isCategoryAxis: true,\r\n                isScalar: isScalar,\r\n                isVertical: isVertical,\r\n                categoryThickness: categoryThickness,\r\n                useTickIntervalForDisplayUnits: true,\r\n                getValueFn: (index, type) => {\r\n                    var domainIndex = domain.indexOf(index);\r\n                    var value = dw.lookupXValue(domainIndex, type);\r\n                    return value;\r\n                },\r\n                scaleType: axisScaleType,\r\n                borderSettings: data.borderSettings\r\n            });\r\n            // intentionally updating the input layout by ref\r\n            layout.categoryThickness = axisProperties.categoryThickness;\r\n            return axisProperties;\r\n        }\r\n\r\n        public setXScale(is100Pct: boolean, forcedTickCount?: number, forcedXDomain?: any[], axisScaleType?: string): IAxisProperties {\r\n            var width = this.width;\r\n            var forcedXMin, forcedXMax;\r\n\r\n            if (forcedXDomain && forcedXDomain.length === 2) {\r\n                forcedXMin = forcedXDomain[0];\r\n                forcedXMax = forcedXDomain[1];\r\n            }\r\n\r\n            var props = this.xProps = this.getCategoryAxis(\r\n                this.data,\r\n                width,\r\n                this.categoryLayout,\r\n                false,\r\n                forcedXMin,\r\n                forcedXMax,\r\n                axisScaleType);\r\n\r\n            return props;\r\n        }\r\n\r\n        public setYScale(is100Pct: boolean, forcedTickCount?: number, forcedYDomain?: any[], axisScaleType?: string): IAxisProperties {\r\n            var height = this.viewportHeight;\r\n            var valueDomain = StackedUtil.calcValueDomain(this.data.series, is100Pct);\r\n            var valueDomainArr = [valueDomain.min, valueDomain.max];\r\n            var combinedDomain = AxisHelper.combineDomain(forcedYDomain, valueDomainArr);\r\n            var shouldClamp = AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);\r\n            var metadataColumn = this.data.valuesMetadata[0];\r\n            var formatString = is100Pct ?\r\n                this.graphicsContext.hostService.getLocalizedString('Percentage')\r\n                : valueFormatter.getFormatString(metadataColumn, columnChartProps.general.formatString);\r\n\r\n            var mekkoMekkoCreateAxisOptions: MekkoCreateAxisOptions = {\r\n                pixelSpan: height,\r\n                dataDomain: combinedDomain,\r\n                metaDataColumn: metadataColumn,\r\n                formatString: formatString,\r\n                outerPadding: 0,\r\n                isScalar: true,\r\n                isVertical: true,\r\n                forcedTickCount: forcedTickCount,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: false,\r\n                scaleType: axisScaleType,\r\n                axisDisplayUnits: 0,\r\n                axisPrecision: 0,\r\n                is100Pct: is100Pct,\r\n                shouldClamp: shouldClamp,\r\n                formatStringProp: undefined,\r\n            };\r\n\r\n            this.yProps = AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);\r\n            return this.yProps;\r\n        }\r\n\r\n        public drawColumns(useAnimation: boolean): MekkoColumnChartDrawInfo {\r\n            var data = this.data;\r\n            debug.assertValue(data, 'data should not be null or undefined');\r\n            this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again\r\n\r\n            var axisOptions: MekkoColumnAxisOptions = {\r\n                columnWidth: 0,\r\n                xScale: this.xProps.scale,\r\n                yScale: this.yProps.scale,\r\n                isScalar: this.categoryLayout.isScalar,\r\n                margin: this.margin,\r\n            };\r\n            var stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions);\r\n            //var dataLabelSettings = data.labelSettings;\r\n            var labelDataPoints: MekkoLabelDataPoint[] = this.createMekkoLabelDataPoints();\r\n            var result: ColumnChartAnimationResult;\r\n            var shapes: D3.UpdateSelection;\r\n            var series = ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);\r\n            if (this.animator && useAnimation) {\r\n                result = this.animator.animate({\r\n                    viewModel: data,\r\n                    series: series,\r\n                    layout: stackedColumnLayout,\r\n                    itemCS: MekkoColumnChartStrategy.classes.item,\r\n                    interactivityService: this.interactivityService,\r\n                    mainGraphicsContext: this.graphicsContext.mainGraphicsContext,\r\n                    viewPort: { height: this.height, width: this.width },\r\n                });\r\n                shapes = result.shapes;\r\n            }\r\n            if (!this.animator || !useAnimation || result.failed) {\r\n                shapes = MekkoColumnChartStrategy.drawDefaultShapes(data,\r\n                    series,\r\n                    stackedColumnLayout,\r\n                    MekkoColumnChartStrategy.classes.item,\r\n                    !this.animator,\r\n                    this.interactivityService && this.interactivityService.hasSelection());\r\n            }\r\n\r\n            ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);\r\n\r\n            return {\r\n                shapesSelection: shapes,\r\n                viewport: { height: this.height, width: this.width },\r\n                axisOptions,\r\n                labelDataPoints: labelDataPoints,\r\n            };\r\n        }\r\n\r\n        private static drawDefaultShapes(data: MekkoColumnChartData,\r\n            series: D3.UpdateSelection,\r\n            layout: IMekkoColumnLayout,\r\n            itemCS: ClassAndSelector,\r\n            filterZeros: boolean,\r\n            hasSelection: boolean): D3.UpdateSelection {\r\n            // We filter out invisible (0, null, etc.) values from the dataset\r\n            // based on whether animations are enabled or not, Dashboard and\r\n            // Exploration mode, respectively.\r\n\r\n            var rectName: string = 'rect';\r\n            filterZeros = false;\r\n\r\n            var dataSelector: (d: ColumnChartSeries) => any[];\r\n            if (filterZeros) {\r\n                dataSelector = (d: ColumnChartSeries) => {\r\n                    var filteredData = _.filter(d.data, (datapoint: ColumnChartDataPoint) => !!datapoint.value);\r\n                    return filteredData;\r\n                };\r\n            }\r\n            else {\r\n                dataSelector = (d: ColumnChartSeries) => d.data;\r\n            }\r\n\r\n            var shapeSelection = series.selectAll(itemCS.selector);\r\n            var shapes = shapeSelection.data(dataSelector, (d: ColumnChartDataPoint) => d.key);\r\n\r\n            shapes.enter()\r\n                .append(rectName)\r\n                .attr(\"class\", (d: ColumnChartDataPoint) => itemCS.class.concat(d.highlight ? \" highlight\" : \"\"));\r\n\r\n            shapes\r\n                .style(\"fill\", (d: ColumnChartDataPoint) => d.color)\r\n                .style(\"fill-opacity\", (d: ColumnChartDataPoint) => ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights))\r\n                .attr(layout.shapeLayout);\r\n\r\n            shapes\r\n                .exit()\r\n                .remove();\r\n\r\n            var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);\r\n            var borders = borderSelection.data(dataSelector, (d: ColumnChartDataPoint) => d.key);\r\n\r\n            var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);\r\n\r\n            borders.enter()\r\n                .append(rectName)\r\n                .classed(MekkoColumnChart.BorderClass.class, true);\r\n\r\n            borders\r\n                .style(\"fill\", (d: ColumnChartDataPoint) => borderColor)\r\n                .style(\"fill-opacity\", (d: ColumnChartDataPoint) => {\r\n                    return data.hasHighlights ? ColumnUtil.DimmedOpacity : ColumnUtil.DefaultOpacity;\r\n                })\r\n                .attr(layout.shapeBorder);\r\n\r\n            borders\r\n                .exit()\r\n                .remove();\r\n\r\n            return shapes;\r\n        }\r\n\r\n        public selectColumn(selectedColumnIndex: number, lastSelectedColumnIndex: number): void {\r\n            ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);\r\n            this.moveHandle(selectedColumnIndex);\r\n        }\r\n\r\n        public getClosestColumnIndex(x: number, y: number): number {\r\n            return ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());\r\n        }\r\n\r\n        /**\r\n         * Get the chart's columns centers (x value).\r\n         */\r\n        private getColumnsCenters(): number[] {\r\n            if (!this.columnsCenters) { // lazy creation\r\n                var categoryWidth: number = this.categoryLayout.categoryThickness * (1 - CartesianChart.InnerPaddingRatio);\r\n                // use the axis scale and first series data to get category centers\r\n                if (this.data.series.length > 0) {\r\n                    var xScaleOffset = 0;\r\n                    if (!this.categoryLayout.isScalar) {\r\n                        xScaleOffset = categoryWidth / 2;\r\n                    }\r\n                    var firstSeries = this.data.series[0];\r\n                    if (firstSeries &&\r\n                        firstSeries.data) {\r\n                        this.columnsCenters = firstSeries.data.map(d => this.xProps.scale(this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset);\r\n                    }\r\n                }\r\n            }\r\n            return this.columnsCenters;\r\n        }\r\n\r\n        private moveHandle(selectedColumnIndex: number) {\r\n            var columnCenters = this.getColumnsCenters();\r\n            var x = columnCenters[selectedColumnIndex];\r\n\r\n            if (!this.columnSelectionLineHandle) {\r\n                var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');\r\n                handle.append('line')\r\n                    .classed('interactive-hover-line', true)\r\n                    .attr({\r\n                        x1: x,\r\n                        x2: x,\r\n                        y1: 0,\r\n                        y2: this.height,\r\n                    });\r\n\r\n                handle.append('circle')\r\n                    .attr({\r\n                        cx: x,\r\n                        cy: this.height,\r\n                        r: '6px',\r\n                    })\r\n                    .classed('drag-handle', true);\r\n            }\r\n            else {\r\n                var handle = this.columnSelectionLineHandle;\r\n                handle.select('line').attr({ x1: x, x2: x });\r\n                handle.select('circle').attr({ cx: x });\r\n            }\r\n        }\r\n\r\n        public static getLayout(data: MekkoColumnChartData, axisOptions: MekkoColumnAxisOptions): IMekkoColumnLayout {\r\n            var xScale = axisOptions.xScale;\r\n            var yScale = axisOptions.yScale;\r\n            var scaledY0 = yScale(0);\r\n            var scaledX0 = xScale(0);\r\n\r\n            var borderWidth: number = MekkoColumnChart.getBorderWidth(data.borderSettings);\r\n\r\n            var columnWidthScale = (d: ColumnChartDataPoint) => {\r\n                var value: number = AxisHelper.diffScaled(xScale, d.value, 0);\r\n                return value;\r\n            };\r\n\r\n            var columnStart = (d: ColumnChartDataPoint) => {\r\n                var value: number = scaledX0 +\r\n                                    AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\r\n                                    borderWidth * d.categoryIndex;\r\n                return value;\r\n            };\r\n\r\n            var borderStart = (d: ColumnChartDataPoint) => {\r\n                var value: number = scaledX0 +\r\n                            AxisHelper.diffScaled(xScale, d.originalPosition, 0) +\r\n                            AxisHelper.diffScaled(xScale, d.value, 0) +\r\n                            borderWidth * d.categoryIndex;\r\n\r\n                return value;\r\n            };\r\n\r\n            return {\r\n                shapeLayout: {\r\n                    width: columnWidthScale,\r\n                    x: columnStart,\r\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\r\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\r\n                },\r\n                shapeBorder: {\r\n                    width: (d: ColumnChartDataPoint) => borderWidth,\r\n                    x: borderStart,\r\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\r\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\r\n                },\r\n                shapeLayoutWithoutHighlights: {\r\n                    width: columnWidthScale,\r\n                    x: columnStart,\r\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\r\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.originalValueAbsolute)\r\n                },\r\n                zeroShapeLayout: {\r\n                    width: columnWidthScale,\r\n                    x: columnStart,\r\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0) + StackedUtil.getSize(yScale, d.valueAbsolute),\r\n                    height: (d: ColumnChartDataPoint) => 0\r\n                },\r\n                shapeXAxis: {\r\n                    width: columnWidthScale,\r\n                    x: columnStart,\r\n                    y: (d: ColumnChartDataPoint) => scaledY0 + AxisHelper.diffScaled(yScale, d.position, 0),\r\n                    height: (d: ColumnChartDataPoint) => StackedUtil.getSize(yScale, d.valueAbsolute)\r\n                },\r\n            };\r\n        }\r\n\r\n        private createMekkoLabelDataPoints(): MekkoLabelDataPoint[] {\r\n            var labelDataPoints: MekkoLabelDataPoint[] = [];\r\n            var data = this.data;\r\n            var series = data.series;\r\n            var formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager();\r\n            var shapeLayout = this.layout.shapeLayout;\r\n\r\n            for (var i: number = 0, ilen = series.length; i < ilen; i++) {\r\n                var currentSeries = series[i];\r\n                var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;\r\n\r\n                if (!labelSettings.show) {\r\n                    continue;\r\n                }\r\n\r\n                if (!currentSeries.data) {\r\n                    continue;\r\n                }\r\n\r\n                var axisFormatter: number = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);\r\n\r\n                for (var j: number = 0; j < currentSeries.data.length; j++) {\r\n                    var dataPoint: ColumnChartDataPoint = currentSeries.data[j];\r\n                    if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Calculate parent rectangle\r\n                    var parentRect: IRect = {\r\n                        left: shapeLayout.x(dataPoint),\r\n                        top: shapeLayout.y(dataPoint),\r\n                        width: shapeLayout.width(dataPoint),\r\n                        height: shapeLayout.height(dataPoint),\r\n                    };\r\n\r\n                    // Calculate label text\r\n                    var formatString = null;\r\n                    var value: number = dataPoint.valueOriginal;\r\n\r\n                    if (!labelSettings.displayUnits) {\r\n                        formatString = NewDataLabelUtils.hundredPercentFormat;\r\n                        value = dataPoint.valueAbsolute;\r\n                    }\r\n\r\n                    var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);\r\n                    var text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value));\r\n\r\n                    // Calculate text size\r\n                    var properties: TextProperties = {\r\n                        text: text,\r\n                        fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,\r\n                        fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,\r\n                        fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,\r\n                    };\r\n                    var textWidth = TextMeasurementService.measureSvgTextWidth(properties);\r\n                    var textHeight = TextMeasurementService.estimateSvgTextHeight(properties);\r\n\r\n                    labelDataPoints.push({\r\n                        isPreferred: true,\r\n                        text: text,\r\n                        textSize: {\r\n                            width: textWidth,\r\n                            height: textHeight,\r\n                        },\r\n                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,\r\n                        insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,\r\n                        isParentRect: true,\r\n                        parentShape: {\r\n                            rect: parentRect,\r\n                            orientation: 1,\r\n                            validPositions: MekkoColumnChartStrategy.validLabelPositions,\r\n                        },\r\n                        identity: dataPoint.identity,\r\n                        parentType: 1,//LabelDataPointParentType.Rectangle,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return labelDataPoints;\r\n        }\r\n    }\r\n\r\n    export interface MekkoChartSettings {\r\n        columnBorder: MekkoBorderSettings;\r\n        labelSettings: MekkoLabelSettings;\r\n    }\r\n\r\n    /**\r\n     * Renders a data series as a cartestian visual.\r\n     */\r\n    export class MekkoChart implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Category',\r\n                }, {\r\n                    name: 'Series',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Series',\r\n                }, {\r\n                    name: 'Y',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Y Axis',\r\n                }, {\r\n                    name: 'Width',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Axis width',\r\n                }\r\n            ],\r\n            objects: {\r\n                columnBorder: {\r\n                    displayName: 'Column Border',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        width: {\r\n                            displayName: 'Width',\r\n                            type: { numeric: true }\r\n                        },\r\n                    },\r\n                },\r\n                labels: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\r\n                    description: data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        showSeries: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DisplayUnits'),\r\n                            description: data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Precision'),\r\n                            description: data.createDisplayNameGetter('Visual_PrecisionDescription'),\r\n                            placeHolderText: data.createDisplayNameGetter('Visual_Precision_Auto'),\r\n                            type: { numeric: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        showAll: {\r\n                            displayName: data.createDisplayNameGetter('Visual_ShowAll'),\r\n                            type: { bool: true }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    },\r\n                },\r\n                legend: {\r\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\r\n                            type: { formatting: { legendPosition: true } }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: 'Title text',\r\n                            type: { text: true }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    }\r\n                },\r\n                categoryAxis: {\r\n                    displayName: data.createDisplayNameGetter('Visual_XAxis'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\r\n                            type: { formatting: { yAxisPosition: true } }\r\n                        },\r\n                        axisScale: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\r\n                            type: { formatting: { axisScale: true } }\r\n                        },\r\n                        /*start: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        end: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\r\n                            type: { numeric: true }\r\n                        },*/\r\n                        axisType: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Type'),\r\n                            type: { formatting: { axisType: true } }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\r\n                            type: { bool: true }\r\n                        },\r\n                        axisStyle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\r\n                            type: { formatting: { axisStyle: true } }\r\n                        },\r\n                        labelColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_LabelColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    }\r\n                },\r\n                valueAxis: {\r\n                    displayName: data.createDisplayNameGetter('Visual_YAxis'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\r\n                            type: { formatting: { yAxisPosition: true } }\r\n                        },\r\n                        axisScale: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\r\n                            type: { formatting: { axisScale: true } }\r\n                        },\r\n                        /*start: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        end: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\r\n                            type: { numeric: true }\r\n                        },*/\r\n                        intersection: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Intersection'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\r\n                            type: { bool: true }\r\n                        },\r\n                        axisStyle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\r\n                            type: { formatting: { axisStyle: true } }\r\n                        },\r\n                        labelColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_LabelColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n\r\n                    }\r\n                },\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\r\n                    properties: {\r\n                        defaultColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        showAllDataPoints: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fillRule: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\r\n                            type: { fillRule: {} },\r\n                            rule: {\r\n                                inputRole: 'Gradient',\r\n                                output: {\r\n                                    property: 'fill',\r\n                                    selector: ['Category'],\r\n                                },\r\n                            },\r\n                        }\r\n                    }\r\n                },\r\n\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Series',\r\n                            select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        }\r\n                    },\r\n                    rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }\r\n                },\r\n            }],\r\n            supportsHighlight: true,\r\n            sorting: {\r\n                default: {},\r\n            },\r\n            drilldown: {\r\n                roles: ['Category']\r\n            },\r\n        };\r\n\r\n        private static properties = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"formatString\"\r\n                }\r\n            },\r\n            columnBorder: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'show', },\r\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'color' },\r\n                width: <DataViewObjectPropertyIdentifier>{ objectName: 'columnBorder', propertyName: 'width' },\r\n            },\r\n        };\r\n\r\n        public static DefaultSettings: MekkoChartSettings = {\r\n            columnBorder: {\r\n                show: true,\r\n                color: '#fff',\r\n                width: 2,\r\n                maxWidth: 5,\r\n            },\r\n            labelSettings: {\r\n                maxPrecision: 4,\r\n                minPrecision: 0,\r\n            }\r\n        };\r\n\r\n        private static getTextProperties(fontSize: number = MekkoChart.FontSize): TextProperties {\r\n            return {\r\n                fontFamily: 'wf_segoe-ui_normal',\r\n                fontSize: jsCommon.PixelConverter.toString(fontSize),\r\n            };\r\n        }\r\n\r\n        public static MinOrdinalRectThickness = 20;\r\n        public static MinScalarRectThickness = 2;\r\n        public static OuterPaddingRatio = 0.4;\r\n        public static InnerPaddingRatio = 0.2;\r\n        public static TickLabelPadding = 2;\r\n\r\n        private static ClassName = 'cartesianChart';\r\n        private static AxisGraphicsContextClassName = 'axisGraphicsContext';\r\n        private static MaxMarginFactor = 0.25;\r\n        private static MinBottomMargin = 50;\r\n        private static LeftPadding = 10;\r\n        private static RightPadding = 10;\r\n        private static BottomPadding = 16;\r\n        private static YAxisLabelPadding = 20;\r\n        private static XAxisLabelPadding = 20;\r\n        private static TickPaddingY = 10;\r\n        private static TickPaddingRotatedX = 5;\r\n        private static FontSize = 11;\r\n\r\n        public static MaxNumberOfLabels = 100;\r\n\r\n        private static MinWidth: number = 100;\r\n        private static MinHeight: number = 100;\r\n\r\n        private axisGraphicsContext: D3.Selection;\r\n        private xAxisGraphicsContext: D3.Selection;\r\n        private y1AxisGraphicsContext: D3.Selection;\r\n        private y2AxisGraphicsContext: D3.Selection;\r\n        private element: JQuery;\r\n        private svg: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private margin: IMargin;\r\n        private type: MekkoChartType;\r\n        private hostServices: IVisualHostServices;\r\n        private layers: IMekkoColumnChartVisual[];\r\n        private legend: ILegend;\r\n        private legendMargins: IViewport;\r\n        private layerLegendData: LegendData;\r\n        private hasSetData: boolean;\r\n        private visualInitOptions: VisualInitOptions;\r\n\r\n        private borderObjectProperties: DataViewObject;\r\n        private legendObjectProperties: DataViewObject;\r\n        private categoryAxisProperties: DataViewObject;\r\n\r\n        private valueAxisProperties: DataViewObject;\r\n        private cartesianSmallViewPortProperties: CartesianSmallViewPortProperties;\r\n        private interactivityService: IInteractivityService;\r\n        private behavior: IInteractiveBehavior;\r\n        private y2AxisExists: boolean;\r\n        private categoryAxisHasUnitType: boolean;\r\n        private valueAxisHasUnitType: boolean;\r\n        private hasCategoryAxis: boolean;\r\n        private yAxisIsCategorical: boolean;\r\n        private secValueAxisHasUnitType: boolean;\r\n        private axes: CartesianAxisProperties;\r\n        private yAxisOrientation: string;\r\n        private bottomMarginLimit: number;\r\n        private leftRightMarginLimit: number;\r\n        private sharedColorPalette: SharedColorPalette;\r\n\r\n        public animator: IGenericAnimator;\r\n\r\n        // Scrollbar related\r\n        private isScrollable: boolean;\r\n        private scrollY: boolean;\r\n        private scrollX: boolean;\r\n        private isXScrollBarVisible: boolean;\r\n        private isYScrollBarVisible: boolean;\r\n        private svgScrollable: D3.Selection;\r\n        private axisGraphicsContextScrollable: D3.Selection;\r\n        private labelGraphicsContextScrollable: D3.Selection;\r\n        private brushGraphicsContext: D3.Selection;\r\n        private brush: D3.Svg.Brush;\r\n        private static ScrollBarWidth = 10;\r\n        // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.\r\n        private dataViews: DataView[];\r\n        private currentViewport: IViewport;\r\n\r\n        constructor(options: MekkoConstructorOptions) {\r\n            this.isScrollable = false;\r\n            if (options) {\r\n                this.type = options.chartType;\r\n                if (options.isScrollable)\r\n                    this.isScrollable = options.isScrollable;\r\n                this.animator = options.animator;\r\n                if (options.cartesianSmallViewPortProperties) {\r\n                    this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;\r\n                }\r\n\r\n                if (options.behavior) {\r\n                    this.behavior = options.behavior;\r\n                }\r\n            } else {\r\n                this.behavior = new MekkoChartBehavior([new ColumnChartWebBehavior()]);\r\n            }\r\n        }\r\n\r\n        public init(options: VisualInitOptions) {\r\n            this.visualInitOptions = options;\r\n            this.layers = [];\r\n\r\n            var element = this.element = options.element;\r\n            var viewport = this.currentViewport = options.viewport;\r\n            this.hostServices = options.host;\r\n            this.brush = d3.svg.brush();\r\n            element.addClass(MekkoChart.ClassName);\r\n            this.margin = {\r\n                top: 1,\r\n                right: 1,\r\n                bottom: 1,\r\n                left: 1\r\n            };\r\n            this.yAxisOrientation = yAxisPosition.left;\r\n            this.adjustMargins(viewport);\r\n\r\n            this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors);\r\n\r\n            var showLinesOnX = true;\r\n            var showLinesOnY = true;\r\n\r\n            var svg = this.svg = d3.select(element.get(0)).append('svg');\r\n            svg.style('position', 'absolute');\r\n\r\n            var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\r\n                .classed(MekkoChart.AxisGraphicsContextClassName, true);\r\n\r\n            this.svgScrollable = svg.append('svg')\r\n                .classed('svgScrollable', true)\r\n                .style('overflow', 'hidden');\r\n\r\n            var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\r\n                .classed(MekkoChart.AxisGraphicsContextClassName, true);\r\n\r\n            this.labelGraphicsContextScrollable = this.svgScrollable.append('g')\r\n                .classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\r\n\r\n            if (this.behavior) {\r\n                this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);\r\n            }\r\n\r\n            var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\r\n\r\n            this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\r\n            this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\r\n            this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\r\n\r\n            this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\r\n            this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\r\n            this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\r\n\r\n            this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\r\n            this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\r\n            this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\r\n\r\n            if (this.behavior) {\r\n                this.interactivityService = createInteractivityService(this.hostServices);\r\n            }\r\n            this.legend = createLegend(\r\n                element,\r\n                options.interactivity && options.interactivity.isInteractiveLegend,\r\n                this.interactivityService,\r\n                true);\r\n        }\r\n\r\n        private renderAxesLabels(options: MekkoAxisRenderingOptions): void {\r\n            debug.assertValue(options, 'options');\r\n            debug.assertValue(options.viewport, 'options.viewport');\r\n            debug.assertValue(options.axisLabels, 'options.axisLabels');\r\n\r\n            this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\r\n            this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\r\n\r\n            var margin = this.margin;\r\n            var width = options.viewport.width - (margin.left + margin.right);\r\n            var height = options.viewport.height;\r\n            var fontSize = MekkoChart.FontSize;\r\n            var heightOffset = fontSize;\r\n\r\n            var showOnRight = this.yAxisOrientation === yAxisPosition.right;\r\n\r\n            if (!options.hideXAxisTitle) {\r\n                var xAxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(options.axisLabels.x)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function() {\r\n                            var text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"xAxisLabel\",\r\n                                \"transform\": SVGUtil.translate(width / 2, height - heightOffset)\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                xAxisLabel.style(\"fill\", options.xLabelColor ? options.xLabelColor.solid.color : null);\r\n\r\n                xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    width,\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n\r\n            if (!options.hideYAxisTitle) {\r\n                var yAxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(options.axisLabels.y)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function() {\r\n                            var text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"yAxisLabel\",\r\n                                \"transform\": \"rotate(-90)\",\r\n                                \"y\": showOnRight ? width + margin.right - fontSize : -margin.left,\r\n                                \"x\": -((height - margin.top - options.legendMargin) / 2),\r\n                                \"dy\": \"1em\"\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                yAxisLabel.style(\"fill\", options.yLabelColor ? options.yLabelColor.solid.color : null);\r\n\r\n                yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    height - (margin.bottom + margin.top),\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n\r\n            if (!options.hideY2AxisTitle && options.axisLabels.y2) {\r\n                var y2AxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(options.axisLabels.y2)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function() {\r\n                            var text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"yAxisLabel\",\r\n                                \"transform\": \"rotate(-90)\",\r\n                                \"y\": showOnRight ? -margin.left : width + margin.right - fontSize,\r\n                                \"x\": -((height - margin.top - options.legendMargin) / 2),\r\n                                \"dy\": \"1em\"\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                y2AxisLabel.style(\"fill\", options.y2LabelColor ? options.y2LabelColor.solid.color : null);\r\n\r\n                y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    height - (margin.bottom + margin.top),\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n        }\r\n\r\n        private adjustMargins(viewport: IViewport): void {\r\n            var margin = this.margin;\r\n\r\n            var width = viewport.width - (margin.left + margin.right);\r\n            var height = viewport.height - (margin.top + margin.bottom);\r\n\r\n            // Adjust margins if ticks are not going to be shown on either axis\r\n            var xAxis = this.element.find('.x.axis');\r\n\r\n            if (AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0\r\n                && AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {\r\n                this.margin = {\r\n                    top: 0,\r\n                    right: 0,\r\n                    bottom: 0,\r\n                    left: 0\r\n                };\r\n                xAxis.hide();\r\n            } else {\r\n                xAxis.show();\r\n            }\r\n        }\r\n\r\n        private translateAxes(viewport: IViewport): void {\r\n            this.adjustMargins(viewport);\r\n            var margin = this.margin;\r\n\r\n            var width = viewport.width - (margin.left + margin.right);\r\n            var height = viewport.height - (margin.top + margin.bottom);\r\n\r\n            var showY1OnRight = this.yAxisOrientation === yAxisPosition.right;\r\n\r\n            this.xAxisGraphicsContext\r\n                .attr('transform', SVGUtil.translate(0, height));\r\n\r\n            this.y1AxisGraphicsContext\r\n                .attr('transform', SVGUtil.translate(showY1OnRight ? width : 0, 0));\r\n\r\n            this.y2AxisGraphicsContext\r\n                .attr('transform', SVGUtil.translate(showY1OnRight ? 0 : width, 0));\r\n\r\n            this.svg.attr({\r\n                'width': viewport.width,\r\n                'height': viewport.height\r\n            });\r\n\r\n            this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);\r\n\r\n            this.svgScrollable.attr({\r\n                'width': viewport.width,\r\n                'height': viewport.height\r\n            });\r\n\r\n            this.svgScrollable.attr({\r\n                'x': 0\r\n            });\r\n\r\n            this.axisGraphicsContext.attr('transform', SVGUtil.translate(margin.left, margin.top));\r\n            this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));\r\n            this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(margin.left, margin.top));\r\n\r\n            if (this.isXScrollBarVisible) {\r\n                this.svgScrollable.attr({\r\n                    'x': this.margin.left\r\n                });\r\n                this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));\r\n                this.labelGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, margin.top));\r\n                this.svgScrollable.attr('width', width);\r\n                this.svg.attr('width', viewport.width)\r\n                    .attr('height', viewport.height + MekkoChart.ScrollBarWidth);\r\n            }\r\n            else if (this.isYScrollBarVisible) {\r\n                this.svgScrollable.attr('height', height + margin.top);\r\n                this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)\r\n                    .attr('height', viewport.height);\r\n            }\r\n        }\r\n\r\n        public static getIsScalar(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, type: ValueType): boolean {\r\n            var axisTypeValue = DataViewObjects.getValue(objects, propertyId);\r\n\r\n            if (!objects || axisTypeValue === undefined) {\r\n                // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.\r\n                // If we have the property, it will override the type.\r\n                return !AxisHelper.isOrdinal(type);\r\n            }\r\n\r\n            // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.\r\n            return (axisTypeValue === axisType.scalar) && !AxisHelper.isOrdinal(type);\r\n        }\r\n\r\n        private populateObjectProperties(dataViews: DataView[]) {\r\n            if (dataViews && dataViews.length > 0) {\r\n                var dataViewMetadata = dataViews[0].metadata;\r\n\r\n                if (dataViewMetadata) {\r\n                    this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\r\n                    this.borderObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});\r\n                }\r\n                else {\r\n                    this.legendObjectProperties = {};\r\n                    this.borderObjectProperties = {};\r\n                }\r\n\r\n                this.categoryAxisProperties = CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\r\n                this.valueAxisProperties = CartesianHelper.getValueAxisProperties(dataViewMetadata);\r\n\r\n                if (dataViewMetadata &&\r\n                    dataViewMetadata.objects) {\r\n                    var categoryAxis = dataViewMetadata.objects['categoryAxis'];\r\n                    var valueAxis = dataViewMetadata.objects['valueAxis'];\r\n\r\n                    if (categoryAxis) {\r\n                        this.categoryAxisProperties['showBorder'] = categoryAxis['showBorder'];\r\n                        this.categoryAxisProperties['fontSize'] = categoryAxis['fontSize'];\r\n                    }\r\n\r\n                    if (valueAxis) {\r\n                        this.valueAxisProperties['fontSize'] = valueAxis['fontSize'];\r\n                    }\r\n                }\r\n                var axisPosition = this.valueAxisProperties['position'];\r\n                this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;\r\n            }\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            var dataViews = this.dataViews = options.dataViews;\r\n            this.currentViewport = options.viewport;\r\n\r\n            if (!dataViews) {\r\n                return;\r\n            }\r\n\r\n            if ((this.currentViewport.width < MekkoChart.MinWidth) ||\r\n                (this.currentViewport.height < MekkoChart.MinHeight)) {\r\n                return;\r\n            }\r\n\r\n            if (this.layers.length === 0) {\r\n                // Lazily instantiate the chart layers on the first data load.\r\n                this.layers = this.createAndInitLayers(dataViews);\r\n\r\n                debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');\r\n            }\r\n            var layers = this.layers;\r\n\r\n            if (dataViews && dataViews.length > 0) {\r\n                var warnings = getInvalidValueWarnings(\r\n                    dataViews,\r\n                    false /*supportsNaN*/,\r\n                    false /*supportsNegativeInfinity*/,\r\n                    false /*supportsPositiveInfinity*/);\r\n\r\n                if (warnings && warnings.length > 0) {\r\n                    this.hostServices.setWarnings(warnings);\r\n                }\r\n                this.populateObjectProperties(dataViews);\r\n            }\r\n\r\n            this.sharedColorPalette.clearPreferredScale();\r\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\r\n                layers[i].setData(getLayerData(dataViews, i, len));\r\n\r\n                if (len > 1) {\r\n                    this.sharedColorPalette.rotateScale();\r\n\t\t\t\t}\r\n            }\r\n\r\n            // Note: interactive legend shouldn't be rendered explicitly here\r\n            // The interactive legend is being rendered in the render method of ICartesianVisual\r\n            if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {\r\n                this.renderLegend();\r\n            }\r\n            this.render(!this.hasSetData || options.suppressAnimations);\r\n            this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);\r\n        }\r\n\r\n        public static parseLabelSettings(objects: DataViewObjects): VisualDataLabelsSettings {\r\n            var labelSettings: VisualDataLabelsSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);\r\n            var labelsObj: DataLabelObject = <DataLabelObject>objects['labels'];\r\n            var minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision,\r\n                maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;\r\n\r\n            dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);\r\n\r\n            if (labelSettings.precision < minPrecision) {\r\n                labelSettings.precision = minPrecision;\r\n            }\r\n\r\n            if (labelSettings.precision > maxPrecision) {\r\n                labelSettings.precision = maxPrecision;\r\n            }\r\n\r\n            return labelSettings;\r\n        }\r\n\r\n        public static parseBorderSettings(objects: DataViewObjects): MekkoBorderSettings {\r\n            var show: boolean = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\r\n            var color = DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\r\n            var width: number = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\r\n            var maxWidth: number = MekkoChart.DefaultSettings.columnBorder.maxWidth;\r\n\r\n            if (width > maxWidth) {\r\n                width = maxWidth;\r\n            } else if (width < 0) {\r\n                width = 0;\r\n            }\r\n\r\n            if (!show) {\r\n                width = 0;\r\n            }\r\n\r\n            return {\r\n                show: show,\r\n                color: color,\r\n                width: width,\r\n            };\r\n        }\r\n\r\n        private enumerateBorder(enumeration: ObjectEnumerationBuilder): void {\r\n            var objects: DataViewObjects = {\r\n                columnBorder: this.borderObjectProperties\r\n            };\r\n\r\n            var show = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);\r\n            var color = DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);\r\n            var width = DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);\r\n\r\n            var maxWidth: number = MekkoChart.DefaultSettings.columnBorder.maxWidth;\r\n\r\n            if (width > maxWidth) {\r\n                width = maxWidth;\r\n            } else if (width < 0) {\r\n                width = 0;\r\n            }\r\n\r\n            var instance: VisualObjectInstance = {\r\n                objectName: 'columnBorder',\r\n                selector: null,\r\n                properties: {\r\n                    show: show,\r\n                    color: color,\r\n                    width: width,\r\n                },\r\n            };\r\n            enumeration\r\n                .pushInstance(instance);\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            var enumeration = new ObjectEnumerationBuilder();\r\n            var layersLength = this.layers ? this.layers.length : 0;\r\n\r\n            if (options.objectName === 'columnBorder') {\r\n                this.enumerateBorder(enumeration);\r\n            }\r\n            else if (options.objectName === 'legend') {\r\n                if (!this.shouldShowLegendCard()) {\r\n                    return;\r\n                }\r\n\r\n                var show = DataViewObject.getValue(this.legendObjectProperties, legendProps.show, this.legend.isVisible());\r\n                var showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, true);\r\n                var titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : '');\r\n                var fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);\r\n\r\n                enumeration.pushInstance({\r\n                    selector: null,\r\n                    properties: {\r\n                        show: show,\r\n                        position: LegendPosition[this.legend.getOrientation()],\r\n                        showTitle: showTitle,\r\n                        titleText: titleText,\r\n                        fontSize: fontSize\r\n                    },\r\n                    objectName: options.objectName\r\n                });\r\n            }\r\n            else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {\r\n                this.getCategoryAxisValues(enumeration);\r\n            }\r\n            else if (options.objectName === 'valueAxis') {\r\n                this.getValueAxisValues(enumeration);\r\n            }\r\n\r\n            for (var i: number = 0, len: number = layersLength; i < len; i++) {\r\n                var layer = this.layers[i];\r\n                if (layer.enumerateObjectInstances) {\r\n                    layer.enumerateObjectInstances(enumeration, options);\r\n                }\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private shouldShowLegendCard(): boolean {\r\n            var layers = this.layers;\r\n            var dataViews = this.dataViews;\r\n\r\n            if (layers && dataViews) {\r\n                var layersLength = layers.length;\r\n                var layersWithValuesCtr = 0;\r\n\r\n                for (var i: number = 0; i < layersLength; i++) {\r\n                    if (layers[i].hasLegend()) {\r\n                        return true;\r\n                    }\r\n\r\n                    // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)\r\n                    var dataView = dataViews[i];\r\n                    if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {\r\n                        layersWithValuesCtr++;\r\n                        if (layersWithValuesCtr > 1) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private getCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n            var supportedType: string = axisType.both;\r\n            var isScalar: boolean = false;\r\n            var logPossible: boolean = !!this.axes.x.isLogScaleAllowed;\r\n            var scaleOptions: string[] = [axisScale.log, axisScale.linear];//until options can be update in propPane, show all options\r\n\r\n            if (this.layers && this.layers[0].getSupportedCategoryAxisType) {\r\n                supportedType = this.layers[0].getSupportedCategoryAxisType();\r\n                if (supportedType === axisType.scalar) {\r\n                    isScalar = true;\r\n                }\r\n                else {\r\n                    isScalar = CartesianHelper.isScalar(supportedType === axisType.both, this.categoryAxisProperties);\r\n                }\r\n            }\r\n\r\n            if (!isScalar) {\r\n                if (this.categoryAxisProperties) {\r\n                    this.categoryAxisProperties['start'] = null;\r\n                    this.categoryAxisProperties['end'] = null;\r\n                }\r\n            }\r\n\r\n            var instance: VisualObjectInstance = {\r\n                selector: null,\r\n                properties: {},\r\n                objectName: 'categoryAxis',\r\n                validValues: {\r\n                    axisScale: scaleOptions\r\n                }\r\n            };\r\n\r\n            instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\r\n            if (this.yAxisIsCategorical)//in case of e.g. barChart\r\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\r\n            if (supportedType === axisType.both) {\r\n                instance.properties['axisType'] = isScalar ? axisType.scalar : axisType.categorical;\r\n            }\r\n            if (isScalar) {\r\n                instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : axisScale.linear;\r\n                instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\r\n                instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\r\n            }\r\n            instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\r\n            instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;\r\n\r\n            instance.properties['fontSize'] = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n\r\n            enumeration\r\n                .pushInstance(instance)\r\n                .pushInstance({\r\n                    selector: null,\r\n                    properties: {\r\n                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\r\n                        labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null,\r\n                        fontSize: this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\r\n                    },\r\n                    objectName: 'categoryAxis',\r\n                    validValues: {\r\n                        axisStyle: this.categoryAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly],\r\n                    }\r\n                });\r\n        }\r\n\r\n        //todo: wrap all these object getters and other related stuff into an interface\r\n        private getValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n            var scaleOptions: string[] = [axisScale.log, axisScale.linear];  //until options can be update in propPane, show all options\r\n            var logPossible: boolean = !!this.axes.y1.isLogScaleAllowed;\r\n            //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;\r\n\r\n            var instance: VisualObjectInstance = {\r\n                selector: null,\r\n                properties: {},\r\n                objectName: 'valueAxis',\r\n                validValues: {\r\n                    axisScale: scaleOptions,\r\n                    secAxisScale: scaleOptions\r\n                }\r\n            };\r\n\r\n            instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\r\n\r\n            if (!this.yAxisIsCategorical) {\r\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\r\n            }\r\n            instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : axisScale.linear;\r\n            instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\r\n            instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\r\n            instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;\r\n\r\n            instance.properties['fontSize'] = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n\r\n            enumeration\r\n                .pushInstance(instance)\r\n                .pushInstance({\r\n                    selector: null,\r\n                    properties: {\r\n                        axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\r\n                        labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null,\r\n                        fontSize: this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt\r\n                    },\r\n                    objectName: 'valueAxis',\r\n                    validValues: {\r\n                        axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\r\n                    },\r\n                });\r\n\r\n            if (this.layers.length === 2) {\r\n                instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;\r\n                if (instance.properties['secShow']) {\r\n                    instance.properties['axisLabel'] = '';//this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made\r\n                }\r\n            }\r\n        }\r\n\r\n        public onClearSelection(): void {\r\n            if (this.hasSetData) {\r\n                for (var i: number = 0, len: number = this.layers.length; i < len; i++) {\r\n                    var layer = this.layers[i];\r\n                    layer.onClearSelection();\r\n                    layer.render(true /* suppressAnimations */);\r\n                }\r\n            }\r\n        }\r\n\r\n        private createAndInitLayers(dataViews: DataView[]): IMekkoColumnChartVisual[] {\r\n            var objects: DataViewObjects;\r\n            if (dataViews && dataViews.length > 0) {\r\n                var dataViewMetadata = dataViews[0].metadata;\r\n                if (dataViewMetadata)\r\n                    objects = dataViewMetadata.objects;\r\n            }\r\n\r\n            // Create the layers\r\n            var layers: IMekkoColumnChartVisual[] = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable);\r\n\r\n            // Initialize the layers\r\n            var cartesianOptions = <CartesianVisualInitOptions>Prototype.inherit(this.visualInitOptions);\r\n            cartesianOptions.svg = this.axisGraphicsContextScrollable;\r\n            cartesianOptions.cartesianHost = {\r\n                updateLegend: data => this.legend.drawLegend(data, this.currentViewport),\r\n                getSharedColors: () => this.sharedColorPalette,\r\n                triggerRender: undefined,\r\n            };\r\n\r\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\r\n                layers[i].init(cartesianOptions);\r\n            }\r\n\r\n            return layers;\r\n        }\r\n\r\n        private renderLegend(): void {\r\n            var layers: IMekkoColumnChartVisual[] = this.layers;\r\n            var legendData: LegendData = { title: \"\", dataPoints: [] };\r\n\r\n            for (var i: number = 0, len: number = layers.length; i < len; i++) {\r\n                this.layerLegendData = layers[i].calculateLegend();\r\n                if (this.layerLegendData) {\r\n                    legendData.title = i === 0 ? this.layerLegendData.title || \"\"\r\n                        : legendData.title;\r\n                    legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\r\n                    if (this.layerLegendData.grouped) {\r\n                        legendData.grouped = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            var legendProperties: DataViewObject = this.legendObjectProperties;\r\n            if (legendProperties) {\r\n                if (!legendProperties['fontSize']) {\r\n                    legendProperties['fontSize'] = NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n                }\r\n\r\n                LegendData.update(legendData, legendProperties);\r\n                var position = <string>legendProperties[legendProps.position];\r\n\r\n                if (position) {\r\n                    this.legend.changeOrientation(LegendPosition[position]);\r\n                }\r\n            }\r\n            else {\r\n                this.legend.changeOrientation(LegendPosition.Top);\r\n            }\r\n\r\n            if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\r\n                legendData.dataPoints = [];\r\n            }\r\n\r\n            this.legend.drawLegend(legendData, this.currentViewport);\r\n        }\r\n\r\n        private hideLegends(): boolean {\r\n            if (this.cartesianSmallViewPortProperties) {\r\n                if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private addUnitTypeToAxisLabel(axes: CartesianAxisProperties): void {\r\n            var unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.x);\r\n            if (axes.x.isCategoryAxis) {\r\n                this.categoryAxisHasUnitType = unitType !== null;\r\n            }\r\n            else {\r\n                this.valueAxisHasUnitType = unitType !== null;\r\n            }\r\n\r\n            if (axes.x.axisLabel && unitType) {\r\n                if (axes.x.isCategoryAxis) {\r\n                    axes.x.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);\r\n                }\r\n                else {\r\n                    axes.x.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);\r\n                }\r\n            }\r\n\r\n            unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.y1);\r\n\r\n            if (!axes.y1.isCategoryAxis) {\r\n                this.valueAxisHasUnitType = unitType !== null;\r\n            }\r\n            else {\r\n                this.categoryAxisHasUnitType = unitType !== null;\r\n            }\r\n\r\n            if (axes.y1.axisLabel && unitType) {\r\n                if (!axes.y1.isCategoryAxis) {\r\n                    axes.y1.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);\r\n                }\r\n                else {\r\n                    axes.y1.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);\r\n                }\r\n            }\r\n\r\n            if (axes.y2) {\r\n                var unitType = MekkoChart.getUnitType(axes, (axis: CartesianAxisProperties): IAxisProperties => axis.y2);\r\n                this.secValueAxisHasUnitType = unitType !== null;\r\n                if (axes.y2.axisLabel && unitType) {\r\n                    if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {\r\n                        if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showBoth) {\r\n                            axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';\r\n                        }\r\n                        else if (this.valueAxisProperties['secAxisStyle'] === axisStyle.showUnitOnly) {\r\n                            axes.y2.axisLabel = unitType;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private shouldRenderSecondaryAxis(axisProperties: IAxisProperties): boolean {\r\n            if (!axisProperties) {\r\n                return false;\r\n            }\r\n            if (!this.valueAxisProperties || this.valueAxisProperties[\"secShow\"] == null || this.valueAxisProperties[\"secShow\"]) {\r\n                return axisProperties.values && axisProperties.values.length > 0;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private shouldRenderAxis(axisProperties: IAxisProperties, propertyName: string = \"show\"): boolean {\r\n            if (!axisProperties) {\r\n                return false;\r\n            }\r\n            else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\r\n                return axisProperties.values && axisProperties.values.length > 0;\r\n            }\r\n            else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\r\n                return axisProperties.values && axisProperties.values.length > 0;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private render(suppressAnimations: boolean): void {\r\n            var legendMargins: IViewport = this.legendMargins = this.legend.getMargins();\r\n            var viewport: IViewport = {\r\n                height: this.currentViewport.height - legendMargins.height,\r\n                width: this.currentViewport.width - legendMargins.width\r\n            };\r\n\r\n            var maxMarginFactor = this.getMaxMarginFactor();\r\n            var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;\r\n            this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));\r\n\r\n            var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(<any>this.categoryAxisProperties['fontSize']) || undefined);\r\n            var y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(<any>this.valueAxisProperties['fontSize']) || undefined);\r\n\r\n            var margin = this.margin;\r\n            // reset defaults\r\n            margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2;\r\n            margin.bottom = MekkoChart.MinBottomMargin;\r\n            margin.right = 0;\r\n\r\n            var axes: CartesianAxisProperties = this.axes = calculateAxes(\r\n                this.layers,\r\n                viewport,\r\n                margin,\r\n                this.categoryAxisProperties,\r\n                this.valueAxisProperties,\r\n                this.isXScrollBarVisible || this.isYScrollBarVisible,\r\n                null);\r\n\r\n            this.yAxisIsCategorical = axes.y1.isCategoryAxis;\r\n            this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;\r\n\r\n            var renderXAxis = this.shouldRenderAxis(axes.x);\r\n            var renderY1Axis = this.shouldRenderAxis(axes.y1);\r\n            var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);\r\n\r\n            var width: number = viewport.width - (margin.left + margin.right);\r\n            var isScalar: boolean = false;\r\n            var mainAxisScale;\r\n            var preferredViewport: IViewport;\r\n            this.isXScrollBarVisible = false;\r\n            this.isYScrollBarVisible = false;\r\n\r\n            var yAxisOrientation = this.yAxisOrientation;\r\n            var showY1OnRight = yAxisOrientation === yAxisPosition.right;\r\n\r\n            if (this.layers) {\r\n                if (this.layers[0].getVisualCategoryAxisIsScalar) {\r\n                    isScalar = this.layers[0].getVisualCategoryAxisIsScalar();\r\n                }\r\n\r\n                if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {\r\n                    var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;\r\n                    var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;\r\n                    preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);\r\n                    if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {\r\n                        this.isXScrollBarVisible = true;\r\n                        viewport.height -= MekkoChart.ScrollBarWidth;\r\n                    }\r\n\r\n                    if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {\r\n                        this.isYScrollBarVisible = true;\r\n                        viewport.width -= MekkoChart.ScrollBarWidth;\r\n                        width = viewport.width - (margin.left + margin.right);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Only create the g tag where there is a scrollbar\r\n            if (this.isXScrollBarVisible || this.isYScrollBarVisible) {\r\n                if (!this.brushGraphicsContext) {\r\n                    this.brushGraphicsContext = this.svg.append(\"g\")\r\n                        .classed('x brush', true);\r\n                }\r\n            }\r\n            else {\r\n                // clear any existing brush if no scrollbar is shown\r\n                this.svg.selectAll('.brush').remove();\r\n                this.brushGraphicsContext = undefined;\r\n            }\r\n\r\n            // Recalculate axes now that scrollbar visible variables have been set\r\n            axes = calculateAxes(\r\n                this.layers,\r\n                viewport,\r\n                margin,\r\n                this.categoryAxisProperties,\r\n                this.valueAxisProperties,\r\n                this.isXScrollBarVisible || this.isYScrollBarVisible,\r\n                null);\r\n\r\n            // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.\r\n            // after the second pass the margins are correct.\r\n            var doneWithMargins: boolean = false,\r\n                maxIterations: number = 2,\r\n                numIterations: number = 0;\r\n            var tickLabelMargins = undefined;\r\n            var chartHasAxisLabels = undefined;\r\n            var axisLabels: ChartAxesLabels = undefined;\r\n            while (!doneWithMargins && numIterations < maxIterations) {\r\n                numIterations++;\r\n                tickLabelMargins = getTickLabelMargins(\r\n                    { width: width, height: viewport.height },\r\n                    leftRightMarginLimit,\r\n                    TextMeasurementService.measureSvgTextWidth,\r\n                    TextMeasurementService.estimateSvgTextHeight,\r\n                    axes,\r\n                    this.bottomMarginLimit,\r\n                    xAxisTextProperties,\r\n                    y1AxisTextProperties,\r\n                    null,\r\n                    false,\r\n                    this.isXScrollBarVisible || this.isYScrollBarVisible,\r\n                    showY1OnRight,\r\n                    renderXAxis,\r\n                    renderY1Axis,\r\n                    renderY2Axis);\r\n\r\n                // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\r\n                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\r\n                    maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\r\n                    xMax = renderXAxis ? (tickLabelMargins.xMax/1.8) : 0;\r\n\r\n                maxMainYaxisSide += MekkoChart.LeftPadding;\r\n                maxSecondYaxisSide += MekkoChart.RightPadding;\r\n                xMax += MekkoChart.BottomPadding;\r\n\r\n                if (this.hideAxisLabels(legendMargins)) {\r\n                    axes.x.axisLabel = null;\r\n                    axes.y1.axisLabel = null;\r\n                    if (axes.y2) {\r\n                        axes.y2.axisLabel = null;\r\n                    }\r\n                }\r\n\r\n                this.addUnitTypeToAxisLabel(axes);\r\n\r\n                axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };\r\n                chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\r\n\r\n                if (axisLabels.x != null) {\r\n                    xMax += MekkoChart.XAxisLabelPadding;\r\n                }\r\n                if (axisLabels.y != null) {\r\n                    maxMainYaxisSide += MekkoChart.YAxisLabelPadding;\r\n                }\r\n                if (axisLabels.y2 != null) {\r\n                    maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;\r\n                }\r\n\r\n                margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\r\n                margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\r\n                margin.bottom = xMax;\r\n                this.margin = margin;\r\n\r\n                width = viewport.width - (margin.left + margin.right);\r\n\r\n                // re-calculate the axes with the new margins\r\n                var previousTickCountY1 = axes.y1.values.length;\r\n                var previousTickCountY2 = axes.y2 && axes.y2.values.length;\r\n                axes = calculateAxes(\r\n                    this.layers,\r\n                    viewport,\r\n                    margin,\r\n                    this.categoryAxisProperties,\r\n                    this.valueAxisProperties,\r\n                    this.isXScrollBarVisible || this.isYScrollBarVisible,\r\n                    axes);\r\n\r\n                // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\r\n                // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\r\n                if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))\r\n                    doneWithMargins = true;\r\n            }\r\n\r\n            this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);\r\n        }\r\n\r\n        private hideAxisLabels(legendMargins: IViewport): boolean {\r\n            if (this.cartesianSmallViewPortProperties) {\r\n                if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static getUnitType(axis: CartesianAxisProperties, axisPropertiesLookup: (axis: CartesianAxisProperties) => IAxisProperties) {\r\n            if (axisPropertiesLookup(axis).formatter &&\r\n                axisPropertiesLookup(axis).formatter.displayUnit &&\r\n                axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {\r\n                    return axisPropertiesLookup(axis).formatter.displayUnit.title;\r\n                }\r\n            return null;\r\n        }\r\n\r\n        private getMaxMarginFactor(): number {\r\n            return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;\r\n        }\r\n\r\n        private static getChartViewport(viewport: IViewport, margin: IMargin): IViewport {\r\n            return {\r\n                width: viewport.width - margin.left - margin.right,\r\n                height: viewport.height - margin.top - margin.bottom,\r\n            };\r\n        }\r\n\r\n        private static wordBreak(\r\n            text: D3.Selection,\r\n            axisProperties: IAxisProperties,\r\n            columnsWidth: number[],\r\n            maxHeight: number,\r\n            borderWidth: number): void {\r\n\r\n            //var allowedLength = axisProperties.xLabelMaxWidth;\r\n            text.each(function(data: any, index: number) {\r\n                var width: number, allowedLength: number;\r\n                var node = d3.select(this);\r\n                if (columnsWidth.length >= index) {\r\n                    width = columnsWidth[index];\r\n                    allowedLength = axisProperties.scale(width);\r\n                } else {\r\n                    allowedLength = axisProperties.xLabelMaxWidth;\r\n                }\r\n                // Reset style of text node\r\n                node\r\n                    .style('text-anchor', 'middle')\r\n                    .attr({\r\n                        'dx': '0em',\r\n                        'dy': '1em',\r\n                        'transform': 'rotate(0)'\r\n                    });\r\n\r\n                TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);\r\n            });\r\n        }\r\n\r\n        private renderChart(\r\n            mainAxisScale: any,\r\n            axes: CartesianAxisProperties,\r\n            width: number,\r\n            tickLabelMargins: any,\r\n            chartHasAxisLabels: boolean,\r\n            axisLabels: ChartAxesLabels,\r\n            viewport: IViewport,\r\n            suppressAnimations: boolean,\r\n            scrollScale?: any,\r\n            extent?: number[]) {\r\n\r\n            var bottomMarginLimit: number = this.bottomMarginLimit;\r\n            var leftRightMarginLimit: number = this.leftRightMarginLimit;\r\n            var layers: IMekkoColumnChartVisual[] = this.layers;\r\n            var duration: number = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\r\n            var chartViewport: IViewport = MekkoChart.getChartViewport(viewport, this.margin);\r\n\r\n            debug.assertValue(layers, 'layers');\r\n\r\n            var xLabelColor: Fill;\r\n            var yLabelColor: Fill;\r\n            var y2LabelColor: Fill;\r\n\r\n            var xFontSize: any;\r\n            var yFontSize: any;\r\n            //hide show x-axis here\r\n            if (this.shouldRenderAxis(axes.x)) {\r\n                if (axes.x.isCategoryAxis) {\r\n                    xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\r\n                    xFontSize =   this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n                } else {\r\n                    xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\r\n                    xFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n                }\r\n                axes.x.axis.orient(\"bottom\");\r\n                if (!axes.x.willLabelsFit) {\r\n                    axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);\r\n                }\r\n\r\n                var xAxisGraphicsElement: D3.Selection = this.xAxisGraphicsContext;\r\n                if (duration) {\r\n                    xAxisGraphicsElement\r\n                        .transition()\r\n                        .duration(duration)\r\n                        .call(axes.x.axis);\r\n                }\r\n                else {\r\n                    xAxisGraphicsElement\r\n                        .call(axes.x.axis);\r\n                }\r\n\r\n                xAxisGraphicsElement\r\n                    .call(MekkoChart.darkenZeroLine)\r\n                    .call(MekkoChart.setAxisLabelColor, xLabelColor)\r\n                    .call(MekkoChart.setAxisLabelFontSize, xFontSize);\r\n\r\n                var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\r\n\r\n                var columnWidth: number[] = [];\r\n                var borderWidth: number = 0;\r\n                if (this.layers && this.layers.length) {\r\n                    columnWidth = this.layers[0].getColumnsWidth();\r\n                    borderWidth = this.layers[0].getBorderWidth();\r\n                }\r\n\r\n                xAxisGraphicsElement\r\n                    .call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8);\r\n\r\n                xAxisTextNodes\r\n                    .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);\r\n            }\r\n            else {\r\n                this.xAxisGraphicsContext.selectAll('*').remove();\r\n            }\r\n\r\n            if (this.shouldRenderAxis(axes.y1)) {\r\n                if (axes.y1.isCategoryAxis) {\r\n                    yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;\r\n                    yFontSize =   this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n                } else {\r\n                    yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;\r\n                    yFontSize =   this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;\r\n                }\r\n                var yAxisOrientation = this.yAxisOrientation;\r\n                var showY1OnRight = yAxisOrientation === yAxisPosition.right;\r\n                axes.y1.axis\r\n                    .tickSize(-width)\r\n                    .tickPadding(MekkoChart.TickPaddingY)\r\n                    .orient(yAxisOrientation.toLowerCase());\r\n\r\n                var y1AxisGraphicsElement: D3.Selection = this.y1AxisGraphicsContext;\r\n                if (duration) {\r\n                    y1AxisGraphicsElement\r\n                        .transition()\r\n                        .duration(duration)\r\n                        .call(axes.y1.axis);\r\n                }\r\n                else {\r\n                    y1AxisGraphicsElement\r\n                        .call(axes.y1.axis);\r\n                }\r\n\r\n                y1AxisGraphicsElement\r\n                    .call(MekkoChart.darkenZeroLine)\r\n                    .call(MekkoChart.setAxisLabelColor, yLabelColor)\r\n                    .call(MekkoChart.setAxisLabelFontSize, yFontSize);\r\n\r\n                if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\r\n                    y1AxisGraphicsElement.selectAll('text')\r\n                        .call(AxisHelper.LabelLayoutStrategy.clip,\r\n                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations\r\n                        leftRightMarginLimit - MekkoChart.LeftPadding,\r\n                        TextMeasurementService.svgEllipsis);\r\n                }\r\n\r\n                if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {\r\n                    y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;\r\n\r\n                    axes.y2.axis\r\n                        .tickPadding(MekkoChart.TickPaddingY)\r\n                        .orient(showY1OnRight ? yAxisPosition.left.toLowerCase() : yAxisPosition.right.toLowerCase());\r\n\r\n                    if (duration) {\r\n                        this.y2AxisGraphicsContext\r\n                            .transition()\r\n                            .duration(duration)\r\n                            .call(axes.y2.axis);\r\n                    }\r\n                    else {\r\n                        this.y2AxisGraphicsContext\r\n                            .call(axes.y2.axis);\r\n                    }\r\n\r\n                    this.y2AxisGraphicsContext\r\n                        .call(MekkoChart.darkenZeroLine)\r\n                        .call(MekkoChart.setAxisLabelColor, y2LabelColor);\r\n\r\n                    if (tickLabelMargins.yRight >= leftRightMarginLimit) {\r\n                        this.y2AxisGraphicsContext.selectAll('text')\r\n                            .call(AxisHelper.LabelLayoutStrategy.clip,\r\n                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations\r\n                            leftRightMarginLimit - MekkoChart.RightPadding,\r\n                            TextMeasurementService.svgEllipsis);\r\n                    }\r\n                }\r\n                else {\r\n                    this.y2AxisGraphicsContext.selectAll('*').remove();\r\n                }\r\n            }\r\n            else {\r\n                this.y1AxisGraphicsContext.selectAll('*').remove();\r\n                this.y2AxisGraphicsContext.selectAll('*').remove();\r\n            }\r\n\r\n            // Axis labels\r\n            if (chartHasAxisLabels) {\r\n                var hideXAxisTitle: boolean = !this.shouldRenderAxis(axes.x, \"showAxisTitle\");\r\n                var hideYAxisTitle: boolean = !this.shouldRenderAxis(axes.y1, \"showAxisTitle\");\r\n                var hideY2AxisTitle: boolean = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\r\n\r\n                var renderAxisOptions: MekkoAxisRenderingOptions = {\r\n                    axisLabels: axisLabels,\r\n                    legendMargin: this.legendMargins.height,\r\n                    viewport: viewport,\r\n                    hideXAxisTitle: hideXAxisTitle,\r\n                    hideYAxisTitle: hideYAxisTitle,\r\n                    hideY2AxisTitle: hideY2AxisTitle,\r\n                    xLabelColor: xLabelColor,\r\n                    yLabelColor: yLabelColor,\r\n                    y2LabelColor: y2LabelColor,\r\n                    margin: undefined,\r\n                };\r\n\r\n                this.renderAxesLabels(renderAxisOptions);\r\n            }\r\n            else {\r\n                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\r\n                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\r\n            }\r\n\r\n            this.translateAxes(viewport);\r\n\r\n            var dataPoints: SelectableDataPoint[] = [];\r\n            var layerBehaviorOptions: any[] = [];\r\n            var labelDataPointsGroup: MekkoLabelDataPointsGroup[] = [];\r\n\r\n            //Render chart columns\r\n            if (this.behavior) {\r\n                for (var i: number = 0, len: number = layers.length; i < len; i++) {\r\n                    var result: MekkoVisualRenderResult = layers[i].render(suppressAnimations);\r\n                    if (result) {\r\n                        dataPoints = dataPoints.concat(result.dataPoints);\r\n                        layerBehaviorOptions.push(result.behaviorOptions);\r\n\r\n                        if (result.labelDataPointGroups) {\r\n                            var resultLabelDataPointsGroups = result.labelDataPointGroups;\r\n                            for (var j: number = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {\r\n                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];\r\n                                labelDataPointsGroup.push({\r\n                                    labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,\r\n                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,\r\n                                });\r\n                            }\r\n                        }\r\n                        else {\r\n                            var resultsLabelDataPoints: MekkoLabelDataPoint[] = result.labelDataPoints;\r\n                            var reducedDataPoints: MekkoLabelDataPoint[] = resultsLabelDataPoints;\r\n                            labelDataPointsGroup.push({\r\n                                labelDataPoints: reducedDataPoints,\r\n                                maxNumberOfLabels: reducedDataPoints.length,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var labelLayoutOptions: DataLabelLayoutOptions = {\r\n                    maximumOffset: NewDataLabelUtils.maxLabelOffset,\r\n                    startingOffset: NewDataLabelUtils.startingLabelOffset\r\n                };\r\n\r\n                var labelLayout: LabelLayout = new LabelLayout(labelLayoutOptions);\r\n                var dataLabels: Label[] = labelLayout.layout(labelDataPointsGroup, chartViewport);\r\n\r\n                if (layers.length > 1) {\r\n                    NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, \"#FFFFFF\", 0.7);\r\n                }\r\n                if (this.animator && !suppressAnimations) {\r\n                    NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());\r\n                }\r\n                else {\r\n                    NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);\r\n                }\r\n                this.labelGraphicsContextScrollable.selectAll(\"text.label\").style(\"pointer-events\", \"none\");\r\n                if (this.interactivityService) {\r\n                    var behaviorOptions: MekkoBehaviorOptions = {\r\n                        layerOptions: layerBehaviorOptions,\r\n                        clearCatcher: this.clearCatcher,\r\n                    };\r\n                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        /**\r\n         * Within the context of the given selection (g), find the offset of\r\n         * the zero tick using the d3 attached datum of g.tick elements.\r\n         * 'Classed' is undefined for transition selections\r\n         */\r\n        private static darkenZeroLine(g: D3.Selection): void {\r\n            var zeroTick = g.selectAll('g.tick').filter((data) => data === 0).node();\r\n            if (zeroTick) {\r\n                d3.select(zeroTick).select('line').classed('zero-line', true);\r\n            }\r\n        }\r\n\r\n        private static setAxisLabelColor(g: D3.Selection, fill: Fill): void {\r\n            g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);\r\n        }\r\n\r\n        private static setAxisLabelFontSize(g: D3.Selection, fontSize: number): void {\r\n            var value = jsCommon.PixelConverter.toString(fontSize);\r\n            g.selectAll('g.tick text').attr('font-size', value);\r\n        }\r\n\r\n        private static moveBorder(g: D3.Selection, scale: D3.Scale.LinearScale, borderWidth: number, yOffset: number = 0): void {\r\n            g.selectAll('g.tick')\r\n                .attr(\"transform\", function(value: number, index: number) {\r\n                     return SVGUtil.translate(scale(value) + (borderWidth * index), yOffset);\r\n            });\r\n        }\r\n    }\r\n\r\n    function getTickLabelMargins(\r\n        viewport: IViewport,\r\n        yMarginLimit: number,\r\n        textWidthMeasurer: ITextAsSVGMeasurer,\r\n        textHeightMeasurer: ITextAsSVGMeasurer,\r\n        axes: CartesianAxisProperties,\r\n        bottomMarginLimit: number,\r\n        xAxisTextProperties: TextProperties,\r\n        y1AxisTextProperties: TextProperties,\r\n        y2AxisTextProperties: TextProperties,\r\n        enableOverflowCheck: boolean,\r\n        scrollbarVisible?: boolean,\r\n        showOnRight?: boolean,\r\n        renderXAxis?: boolean,\r\n        renderY1Axis?: boolean,\r\n        renderY2Axis?: boolean): TickLabelMargins {\r\n\r\n        var XLabelMaxAllowedOverflow = 35;\r\n\r\n        debug.assertValue(axes, 'axes');\r\n        var xAxisProperties: IAxisProperties = axes.x;\r\n        var y1AxisProperties: IAxisProperties = axes.y1;\r\n        var y2AxisProperties: IAxisProperties = axes.y2;\r\n\r\n        debug.assertValue(viewport, 'viewport');\r\n        debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');\r\n        debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');\r\n        debug.assertValue(xAxisProperties, 'xAxis');\r\n        debug.assertValue(y1AxisProperties, 'yAxis');\r\n\r\n        var xLabels = xAxisProperties.values;\r\n        var y1Labels = y1AxisProperties.values;\r\n\r\n        var leftOverflow = 0;\r\n        var rightOverflow = 0;\r\n        var maxWidthY1 = 0;\r\n        var maxWidthY2 = 0;\r\n        var xMax = 0; // bottom margin\r\n        var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;\r\n        var scaleIsOrdinal = AxisHelper.isOrdinalScale(xAxisProperties.scale);\r\n\r\n        var xLabelOuterPadding = 0;\r\n        if (xAxisProperties.outerPadding !== undefined) {\r\n            xLabelOuterPadding = xAxisProperties.outerPadding;\r\n        }\r\n        else if (xAxisProperties.xLabelMaxWidth !== undefined) {\r\n            xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);\r\n        }\r\n\r\n        if (AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0\r\n            ||AxisHelper. getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {\r\n            var rotation;\r\n            if (scrollbarVisible)\r\n                rotation = AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar;\r\n            else\r\n                rotation = AxisHelper.LabelLayoutStrategy.DefaultRotation;\r\n\r\n            if (renderY1Axis) {\r\n                for (var i = 0, len = y1Labels.length; i < len; i++) {\r\n                    y1AxisTextProperties.text = y1Labels[i];\r\n                    maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));\r\n                }\r\n            }\r\n\r\n            if (y2AxisProperties && renderY2Axis) {\r\n                var y2Labels = y2AxisProperties.values;\r\n                for (var i = 0, len = y2Labels.length; i < len; i++) {\r\n                    y2AxisTextProperties.text = y2Labels[i];\r\n                    maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));\r\n                }\r\n            }\r\n\r\n            var textHeight = textHeightMeasurer(xAxisTextProperties);\r\n            var maxNumLines = Math.floor(bottomMarginLimit / textHeight);\r\n            var xScale = xAxisProperties.scale;\r\n            var xDomain = xScale.domain();\r\n            if (renderXAxis && xLabels.length > 0) {\r\n                for (var i = 0, len = xLabels.length; i < len; i++) {\r\n                    // find the max height of the x-labels, perhaps rotated or wrapped\r\n                    var height: number;\r\n                    xAxisTextProperties.text = xLabels[i];\r\n                    var width = textWidthMeasurer(xAxisTextProperties);\r\n                    if (xAxisProperties.willLabelsWordBreak) {\r\n                        // Split label and count rows\r\n                        var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);\r\n                        height = wordBreaks.length * textHeight;\r\n                        // word wrapping will truncate at xLabelMaxWidth\r\n                        width = xAxisProperties.xLabelMaxWidth;\r\n                    }\r\n                    else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {\r\n                        height = width * rotation.sine;\r\n                        width = width * rotation.cosine;\r\n                    }\r\n                    else {\r\n                        height = textHeight;\r\n                    }\r\n\r\n                    // calculate left and right overflow due to wide X labels\r\n                    // (Note: no right overflow when rotated)\r\n                    if (i === 0) {\r\n                        if (scaleIsOrdinal) {\r\n                            if (!xAxisProperties.willLabelsFit /*rotated text*/)\r\n                                leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;\r\n                            else\r\n                                leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\r\n                            leftOverflow = Math.max(leftOverflow, 0);\r\n                        }\r\n                        else if (xDomain.length > 1) {\r\n                            // Scalar - do some math\r\n                            var xPos = xScale(xDomain[0]);\r\n                            // xPos already incorporates xLabelOuterPadding, don't subtract it twice\r\n                            leftOverflow = (width / 2) - xPos;\r\n                            leftOverflow = Math.max(leftOverflow, 0);\r\n                        }\r\n                    } else if (i === len - 1) {\r\n                        if (scaleIsOrdinal) {\r\n                            // if we are rotating text (!willLabelsFit) there won't be any right overflow\r\n                            if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {\r\n                                // assume this label is placed near the edge\r\n                                rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;\r\n                                rightOverflow = Math.max(rightOverflow, 0);\r\n                            }\r\n                        }\r\n                        else if (xDomain.length > 1) {\r\n                            // Scalar - do some math\r\n                            var xPos = xScale(xDomain[1]);\r\n                            // xPos already incorporates xLabelOuterPadding, don't subtract it twice\r\n                            rightOverflow = (width / 2) - (viewport.width - xPos);\r\n                            rightOverflow = Math.max(rightOverflow, 0);\r\n                        }\r\n                    }\r\n\r\n                    xMax = Math.max(xMax, height);\r\n                }\r\n                // trim any actual overflow to the limit\r\n                leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0;\r\n                rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;\r\n            }\r\n        }\r\n\r\n        var rightMargin = 0,\r\n            leftMargin = 0,\r\n            bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);\r\n\r\n        if (showOnRight) {\r\n            leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);\r\n            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);\r\n        }\r\n        else {\r\n            leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);\r\n            rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);\r\n        }\r\n\r\n        return {\r\n            xMax: Math.ceil(bottomMargin),\r\n            yLeft: Math.ceil(leftMargin),\r\n            yRight: Math.ceil(rightMargin),\r\n        };\r\n    }\r\n\r\n    function getLayerData(dataViews: DataView[], currentIdx: number, totalLayers: number): DataView[] {\r\n        if (totalLayers > 1) {\r\n            if (dataViews && dataViews.length > currentIdx)\r\n                return [dataViews[currentIdx]];\r\n            return [];\r\n        }\r\n\r\n        return dataViews;\r\n    }\r\n\r\n    /**\r\n     * Returns a boolean, that indicates if y axis title should be displayed.\r\n     * @return True if y axis title should be displayed,\r\n     * otherwise false.\r\n     */\r\n    function shouldShowYAxisLabel(layerNumber: number, valueAxisProperties: DataViewObject, yAxisWillMerge: boolean): boolean {\r\n        return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||\r\n            (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));\r\n    }\r\n\r\n    /**\r\n     * Computes the Cartesian Chart axes from the set of layers.\r\n     */\r\n    function calculateAxes(\r\n        layers: IMekkoColumnChartVisual[],\r\n        viewport: IViewport,\r\n        margin: IMargin,\r\n        categoryAxisProperties: DataViewObject,\r\n        valueAxisProperties: DataViewObject,\r\n        scrollbarVisible: boolean,\r\n        existingAxisProperties: CartesianAxisProperties): CartesianAxisProperties {\r\n        debug.assertValue(layers, 'layers');\r\n\r\n        var visualOptions: MekkoCalculateScaleAndDomainOptions = {\r\n            viewport: viewport,\r\n            margin: margin,\r\n            forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\r\n            forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\r\n            showCategoryAxisLabel: false,\r\n            showValueAxisLabel: false,\r\n            categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? <string>categoryAxisProperties['axisScale'] : axisScale.linear,\r\n            valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? <string>valueAxisProperties['axisScale'] : axisScale.linear,\r\n            trimOrdinalDataOnOverflow: false\r\n        };\r\n\r\n        var yAxisWillMerge = false;\r\n\r\n        if (valueAxisProperties) {\r\n            visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\r\n        }\r\n\r\n        var result: CartesianAxisProperties;\r\n        for (var layerNumber: number = 0, len: number = layers.length; layerNumber < len; layerNumber++) {\r\n            var currentlayer = layers[layerNumber];\r\n            visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);//here\r\n            //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here\r\n            visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);\r\n\r\n            var axes = currentlayer.calculateAxesProperties(visualOptions);\r\n\r\n            if (layerNumber === 0) {\r\n                result = {\r\n                    x: axes[0],\r\n                    y1: axes[1]\r\n                };\r\n            }\r\n\r\n            result.x.willLabelsFit = false;\r\n            result.x.willLabelsWordBreak = false;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    export function createLayers(\r\n        type: MekkoChartType,\r\n        objects: DataViewObjects,\r\n        interactivityService: IInteractivityService,\r\n        animator?: any,\r\n        isScrollable: boolean = true): IMekkoColumnChartVisual[] {\r\n\r\n        var layers: IMekkoColumnChartVisual[] = [];\r\n\r\n        var cartesianOptions: CartesianVisualConstructorOptions = {\r\n            isScrollable: isScrollable,\r\n            animator: animator,\r\n            interactivityService: interactivityService\r\n        };\r\n\r\n        layers.push(createMekkoChartLayer(ColumnChartType.hundredPercentStackedColumn, cartesianOptions));\r\n\r\n        return layers;\r\n    }\r\n\r\n    function createMekkoChartLayer(type: ColumnChartType, defaultOptions: CartesianVisualConstructorOptions): MekkoColumnChart {\r\n        var options: ColumnChartConstructorOptions = {\r\n            animator: <IColumnChartAnimator>defaultOptions.animator,\r\n            interactivityService: defaultOptions.interactivityService,\r\n            isScrollable: defaultOptions.isScrollable,\r\n            chartType: type\r\n        };\r\n        return new MekkoColumnChart(options);\r\n    }\r\n\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    var flagBar: number = 1 << 1;\r\n    //var flagColumn: number = 1 << 2;\r\n    var flagStacked: number = 1 << 4;\r\n\r\n    var RoleNames = {\r\n        category: 'Category',\r\n        series: 'Series',\r\n        y: 'Y',\r\n        width: 'Width'\r\n    };\r\n\r\n    /**\r\n     * Renders a stacked and clustered column chart.\r\n     */\r\n    export interface IMekkoColumnChartVisual /*extends ICartesianVisual*/ {\r\n        getColumnsWidth(): number[];\r\n        getBorderWidth(): number;\r\n\r\n\t\tinit(options: CartesianVisualInitOptions): void;\r\n        setData(dataViews: DataView[], resized?: boolean): void;\r\n        calculateAxesProperties(options: CalculateScaleAndDomainOptions): IAxisProperties[];\r\n        overrideXScale(xProperties: IAxisProperties): void;\r\n        render(suppressAnimations: boolean): MekkoVisualRenderResult;\r\n        calculateLegend(): LegendData;\r\n        hasLegend(): boolean;\r\n        onClearSelection(): void;\r\n        enumerateObjectInstances?(enumeration: ObjectEnumerationBuilder, options: EnumerateVisualObjectInstancesOptions): void;\r\n        getVisualCategoryAxisIsScalar?(): boolean;\r\n        getSupportedCategoryAxisType?(): string;\r\n        getPreferredPlotArea?(isScalar: boolean, categoryCount: number, categoryThickness: number): IViewport;\r\n        setFilteredData?(startIndex: number, endIndex: number): CartesianData;\r\n    }\r\n\r\n    export interface IMekkoColumnChartStrategy /*extends IColumnChartStrategy*/ {\r\n\t\tdrawColumns(useAnimation: boolean): MekkoColumnChartDrawInfo;\r\n\r\n\t\tsetData(data: ColumnChartData): void;\r\n        setupVisualProps(columnChartProps: ColumnChartContext): void;\r\n        setXScale(is100Pct: boolean, forcedTickCount?: number, forcedXDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;\r\n        setYScale(is100Pct: boolean, forcedTickCount?: number, forcedYDomain?: any[], axisScaleType?: string, axisDisplayUnits?: number, axisPrecision?: number): IAxisProperties;\r\n\r\n        selectColumn(selectedColumnIndex: number, lastSelectedColumnIndex: number): void;\r\n        getClosestColumnIndex(x: number, y: number): number;\r\n    }\r\n\r\n    export class MekkoColumnChart implements IMekkoColumnChartVisual {\r\n        private static ColumnChartClassName = 'columnChart';\r\n\r\n        public static SeriesClasses: ClassAndSelector = createClassAndSelector(\"series\");\r\n        public static BorderClass: ClassAndSelector = createClassAndSelector(\"mekkoborder\");\r\n\r\n        private svg: D3.Selection;\r\n        private unclippedGraphicsContext: D3.Selection;\r\n        private mainGraphicsContext: D3.Selection;\r\n        private labelGraphicsContext: D3.Selection;\r\n        private xAxisProperties: IAxisProperties;\r\n        private yAxisProperties: IAxisProperties;\r\n        private currentViewport: IViewport;\r\n        private data: MekkoColumnChartData;\r\n        private style: IVisualStyle;\r\n        private colors: IDataColorPalette;\r\n        private chartType: ColumnChartType;\r\n        private columnChart: IMekkoColumnChartStrategy;\r\n        private hostService: IVisualHostServices;\r\n        private cartesianVisualHost: ICartesianVisualHost;\r\n        private interactivity: InteractivityOptions;\r\n        private margin: IMargin;\r\n        private options: CartesianVisualInitOptions;\r\n        private lastInteractiveSelectedColumnIndex: number;\r\n        private supportsOverflow: boolean;\r\n        private interactivityService: IInteractivityService;\r\n        private dataViewCat: DataViewCategorical;\r\n        private categoryAxisType: string;\r\n        private animator: IColumnChartAnimator;\r\n        private isScrollable: boolean;\r\n        private element: JQuery;\r\n\r\n        constructor(options: ColumnChartConstructorOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            var chartType: ColumnChartType = options.chartType;\r\n            debug.assertValue(chartType, 'chartType');\r\n            this.chartType = chartType;\r\n            this.categoryAxisType = null;\r\n            this.animator = options.animator;\r\n            this.isScrollable = options.isScrollable;\r\n            this.interactivityService = options.interactivityService;\r\n        }\r\n\r\n        public init(options: CartesianVisualInitOptions) {\r\n            this.svg = options.svg;\r\n            this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);\r\n            this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);\r\n            this.labelGraphicsContext = this.svg.append('g').classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);\r\n\r\n            this.style = options.style;\r\n            this.currentViewport = options.viewport;\r\n            this.hostService = options.host;\r\n            this.interactivity = options.interactivity;\r\n            this.colors = this.style.colorPalette.dataColors;\r\n            this.cartesianVisualHost = options.cartesianHost;\r\n            this.options = options;\r\n            this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);\r\n            var element = this.element = options.element;\r\n            element.addClass(MekkoColumnChart.ColumnChartClassName);\r\n\r\n            this.columnChart = new MekkoColumnChartStrategy();\r\n        }\r\n\r\n        private getCategoryLayout(numCategoryValues: number, options: MekkoCalculateScaleAndDomainOptions): CategoryLayout {\r\n            var availableWidth: number = this.currentViewport.width - (this.margin.left + this.margin.right);\r\n            var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\r\n            var categoryDataType: ValueType = AxisHelper.getCategoryValueType(metaDataColumn);\r\n            var isScalar = this.data ? this.data.scalarCategoryAxis : false;\r\n            var domain = AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);\r\n\r\n            return CartesianChart.getLayout(\r\n                this.data,\r\n                {\r\n                    availableWidth: availableWidth,\r\n                    categoryCount: numCategoryValues,\r\n                    domain: domain,\r\n                    isScalar: isScalar,\r\n                    isScrollable: this.isScrollable,\r\n                    trimOrdinalDataOnOverflow: false\r\n                });\r\n        }\r\n\r\n        public static getBorderWidth(border: MekkoBorderSettings) {\r\n            if (!border ||\r\n                !border.show ||\r\n                !border.width) {\r\n                return 0;\r\n            }\r\n\r\n            var width: number = border.width;\r\n\r\n            if (width < 0) {\r\n                return 0;\r\n            }\r\n            if (width > border.maxWidth) {\r\n                return border.maxWidth;\r\n            }\r\n\r\n            return width;\r\n        }\r\n\r\n        public static getBorderColor(border: MekkoBorderSettings) {\r\n            if (!border) {\r\n                return MekkoChart.DefaultSettings.columnBorder.color;\r\n            }\r\n            return border.color;\r\n        }\r\n\r\n        public static converter(dataView: DataViewCategorical,\r\n                                colors: IDataColorPalette,\r\n                                is100PercentStacked: boolean = false,\r\n                                isScalar: boolean = false,\r\n                                supportsOverflow: boolean = false,\r\n                                dataViewMetadata: DataViewMetadata = null,\r\n                                chartType?: ColumnChartType): MekkoColumnChartData {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colors, 'colors');\r\n\r\n            var xAxisCardProperties = CartesianHelper.getCategoryAxisProperties(dataViewMetadata);\r\n            var valueAxisProperties = CartesianHelper.getValueAxisProperties(dataViewMetadata);\r\n            isScalar = CartesianHelper.isScalar(isScalar, xAxisCardProperties);\r\n            dataView = ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);\r\n\r\n            var converterStrategy = new ColumnChartConverterHelper(dataView);\r\n\r\n            var categoryInfo = converterHelper.getPivotedCategories(dataView, columnChartProps.general.formatString);\r\n            var categories = categoryInfo.categories,\r\n                categoryFormatter: IValueFormatter = categoryInfo.categoryFormatter,\r\n                categoryIdentities: DataViewScopeIdentity[] = categoryInfo.categoryIdentities,\r\n                categoryMetadata: DataViewMetadataColumn = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;\r\n            //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;\r\n\r\n            var borderSettings: MekkoBorderSettings = MekkoChart.DefaultSettings.columnBorder;\r\n            var labelSettings: VisualDataLabelsSettings = dataLabelUtils.getDefaultColumnLabelSettings(true);\r\n\r\n            var defaultDataPointColor = undefined;\r\n            var showAllDataPoints = undefined;\r\n            if (dataViewMetadata && dataViewMetadata.objects) {\r\n                var objects = dataViewMetadata.objects;\r\n\r\n                defaultDataPointColor = DataViewObjects.getFillColor(objects, columnChartProps.dataPoint.defaultColor);\r\n                showAllDataPoints = DataViewObjects.getValue<boolean>(objects, columnChartProps.dataPoint.showAllDataPoints);\r\n\r\n                labelSettings = MekkoChart.parseLabelSettings(objects);\r\n                borderSettings = MekkoChart.parseBorderSettings(objects);\r\n            }\r\n\r\n            // Allocate colors\r\n            var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);\r\n            var legend: MekkoLegendDataPoint[] = legendAndSeriesInfo.legend.dataPoints;\r\n            var seriesSources: DataViewMetadataColumn[] = legendAndSeriesInfo.seriesSources;\r\n\r\n            // Determine data points\r\n            var result: MekkoDataPoints = MekkoColumnChart.createDataPoints(\r\n                dataView,\r\n                categories,\r\n                categoryIdentities,\r\n                legend,\r\n                legendAndSeriesInfo.seriesObjects,\r\n                converterStrategy,\r\n                labelSettings,\r\n                is100PercentStacked,\r\n                isScalar,\r\n                supportsOverflow,\r\n                converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category),\r\n                categoryInfo.categoryObjects,\r\n                defaultDataPointColor,\r\n                chartType,\r\n                categoryMetadata);\r\n            var columnSeries: ColumnChartSeries[] = result.series;\r\n\r\n            var valuesMetadata: DataViewMetadataColumn[] = [];\r\n            for (var j = 0, jlen = legend.length; j < jlen; j++) {\r\n                valuesMetadata.push(seriesSources[j]);\r\n            }\r\n\r\n            var labels = converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);\r\n\r\n            return {\r\n                categories: categories,\r\n                categoriesWidth: result.categoriesWidth,\r\n                categoryFormatter: categoryFormatter,\r\n                series: columnSeries,\r\n                valuesMetadata: valuesMetadata,\r\n                legendData: legendAndSeriesInfo.legend,\r\n                hasHighlights: result.hasHighlights,\r\n                categoryMetadata: categoryMetadata,\r\n                scalarCategoryAxis: isScalar,\r\n                borderSettings: borderSettings,\r\n                labelSettings: labelSettings,\r\n                axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },\r\n                hasDynamicSeries: result.hasDynamicSeries,\r\n                defaultDataPointColor: defaultDataPointColor,\r\n                showAllDataPoints: showAllDataPoints,\r\n                isMultiMeasure: false,\r\n            };\r\n        }\r\n\r\n        private static getStackedMultiplier(\r\n            rawValues: number[][],\r\n            rowIdx: number,\r\n            seriesCount: number,\r\n            categoryCount: number): ValueMultiplers {\r\n\r\n            var pos: number = 0,\r\n                neg: number = 0;\r\n\r\n            for (var i = 0; i < seriesCount; i++) {\r\n                var value: number = rawValues[i][rowIdx];\r\n                value = AxisHelper.normalizeNonFiniteNumber(value);\r\n\r\n                if (value > 0) {\r\n                    pos += value;\r\n                } else if (value < 0) {\r\n                    neg -= value;\r\n                }\r\n            }\r\n\r\n            var absTotal: number = pos + neg;\r\n            return {\r\n                pos: pos ? (pos / absTotal) / pos : 1,\r\n                neg: neg ? (neg / absTotal) / neg : 1,\r\n            };\r\n        }\r\n\r\n        private static createDataPoints(\r\n            dataViewCat: DataViewCategorical,\r\n            categories: any[],\r\n            categoryIdentities: DataViewScopeIdentity[],\r\n            legend: MekkoLegendDataPoint[],\r\n            seriesObjectsList: DataViewObjects[][],\r\n            converterStrategy: ColumnChartConverterHelper,\r\n\r\n            defaultLabelSettings: VisualDataLabelsSettings,\r\n            is100PercentStacked: boolean = false,\r\n            isScalar: boolean = false,\r\n            supportsOverflow: boolean = false,\r\n            isCategoryAlsoSeries?: boolean,\r\n            categoryObjectsList?: DataViewObjects[],\r\n            defaultDataPointColor?: string,\r\n            chartType?: ColumnChartType,\r\n            categoryMetadata?: DataViewMetadataColumn): MekkoDataPoints {\r\n\r\n            var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;\r\n\r\n            var categoryCount = categories.length;\r\n            var seriesCount = legend.length;\r\n            var columnSeries: ColumnChartSeries[] = [];\r\n\r\n            if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {\r\n                return { series: columnSeries,\r\n                         hasHighlights: false,\r\n                         hasDynamicSeries: false,\r\n                         categoriesWidth: [],\r\n                        };\r\n\t\t\t}\r\n\r\n            var dvCategories = dataViewCat.categories;\r\n            categoryMetadata = (dvCategories && dvCategories.length > 0)\r\n                ? dvCategories[0].source\r\n                : null;\r\n            var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);\r\n            var isDateTime = AxisHelper.isDateTime(categoryType);\r\n            var baseValuesPos = [], baseValuesNeg = [];\r\n\r\n            var rawValues: number[][] = [];\r\n            var rawHighlightValues: number[][] = [];\r\n\r\n            var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);\r\n            var widthColumns: number[] = [];\r\n            var widthIndex = -1;\r\n\r\n\t\t\tvar seriesIndex: number = 0;\r\n            var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different\r\n            var hasHighlights = converterStrategy.hasHighlightValues(0);\r\n            for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\r\n                if (dataViewCat.values[seriesIndex].source.roles &&\r\n                    dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&\r\n                    !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {\r\n\r\n                    widthIndex = seriesIndex;\r\n                    var widthValues: number[] = dataViewCat.values[seriesIndex].values;\r\n                    for (var i: number = 0, valuesLen = widthValues.length; i < valuesLen; i++) {\r\n                        widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\r\n                    }\r\n                    continue;\r\n                }\r\n                var seriesValues = [];\r\n                var seriesHighlightValues = [];\r\n                for (var categoryIndex: number = 0; categoryIndex < categoryCount; categoryIndex++) {\r\n                    var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);\r\n                    seriesValues[categoryIndex] = value;\r\n                    if (hasHighlights) {\r\n                        var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);\r\n                        seriesHighlightValues[categoryIndex] = highlightValue;\r\n                        // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.\r\n                        if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) || // Both positive; value greater than highlight\r\n                            (value <= 0 && highlightValue <= 0 && value <= highlightValue))) { // Both negative; value less than highlight\r\n                            highlightsOverflow = true;\r\n                        }\r\n                    }\r\n                }\r\n                rawValues.push(seriesValues);\r\n                if (hasHighlights) {\r\n                    rawHighlightValues.push(seriesHighlightValues);\r\n                }\r\n            }\r\n\r\n\t\t\t//console.log(dataViewCat);\r\n\r\n            if (highlightsOverflow && !supportsOverflow) {\r\n                highlightsOverflow = false;\r\n                hasHighlights = false;\r\n                rawValues = rawHighlightValues;\r\n            }\r\n\r\n            if (widthColumns.length < 1) {\r\n                for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {\r\n                    if (dataViewCat.values[seriesIndex].source.roles &&\r\n                        dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {\r\n\r\n                        widthIndex = seriesIndex;\r\n                        var widthValues: number[] = dataViewCat.values[seriesIndex].values;\r\n                        for (var i: number = 0, valuesLen: number = widthValues.length; i < valuesLen; i++) {\r\n                            widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);\r\n                        }\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (widthColumns.length < 1) {\r\n                for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\r\n                    widthColumns.push(1);\r\n                }\r\n            }\r\n\r\n            var totalSum: number = d3.sum(widthColumns);\r\n            var linearScale = d3.scale.linear()\r\n                .domain([0, totalSum])\r\n                .range([0, 1]);\r\n\r\n            var columnStartX: number[] = [0];\r\n            var columnWidth: number[] = [];\r\n            for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {\r\n                var stepWidth: number = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);\r\n                columnStartX.push(stepWidth);\r\n            }\r\n\r\n            for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {\r\n                columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);\r\n                columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);\r\n            }\r\n\r\n            var dataPointObjects: DataViewObjects[] = categoryObjectsList,\r\n                formatStringProp = columnChartProps.general.formatString;\r\n            for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {\r\n                var seriesDataPoints: ColumnChartDataPoint[] = [],\r\n                    legendItem = legend[seriesIndex],\r\n                    seriesLabelSettings: VisualDataLabelsSettings;\r\n\r\n                if (!hasDynamicSeries) {\r\n                    var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;\r\n                    var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? <DataLabelObject>labelsSeriesGroup.source.objects['labels'] : null;\r\n                    if (labelObjects) {\r\n                        seriesLabelSettings = Prototype.inherit(defaultLabelSettings);\r\n                        dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);\r\n                    }\r\n                }\r\n\r\n                var series: ColumnChartSeries = {\r\n                    displayName: legendItem.label,\r\n                    key: 'series' + seriesIndex,\r\n                    index: seriesIndex,\r\n                    data: seriesDataPoints,\r\n                    identity: legendItem.identity,\r\n                    color: legendItem.color,\r\n                    labelSettings: seriesLabelSettings,\r\n                };\r\n\r\n                if (seriesCount > 1) {\r\n                    dataPointObjects = seriesObjectsList[seriesIndex];\r\n                }\r\n                var metadata = dataViewCat.values[seriesIndex].source;\r\n\r\n                for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {\r\n                    if (seriesIndex === 0) {\r\n                        baseValuesPos.push(0);\r\n                        baseValuesNeg.push(0);\r\n                    }\r\n\r\n                    var value = AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);\r\n                    if (value == null) {\r\n                        // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.\r\n                        // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.\r\n                        if (seriesIndex > 0) {\r\n                            continue;\r\n                        }\r\n                    }\r\n\r\n                    var originalValue: number = value;\r\n                    var categoryValue = categories[categoryIndex];\r\n                    if (isDateTime && categoryValue) {\r\n                        categoryValue = categoryValue.getTime();\r\n                    }\r\n                    if (isScalar && (categoryValue == null || isNaN(categoryValue))) {\r\n                        continue;\r\n                    }\r\n\r\n                    var multipliers: ValueMultiplers;\r\n                    if (is100PercentStacked) {\r\n                        //multipliers = StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);\r\n                        multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);\r\n                    }\r\n                    var unadjustedValue = value,\r\n                        isNegative = value < 0;\r\n\r\n                    if (multipliers) {\r\n                        if (isNegative) {\r\n                            value *= multipliers.neg;\r\n                        } else {\r\n                            value *= multipliers.pos;\r\n                        }\r\n                    }\r\n\r\n                    var valueAbsolute = Math.abs(value);\r\n                    var position: number;\r\n                    if (isNegative) {\r\n                        position = baseValuesNeg[categoryIndex];\r\n\r\n                        if (!isNaN(valueAbsolute)) {\r\n                            baseValuesNeg[categoryIndex] -= valueAbsolute;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (!isNaN(valueAbsolute)) {\r\n                            baseValuesPos[categoryIndex] += valueAbsolute;\r\n                        }\r\n\r\n                        position = baseValuesPos[categoryIndex];\r\n                    }\r\n\r\n                    var columnGroup: DataViewValueColumnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;\r\n                    var category: DataViewCategoryColumn = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;\r\n                    var identity = SelectionIdBuilder.builder()\r\n                        .withCategory(category, categoryIndex)\r\n                        .withSeries(dataViewCat.values, columnGroup)\r\n                        .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))\r\n                        .createSelectionId();\r\n\r\n                    var rawCategoryValue = categories[categoryIndex];\r\n                    var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);\r\n\r\n                    var seriesData: TooltipSeriesDataItem[] = [];\r\n\r\n                    if (columnGroup) {\r\n\r\n                        var seriesValueColumn: DataViewValueColumn = {\r\n                            values: [],\r\n                            source: dataViewCat.values.source,\r\n                        };\r\n                        seriesData.push({\r\n                            value: columnGroup.name,\r\n                            metadata: seriesValueColumn,\r\n                        });\r\n\r\n                        for (var columnIndex: number = 0; columnIndex < columnGroup.values.length; columnIndex++) {\r\n                            var columnValues: DataViewValueColumn = columnGroup.values[columnIndex];\r\n                            seriesData.push({\r\n                                value: columnValues.values[categoryIndex],\r\n                                metadata: columnValues,\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, null/*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null/*seriesIndex*/, categoryIndex);\r\n\r\n                    var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;\r\n                    var labelColor = dataPointLabelSettings.labelColor;\r\n                    var lastValue = undefined;\r\n                    //Stacked column/bar label color is white by default (except last series)\r\n                    if ((EnumExtensions.hasFlag(chartType, flagStacked))) {\r\n                        lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);\r\n                        labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : dataLabelUtils.defaultInsideLabelColor;\r\n                    }\r\n\r\n                    value = columnWidth[categoryIndex];\r\n                    var originalPosition: number = columnStartX[categoryIndex];\r\n\r\n                    var dataPoint: ColumnChartDataPoint = {\r\n                        categoryValue: categoryValue,\r\n                        value: value,\r\n                        position: position,\r\n                        valueAbsolute: valueAbsolute,\r\n                        valueOriginal: unadjustedValue,\r\n                        seriesIndex: seriesIndex,\r\n                        labelSettings: dataPointLabelSettings,\r\n                        categoryIndex: categoryIndex,\r\n                        color: color,\r\n                        selected: false,\r\n                        originalValue: value,\r\n                        originalPosition: originalPosition,//position,\r\n                        originalValueAbsolute: valueAbsolute,\r\n                        identity: identity,\r\n                        key: identity.getKey(),\r\n                        tooltipInfo: tooltipInfo,\r\n                        labelFill: labelColor,\r\n                        labelFormatString: metadata.format,\r\n                        lastSeries: lastValue,\r\n                        chartType: chartType,\r\n                    };\r\n\r\n                    seriesDataPoints.push(dataPoint);\r\n\r\n                    if (hasHighlights) {\r\n                        var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];\r\n                        var unadjustedValueHighlight = valueHighlight;\r\n\r\n                        var highlightedTooltip: boolean = true;\r\n                        if (valueHighlight === null) {\r\n                            valueHighlight = 0;\r\n                            highlightedTooltip = false;\r\n                        }\r\n\r\n                        if (is100PercentStacked) {\r\n                            valueHighlight *= multipliers.pos;\r\n                        }\r\n                        var absoluteValueHighlight = Math.abs(valueHighlight);\r\n                        var highlightPosition = position;\r\n\r\n                        if (valueHighlight > 0) {\r\n                            highlightPosition -= valueAbsolute - absoluteValueHighlight;\r\n                        }\r\n                        else if (valueHighlight === 0 && value > 0) {\r\n                            highlightPosition -= valueAbsolute;\r\n                        }\r\n\r\n                        var highlightIdentity = SelectionId.createWithHighlight(identity);\r\n                        var rawCategoryValue = categories[categoryIndex];\r\n                        //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;\r\n                        //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);\r\n\r\n                        if (highlightedTooltip) {\r\n                            // Override non highlighted data point\r\n                            dataPoint.tooltipInfo = tooltipInfo;\r\n                        }\r\n\r\n                        var highlightDataPoint: ColumnChartDataPoint = {\r\n                            categoryValue: categoryValue,\r\n                            value: value,\r\n                            position: highlightPosition,\r\n                            valueAbsolute: absoluteValueHighlight,\r\n                            valueOriginal: unadjustedValueHighlight,\r\n                            seriesIndex: seriesIndex,\r\n                            labelSettings: dataPointLabelSettings,\r\n                            categoryIndex: categoryIndex,\r\n                            color: color,\r\n                            selected: false,\r\n                            highlight: true,\r\n                            originalValue: value,\r\n                            originalPosition: originalPosition,\r\n                            originalValueAbsolute: valueAbsolute,\r\n                            drawThinner: highlightsOverflow,\r\n                            identity: highlightIdentity,\r\n                            key: highlightIdentity.getKey(),\r\n                            tooltipInfo: tooltipInfo,\r\n                            labelFormatString: metadata.format,\r\n                            labelFill: labelColor,\r\n                            lastSeries: lastValue,\r\n                            chartType: chartType,\r\n                        };\r\n\r\n                        seriesDataPoints.push(highlightDataPoint);\r\n                    }\r\n                }\r\n\r\n                columnSeries.push(series);\r\n            }\r\n\r\n            return {\r\n                series: columnSeries,\r\n                categoriesWidth: columnWidth,\r\n                hasHighlights: hasHighlights,\r\n                hasDynamicSeries: hasDynamicSeries,\r\n            };\r\n        }\r\n\r\n        private static getDataPointColor(\r\n            legendItem: MekkoLegendDataPoint,\r\n            categoryIndex: number,\r\n            dataPointObjects?: DataViewObjects[]): string {\r\n            debug.assertValue(legendItem, 'legendItem');\r\n            debug.assertValue(categoryIndex, 'categoryIndex');\r\n            debug.assertAnyValue(dataPointObjects, 'dataPointObjects');\r\n\r\n            if (dataPointObjects) {\r\n                var colorOverride = DataViewObjects.getFillColor(dataPointObjects[categoryIndex], columnChartProps.dataPoint.fill);\r\n                if (colorOverride) {\r\n                    return colorOverride;\r\n                }\r\n            }\r\n\r\n            return legendItem.color;\r\n        }\r\n\r\n        private static getStackedLabelColor(isNegative: boolean, seriesIndex: number, seriesCount: number, categoryIndex: number, rawValues: number[][]): boolean {\r\n            var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);\r\n            //run for the next series and check if current series is last\r\n            for (var i: number = seriesIndex + 1; i < seriesCount; i++) {\r\n                var nextValues: number = AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);\r\n                if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {\r\n                    lastValue = false;\r\n                    break;\r\n                }\r\n            }\r\n            return lastValue;\r\n        }\r\n\r\n        public static sliceSeries(series: ColumnChartSeries[], endIndex: number, startIndex: number = 0): ColumnChartSeries[] {\r\n            var newSeries: ColumnChartSeries[] = [];\r\n            if (series && series.length > 0) {\r\n                for (var i = 0, len = series.length; i < len; i++) {\r\n                    var iNewSeries = newSeries[i] = Prototype.inherit(series[i]);\r\n                    iNewSeries.data = series[i].data.filter(d => d.categoryIndex >= startIndex && d.categoryIndex < endIndex);\r\n                }\r\n            }\r\n            return newSeries;\r\n        }\r\n        public static getInteractiveColumnChartDomElement(element: JQuery): HTMLElement {\r\n            return element.children(\"svg\").get(0);\r\n        }\r\n\r\n        public getColumnsWidth(): number[] {\r\n            var data: MekkoColumnChartData = this.data;\r\n            if (!data ||\r\n                !data.series ||\r\n                !data.series[0] ||\r\n                !data.series[0].data) {\r\n                return [];\r\n            }\r\n\r\n            return data.categoriesWidth;\r\n        }\r\n\r\n        public getBorderWidth(): number {\r\n            return MekkoColumnChart.getBorderWidth(this.data.borderSettings);\r\n        }\r\n\r\n        public setData(dataViews: DataView[]): void {\r\n            debug.assertValue(dataViews, \"dataViews\");\r\n            var is100PctStacked: boolean = true;\r\n            this.data = {\r\n                categories: [],\r\n                categoriesWidth: [],\r\n                categoryFormatter: null,\r\n                series: [],\r\n                valuesMetadata: [],\r\n                legendData: null,\r\n                hasHighlights: false,\r\n                categoryMetadata: null,\r\n                scalarCategoryAxis: false,\r\n                borderSettings: null,\r\n                labelSettings: dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),\r\n                axesLabels: { x: null, y: null },\r\n                hasDynamicSeries: false,\r\n                defaultDataPointColor: null,\r\n                isMultiMeasure: false,\r\n            };\r\n\r\n            if (dataViews.length > 0) {\r\n                var dataView = dataViews[0];\r\n\r\n                if (dataView && dataView.categorical) {\r\n                    var dataViewCat = this.dataViewCat = dataView.categorical;\r\n                    /*\r\n                    var dvCategories = dataViewCat.categories;\r\n                    var categoryMetadata = (dvCategories && dvCategories.length > 0)\r\n                        ? dvCategories[0].source\r\n                        : null;\r\n                    var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);\r\n                    */\r\n                    this.data = MekkoColumnChart.converter(\r\n                        dataViewCat,\r\n                        this.cartesianVisualHost.getSharedColors(),\r\n                        true,//s100PctStacked,\r\n                        false,//CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, columnChartProps.categoryAxis.axisType, categoryType),\r\n                        this.supportsOverflow,\r\n                        dataView.metadata,\r\n                        this.chartType);\r\n\r\n                    var series: ColumnChartSeries[] = this.data.series;\r\n                    for (var i: number = 0, ilen: number = series.length; i < ilen; i++) {\r\n                        var currentSeries: ColumnChartSeries = series[i];\r\n                        if (this.interactivityService) {\r\n                            this.interactivityService.applySelectionStateToData(currentSeries.data);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public calculateLegend(): LegendData {\r\n            // if we're in interactive mode, return the interactive legend\r\n            if (this.interactivity && this.interactivity.isInteractiveLegend) {\r\n                return this.createInteractiveMekkoLegendDataPoints(0);\r\n            }\r\n            var legendData = this.data ? this.data.legendData : null;\r\n            var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];\r\n\r\n            if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))\r\n                return null;\r\n\r\n            return legendData;\r\n        }\r\n\r\n        public hasLegend(): boolean {\r\n            return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));\r\n        }\r\n\r\n        public enumerateObjectInstances(enumeration: ObjectEnumerationBuilder, options: EnumerateVisualObjectInstancesOptions): void {\r\n            switch (options.objectName) {\r\n                case 'dataPoint':\r\n                    if (!GradientUtils.hasGradientRole(this.dataViewCat))\r\n                        this.enumerateDataPoints(enumeration);\r\n                    break;\r\n                case 'labels':\r\n                    this.enumerateDataLabels(enumeration);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder): void {\r\n            var data = this.data,\r\n                labelSettings = this.data.labelSettings,\r\n                seriesCount = data.series.length;\r\n\r\n            //Draw default settings\r\n            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));\r\n\r\n            if (seriesCount === 0) {\r\n                return;\r\n            }\r\n\r\n            //Draw series settings\r\n            if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) {\r\n                for (var i = 0; i < seriesCount; i++) {\r\n                    var series: ColumnChartSeries = data.series[i],\r\n                        labelSettings: VisualDataLabelsSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;\r\n\r\n                    //enumeration.pushContainer({ displayName: series.displayName });\r\n                    dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));\r\n                    //enumeration.popContainer();\r\n                }\r\n            }\r\n        }\r\n\r\n        private getLabelSettingsOptions(enumeration: ObjectEnumerationBuilder, labelSettings: VisualDataLabelsSettings, isSeries: boolean, series?: ColumnChartSeries): VisualDataLabelsSettingsOptions {\r\n            var is100PctStacked: boolean = true;\r\n            return {\r\n                enumeration: enumeration,\r\n                dataLabelsSettings: labelSettings,\r\n                show: !isSeries,\r\n                displayUnits: is100PctStacked,\r\n                precision: true,\r\n                selector: series && series.identity ? series.identity.getSelector() : null\r\n            };\r\n        }\r\n\r\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder): void {\r\n            var data: MekkoColumnChartData = this.data;\r\n            if (!data || !data.series) {\r\n                return;\r\n            }\r\n\r\n            var seriesCount = data.series.length;\r\n\r\n            if (seriesCount === 0) {\r\n                return;\r\n            }\r\n\r\n            if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {\r\n                for (var i: number = 0; i < seriesCount; i++) {\r\n                    var series: ColumnChartSeries = data.series[i];\r\n                    enumeration.pushInstance({\r\n                        objectName: 'dataPoint',\r\n                        displayName: series.displayName,\r\n                        selector: ColorHelper.normalizeSelector(series.identity.getSelector()),\r\n                        properties: {\r\n                            fill: { solid: { color: series.color } }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                // For single-category, single-measure column charts, the user can color the individual bars.\r\n                var singleSeriesData: ColumnChartDataPoint[] = data.series[0].data;\r\n                var categoryFormatter: IValueFormatter = data.categoryFormatter;\r\n\r\n                // Add default color and show all slices\r\n                enumeration.pushInstance({\r\n                    objectName: 'dataPoint',\r\n                    selector: null,\r\n                    properties: {\r\n                        defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\r\n                    }\r\n                }).pushInstance({\r\n                    objectName: 'dataPoint',\r\n                    selector: null,\r\n                    properties: {\r\n                        showAllDataPoints: !!data.showAllDataPoints\r\n                    }\r\n                });\r\n\r\n                for (var i: number = 0; i < singleSeriesData.length; i++) {\r\n                    var singleSeriesDataPoints = singleSeriesData[i],\r\n                        categoryValue: any = data.categories[i];\r\n                    enumeration.pushInstance({\r\n                        objectName: 'dataPoint',\r\n                        displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,\r\n                        selector: ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/true),\r\n                        properties: {\r\n                            fill: { solid: { color: singleSeriesDataPoints.color } }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        public calculateAxesProperties(options: MekkoCalculateScaleAndDomainOptions): IAxisProperties[] {\r\n            var data: MekkoColumnChartData = this.data;\r\n            this.currentViewport = options.viewport;\r\n            var margin: IMargin = this.margin = options.margin;\r\n\r\n            var origCatgSize = (data && data.categories) ? data.categories.length : 0;\r\n            var chartLayout: CategoryLayout = data ? this.getCategoryLayout(origCatgSize, options) : {\r\n                categoryCount: 0,\r\n                categoryThickness: CartesianChart.MinOrdinalRectThickness,\r\n                outerPaddingRatio: CartesianChart.OuterPaddingRatio,\r\n                isScalar: false\r\n            };\r\n            this.categoryAxisType = chartLayout.isScalar ? axisType.scalar : null;\r\n            this.columnChart.setData(data);\r\n\r\n            var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);\r\n\r\n            /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.\r\n             In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */\r\n            if (preferredPlotArea.width === this.currentViewport.width) {\r\n                preferredPlotArea.width -= (margin.left + margin.right);\r\n            }\r\n            preferredPlotArea.height -= (margin.top + margin.bottom);\r\n\r\n            var is100Pct: boolean = true;\r\n\r\n            // When the category axis is scrollable the height of the category axis and value axis will be different\r\n            // The height of the value axis would be same as viewportHeight\r\n            var chartContext: MekkoColumnChartContext = {\r\n                height: preferredPlotArea.height,\r\n                width: preferredPlotArea.width,\r\n                duration: 0,\r\n                hostService: this.hostService,\r\n                unclippedGraphicsContext: this.unclippedGraphicsContext,\r\n                mainGraphicsContext: this.mainGraphicsContext,\r\n                labelGraphicsContext: this.labelGraphicsContext,\r\n                margin: this.margin,\r\n                layout: chartLayout,\r\n                animator: this.animator,\r\n                interactivityService: this.interactivityService,\r\n                viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),\r\n                viewportWidth: this.currentViewport.width - (margin.left + margin.right),\r\n                is100Pct: is100Pct,\r\n                isComboChart: true,\r\n            };\r\n            this.ApplyInteractivity(chartContext);\r\n            this.columnChart.setupVisualProps(chartContext);\r\n\r\n            var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);\r\n\r\n            if (isBarChart) {\r\n                var temp = options.forcedXDomain;\r\n                options.forcedXDomain = options.forcedYDomain;\r\n                options.forcedYDomain = temp;\r\n            }\r\n\r\n            this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);\r\n            this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);\r\n\r\n            if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {\r\n                this.xAxisProperties.axisLabel = data.axesLabels.x;\r\n            }\r\n            else {\r\n                this.xAxisProperties.axisLabel = null;\r\n            }\r\n            if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {\r\n                this.yAxisProperties.axisLabel = data.axesLabels.y;\r\n            }\r\n            else {\r\n                this.yAxisProperties.axisLabel = null;\r\n            }\r\n\r\n            return [this.xAxisProperties, this.yAxisProperties];\r\n        }\r\n\r\n        public getPreferredPlotArea(isScalar: boolean, categoryCount: number, categoryThickness: number): IViewport {\r\n            var viewport: IViewport = {\r\n                height: this.currentViewport.height,\r\n                width: this.currentViewport.width\r\n            };\r\n\r\n            if (this.isScrollable && !isScalar) {\r\n                var preferredWidth = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);\r\n                if (EnumExtensions.hasFlag(this.chartType, flagBar)) {\r\n                    viewport.height = Math.max(preferredWidth, viewport.height);\r\n                }\r\n                else\r\n                    viewport.width = Math.max(preferredWidth, viewport.width);\r\n            }\r\n            return viewport;\r\n        }\r\n\r\n        private ApplyInteractivity(chartContext: MekkoColumnChartContext): void {\r\n            var interactivity = this.interactivity;\r\n            if (interactivity) {\r\n                if (interactivity.dragDataPoint) {\r\n                    chartContext.onDragStart = (datum: ColumnChartDataPoint) => {\r\n                        if (!datum.identity)\r\n                            return;\r\n\r\n                        this.hostService.onDragStart({\r\n                            event: <any>d3.event,\r\n                            data: {\r\n                                data: datum.identity.getSelector()\r\n                            }\r\n                        });\r\n                    };\r\n                }\r\n\r\n                if (interactivity.isInteractiveLegend) {\r\n                    var dragMove = () => {\r\n                        var mousePoint = d3.mouse(this.mainGraphicsContext[0][0]); // get the x and y for the column area itself\r\n                        var x: number = mousePoint[0];\r\n                        var y: number = mousePoint[1];\r\n                        var index: number = this.columnChart.getClosestColumnIndex(x, y);\r\n                        this.selectColumn(index);\r\n                    };\r\n\r\n                    var ColumnChartSvg: EventTarget = ColumnChart.getInteractiveColumnChartDomElement(this.element);\r\n\r\n                    //set click interaction on the visual\r\n                    this.svg.on('click', dragMove);\r\n                    //set click interaction on the background\r\n                    d3.select(ColumnChartSvg).on('click', dragMove);\r\n                    var drag = d3.behavior.drag()\r\n                        .origin(Object)\r\n                        .on(\"drag\", dragMove);\r\n                    //set drag interaction on the visual\r\n                    this.svg.call(drag);\r\n                    //set drag interaction on the background\r\n                    d3.select(ColumnChartSvg).call(drag);\r\n                }\r\n            }\r\n        }\r\n\r\n        private selectColumn(indexOfColumnSelected: number, force: boolean = false): void {\r\n            if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected) return; // same column, nothing to do here\r\n\r\n            var legendData: LegendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);\r\n            var MekkoLegendDataPoints: MekkoLegendDataPoint[] = legendData.dataPoints;\r\n            this.cartesianVisualHost.updateLegend(legendData);\r\n            if (MekkoLegendDataPoints.length > 0) {\r\n                this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);\r\n            }\r\n            this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;\r\n        }\r\n\r\n        private createInteractiveMekkoLegendDataPoints(columnIndex: number): LegendData {\r\n            var data: MekkoColumnChartData = this.data;\r\n            if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {\r\n                return { dataPoints: [] };\r\n            }\r\n\r\n            var formatStringProp = columnChartProps.general.formatString;\r\n            var MekkoLegendDataPoints: MekkoLegendDataPoint[] = [];\r\n            var category = data.categories && data.categories[columnIndex];\r\n            var allSeries: ColumnChartSeries[] = data.series;\r\n            var dataPoints = data.legendData && data.legendData.dataPoints;\r\n            var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);\r\n\r\n            for (var i: number = 0, len = allSeries.length; i < len; i++) {\r\n                var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);\r\n                var valueMetadata = data.valuesMetadata[i];\r\n                var formattedLabel = converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);\r\n                var dataPointColor: string;\r\n                if (allSeries.length === 1) {\r\n                    var series = allSeries[0];\r\n                    dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;\r\n                } else {\r\n                    dataPointColor = dataPoints.length > i && dataPoints[i].color;\r\n                }\r\n\r\n                MekkoLegendDataPoints.push({\r\n                    color: dataPointColor,\r\n                    icon: LegendIcon.Box,\r\n                    label: formattedLabel,\r\n                    category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,\r\n                    measure: valueFormatter.format(measure, valueFormatter.getFormatString(valueMetadata, formatStringProp)),\r\n                    identity: SelectionId.createNull(),\r\n                    selected: false,\r\n                });\r\n            }\r\n\r\n            return { dataPoints: MekkoLegendDataPoints };\r\n        }\r\n\r\n        public overrideXScale(xProperties: IAxisProperties): void {\r\n            this.xAxisProperties = xProperties;\r\n        }\r\n\r\n        public render(suppressAnimations: boolean): MekkoVisualRenderResult {\r\n            var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);\r\n            var data: MekkoColumnChartData = this.data;\r\n\r\n            var margin = this.margin;\r\n            var viewport = this.currentViewport;\r\n            var height = viewport.height - (margin.top + margin.bottom);\r\n            var width = viewport.width - (margin.left + margin.right);\r\n\r\n            this.mainGraphicsContext\r\n                .attr('height', height)\r\n                .attr('width', width);\r\n\r\n            TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo);\r\n            var allDataPoints: ColumnChartDataPoint[] = [];\r\n            var behaviorOptions: ColumnBehaviorOptions = undefined;\r\n            if (this.interactivityService) {\r\n                for (var i: number = 0, ilen = data.series.length; i < ilen; i++) {\r\n                    allDataPoints = allDataPoints.concat(data.series[i].data);\r\n                }\r\n                behaviorOptions = {\r\n                    datapoints: allDataPoints,\r\n                    bars: MekkoColumnChartDrawInfo.shapesSelection,\r\n                    hasHighlights: data.hasHighlights,\r\n                    eventGroup: this.mainGraphicsContext,\r\n                    mainGraphicsContext: this.mainGraphicsContext,\r\n                    viewport: MekkoColumnChartDrawInfo.viewport,\r\n                    axisOptions: MekkoColumnChartDrawInfo.axisOptions,\r\n                    showLabel: data.labelSettings.show\r\n                };\r\n            }\r\n\r\n            if (this.interactivity && this.interactivity.isInteractiveLegend) {\r\n                if (this.data.series.length > 0) {\r\n                    this.selectColumn(0, true); // start with the first column\r\n                }\r\n            }\r\n            SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\r\n            return {\r\n                dataPoints: allDataPoints,\r\n                behaviorOptions: behaviorOptions,\r\n                labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,\r\n                labelsAreNumeric: true\r\n            };\r\n        }\r\n\r\n        public onClearSelection(): void {\r\n            if (this.interactivityService) {\r\n                this.interactivityService.clearSelection();\r\n            }\r\n        }\r\n\r\n        public getVisualCategoryAxisIsScalar(): boolean {\r\n            return this.data ? this.data.scalarCategoryAxis : false;\r\n        }\r\n\r\n        public getSupportedCategoryAxisType(): string {\r\n            var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;\r\n            var valueType = AxisHelper.getCategoryValueType(metaDataColumn);\r\n            var isOrdinal = AxisHelper.isOrdinal(valueType);\r\n            return isOrdinal ? axisType.categorical : axisType.both;\r\n        }\r\n\r\n        public setFilteredData(startIndex: number, endIndex: number): CartesianData {\r\n            var data = Prototype.inherit(this.data);\r\n            data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);\r\n            data.categories = data.categories.slice(startIndex, endIndex);\r\n            this.columnChart.setData(data);\r\n            return data;\r\n        }\r\n    }\r\n\r\n    class ColumnChartConverterHelper implements IColumnChartConverterStrategy {\r\n        private dataView: DataViewCategorical;\r\n\r\n        constructor(dataView: DataViewCategorical) {\r\n            this.dataView = dataView;\r\n        }\r\n\r\n\t\t  private static hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            var roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        public getLegend(colors: IDataColorPalette, defaultColor?: string): LegendSeriesInfo {\r\n            var legend: MekkoLegendDataPoint[] = [];\r\n            var seriesSources: DataViewMetadataColumn[] = [];\r\n            var seriesObjects: DataViewObjects[][] = [];\r\n            var grouped: boolean = false;\r\n\r\n            var colorHelper = new ColorHelper(colors, columnChartProps.dataPoint.fill, defaultColor);\r\n            var legendTitle = undefined;\r\n            if (this.dataView && this.dataView.values) {\r\n                var allValues = this.dataView.values;\r\n                var valueGroups = allValues.grouped();\r\n\r\n                var hasDynamicSeries = !!(allValues && allValues.source);\r\n\r\n                var formatStringProp = columnChartProps.general.formatString;\r\n                for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {\r\n                    var valueGroup = valueGroups[valueGroupsIndex],\r\n                        valueGroupObjects = valueGroup.objects,\r\n                        values = valueGroup.values;\r\n\r\n                    for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {\r\n                        var series: DataViewValueColumn = values[valueIndex];\r\n                        var source: DataViewMetadataColumn = series.source;\r\n                        // Gradient measures do not create series.\r\n                        if (ColumnChartConverterHelper.hasRole(source, 'Width') && !ColumnChartConverterHelper.hasRole(source, 'Y')) {\r\n                            continue;\r\n                        }\r\n\r\n                        seriesSources.push(source);\r\n                        seriesObjects.push(series.objects);\r\n\r\n                        var selectionId = series.identity ?\r\n                            SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :\r\n                            SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));\r\n\r\n                        var label = converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);\r\n\r\n                        var color = hasDynamicSeries\r\n                            ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)\r\n                            : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);\r\n\r\n                        legend.push({\r\n                            icon: LegendIcon.Box,\r\n                            color: color,\r\n                            label: label,\r\n                            identity: selectionId,\r\n                            selected: false,\r\n                        });\r\n\r\n                        if (series.identity && source.groupName !== undefined) {\r\n                            grouped = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                var dvValues: DataViewValueColumns = this.dataView.values;\r\n                legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : \"\";\r\n            }\r\n\r\n            var legendData = {\r\n                title: legendTitle,\r\n                dataPoints: legend,\r\n                grouped: grouped,\r\n            };\r\n\r\n            return {\r\n                legend: legendData,\r\n                seriesSources: seriesSources,\r\n                seriesObjects: seriesObjects,\r\n            };\r\n        }\r\n\r\n        public getValueBySeriesAndCategory(series: number, category: number): number {\r\n            return this.dataView.values[series].values[category];\r\n        }\r\n\r\n        public getMeasureNameByIndex(index: number): string {\r\n            return this.dataView.values[index].source.queryName;\r\n        }\r\n\r\n        public hasHighlightValues(series: number): boolean {\r\n            var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;\r\n            return column && !!column.highlights;\r\n        }\r\n\r\n        public getHighlightBySeriesAndCategory(series: number, category: number): number {\r\n            return this.dataView.values[series].highlights[category];\r\n        }\r\n    }\r\n\r\n    export interface MekkoBehaviorOptions {\r\n        layerOptions: any[];\r\n        clearCatcher: D3.Selection;\r\n    }\r\n\r\n    export class MekkoChartBehavior implements IInteractiveBehavior {\r\n        private behaviors: IInteractiveBehavior[];\r\n\r\n        constructor(behaviors: IInteractiveBehavior[]) {\r\n            this.behaviors = behaviors;\r\n        }\r\n\r\n        public bindEvents(options: MekkoBehaviorOptions, selectionHandler: ISelectionHandler): void {\r\n            var behaviors = this.behaviors;\r\n            for (var i: number = 0, ilen: number = behaviors.length; i < ilen; i++) {\r\n                behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);\r\n            }\r\n\r\n            options.clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            for (var i: number = 0; i < this.behaviors.length; i++) {\r\n                this.behaviors[i].renderSelection(hasSelection);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/mekkoChart/visual/mekkoChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import SelectionManager = utility.SelectionManager;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import ValueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export interface SankeyDiagramConstructorOptions {\r\n        svg?: D3.Selection;\r\n        margin?: IMargin;\r\n        curvatureOfLinks?: number;\r\n    }\r\n\r\n    export interface SankeyDiagramLabel {\r\n        name: string;\r\n        formattedName: string;\r\n        width: number;\r\n        height: number;\r\n        colour: string;\r\n    }\r\n\r\n    export interface SankeyDiagramTooltipData {\r\n        tooltipData: TooltipDataItem[];\r\n    }\r\n\r\n    export interface SankeyDiagramScale {\r\n        x: number;\r\n        y: number;\r\n    }\r\n\r\n    export interface SankeyDiagramSettings {\r\n        scale?: SankeyDiagramScale;\r\n        fontSize: number;\r\n        isVisibleLabels?: boolean;\r\n        colourOfLabels: string;\r\n    }\r\n\r\n    export interface SankeyDiagramNode extends SankeyDiagramTooltipData {\r\n        label: SankeyDiagramLabel;\r\n        inputWeight: number;\r\n        outputWeight: number;\r\n        links: SankeyDiagramLink[];\r\n        x?: number;\r\n        y?: number;\r\n        width?: number;\r\n        height?: number;\r\n        colour: string;\r\n        selectionIds: SelectionId[];\r\n    }\r\n\r\n    export interface SankeyDiagramLink extends SankeyDiagramTooltipData {\r\n        source: SankeyDiagramNode;\r\n        destination: SankeyDiagramNode;\r\n        weigth: number;\r\n        height?: number;\r\n        dySource?: number;\r\n        dyDestination?: number;\r\n        colour: string;\r\n        selectionId: SelectionId;\r\n    }\r\n\r\n    export interface SankeyDiagramDataView {\r\n        nodes: SankeyDiagramNode[];\r\n        links: SankeyDiagramLink[];\r\n        settings: SankeyDiagramSettings;\r\n    }\r\n\r\n    export interface SankeyDiagramRoleNames {\r\n        rows: string;\r\n        columns: string;\r\n        values: string;\r\n    }\r\n\r\n    interface SankeyDiagramDataPoint {\r\n        source: any;\r\n        destination: any;\r\n        weigth: number;\r\n    }\r\n\r\n    interface SankeyDiagramProperty {\r\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\r\n    }\r\n\r\n    interface SankeyDiagramProperties {\r\n        [objectName: string]: SankeyDiagramProperty;\r\n    }\r\n\r\n    export class SankeyDiagram implements IVisual {\r\n        private static ClassName: string = \"sankeyDiagram\";\r\n\r\n        private static Nodes: ClassAndSelector = {\r\n            \"class\": \"nodes\",\r\n            selector: \".nodes\"\r\n        };\r\n\r\n        private static Node: ClassAndSelector = {\r\n            \"class\": \"node\",\r\n            selector: \".node\"\r\n        };\r\n\r\n        private static NodeRect: ClassAndSelector = {\r\n            \"class\": \"nodeRect\",\r\n            selector: \".nodeRect\"\r\n        };\r\n\r\n        private static NodeLabel: ClassAndSelector = {\r\n            \"class\": \"nodeLabel\",\r\n            selector: \".nodeLabel\"\r\n        };\r\n\r\n        private static Links: ClassAndSelector = {\r\n            \"class\": \"links\",\r\n            selector: \".links\"\r\n        };\r\n\r\n        private static Link: ClassAndSelector = {\r\n            \"class\": \"link\",\r\n            selector: \".link\"\r\n        };\r\n\r\n        private static DefaultColourOfNode: string = \"rgb(62, 187, 162)\";\r\n        private static DefaultColourOfLink: string = \"black\";\r\n\r\n        private static DefaultSettings: SankeyDiagramSettings = {\r\n            isVisibleLabels: true,\r\n            scale: { x: 1, y: 1 },\r\n            colourOfLabels: \"black\",\r\n            fontSize: 12\r\n        };\r\n\r\n        private static MinWidthOfLabel: number = 35;\r\n\r\n        private static NodePadding: number = 5;\r\n        private static LabelPadding: number = 4;\r\n\r\n        public static RoleNames: SankeyDiagramRoleNames = {\r\n            rows: \"Source\",\r\n            columns: \"Destination\",\r\n            values: \"Weight\"\r\n        };\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [{\r\n                name: SankeyDiagram.RoleNames.rows,\r\n                kind: VisualDataRoleKind.Grouping,\r\n                displayName: SankeyDiagram.RoleNames.rows\r\n            }, {\r\n                name: SankeyDiagram.RoleNames.columns,\r\n                kind: VisualDataRoleKind.Grouping,\r\n                displayName: SankeyDiagram.RoleNames.columns\r\n            }, {\r\n                name: SankeyDiagram.RoleNames.values,\r\n                kind: VisualDataRoleKind.Measure,\r\n                displayName: SankeyDiagram.RoleNames.values\r\n            }],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 0, max: 0 } },\r\n                    { \"Source\": { min: 0, max: 1 }, \"Destination\": { min: 0, max: 1 }, \"Weight\": { min: 1, max: 1 } }\r\n                ],\r\n                categorical: {\r\n                    categories: { \r\n                        for: { in: SankeyDiagram.RoleNames.rows },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        select: [\r\n                            { bind: { to: SankeyDiagram.RoleNames.columns } },\r\n                            { bind: { to: SankeyDiagram.RoleNames.values } }\r\n                        ]\r\n                    }\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\r\n                    properties: {\r\n                        formatString: { type: { formatting: { formatString: true } } }\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter(\"Visual_Show\"),\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                links: {\r\n                    displayName: \"Links\",\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private static Properties: SankeyDiagramProperties = SankeyDiagram.getProperties(SankeyDiagram.capabilities);\r\n        public static getProperties(capabilities: VisualCapabilities): any {\r\n            var result = {};\r\n            for(var objectKey in capabilities.objects) {\r\n                result[objectKey] = {};\r\n                for(var propKey in capabilities.objects[objectKey].properties) {\r\n                    result[objectKey][propKey] = <DataViewObjectPropertyIdentifier> { \r\n                        objectName: objectKey,\r\n                        propertyName: propKey\r\n                    };\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private margin: IMargin = {\r\n            top: 10,\r\n            right: 10,\r\n            bottom: 10,\r\n            left: 10\r\n        };\r\n\r\n        private nodeWidth: number = 21.5;\r\n        private curvatureOfLinks: number = 0.5;\r\n\r\n        private root: D3.Selection;\r\n        private svg: D3.Selection;\r\n        private main: D3.Selection;\r\n        private nodes: D3.Selection;\r\n        private links: D3.Selection;\r\n\r\n        private colours: IDataColorPalette;\r\n\r\n        private viewport: IViewport;\r\n\r\n        private get textProperties(): TextProperties{\r\n            return {\r\n                fontFamily: this.root.style(\"font-family\"),\r\n                fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)\r\n            };\r\n        }\r\n\r\n        private dataView: SankeyDiagramDataView;\r\n\r\n        private selectionManager: SelectionManager;\r\n\r\n        constructor(constructorOptions?: SankeyDiagramConstructorOptions) {\r\n            if (constructorOptions) {\r\n                this.svg = constructorOptions.svg;\r\n                this.margin = constructorOptions.margin || this.margin;\r\n                this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;\r\n            }\r\n        }\r\n\r\n        public init(visualsInitOptions: VisualInitOptions): void {\r\n            if (this.svg) {\r\n                this.root = this.svg;\r\n            } else {\r\n                this.root = d3.select(visualsInitOptions.element.get(0))\r\n                    .append(\"svg\");\r\n            }\r\n\r\n            this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });\r\n\r\n            var style: IVisualStyle = visualsInitOptions.style;\r\n\r\n            this.colours = style && style.colorPalette\r\n                ? style.colorPalette.dataColors\r\n                : new DataColorPalette();\r\n\r\n            this.root.classed(SankeyDiagram.ClassName, true);\r\n\r\n            this.main = this.root.append(\"g\");\r\n\r\n            this.links = this.main\r\n                .append(\"g\")\r\n                .classed(SankeyDiagram.Links[\"class\"], true);\r\n\r\n            this.nodes = this.main\r\n                .append(\"g\")\r\n                .classed(SankeyDiagram.Nodes[\"class\"], true);\r\n        }\r\n\r\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\r\n            if (!visualUpdateOptions ||\r\n                !visualUpdateOptions.dataViews) {\r\n                return;\r\n            }\r\n\r\n            var dataView: DataView = visualUpdateOptions.dataViews[0],\r\n                sankeyDiagramDataView: SankeyDiagramDataView;\r\n\r\n            this.updateViewport(visualUpdateOptions.viewport);\r\n\r\n            sankeyDiagramDataView = this.converter(dataView);\r\n\r\n            this.findNodePosition(sankeyDiagramDataView);\r\n\r\n            this.dataView = sankeyDiagramDataView;\r\n\r\n            this.render(sankeyDiagramDataView);\r\n        }\r\n\r\n        private updateViewport(viewport: IViewport): void {\r\n            var height: number,\r\n                width: number;\r\n\r\n            height = this.getPositiveNumber(viewport.height);\r\n            width = this.getPositiveNumber(viewport.width);\r\n\r\n            this.viewport = {\r\n                height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),\r\n                width: this.getPositiveNumber(width - this.margin.left - this.margin.right)\r\n            };\r\n\r\n            this.updateElements(height, width);\r\n        }\r\n\r\n        private getPositiveNumber(value: number): number {\r\n            return value < 0 || isNaN(value) || value === Infinity || value === -Infinity\r\n                ? 0\r\n                : value;\r\n        }\r\n\r\n        private updateElements(height: number, width: number): void {\r\n            this.root.attr({\r\n                \"height\": height,\r\n                \"width\": width\r\n            });\r\n\r\n            this.main.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\r\n        }\r\n\r\n        public converter(dataView: DataView): SankeyDiagramDataView {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[1] ||\r\n                !dataView.categorical.categories[0].values ||\r\n                !dataView.categorical.categories[1].values) {\r\n                return {\r\n                    nodes: [],\r\n                    links: [],\r\n                    settings: {\r\n                        scale: { x: 1, y: 1 },\r\n                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\r\n                        fontSize: SankeyDiagram.DefaultSettings.fontSize\r\n                    }\r\n                };\r\n            }\r\n\r\n            var nodes: SankeyDiagramNode[] = [],\r\n                links: SankeyDiagramLink[] = [],\r\n                dataPoints: SankeyDiagramDataPoint[] = [],\r\n                categories: any[] = dataView.categorical.categories[0].values,\r\n                secondCategories: any[] = dataView.categorical.categories[1].values,\r\n                valuesColumn: DataViewValueColumn = dataView.categorical.values && dataView.categorical.values[0],\r\n                weightValues: number[] = valuesColumn && valuesColumn.values && valuesColumn.values.map(x=> x || 0) || [],\r\n                allCategories: any[],\r\n                valueFormatterForCategories: IValueFormatter,\r\n                formatOfWeigth: string = \"g\",\r\n                valuesFormatterForWeigth: IValueFormatter,\r\n                objects: DataViewObjects,\r\n                linksObjects: DataViewObjects[] = dataView.categorical.categories[0].objects || [],\r\n                labelColour: string,\r\n                settings: SankeyDiagramSettings,\r\n                shiftOfColour: number,\r\n                identities: DataViewScopeIdentity[] = [];\r\n\r\n            if (dataView.categorical.categories[0].identity) {\r\n                identities = identities.concat(dataView.categorical.categories[0].identity);\r\n            }\r\n\r\n            if (dataView.categorical.categories[1].identity) {\r\n                identities = identities.concat(dataView.categorical.categories[1].identity);\r\n            }\r\n\r\n            objects = this.getObjectsFromDataView(dataView);\r\n\r\n            labelColour = this.getColour(\r\n                SankeyDiagram.Properties[\"labels\"][\"fill\"],\r\n                SankeyDiagram.DefaultSettings.colourOfLabels,\r\n                objects);\r\n\r\n            if (valuesColumn && valuesColumn.source) {\r\n                formatOfWeigth = ValueFormatter.getFormatString(\r\n                    valuesColumn.source,\r\n                    SankeyDiagram.Properties[\"general\"][\"formatString\"]);\r\n            }\r\n\r\n            dataPoints = categories.map((item: any, index: number) => {\r\n                return {\r\n                    source: item,\r\n                    destination: secondCategories[index],\r\n                    weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1\r\n                };\r\n            });\r\n\r\n            allCategories = categories.concat(secondCategories);\r\n\r\n            valueFormatterForCategories = ValueFormatter.create({\r\n                format: ValueFormatter.getFormatString(\r\n                    dataView.categorical.categories[0].source,\r\n                    SankeyDiagram.Properties[\"general\"][\"formatString\"]),\r\n                value: allCategories[0],\r\n                value2: allCategories[allCategories.length - 1]\r\n            });\r\n\r\n            valuesFormatterForWeigth = ValueFormatter.create({\r\n                format: formatOfWeigth,\r\n                value: Math.max(d3.max(weightValues) || 1, 1),\r\n            });\r\n\r\n            allCategories.forEach((item: any, index: number) => {\r\n                if (!nodes.some((node: SankeyDiagramNode) => {\r\n                    if (item === node.label.name) {\r\n                        node.selectionIds.push(SelectionId.createWithId(identities[index]));\r\n\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                })) {\r\n                    var formattedValue: string = valueFormatterForCategories.format(item),\r\n                        label: SankeyDiagramLabel,\r\n                        selectionId: SelectionId,\r\n                        textProperties: TextProperties = {\r\n                            text: formattedValue,\r\n                            fontFamily: this.textProperties.fontFamily,\r\n                            fontSize: this.textProperties.fontSize\r\n                        };\r\n\r\n                    label = {\r\n                        name: item,\r\n                        formattedName: valueFormatterForCategories.format(item),\r\n                        width: TextMeasurementService.measureSvgTextWidth(textProperties),\r\n                        height: TextMeasurementService.estimateSvgTextHeight(textProperties),\r\n                        colour: labelColour\r\n                    };\r\n\r\n                    selectionId = SelectionId.createWithId(identities[index]);\r\n\r\n                    nodes.push({\r\n                        label: label,\r\n                        links: [],\r\n                        inputWeight: 0,\r\n                        outputWeight: 0,\r\n                        width: this.nodeWidth,\r\n                        height: 0,\r\n                        colour: SankeyDiagram.DefaultColourOfNode,\r\n                        tooltipData: [],\r\n                        selectionIds: [selectionId]\r\n                    });\r\n                }\r\n            });\r\n\r\n            shiftOfColour = this.colours.getAllColors().length / nodes.length;\r\n\r\n            nodes.forEach((node: SankeyDiagramNode, index: number) => {\r\n                node.colour = this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;\r\n            });\r\n\r\n            dataPoints.forEach((dataPoint: SankeyDiagramDataPoint, index: number) => {\r\n                var sourceNode: SankeyDiagramNode,\r\n                    destinationNode: SankeyDiagramNode,\r\n                    link: SankeyDiagramLink,\r\n                    linkColour: string;\r\n\r\n                if (dataPoint.source === dataPoint.destination) {\r\n                    return;\r\n                }\r\n\r\n                nodes.forEach((node: SankeyDiagramNode) => {\r\n                    if (node.label.name === dataPoint.source) {\r\n                        sourceNode = node;\r\n                    }\r\n\r\n                    if (node.label.name === dataPoint.destination) {\r\n                        destinationNode = node;\r\n                    }\r\n                });\r\n\r\n                linkColour = this.getColour(\r\n                    SankeyDiagram.Properties[\"links\"][\"fill\"],\r\n                    SankeyDiagram.DefaultColourOfLink,\r\n                    linksObjects[index]);\r\n\r\n                link = {\r\n                    source: sourceNode,\r\n                    destination: destinationNode,\r\n                    weigth: dataPoint.weigth,\r\n                    height: dataPoint.weigth,\r\n                    colour: linkColour,\r\n                    tooltipData: this.getTooltipDataForLink(\r\n                        valuesFormatterForWeigth,\r\n                        sourceNode.label.formattedName,\r\n                        destinationNode.label.formattedName,\r\n                        dataPoint.weigth),\r\n                    selectionId: SelectionId.createWithId(identities[index])\r\n                };\r\n\r\n                links.push(link);\r\n\r\n                sourceNode.links.push(link);\r\n                destinationNode.links.push(link);\r\n\r\n                this.updateValueOfNode(sourceNode);\r\n                this.updateValueOfNode(destinationNode);\r\n\r\n                sourceNode.tooltipData = this.getTooltipForNode(\r\n                    valuesFormatterForWeigth,\r\n                    sourceNode.label.formattedName,\r\n                    sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight);\r\n\r\n                destinationNode.tooltipData = this.getTooltipForNode(\r\n                    valuesFormatterForWeigth,\r\n                    destinationNode.label.formattedName,\r\n                    destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight);\r\n            });\r\n\r\n            settings = this.parseSettings(objects);\r\n\r\n            settings.colourOfLabels = labelColour;\r\n\r\n            return {\r\n                nodes: nodes,\r\n                links: links,\r\n                settings: settings\r\n            };\r\n        }\r\n\r\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\r\n            if (!dataView ||\r\n                    !dataView.metadata ||\r\n                    !dataView.metadata.columns ||\r\n                    !dataView.metadata.objects) {\r\n                return null;\r\n            }\r\n\r\n            return dataView.metadata.objects;\r\n        }\r\n\r\n        private getColour(properties: DataViewObjectPropertyIdentifier, defaultColor: string, objects: DataViewObjects): string {\r\n            var colorHelper: ColorHelper;\r\n\r\n            colorHelper = new ColorHelper(this.colours, properties, defaultColor);\r\n\r\n            return colorHelper.getColorForMeasure(objects, \"\");\r\n        }\r\n\r\n        private getTooltipDataForLink(\r\n            valueFormatter: IValueFormatter,\r\n            sourceNodeName: string,\r\n            destinationNodeName: string,\r\n            linkWeight: number): TooltipDataItem[] {\r\n\r\n            var formattedLinkWeight: string;\r\n\r\n            if (valueFormatter && valueFormatter.format) {\r\n                formattedLinkWeight = valueFormatter.format(linkWeight);\r\n            } else {\r\n                formattedLinkWeight = linkWeight.toString();\r\n            }\r\n\r\n            return [{\r\n                displayName: SankeyDiagram.RoleNames.rows,\r\n                value: sourceNodeName\r\n            }, {\r\n                displayName: SankeyDiagram.RoleNames.columns,\r\n                value: destinationNodeName\r\n            }, {\r\n                displayName: SankeyDiagram.RoleNames.values,\r\n                value: formattedLinkWeight\r\n            }];\r\n        }\r\n\r\n        private updateValueOfNode(node: SankeyDiagramNode): void {\r\n            node.inputWeight = node.links.reduce((previousValue: number, currentValue: SankeyDiagramLink) => {\r\n                return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);\r\n            }, 0);\r\n\r\n            node.outputWeight = node.links.reduce((previousValue: number, currentValue: SankeyDiagramLink) => {\r\n                return previousValue + (currentValue.source === node ? currentValue.weigth : 0);\r\n            }, 0);\r\n        }\r\n\r\n        private getTooltipForNode(\r\n            valueFormatter: IValueFormatter,\r\n            nodeName: string,\r\n            nodeWeight: number): TooltipDataItem[] {\r\n\r\n            var formattedNodeWeigth: string;\r\n\r\n            if (valueFormatter && valueFormatter.format) {\r\n                formattedNodeWeigth = valueFormatter.format(nodeWeight);\r\n            } else {\r\n                formattedNodeWeigth = nodeWeight.toString();\r\n            }\r\n\r\n            return [{\r\n                displayName: \"Name\",\r\n                value: nodeName\r\n            }, {\r\n                displayName: SankeyDiagram.RoleNames.values,\r\n                value: formattedNodeWeigth\r\n            }];\r\n        }\r\n\r\n        private parseSettings(objects: DataViewObjects): SankeyDiagramSettings {\r\n            var isVisibleLabels: boolean = false;\r\n\r\n            isVisibleLabels = DataViewObjects.getValue(\r\n                objects,\r\n                SankeyDiagram.Properties[\"labels\"][\"show\"],\r\n                SankeyDiagram.DefaultSettings.isVisibleLabels);\r\n\r\n            return {\r\n                isVisibleLabels: isVisibleLabels,\r\n                scale: {\r\n                    x: SankeyDiagram.DefaultSettings.scale.x,\r\n                    y: SankeyDiagram.DefaultSettings.scale.y\r\n                },\r\n                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,\r\n                fontSize: DataViewObjects.getValue<number>(objects, \r\n                    SankeyDiagram.Properties[\"labels\"][\"fontSize\"],\r\n                    SankeyDiagram.DefaultSettings.fontSize)\r\n            };\r\n        }\r\n\r\n        private findNodePosition(sankeyDiagramDataView: SankeyDiagramDataView): void {\r\n            this.findNodePositionByX(sankeyDiagramDataView);\r\n            this.findNodePositionByY(sankeyDiagramDataView);\r\n        }\r\n\r\n        private findNodePositionByX(sankeyDiagramDataView: SankeyDiagramDataView): void {\r\n            var nodes: SankeyDiagramNode[] = sankeyDiagramDataView.nodes,\r\n                nextNodes: SankeyDiagramNode[] = [],\r\n                previousNodes: SankeyDiagramNode[] = [],\r\n                x: number = 0,\r\n                isRecursiveDependencies: boolean = false;\r\n\r\n            while (nodes.length > 0) {\r\n                nextNodes = [];\r\n\r\n                nodes.forEach((node: SankeyDiagramNode) => {\r\n                    node.x = x;\r\n\r\n                    node.links.forEach((link: SankeyDiagramLink) => {\r\n                        if (node === link.source && node !== link.destination) {\r\n                            if (nextNodes.every((item: SankeyDiagramNode) => {\r\n                                return item !== link.destination;\r\n                            })) {\r\n                                nextNodes.push(link.destination);\r\n                            }\r\n                        }\r\n                    });\r\n                });\r\n\r\n                isRecursiveDependencies = nextNodes.length === previousNodes.length && \r\n                    previousNodes.every((previousNode: SankeyDiagramNode) => {\r\n                        return nextNodes.some((nextNode: SankeyDiagramNode) => {\r\n                            return nextNode === previousNode;\r\n                        });\r\n                    });\r\n\r\n                if (isRecursiveDependencies) {\r\n                    previousNodes.forEach((element: SankeyDiagramNode) => {\r\n                        element.x = x;\r\n\r\n                        x++;\r\n                    });\r\n\r\n                    nodes = [];\r\n                } else {\r\n                    nodes = nextNodes;\r\n\r\n                    previousNodes = nodes;\r\n\r\n                    x++;\r\n                }\r\n            }\r\n\r\n            sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1);\r\n\r\n            this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);\r\n        }\r\n\r\n        private scaleByAxisX(nodes: SankeyDiagramNode[], scale: number): void {\r\n            nodes.forEach((node: SankeyDiagramNode) => {\r\n                node.x *= scale;\r\n            });\r\n        }\r\n\r\n        private getScaleByAxisX(numberOfColumns: number = 1): number {\r\n            return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);\r\n        }\r\n\r\n        private findNodePositionByY(sankeyDiagramDataView: SankeyDiagramDataView): void {\r\n            var nodes: SankeyDiagramNode[] = sankeyDiagramDataView.nodes,\r\n                links: SankeyDiagramLink[] = sankeyDiagramDataView.links,\r\n                currentX: number = 0,\r\n                index: number = 0,\r\n                maxIndex: number = 0,\r\n                sumValueOfNodes: number = 0,\r\n                maxValueOfNodes: number = 0;\r\n \r\n            nodes = nodes.sort((firstNode: SankeyDiagramNode, secondNode: SankeyDiagramNode) => {\r\n                return firstNode.x - secondNode.x;\r\n            });\r\n\r\n            nodes.forEach((node: SankeyDiagramNode) => {\r\n                if (currentX !== node.x) {\r\n                    index = 0;\r\n                    currentX = node.x;\r\n                    sumValueOfNodes = 0;\r\n                }\r\n\r\n                sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight);\r\n\r\n                if (sumValueOfNodes > maxValueOfNodes) {\r\n                    maxValueOfNodes = sumValueOfNodes;\r\n                }\r\n\r\n                if (index > maxIndex) {\r\n                    maxIndex = index;\r\n                }\r\n\r\n                index++;\r\n            });\r\n\r\n            sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes);\r\n\r\n            this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);\r\n        }\r\n\r\n        private getScaleByAxisY(numberOfRows: number, sumValueOfNodes: number): number {\r\n            return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);\r\n        }\r\n\r\n        private scaleByAxisY(\r\n            nodes: SankeyDiagramNode[],\r\n            links: SankeyDiagramLink[],\r\n            scale: number): void {\r\n\r\n            var shiftByAxisY: number = 0,\r\n                currentX: number = 0,\r\n                index: number = 0;\r\n\r\n            nodes.forEach((node: SankeyDiagramNode) => {\r\n                if (currentX !== node.x) {\r\n                    currentX = node.x;\r\n                    shiftByAxisY = 0;\r\n                    index = 0;\r\n                }\r\n\r\n                node.height = Math.max(node.inputWeight, node.outputWeight) * scale;\r\n\r\n                node.y = shiftByAxisY + SankeyDiagram.NodePadding * index;\r\n\r\n                shiftByAxisY += node.height;\r\n\r\n                index++;\r\n            });\r\n\r\n            nodes.forEach((node: SankeyDiagramNode) => {\r\n                node.links = node.links.sort((firstLink: SankeyDiagramLink, secondLink: SankeyDiagramLink) => {\r\n                    var firstY: number,\r\n                        secondY: number;\r\n\r\n                    firstY = firstLink.source === node\r\n                        ? firstLink.destination.y\r\n                        : firstLink.source.y;\r\n\r\n                    secondY = secondLink.source === node\r\n                        ? secondLink.destination.y\r\n                        : secondLink.source.y;\r\n\r\n                    return firstY - secondY;\r\n                });\r\n\r\n                var shiftByAxisYOfLeftLink: number = 0,\r\n                    shiftByAxisYOfRightLink: number = 0;\r\n\r\n                node.links.forEach((link: SankeyDiagramLink) => {\r\n                    var shiftByAxisY: number = 0;\r\n\r\n                    link.height = link.weigth * scale;\r\n\r\n                    if (link.source.x < node.x || link.destination.x < node.x) {\r\n                        shiftByAxisY = shiftByAxisYOfLeftLink;\r\n\r\n                        shiftByAxisYOfLeftLink += link.height;\r\n                    } else if (link.source.x > node.x || link.destination.x > node.x) {\r\n                        shiftByAxisY = shiftByAxisYOfRightLink;\r\n\r\n                        shiftByAxisYOfRightLink += link.height;\r\n                    }\r\n\r\n                    if (link.source === node) {\r\n                        link.dySource = shiftByAxisY;\r\n                    } else if (link.destination === node) {\r\n                        link.dyDestination = shiftByAxisY;\r\n                    }\r\n                });\r\n            });\r\n        }\r\n\r\n        private render(sankeyDiagramDataView: SankeyDiagramDataView): void {\r\n            var nodesSelection: D3.UpdateSelection,\r\n                linksSelection: D3.UpdateSelection;\r\n\r\n            linksSelection = this.renderLinks(sankeyDiagramDataView);\r\n            nodesSelection = this.renderNodes(sankeyDiagramDataView);\r\n\r\n            this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);\r\n        }\r\n\r\n        private renderNodes(sankeyDiagramDataView: SankeyDiagramDataView): D3.UpdateSelection {\r\n            var nodesEnterSelection: D3.Selection,\r\n                nodesSelection: D3.UpdateSelection,\r\n                nodeElements: D3.Selection;\r\n\r\n            nodeElements = this.main\r\n                .select(SankeyDiagram.Nodes.selector)\r\n                .selectAll(SankeyDiagram.Node.selector);\r\n\r\n            nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(x => x.height > 0));\r\n\r\n            nodesEnterSelection = nodesSelection\r\n                .enter()\r\n                .append(\"g\");\r\n\r\n            nodesSelection\r\n                .attr(\"transform\", (node: SankeyDiagramNode) => {\r\n                    return SVGUtil.translate(node.x, node.y);\r\n                })\r\n                .classed(SankeyDiagram.Node[\"class\"], true);\r\n\r\n            nodesEnterSelection\r\n                .append(\"rect\")\r\n                .classed(SankeyDiagram.NodeRect[\"class\"], true);\r\n\r\n            nodesEnterSelection\r\n                .append(\"text\")\r\n                .classed(SankeyDiagram.NodeLabel[\"class\"], true);\r\n\r\n            nodesSelection\r\n                .select(SankeyDiagram.NodeRect.selector)\r\n                .style({\r\n                    \"fill\": (node: SankeyDiagramNode) => node.colour,\r\n                    \"stroke\": (node: SankeyDiagramNode) => d3.rgb(node.colour).darker(1.5)\r\n                })\r\n                .attr({\r\n                    x: 0,\r\n                    y: 0,\r\n                    height: (node: SankeyDiagramNode) => node.height,\r\n                    width: (node: SankeyDiagramNode) => node.width\r\n                });\r\n\r\n            nodesSelection\r\n                .select(SankeyDiagram.NodeLabel.selector)\r\n                .attr({\r\n                    x: (node: SankeyDiagramNode) => this.getLabelPositionByAxisX(node),\r\n                    y: (node: SankeyDiagramNode) => node.height / 2,\r\n                    dy: \"0.35em\"\r\n                })\r\n                .style(\"fill\", (node: SankeyDiagramNode) => node.label.colour)\r\n                .style(\"font-size\", this.textProperties.fontSize)\r\n                .style(\"display\", (node: SankeyDiagramNode) => {\r\n                    var isNotVisibleLabel: boolean = false, \r\n                        labelPositionByAxisX: number = this.getCurrentPositionOfLabelByAxisX(node);\r\n\r\n                    isNotVisibleLabel = \r\n                        labelPositionByAxisX >= this.viewport.width ||\r\n                        labelPositionByAxisX <= 0 ||\r\n                        (node.height + SankeyDiagram.NodePadding) < node.label.height;\r\n\r\n                    if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels\r\n                        || sankeyDiagramDataView.settings.scale.x / 2 <  SankeyDiagram.MinWidthOfLabel) {\r\n                        return \"none\";\r\n                    }\r\n\r\n                    return null;\r\n                })\r\n                .style(\"text-anchor\", (node: SankeyDiagramNode) => {\r\n                    if (this.isLabelLargerWidth(node)) {\r\n                        return \"end\";\r\n                    }\r\n\r\n                    return null;\r\n                })\r\n                .text((node: SankeyDiagramNode) => {\r\n                    var maxWidth: number = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;\r\n\r\n                    if (this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {\r\n                        return TextMeasurementService.getTailoredTextOrDefault({\r\n                            text: node.label.formattedName,\r\n                            fontFamily: this.textProperties.fontFamily,\r\n                            fontSize: this.textProperties.fontSize\r\n                        }, maxWidth);\r\n                    }\r\n\r\n                    return node.label.formattedName;\r\n                });\r\n\r\n            nodesSelection\r\n                .exit()\r\n                .remove();\r\n\r\n            this.renderTooltip(nodesSelection);\r\n\r\n            return nodesSelection;\r\n        }\r\n\r\n        private getLabelPositionByAxisX(node: SankeyDiagramNode): number {\r\n            if (this.isLabelLargerWidth(node)) {\r\n                return -(SankeyDiagram.LabelPadding);\r\n            }\r\n\r\n            return node.width + SankeyDiagram.LabelPadding;\r\n        }\r\n\r\n        private isLabelLargerWidth(node: SankeyDiagramNode): boolean {\r\n            var shiftByAxisX: number = node.x + node.width + SankeyDiagram.LabelPadding;\r\n\r\n            return shiftByAxisX + node.label.width > this.viewport.width;\r\n        }\r\n\r\n        private getCurrentPositionOfLabelByAxisX(node: SankeyDiagramNode): number {\r\n            var labelPositionByAxisX: number = this.getLabelPositionByAxisX(node);\r\n\r\n            labelPositionByAxisX = labelPositionByAxisX > 0\r\n                ? labelPositionByAxisX + node.x + node.label.width + node.width\r\n                : node.x + labelPositionByAxisX - node.label.width - node.width;\r\n\r\n            return labelPositionByAxisX;\r\n        }\r\n\r\n        private renderLinks(sankeyDiagramDataView: SankeyDiagramDataView): D3.UpdateSelection {\r\n            var linksSelection: D3.UpdateSelection,\r\n                linksElements: D3.Selection;\r\n\r\n            linksElements = this.main\r\n                .select(SankeyDiagram.Links.selector)\r\n                .selectAll(SankeyDiagram.Link.selector);\r\n\r\n            linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(x => x.height > 0));\r\n\r\n            linksSelection\r\n                .enter()\r\n                .append(\"path\")\r\n                .classed(SankeyDiagram.Link[\"class\"], true);\r\n\r\n            linksSelection\r\n                .attr(\"d\", (link: SankeyDiagramLink) => {\r\n                    return this.getSvgPath(link);\r\n                })\r\n                .style({\r\n                    \"stroke-width\": (link: SankeyDiagramLink) => link.height,\r\n                    \"stroke\": (link: SankeyDiagramLink) => link.colour\r\n                });\r\n\r\n            linksSelection\r\n                .exit()\r\n                .remove();\r\n\r\n            this.renderTooltip(linksSelection);\r\n\r\n            return linksSelection;\r\n        }\r\n\r\n        private getSvgPath(link: SankeyDiagramLink): string {\r\n            var x0: number,\r\n                x1: number,\r\n                xi: D3.Transition.BaseInterpolate,\r\n                x2: number,\r\n                x3: number,\r\n                y0: number,\r\n                y1: number;\r\n\r\n            if (link.destination.x < link.source.x) {\r\n                x0 = link.source.x;\r\n                x1 = link.destination.x + link.destination.width;\r\n            } else {\r\n                x0 = link.source.x + link.source.width;\r\n                x1 = link.destination.x;\r\n            }\r\n\r\n            xi = d3.interpolateNumber(x0, x1);\r\n            x2 = xi(this.curvatureOfLinks);\r\n            x3 = xi(1 - this.curvatureOfLinks);\r\n            y0 = link.source.y + link.dySource + link.height / 2;\r\n            y1 = link.destination.y + link.dyDestination + link.height / 2;\r\n\r\n            return `M ${x0} ${y0} C ${x2} ${y0}, ${x3} ${y1}, ${x1} ${y1}`;\r\n        }\r\n\r\n        private renderTooltip(selection: D3.UpdateSelection): void {\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\r\n                return (<SankeyDiagramTooltipData> tooltipEvent.data).tooltipData;\r\n            });\r\n        }\r\n\r\n        private bindSelectionHandler(\r\n            sankeyDiagramDataView: SankeyDiagramDataView,\r\n            nodesSelection: D3.UpdateSelection,\r\n            linksSelection: D3.UpdateSelection): void {\r\n\r\n            nodesSelection.on(\"click\", (node: SankeyDiagramNode) => {\r\n                var selectionIds = _.isEqual(\r\n                        node.selectionIds.map(x=>x.getKey()),\r\n                        this.selectionManager.getSelectionIds().map(x=>x.getKey()))\r\n                    ? []\r\n                    : node.selectionIds;\r\n\r\n                this.selectMany(selectionIds, true).then(() => this.setSelection(nodesSelection, linksSelection));\r\n\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            linksSelection.on(\"click\", (link: SankeyDiagramLink) => {\r\n                this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(() =>\r\n                    this.setSelection(nodesSelection, linksSelection));\r\n\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            this.root.on(\"click\", () => {\r\n                this.selectionManager.clear().then(() => this.setSelection(nodesSelection, linksSelection));\r\n            });\r\n\r\n            this.setSelection(nodesSelection, linksSelection);\r\n        }\r\n\r\n        private selectMany(selectionIds: SelectionId[], clear: boolean = false): JQueryPromise<{}> {\r\n            if(clear) {\r\n                return this.selectionManager.clear().then(() => this.selectMany(selectionIds, false));\r\n            }\r\n\r\n            var selectionDeffered = selectionIds.map(id => this.selectionManager.select(id, true));\r\n            return (<JQueryPromise<{}>>$.when.apply(null, selectionDeffered));\r\n        }\r\n\r\n        private setSelection(nodes: D3.UpdateSelection, links: D3.UpdateSelection): void {\r\n\r\n            var selectionIds: SelectionId[] = this.selectionManager.getSelectionIds();\r\n\r\n            nodes.classed(\"selected\", selectionIds.length > 0);\r\n            links.classed(\"selected\", false);\r\n\r\n            if (selectionIds.length === 0) {\r\n                return;\r\n            }\r\n\r\n            var selectedNodesSelection = nodes.filter((node: SankeyDiagramNode) => selectionIds\r\n                .some((selectedId: SelectionId) => node.selectionIds\r\n                .some( x => x.getKey() === selectedId.getKey())));\r\n\r\n            var selectedLinksSelection = links.filter((link: SankeyDiagramLink) =>\r\n                 selectionIds.some((selectionId: SelectionId) => selectionId.getKey() === link.selectionId.getKey()));\r\n\r\n            selectedNodesSelection.classed(\"selected\", false);\r\n            selectedLinksSelection.classed(\"selected\", true);\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            var enumeration = new ObjectEnumerationBuilder();\r\n\r\n            if (!this.dataView) {\r\n                return [];\r\n            }\r\n\r\n            switch (options.objectName) {\r\n                case \"labels\": {\r\n                    this.enumerateLabels(enumeration);\r\n                    break;\r\n                }\r\n                case \"links\": {\r\n                    this.enumerateLinks(enumeration);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private enumerateLabels(enumeration: ObjectEnumerationBuilder): void {\r\n            var settings: SankeyDiagramSettings = this.dataView.settings,\r\n                labels: VisualObjectInstance;\r\n\r\n            if (!settings) {\r\n                return;\r\n            }\r\n\r\n            labels = {\r\n                objectName: \"labels\",\r\n                displayName: \"labels\",\r\n                selector: null,\r\n                properties: {\r\n                    show: settings.isVisibleLabels,\r\n                    fill: settings.colourOfLabels,\r\n                    fontSize: settings.fontSize\r\n                }\r\n            };\r\n\r\n            enumeration.pushInstance(labels);\r\n        }\r\n\r\n        private enumerateLinks(enumeration: ObjectEnumerationBuilder): void {\r\n            var links: SankeyDiagramLink[] = this.dataView.links;\r\n\r\n            if (!links || !(links.length > 0)) {\r\n                return;\r\n            }\r\n\r\n            links.forEach((link: SankeyDiagramLink) => {\r\n                enumeration.pushInstance({\r\n                    objectName: \"links\",\r\n                    displayName: `${link.source.label.formattedName} - ${link.destination.label.formattedName}`,\r\n                    selector: ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),\r\n                    properties: {\r\n                        fill: { solid: { color: link.colour } }\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/sankeyDiagram/visual/sankeyDiagram.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    export let bulletChartProps = {\r\n        values: {\r\n            targetValue: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'targetValue' },\r\n            minimumPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'minimumPercent' },\r\n            needsImprovementPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'needsImprovementPercent' },\r\n            satisfactoryPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'satisfactoryPercent' },\r\n            goodPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'goodPercent' },\r\n            veryGoodPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'veryGoodPercent' },\r\n            maximumPercent: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'maximumPercent' },\r\n            targetValue2: <DataViewObjectPropertyIdentifier>{ objectName: 'values', propertyName: 'targetValue2' },\r\n        },\r\n        orientation: {\r\n            orientation: <DataViewObjectPropertyIdentifier>{ objectName: 'orientation', propertyName: 'orientation' },\r\n        },\r\n        colors: {\r\n            badColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'badColor' },\r\n            needsImprovementColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'needsImprovementColor' },\r\n            satisfactoryColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'satisfactoryColor' },\r\n            goodColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'goodColor' },\r\n            veryGoodColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'veryGoodColor' },\r\n            bulletColor: <DataViewObjectPropertyIdentifier>{ objectName: 'colors', propertyName: 'bulletColor' },\r\n        },\r\n        axis: {\r\n            axis: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'axis' },\r\n            axisColor: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'axisColor' },\r\n            measureUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'measureUnits' },\r\n            unitsColor: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'unitsColor' },\r\n        },\r\n        formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\r\n        labels: {\r\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\r\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\r\n            labelColor: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelColor' }\r\n        }\r\n    };\r\n\r\n    export interface BarData {\r\n        scale: any;\r\n        barIndex: number;\r\n        categoryLabel: string;\r\n        axis: any;\r\n        x: number;\r\n        y: number;\r\n        key: string;\r\n    }\r\n\r\n    export interface BarRect extends SelectableDataPoint {\r\n        barIndex: number;\r\n        start: number;\r\n        end: number;\r\n        fill: string;\r\n        tooltipInfo?: TooltipDataItem[];\r\n        key: string;\r\n    }\r\n\r\n    export interface TargetValue {\r\n        barIndex: number;\r\n        value: number;\r\n        value2: number;\r\n        fill: string;\r\n        key: string;\r\n    }\r\n\r\n    export interface ScaledValues {\r\n        firstScale: number;\r\n        secondScale: number;\r\n        thirdScale: number;\r\n        fourthScale: number;\r\n        fifthScale: number;\r\n    }\r\n\r\n    export interface BarValueRect extends BarRect {\r\n    }\r\n\r\n    export interface BulletChartSettings {\r\n        values: {\r\n            targetValue: number;\r\n            minimumPercent: number;\r\n            needsImprovementPercent: number;\r\n            satisfactoryPercent: number;\r\n            goodPercent: number;\r\n            veryGoodPercent: number;\r\n            maximumPercent: number;\r\n            targetValue2: number;\r\n        };\r\n        orientation: {\r\n            orientation: string;\r\n            reverse: boolean;\r\n            vertical: boolean;\r\n        };\r\n        colors: {\r\n            badColor: string;\r\n            needsImprovementColor: string;\r\n            satisfactoryColor: string;\r\n            goodColor: string;\r\n            veryGoodColor: string;\r\n            bulletColor: string;\r\n        };\r\n\r\n        axis: {\r\n            axis: boolean;\r\n            axisColor: string;\r\n            measureUnits: string;\r\n            unitsColor: string;\r\n        };\r\n        labelSettings: VisualDataLabelsSettings;\r\n    }\r\n\r\n    //Model\r\n    export interface BulletChartModel {\r\n        bars: BarData[];\r\n        bulletChartSettings: BulletChartSettings;\r\n        bulletValueFormatString: string;\r\n        barRects: BarRect[];\r\n        valueRects: BarValueRect[];\r\n        targetValues: TargetValue[];\r\n    }\r\n\r\n    export let bulletChartRoleNames = {\r\n        value: 'Value',\r\n        targetValue: 'TargetValue',\r\n        minValue: 'Minimum',\r\n        needsImprovementValue: 'NeedsImprovement',\r\n        satisfactoryValue: 'Satisfactory',\r\n        goodValue: 'Good',\r\n        veryGoodValue: 'VeryGood',\r\n        maxValue: 'Maximum',\r\n        targetValue2: 'TargetValue2',\r\n    };\r\n\r\n    module Orientation {\r\n        export const HORIZONTALLEFT: string = 'Horizontal Left';\r\n        export const HORIZONTALRIGHT: string = 'Horizontal Right';\r\n        export const VERTICALTOP: string = 'Vertical Top';\r\n        export const VERTICALBOTTOM: string = 'Vertical Bottom';\r\n\r\n        export var type: IEnumType = createEnumType([\r\n            { value: HORIZONTALLEFT, displayName: HORIZONTALLEFT },\r\n            { value: HORIZONTALRIGHT, displayName: HORIZONTALRIGHT },\r\n            { value: VERTICALTOP, displayName: VERTICALTOP },\r\n            { value: VERTICALBOTTOM, displayName: VERTICALBOTTOM }\r\n        ]);\r\n    }\r\n\r\n    export class BulletChart implements IVisual {\r\n        private static ScrollBarSize = 13;\r\n        private static SpaceRequiredForBar = 60;\r\n        private static SpaceRequiredForBarVertically = 100;\r\n        private static StartMarginHorizontal = 30;\r\n        private static StartMarginVertical = 50;\r\n        private static BulletSize = 25;\r\n        private static DefaultSubtitleFontSizeInPt = 9;\r\n        private static BarMargin = 10;\r\n        private static MaxLabelWidth = 80;\r\n        private static MaxLabelHeight = 60;\r\n        private static SubtitleMargin = 10;\r\n        private static AxisFontSizeInPt = 8;\r\n\r\n        private static BiggestLabelWidth = 0;\r\n        private static BiggestLabelHeight = 0;\r\n        private static MarkerMarginHorizontal = BulletChart.BulletSize / 3;\r\n        private static MarkerMarginVertical = BulletChart.BulletSize / 4;\r\n\r\n        private static FontFamily: string = \"Segoe UI\";\r\n        private baselineDelta: number = 0;\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Category',\r\n                }, {\r\n                    name: 'Value',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Value',\r\n                }, {\r\n                    name: 'TargetValue',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Target Value',\r\n                }, {\r\n                    name: 'Minimum',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Minimum',\r\n                }, {\r\n                    name: 'NeedsImprovement',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Needs Improvement',\r\n                }, {\r\n                    name: 'Satisfactory',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Satisfactory',\r\n                }, {\r\n                    name: 'Good',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Good',\r\n                }, {\r\n                    name: 'VeryGood',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Very Good',\r\n                }, {\r\n                    name: 'Maximum',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Maximum',\r\n                }, {\r\n                    name: 'TargetValue2',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Target Value 2'\r\n                }\r\n            ],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                values: {\r\n                    displayName: 'Data values',\r\n                    properties: {\r\n                        targetValue: {\r\n                            displayName: 'Target Value',\r\n                            type: { numeric: true }\r\n                        },\r\n                        targetValue2: {\r\n                            displayName: 'Target Value 2',\r\n                            type: { numeric: true },\r\n                        },\r\n                        minimumPercent: {\r\n                            displayName: 'Minimum %',\r\n                            type: { numeric: true }\r\n                        },\r\n                        needsImprovementPercent: {\r\n                            displayName: 'Needs Improvement %',\r\n                            type: { numeric: true },\r\n                        },\r\n                        satisfactoryPercent: {\r\n                            displayName: 'Satisfactory %',\r\n                            type: { numeric: true }\r\n                        },\r\n                        goodPercent: {\r\n                            displayName: 'Good %',\r\n                            type: { numeric: true }\r\n                        },\r\n                        veryGoodPercent: {\r\n                            displayName: 'Very Good %',\r\n                            type: { numeric: true },\r\n                        },\r\n                        maximumPercent: {\r\n                            displayName: 'Maximum %',\r\n                            type: { numeric: true }\r\n                        },\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: 'Category labels',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true },\r\n                        },\r\n                        labelColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } },\r\n                        },\r\n                    },\r\n                },\r\n                orientation: {\r\n                    displayName: 'Orientation',\r\n                    properties: {\r\n                        orientation: {\r\n                            displayName: 'Orientation',\r\n                            type: { enumeration: Orientation.type }\r\n                        }\r\n                    }\r\n                },\r\n                colors: {\r\n                    displayName: 'Colors',\r\n                    properties: {\r\n                        badColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Bad Color'\r\n                        },\r\n                        needsImprovementColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Needs Improvement Color',\r\n                        },\r\n                        satisfactoryColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Satisfactory Color'\r\n                        },\r\n                        goodColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Good Color'\r\n                        },\r\n                        veryGoodColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Very Good Color',\r\n                        },\r\n                        bulletColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Bullet Color'\r\n                        }\r\n                    },\r\n                },\r\n                axis: {\r\n                    displayName: 'Axis',\r\n                    properties: {\r\n                        axis: {\r\n                            displayName: 'Axis',\r\n                            type: { bool: true }\r\n                        },\r\n                        axisColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Axis Color'\r\n                        },\r\n                        measureUnits: {\r\n                            type: { text: true },\r\n                            displayName: 'Measure Units '\r\n                        },\r\n                        unitsColor: {\r\n                            type: { fill: { solid: { color: true } } },\r\n                            displayName: 'Units Color'\r\n                        },\r\n                    }\r\n                }\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    {\r\n                        'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },\r\n                        'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },\r\n                    },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        select: [\r\n                            { bind: { to: 'Value' } },\r\n                            { bind: { to: 'TargetValue' } },\r\n                            { bind: { to: 'TargetValue2' } },\r\n                            { bind: { to: 'Minimum' } },\r\n                            { bind: { to: 'NeedsImprovement' } },\r\n                            { bind: { to: 'Satisfactory' } },\r\n                            { bind: { to: 'Good' } },\r\n                            { bind: { to: 'VeryGood' } },\r\n                            { bind: { to: 'Maximum' } },\r\n                        ]\r\n                    },\r\n                },\r\n            }],\r\n            supportsHighlight: true,\r\n            sorting: {\r\n                default: {},\r\n            },\r\n            drilldown: {\r\n                roles: ['Category']\r\n            }\r\n        };\r\n\r\n        //Variables\r\n        private clearCatcher: D3.Selection;\r\n        private bulletBody: D3.Selection;\r\n        private scrollContainer: D3.Selection;\r\n        private labelGraphicsContext: D3.Selection;\r\n        private bulletGraphicsContext: D3.Selection;\r\n        private model: BulletChartModel;\r\n        private behavior: BulletWebBehavior;\r\n        private interactivityService: IInteractivityService;\r\n        private hostService: IVisualHostServices;\r\n\r\n        private get reverse(): boolean {\r\n            return this.model.bulletChartSettings.orientation.reverse;\r\n        }\r\n\r\n        private get vertical(): boolean {\r\n            return this.model.bulletChartSettings.orientation.vertical;\r\n        }\r\n\r\n        public static DefaultStyleProperties(): BulletChartSettings {\r\n            return {\r\n                values: {\r\n                    targetValue: 0,\r\n                    targetValue2: 0,\r\n                    minimumPercent: 0,\r\n                    needsImprovementPercent: 25,\r\n                    satisfactoryPercent: 50,\r\n                    goodPercent: 100,\r\n                    veryGoodPercent: 125,\r\n                    maximumPercent: 200,\r\n                },\r\n                orientation: {\r\n                    orientation: Orientation.HORIZONTALLEFT,\r\n                    reverse: false,\r\n                    vertical: false\r\n                },\r\n                colors: {\r\n                    badColor: 'Darkred',\r\n                    needsImprovementColor: 'Red',\r\n                    satisfactoryColor: 'Yellow',\r\n                    goodColor: 'Green',\r\n                    veryGoodColor: 'Darkgreen',\r\n                    bulletColor: 'Black'\r\n                },\r\n                axis: {\r\n                    axis: true,\r\n                    axisColor: 'Grey',\r\n                    measureUnits: '',\r\n                    unitsColor: 'Grey',\r\n                },\r\n                labelSettings: {\r\n                    fontSize: 11,\r\n                    show: true,\r\n                    labelColor: 'Black',\r\n                },\r\n            };\r\n        }\r\n\r\n        private viewport: IViewport;\r\n\r\n        private get viewportIn(): IViewport {\r\n            return <IViewport>{\r\n                width: this.viewport.width,\r\n                height: this.viewport.height\r\n            };\r\n        }\r\n\r\n        private get viewportScroll(): IViewport {\r\n            let viewportIn = this.viewportIn;\r\n            return <IViewport>{\r\n                width: viewportIn.width - BulletChart.ScrollBarSize,\r\n                height: viewportIn.height - BulletChart.ScrollBarSize\r\n            };\r\n        }\r\n\r\n        private static getTextProperties(text: string, fontSize: number): TextProperties {\r\n            return <TextProperties>{\r\n                fontFamily: BulletChart.FontFamily,\r\n                fontSize: PixelConverter.fromPoint(fontSize),\r\n                text: text,\r\n            };\r\n        }\r\n        \r\n        // Convert a DataView into a view model\r\n        public static converter(dataView: DataView, options: VisualUpdateOptions): BulletChartModel {\r\n            let defaultSettings = BulletChart.DefaultStyleProperties();\r\n            let bulletModel: BulletChartModel = <BulletChartModel>{\r\n                bulletValueFormatString: null,\r\n                bulletChartSettings: defaultSettings,\r\n                bars: [],\r\n                barRects: [],\r\n                valueRects: [],\r\n                targetValues: [],\r\n            };\r\n\r\n            if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length === 0\r\n                || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {\r\n                return bulletModel;\r\n            }\r\n\r\n            let objects = dataView.metadata.objects;\r\n            let settings = bulletModel.bulletChartSettings;\r\n\r\n            if (objects) {\r\n                settings.values.targetValue = DataViewObjects.getValue<number>(objects, bulletChartProps.values.targetValue, defaultSettings.values.targetValue);\r\n                settings.values.targetValue2 = DataViewObjects.getValue<number>(objects, bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2);\r\n                settings.values.minimumPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent);\r\n                settings.values.needsImprovementPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent);\r\n                settings.values.satisfactoryPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent);\r\n                settings.values.goodPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent);\r\n                settings.values.veryGoodPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent);\r\n                settings.values.maximumPercent = DataViewObjects.getValue<number>(objects, bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent);\r\n\r\n                settings.orientation.orientation = DataViewObjects.getValue<string>(objects, bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation);\r\n\r\n                settings.colors.badColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.badColor, defaultSettings.colors.badColor);\r\n                settings.colors.needsImprovementColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor);\r\n                settings.colors.satisfactoryColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor);\r\n                settings.colors.goodColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor);\r\n                settings.colors.veryGoodColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor);\r\n                settings.colors.bulletColor = DataViewObjects.getFillColor(objects, bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor);\r\n\r\n                settings.axis.axis = DataViewObjects.getValue<boolean>(objects, bulletChartProps.axis.axis, defaultSettings.axis.axis);\r\n                settings.axis.axisColor = DataViewObjects.getFillColor(objects, bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor);\r\n                settings.axis.measureUnits = TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(\r\n                    DataViewObjects.getValue<string>(objects, bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);\r\n                settings.axis.unitsColor = DataViewObjects.getFillColor(objects, bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor);\r\n\r\n                settings.labelSettings.fontSize = DataViewObjects.getValue<number>(objects, bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize);\r\n                settings.labelSettings.show = DataViewObjects.getValue<boolean>(objects, bulletChartProps.labels.show, defaultSettings.labelSettings.show);\r\n                settings.labelSettings.labelColor = DataViewObjects.getFillColor(objects, bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor);\r\n            }\r\n            if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\r\n                settings.orientation.reverse = true;\r\n\r\n            if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)\r\n                settings.orientation.vertical = true;\r\n\r\n            let categories: DataViewCategoryColumn,\r\n                categoryValues: any[],\r\n                categoryValuesLen: number = 1,\r\n                categoryFormatString: string;\r\n\r\n            if (dataView.categorical.categories) {\r\n                categories = dataView.categorical.categories[0];\r\n                categoryValues = categories.values;\r\n                categoryValuesLen = categoryValues.length;\r\n                categoryFormatString = valueFormatter.getFormatString(categories.source, bulletChartProps.formatString);\r\n            }\r\n\r\n            bulletModel.bulletValueFormatString = valueFormatter.getFormatString(dataView.categorical.values[0].source, bulletChartProps.formatString);\r\n\r\n            for (let idx = 0; idx < categoryValuesLen; idx++) {\r\n                let toolTipItems = [];\r\n                let category: string, value: number, targetValue: number, targetValue2: number, minimum: number, satisfactory: number,\r\n                    good: number, maximum: number, needsImprovement: number, veryGood: number;\r\n                let highlight: boolean = false,\r\n                    categoryIdentity: DataViewScopeIdentity;\r\n\r\n                if (categoryValues) {\r\n                    let categoryValue = categoryValues[idx];\r\n\r\n                    category = valueFormatter.format(categoryValue, categoryFormatString);\r\n                    categoryIdentity = categories.identity ? categories.identity[idx] : null;\r\n\r\n                    let textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);\r\n                    category = TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);\r\n\r\n                    let labelWidth = TextMeasurementService.measureSvgTextWidth(textProperties);\r\n                    let labelHeight = TextMeasurementService.estimateSvgTextHeight(textProperties);\r\n\r\n                    BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth);\r\n                    BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);\r\n                }\r\n\r\n                let values = dataView.categorical.values;\r\n                targetValue = settings.values.targetValue;\r\n                targetValue2 = settings.values.targetValue2;\r\n\r\n                for (let i = 0; i < values.length; i++) {\r\n                    let col = values[i].source;\r\n                    let currentVal = values[i].values[idx] || 0;\r\n\r\n                    if (col && col.roles) {\r\n                        if (col.roles[bulletChartRoleNames.value]) {\r\n                            if (values[i].highlights)\r\n                                highlight = values[i].highlights[idx] !== null;\r\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\r\n                            value = currentVal;\r\n                        } else if (col.roles[bulletChartRoleNames.targetValue]) {\r\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\r\n                            targetValue = currentVal;\r\n                        } else if (col.roles[bulletChartRoleNames.targetValue2]) {\r\n                            toolTipItems.push({ value: currentVal, metadata: values[i] });\r\n                            targetValue2 = currentVal;\r\n                        } else if (col.roles[bulletChartRoleNames.minValue])\r\n                            minimum = currentVal;\r\n                        else if (col.roles[bulletChartRoleNames.needsImprovementValue])\r\n                            needsImprovement = currentVal;\r\n                        else if (col.roles[bulletChartRoleNames.satisfactoryValue])\r\n                            satisfactory = currentVal;\r\n                        else if (col.roles[bulletChartRoleNames.goodValue])\r\n                            good = currentVal;\r\n                        else if (col.roles[bulletChartRoleNames.veryGoodValue])\r\n                            veryGood = currentVal;\r\n                        else if (col.roles[bulletChartRoleNames.maxValue])\r\n                            maximum = currentVal;\r\n                    }\r\n                }\r\n\r\n                if (!minimum)\r\n                    minimum = settings.values.minimumPercent * targetValue / 100;\r\n                if (!needsImprovement)\r\n                    needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;\r\n                if (!satisfactory)\r\n                    satisfactory = settings.values.satisfactoryPercent * targetValue / 100;\r\n                if (!good)\r\n                    good = settings.values.goodPercent * targetValue / 100;\r\n                if (!veryGood)\r\n                    veryGood = settings.values.veryGoodPercent * targetValue / 100;\r\n                if (!maximum)\r\n                    maximum = settings.values.maximumPercent * targetValue / 100;\r\n\r\n                let viewportLength = (settings.orientation.vertical ? (options.viewport.height - BulletChart.MaxLabelHeight) : (options.viewport.width - BulletChart.MaxLabelWidth)) -\r\n                    BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize;\r\n                let sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);\r\n                let scale = (d3.scale.linear()\r\n                    .clamp(true)\r\n                    .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])\r\n                    .range(settings.orientation.vertical ? [viewportLength, 0] : [0, viewportLength]));\r\n\r\n                // Scalles without\r\n                let firstScale = scale(minimum);\r\n                let secondScale = scale(needsImprovement);\r\n                let thirdScale = scale(satisfactory);\r\n                let fourthScale = scale(good);\r\n                let fifthScale = scale(veryGood);\r\n                let lastScale = scale(maximum);\r\n                let valueScale = scale(value);\r\n\r\n                let firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor,\r\n                    thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;\r\n\r\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity);\r\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity);\r\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity);\r\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity);\r\n                BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity);\r\n                BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity);\r\n\r\n                // markerValue\r\n                bulletModel.targetValues.push({\r\n                    barIndex: idx,\r\n                    value: scale(targetValue),\r\n                    fill: settings.colors.bulletColor,\r\n                    key: SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),\r\n                    value2: scale(targetValue2),\r\n                });\r\n\r\n                let xAxis = null;\r\n                if (settings.axis.axis) {\r\n                    xAxis = d3.svg.axis();\r\n                    xAxis.orient(settings.orientation.vertical ? \"left\" : \"bottom\");\r\n                    let minTickSize = Math.round(Math.max(3, viewportLength / 100));\r\n                    let axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]\r\n                        .filter(x => !isNaN(x));\r\n                    xAxis.tickFormat(valueFormatter.create({\r\n                        format: bulletModel.bulletValueFormatString,\r\n                        value: axisValues.length ? Math.max.apply(null, axisValues) : 0\r\n                    }).format);\r\n                    xAxis.ticks(minTickSize);\r\n                    xAxis.scale(scale);\r\n                }\r\n\r\n                let bar: BarData = {\r\n                    scale: scale,\r\n                    barIndex: idx,\r\n                    categoryLabel: category,\r\n                    x: (settings.orientation.vertical) ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,\r\n                    y: (settings.orientation.vertical) ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,\r\n                    axis: xAxis,\r\n                    key: SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),\r\n                };\r\n\r\n                bulletModel.bars.push(bar);\r\n            }\r\n\r\n            return bulletModel;\r\n        }\r\n\r\n        private static addItemToBarArray(collection: BarRect[], barIndex: number, start: number, end: number, fill: string, tooltipInfo?: any[], categoryIdentity?: any): void {\r\n            collection.push({\r\n                barIndex: barIndex,\r\n                start: start,\r\n                end: end,\r\n                fill: fill,\r\n                tooltipInfo: TooltipBuilder.createTooltipInfo(bulletChartProps.formatString, null, null, null, null, tooltipInfo),\r\n                selected: false,\r\n                identity: SelectionId.createWithId(categoryIdentity),\r\n                key: SelectionId.createWithIdAndMeasure(categoryIdentity, start + \" \" + end).getKey(),\r\n            });\r\n        }\r\n \r\n        /* One time setup*/\r\n        public init(options: VisualInitOptions): void {\r\n            let body = d3.select(options.element.get(0));\r\n            this.hostService = options.host;\r\n\r\n            this.bulletBody = body\r\n                .append('div')\r\n                .classed('bulletChart', true);\r\n\r\n            this.scrollContainer = this.bulletBody.append('svg')\r\n                .classed('bullet-scroll-region', true);\r\n            this.clearCatcher = appendClearCatcher(this.scrollContainer);\r\n\r\n            this.labelGraphicsContext = this.scrollContainer.append('g');\r\n            this.bulletGraphicsContext = this.scrollContainer.append('g');\r\n\r\n            this.behavior = new BulletWebBehavior();\r\n\r\n            this.interactivityService = createInteractivityService(options.host);\r\n        }\r\n\r\n        /* Called for data, size, formatting changes*/\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options.dataViews || !options.dataViews[0]) return;\r\n            BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;\r\n            let dataView = options.dataViews[0];\r\n            this.viewport = options.viewport;\r\n            this.model = BulletChart.converter(dataView, options);\r\n\r\n            //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.\r\n            this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties(\"1\", this.model.bulletChartSettings.labelSettings.fontSize));\r\n\r\n            this.ClearViewport();\r\n            if (!this.model) {\r\n                return;\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(this.model.barRects);\r\n            }\r\n\r\n            this.bulletBody.style({\r\n                'height': this.viewportIn.height + 'px',\r\n                'width': this.viewportIn.width + 'px',\r\n            });\r\n            if (this.vertical) {\r\n                this.scrollContainer.attr({\r\n                    width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically) + 'px',\r\n                    height: this.viewportScroll.height + 'px'\r\n                });\r\n            }\r\n            else {\r\n                this.scrollContainer.attr({\r\n                    height: (this.model.bars.length * BulletChart.SpaceRequiredForBar) + 'px',\r\n                    width: this.viewportScroll.width + 'px'\r\n                });\r\n            }\r\n\r\n            if (this.vertical)\r\n                this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);\r\n            else\r\n                this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);\r\n        }\r\n\r\n        private ClearViewport() {\r\n            this.labelGraphicsContext.selectAll(\"text\").remove();\r\n            this.bulletGraphicsContext.selectAll(\"rect\").remove();\r\n            this.bulletGraphicsContext.selectAll('axis').remove();\r\n            this.bulletGraphicsContext.selectAll('path').remove();\r\n            this.bulletGraphicsContext.selectAll('line').remove();\r\n            this.bulletGraphicsContext.selectAll('tick').remove();\r\n            this.bulletGraphicsContext.selectAll('g').remove();\r\n        }\r\n\r\n        private calculateLabelWidth(barData: BarData, bar?: BarRect, reversed?: boolean) {\r\n            if (reversed)\r\n                return BulletChart.StartMarginHorizontal + ((bar) ? bar.start : 0);\r\n\r\n            let textSize = TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\r\n            if (textSize > BulletChart.BiggestLabelWidth)\r\n                return barData.x + BulletChart.MaxLabelWidth + ((bar) ? bar.start : 0);\r\n            return barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + ((bar) ? bar.start : 0);\r\n        }\r\n\r\n        private calculateLabelHeight(barData: BarData, bar?: BarRect, reversed?: boolean) {\r\n            if (reversed)\r\n                return BulletChart.StartMarginVertical + ((bar) ? bar.end : 0);\r\n\r\n            let textSize = TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));\r\n            if (textSize > BulletChart.BiggestLabelHeight)\r\n                return barData.y + BulletChart.MaxLabelHeight + ((bar) ? bar.end : 0);\r\n            return barData.y + textSize + BulletChart.BarMargin + ((bar) ? bar.end : 0);\r\n        }\r\n\r\n        private setUpBulletsHorizontally(bulletBody: D3.Selection, model: BulletChartModel, reveresed: boolean) {\r\n            let bars = model.bars;\r\n            let rects = model.barRects;\r\n            let valueRects = model.valueRects;\r\n            let targetValues = model.targetValues;\r\n            let barSelection = this.labelGraphicsContext.selectAll('text').data(bars, (d: BarData) => d.key);\r\n            let rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, (d: BarRect) => d.key);\r\n\r\n            // Draw bullets\r\n            let bullets = rectSelection.enter().append('rect').attr({\r\n                'x': ((d: BarRect) => { return this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\r\n                'y': ((d: BarRect) => bars[d.barIndex].y - BulletChart.BulletSize / 2),\r\n                'width': ((d: BarRect) => d.end - d.start),\r\n                'height': BulletChart.BulletSize,\r\n            }).classed('range', true).style({\r\n                'fill': ((d: BarRect) => d.fill)\r\n            });\r\n\r\n            rectSelection.exit();\r\n\r\n            // Draw value rects\r\n            let valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, (d: BarValueRect) => d.key);\r\n            valueSelection.enter().append('rect').attr({\r\n                'x': ((d: BarValueRect) => { return this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),\r\n                'y': ((d: BarValueRect) => bars[d.barIndex].y - BulletChart.BulletSize / 8),\r\n                'width': ((d: BarValueRect) => d.end - d.start),\r\n                'height': BulletChart.BulletSize * 1 / 4,\r\n            }).classed('value', true).style({\r\n                'fill': ((d: BarValueRect) => d.fill),\r\n            });\r\n\r\n            valueSelection.exit();\r\n            // Draw markers\r\n            let markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, (d: TargetValue) => d.key);\r\n            markerSelection.enter().append('line').attr({\r\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\r\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),\r\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\r\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n            });\r\n\r\n            markerSelection.enter().append('line').attr({\r\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\r\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n                'transform': 'rotate(45deg)',\r\n                'transform-origin': '50% 50% 0',\r\n            });\r\n\r\n            markerSelection.enter().append('line').attr({\r\n                'x1': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'x2': ((d: TargetValue) => { return this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'y1': ((d: TargetValue) => bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal),\r\n                'y2': ((d: TargetValue) => bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n                'transform': 'rotate(315deg)',\r\n                'transform-origin': '50% 50% 0',\r\n            });\r\n\r\n            markerSelection.exit();\r\n\r\n            // Draw axes\r\n            if (model.bulletChartSettings.axis.axis) {\r\n                // Using var instead of let since you can't pass let parameters to functions inside loops.\r\n                // needs to be changed to let when typescript 1.8 comes out.\r\n                for (var idx = 0; idx < bars.length; idx++) {\r\n                    var bar = bars[idx];\r\n                    this.bulletGraphicsContext.append(\"g\").attr({\r\n                        'transform': () => {\r\n                            let xLocation = this.calculateLabelWidth(bar, null, reveresed);\r\n                            let yLocation = bar.y + BulletChart.BulletSize / 2;\r\n\r\n                            return 'translate(' + xLocation + ',' + yLocation + ')';\r\n                        },\r\n                    }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\r\n                        'fill': model.bulletChartSettings.axis.axisColor,\r\n                        'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)\r\n                    }).selectAll('line').style({\r\n                        'stroke': model.bulletChartSettings.axis.axisColor,\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Draw Labels\r\n            if (model.bulletChartSettings.labelSettings.show) {\r\n                barSelection.enter().append('text').classed(\"title\", true).attr({\r\n                    'x': ((d: BarData) => {\r\n                        if (reveresed)\r\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().width + BulletChart.StartMarginHorizontal;\r\n                        return d.x;\r\n                    }),\r\n                    'y': ((d: BarData) => d.y + this.baselineDelta),\r\n                    'fill': model.bulletChartSettings.labelSettings.labelColor,\r\n                    'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\r\n                }).text((d: BarData) => d.categoryLabel);\r\n            }\r\n\r\n            // Draw measure label\r\n            if (model.bulletChartSettings.axis.measureUnits) {\r\n                barSelection.enter().append('text').attr({\r\n                    'x': ((d: BarData) => {\r\n                        if (reveresed)\r\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin;\r\n                        return d.x - BulletChart.SubtitleMargin;\r\n                    }),\r\n                    'y': ((d: BarData) => d.y + BulletChart.BulletSize),\r\n                    'fill': model.bulletChartSettings.axis.unitsColor,\r\n                    'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\r\n                }).text(model.bulletChartSettings.axis.measureUnits);\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                let behaviorOptions: BulletBehaviorOptions = {\r\n                    rects: bullets,\r\n                    valueRects: valueSelection,\r\n                    clearCatcher: this.clearCatcher,\r\n                    interactivityService: this.interactivityService,\r\n                    bulletChartSettings: this.model.bulletChartSettings,\r\n                    hasHighlights: false,\r\n                };\r\n\r\n                let targetCollection = this.model.barRects.concat(this.model.valueRects);\r\n                this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\r\n            }\r\n\r\n            barSelection.exit();\r\n            TooltipManager.addTooltip(valueSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\r\n            TooltipManager.addTooltip(rectSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\r\n        }\r\n\r\n        private setUpBulletsVertically(bulletBody: D3.Selection, model: BulletChartModel, reveresed: boolean) {\r\n            let bars = model.bars;\r\n            let rects = model.barRects;\r\n            let valueRects = model.valueRects;\r\n            let targetValues = model.targetValues;\r\n            let barSelection = this.labelGraphicsContext.selectAll('text').data(bars, (d: BarData) => d.key);\r\n            let rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, (d: BarRect) => d.key);\r\n\r\n            // Draw bullets\r\n            let bullets = rectSelection.enter().append('rect').attr({\r\n                'x': ((d: BarRect) => bars[d.barIndex].x),\r\n                'y': ((d: BarRect) => { return this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\r\n                'height': ((d: BarRect) => d.start - d.end),\r\n                'width': BulletChart.BulletSize,\r\n            }).classed('range', true).style({\r\n                'fill': ((d: BarRect) => d.fill)\r\n            });\r\n\r\n            rectSelection.exit();\r\n\r\n            // Draw value rects\r\n            let valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, (d: BarValueRect) => d.key);\r\n            valueSelection.enter().append('rect').attr({\r\n                'x': ((d: BarValueRect) => bars[d.barIndex].x + BulletChart.BulletSize / 3),\r\n                'y': ((d: BarValueRect) => { return this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),\r\n                'height': ((d: BarValueRect) => d.start - d.end),\r\n                'width': BulletChart.BulletSize * 1 / 4,\r\n            }).classed('value', true).style({\r\n                'fill': ((d: BarValueRect) => d.fill),\r\n            });\r\n\r\n            valueSelection.exit();\r\n\r\n            // Draw markers\r\n            let markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, (d: TargetValue) => d.key);\r\n            markerSelection.enter().append('line').attr({\r\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\r\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\r\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\r\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n            });\r\n\r\n            markerSelection.enter().append('line').attr({\r\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\r\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n                'transform': 'rotate(45deg)',\r\n                'transform-origin': '50% 50% 0',\r\n            });\r\n\r\n            markerSelection.enter().append('line').attr({\r\n                'y1': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'y2': ((d: TargetValue) => { return this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),\r\n                'x1': ((d: TargetValue) => bars[d.barIndex].x + BulletChart.MarkerMarginVertical),\r\n                'x2': ((d: TargetValue) => bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3)),\r\n            }).style({\r\n                'stroke': ((d: TargetValue) => d.fill),\r\n                'stroke-width': 2,\r\n                'transform': 'rotate(315deg)',\r\n                'transform-origin': '50% 50% 0',\r\n            });\r\n\r\n            markerSelection.exit();\r\n\r\n            // // Draw axes\r\n            if (model.bulletChartSettings.axis.axis) {\r\n\r\n                // Using var instead of let since you can't pass let parameters to functions inside loops.\r\n                // needs to be changed to let when typescript 1.8 comes out.\r\n                for (var idx = 0; idx < bars.length; idx++) {\r\n                    var bar = bars[idx];\r\n                    this.bulletGraphicsContext.append(\"g\").attr({\r\n                        'transform': () => {\r\n                            let xLocation = bar.x;\r\n                            let yLocation = this.calculateLabelHeight(bar, null, reveresed);\r\n                            // let yLocation = bar.y + BulletChart.BulletSize / 2;\r\n                            return 'translate(' + xLocation + ',' + yLocation + ')';\r\n                        },\r\n                    }).classed(\"axis\", true).call(bar.axis.scale(bar.scale)).style({\r\n                        'fill': model.bulletChartSettings.axis.axisColor,\r\n                        'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),\r\n                    }).selectAll('line').style({\r\n                        'stroke': model.bulletChartSettings.axis.axisColor,\r\n                    });\r\n                }\r\n            }\r\n\r\n            // Draw Labels\r\n            if (model.bulletChartSettings.labelSettings.show) {\r\n                barSelection.enter().append('text').classed(\"title\", true).attr({\r\n                    'x': ((d: BarData) => d.x),\r\n                    'y': ((d: BarData) => {\r\n                        if (reveresed)\r\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize;\r\n                        return d.y + TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel,\r\n                            model.bulletChartSettings.labelSettings.fontSize)) / 2;\r\n                    }),\r\n                    'fill': model.bulletChartSettings.labelSettings.labelColor,\r\n                    'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),\r\n                }).text((d: BarData) => d.categoryLabel);\r\n            }\r\n\r\n            // Draw measure label\r\n            if (model.bulletChartSettings.axis.measureUnits) {\r\n                barSelection.enter().append('text').attr({\r\n                    'x': ((d: BarData) => d.x + BulletChart.BulletSize),\r\n                    'y': ((d: BarData) => {\r\n                        if (reveresed)\r\n                            return this.bulletGraphicsContext.node<SVGElement>().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\r\n                        return d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;\r\n                    }),\r\n                    'fill': model.bulletChartSettings.axis.unitsColor,\r\n                    'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)\r\n                }).text(model.bulletChartSettings.axis.measureUnits);\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                let behaviorOptions: BulletBehaviorOptions = {\r\n                    rects: bullets,\r\n                    valueRects: valueSelection,\r\n                    clearCatcher: this.clearCatcher,\r\n                    interactivityService: this.interactivityService,\r\n                    bulletChartSettings: this.model.bulletChartSettings,\r\n                    hasHighlights: false,\r\n                };\r\n\r\n                let targetCollection = this.model.barRects.concat(this.model.valueRects);\r\n                this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);\r\n            }\r\n\r\n            barSelection.exit();\r\n            TooltipManager.addTooltip(valueSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\r\n            TooltipManager.addTooltip(rectSelection, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\r\n        }\r\n\r\n        /*About to remove your visual, do clean up here */\r\n        public destroy() { }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            let data = this.model;\r\n            if (!data) {\r\n                return;\r\n            }\r\n\r\n            let objectName = options.objectName;\r\n            switch (objectName) {\r\n                case 'labels':\r\n                    return this.enumerateLabels(data);\r\n                case 'values':\r\n                    return this.enumerateValues(data);\r\n                case 'orientation':\r\n                    return this.enumerateOrientation(data);\r\n                case 'axis':\r\n                    return this.enumerateAxis(data);\r\n                case 'colors':\r\n                    return this.enumerateColors(data);\r\n            }\r\n        }\r\n\r\n        private enumerateLabels(data: BulletChartModel): VisualObjectInstance[] {\r\n            return [{\r\n                selector: null,\r\n                objectName: 'labels',\r\n                properties: {\r\n                    show: this.model.bulletChartSettings.labelSettings.show,\r\n                    labelColor: this.model.bulletChartSettings.labelSettings.labelColor,\r\n                    fontSize: this.model.bulletChartSettings.labelSettings.fontSize,\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateValues(data: BulletChartModel): VisualObjectInstance[] {\r\n            return [{\r\n                selector: null,\r\n                objectName: 'values',\r\n                properties: {\r\n                    targetValue: this.model.bulletChartSettings.values.targetValue,\r\n                    targetValue2: this.model.bulletChartSettings.values.targetValue2,\r\n                    minimumPercent: this.model.bulletChartSettings.values.minimumPercent,\r\n                    needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,\r\n                    satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,\r\n                    goodPercent: this.model.bulletChartSettings.values.goodPercent,\r\n                    veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,\r\n                    maximumPercent: this.model.bulletChartSettings.values.maximumPercent,\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateOrientation(data: BulletChartModel): VisualObjectInstance[] {\r\n            return [{\r\n                selector: null,\r\n                objectName: 'orientation',\r\n                properties: {\r\n                    orientation: this.model.bulletChartSettings.orientation.orientation\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateAxis(data: BulletChartModel): VisualObjectInstance[] {\r\n            return [{\r\n                selector: null,\r\n                objectName: 'axis',\r\n                properties: {\r\n                    axis: this.model.bulletChartSettings.axis.axis,\r\n                    axisColor: this.model.bulletChartSettings.axis.axisColor,\r\n                    measureUnits: this.model.bulletChartSettings.axis.measureUnits,\r\n                    unitsColor: this.model.bulletChartSettings.axis.unitsColor,\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateColors(data: BulletChartModel): VisualObjectInstance[] {\r\n            return [{\r\n                selector: null,\r\n                objectName: 'colors',\r\n                properties: {\r\n                    badColor: this.model.bulletChartSettings.colors.badColor,\r\n                    needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,\r\n                    satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,\r\n                    goodColor: this.model.bulletChartSettings.colors.goodColor,\r\n                    veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,\r\n                    bulletColor: this.model.bulletChartSettings.colors.bulletColor,\r\n                }\r\n            }];\r\n        }\r\n    }\r\n\r\n    //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\r\n    export module TextMeasurementHelper {\r\n\r\n        interface CanvasContext {\r\n            font: string;\r\n            measureText(text: string): { width: number };\r\n        }\r\n\r\n        interface CanvasElement extends HTMLElement {\r\n            getContext(name: string);\r\n        }\r\n\r\n        let spanElement: JQuery;\r\n        let svgTextElement: D3.Selection;\r\n        let canvasCtx: CanvasContext;\r\n\r\n        export function estimateSvgTextBaselineDelta(textProperties: TextProperties): number {\r\n            let rect = estimateSvgTextRect(textProperties);\r\n            return rect.y + rect.height;\r\n        }\r\n\r\n        function ensureDOM(): void {\r\n            if (spanElement)\r\n                return;\r\n\r\n            spanElement = $('<span/>');\r\n            $('body').append(spanElement);\r\n            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\r\n            svgTextElement = d3.select($('body').get(0))\r\n                .append('svg')\r\n                .style({\r\n                    'height': '0px',\r\n                    'width': '0px',\r\n                    'position': 'absolute'\r\n                })\r\n                .append('text');\r\n            canvasCtx = (<CanvasElement>$('<canvas/>').get(0)).getContext(\"2d\");\r\n        }\r\n\r\n        function measureSvgTextRect(textProperties: TextProperties): SVGRect {\r\n            debug.assertValue(textProperties, 'textProperties');\r\n\r\n            ensureDOM();\r\n\r\n            svgTextElement.style(null);\r\n            svgTextElement\r\n                .text(textProperties.text)\r\n                .attr({\r\n                    'visibility': 'hidden',\r\n                    'font-family': textProperties.fontFamily,\r\n                    'font-size': textProperties.fontSize,\r\n                    'font-weight': textProperties.fontWeight,\r\n                    'font-style': textProperties.fontStyle,\r\n                    'white-space': textProperties.whiteSpace || 'nowrap'\r\n                });\r\n\r\n            // We're expecting the browser to give a synchronous measurement here\r\n            // We're using SVGTextElement because it works across all browsers \r\n            return svgTextElement.node<SVGTextElement>().getBBox();\r\n        }\r\n\r\n        function estimateSvgTextRect(textProperties: TextProperties): SVGRect {\r\n            debug.assertValue(textProperties, 'textProperties');\r\n\r\n            let estimatedTextProperties: TextProperties = {\r\n                fontFamily: textProperties.fontFamily,\r\n                fontSize: textProperties.fontSize,\r\n                text: \"M\",\r\n            };\r\n\r\n            let rect = measureSvgTextRect(estimatedTextProperties);\r\n\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    export interface BulletBehaviorOptions {\r\n        rects: D3.Selection;\r\n        valueRects: D3.Selection;\r\n        clearCatcher: D3.Selection;\r\n        interactivityService: IInteractivityService;\r\n        bulletChartSettings: BulletChartSettings;\r\n        hasHighlights: boolean;\r\n    }\r\n\r\n    export class BulletWebBehavior implements IInteractiveBehavior {\r\n        private options: BulletBehaviorOptions;\r\n\r\n        public bindEvents(options: BulletBehaviorOptions, selectionHandler: ISelectionHandler) {\r\n            this.options = options;\r\n            let clearCatcher = options.clearCatcher;\r\n\r\n            options.valueRects.on('click', (d: BarValueRect, i: number) => {\r\n                d3.event.stopPropagation();\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n            });\r\n\r\n            options.rects.on('click', (d: BarRect, i: number) => {\r\n                d3.event.stopPropagation();\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n            });\r\n\r\n            clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            let options = this.options;\r\n\r\n            options.valueRects.style(\"opacity\", (d: BarValueRect) => {\r\n                return hasSelection ? (d.selected ? '1' : '0.4') : '1';\r\n            });\r\n\r\n            options.rects.style(\"opacity\", (d: BarRect) => {\r\n                return hasSelection ? (d.selected ? '1' : '0.4') : '1';\r\n            });\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/bulletChart/visual/bulletChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud\r\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ValueFormatter = powerbi.visuals.valueFormatter;\r\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n\r\n    type D3Element =\r\n        D3.UpdateSelection\r\n        | D3.Selection\r\n        | D3.Selectors\r\n        | D3.Transition.Transition;\r\n\r\n    export enum WordCloudScaleType {\r\n        logn,\r\n        sqrt,\r\n        value\r\n    };\r\n\r\n    export interface WordCloudText {\r\n        text: string;\r\n        count: number;\r\n        index: number;\r\n        selectionId: SelectionId;\r\n        color: string;\r\n    }\r\n\r\n    export interface WordCloudDataPoint extends IPoint {\r\n        text: string;\r\n        xOff: number;\r\n        yOff: number;\r\n        rotate?: number;\r\n        size: number;\r\n        padding: number;\r\n        width: number;\r\n        height: number;\r\n        sprite?: number[];\r\n        x0: number;\r\n        y0: number;\r\n        x1: number;\r\n        y1: number;\r\n        color: string;\r\n        selectionId: SelectionId;\r\n        wordIndex: number;\r\n    }\r\n\r\n    export interface WordCloudData {\r\n        settings: WordCloudSettings;\r\n        texts: WordCloudText[];\r\n    }\r\n\r\n    export interface WordCloudDataView {\r\n        data: WordCloudDataPoint[];\r\n        leftBorder: IPoint;\r\n        rightBorder: IPoint;\r\n    }\r\n\r\n    export interface WordCloudConstructorOptions {\r\n        svg?: D3.Selection;\r\n        animator?: IGenericAnimator;\r\n        margin?: IMargin;\r\n    }\r\n\r\n    export interface WordCloudSettings {\r\n        minFontSize: number;\r\n        maxFontSize: number;\r\n        minAngle?: number;\r\n        maxAngle?: number;\r\n        maxNumberOfOrientations?: number;\r\n        valueFormatter?: IValueFormatter;\r\n        isRotateText: boolean;\r\n        isBrokenText: boolean;\r\n        isRemoveStopWords: boolean;\r\n        stopWords: string;\r\n        isDefaultStopWords: boolean;\r\n        stopWordsArray: string[];\r\n        maxNumberOfWords: number;\r\n    }\r\n\r\n    class VisualLayout {\r\n        private marginValue: IMargin;\r\n        private viewportValue: IViewport;\r\n        private viewportInValue: IViewport;\r\n\r\n        public defaultMargin: IMargin;\r\n        public defaultViewport: IViewport;\r\n\r\n        constructor(defaultViewport?: IViewport, defaultMargin?: IMargin) {\r\n            this.defaultViewport = defaultViewport || { width: 0, height: 0 };\r\n            this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };\r\n        }\r\n\r\n        public get margin(): IMargin {\r\n            return this.marginValue || (this.margin = this.defaultMargin);\r\n        }\r\n\r\n        public set margin(value: IMargin) {\r\n            this.marginValue = VisualLayout.restrictToMinMax(value);\r\n            this.update();\r\n        }\r\n\r\n        public get viewport(): IViewport {\r\n            return this.viewportValue || (this.viewportValue = this.defaultViewport);\r\n        }\r\n\r\n        public set viewport(value: IViewport) {\r\n            this.viewportValue = VisualLayout.restrictToMinMax(value);\r\n            this.update();\r\n        }\r\n\r\n        public get viewportIn(): IViewport {\r\n            return this.viewportInValue || this.viewport;\r\n        }\r\n\r\n        public get viewportInIsZero(): boolean {\r\n            return this.viewportIn.width === 0 || this.viewportIn.height === 0;\r\n        }\r\n\r\n        private update(): void {\r\n            this.viewportInValue = VisualLayout.restrictToMinMax({\r\n                width: this.viewport.width - (this.margin.left + this.margin.right),\r\n                height: this.viewport.height - (this.margin.top + this.margin.bottom)\r\n            });\r\n        }\r\n\r\n        private static restrictToMinMax<T>(value: T): T {\r\n            let result = $.extend({}, value);\r\n            d3.keys(value).forEach(x => result[x] = Math.max(0, value[x]));\r\n            return result;\r\n        }\r\n    }\r\n\r\n    export class WordCloud implements IVisual {\r\n        private static ClassName: string = \"wordCloud\";\r\n\r\n        private static Properties: any = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"formatString\"\r\n                },\r\n                maxNumberOfWords: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"maxNumberOfWords\"\r\n                },\r\n                minFontSize: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"minFontSize\"\r\n                },\r\n                maxFontSize: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"maxFontSize\"\r\n                },\r\n                isBrokenText: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"isBrokenText\"\r\n                },\r\n            },\r\n            dataPoint: {\r\n                fill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"dataPoint\",\r\n                    propertyName: \"fill\"\r\n                }\r\n            },\r\n            stopWords: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"stopWords\",\r\n                    propertyName: \"show\"\r\n                },\r\n                isDefaultStopWords: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"stopWords\",\r\n                    propertyName: \"isDefaultStopWords\"\r\n                },\r\n                words: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"stopWords\",\r\n                    propertyName: \"words\"\r\n                },\r\n            },\r\n            rotateText: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"rotateText\",\r\n                    propertyName: \"show\"\r\n                },\r\n                minAngle: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"rotateText\",\r\n                    propertyName: \"minAngle\"\r\n                },\r\n                maxAngle: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"rotateText\",\r\n                    propertyName: \"maxAngle\"\r\n                },\r\n                maxNumberOfOrientations: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"rotateText\",\r\n                    propertyName: \"maxNumberOfOrientations\"\r\n                }\r\n            }\r\n        };\r\n\r\n        private static Words: ClassAndSelector = {\r\n            \"class\": \"words\",\r\n            selector: \".words\"\r\n        };\r\n\r\n        private static Word: ClassAndSelector = {\r\n            \"class\": \"word\",\r\n            selector: \".word\"\r\n        };\r\n\r\n        private static Size: string = \"px\";\r\n        private static StopWordsDelemiter: string = \" \";\r\n\r\n        private static Radians: number = Math.PI / 180;\r\n\r\n        private static MinAngle: number = -180;\r\n        private static MaxAngle: number = 180;\r\n\r\n        private static MaxNumberOfWords: number = 2500;\r\n\r\n        private static MinOpacity: number = 0.2;\r\n        private static MaxOpacity: number = 1;\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [{\r\n                name: \"Category\",\r\n                kind: VisualDataRoleKind.Grouping,\r\n                displayName: \"Category\"\r\n            }, {\r\n                    name: \"Values\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: \"Values\"\r\n                }],\r\n            dataViewMappings: [{\r\n                conditions: [{\r\n                    \"Category\": {\r\n                        min: 1,\r\n                        max: 1\r\n                    },\r\n                    \"Values\": {\r\n                        min: 0,\r\n                        max: 1\r\n                    }\r\n                }],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: \"Category\" },\r\n                        dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }\r\n                    },\r\n                    values: {\r\n                        for: { in: \"Values\" }\r\n                    }\r\n                }\r\n            }],\r\n            sorting: {\r\n                implicit: {\r\n                    clauses: [{\r\n                        role: \"Values\",\r\n                        direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit\r\n                    }]\r\n                }\r\n            },\r\n            objects: {\r\n                general: {\r\n                    displayName: \"General\",\r\n                    properties: {\r\n                        formatString: {\r\n                            type: {\r\n                                formatting: {\r\n                                    formatString: true\r\n                                }\r\n                            }\r\n                        },\r\n                        maxNumberOfWords: {\r\n                            displayName: \"Max number of words\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        minFontSize: {\r\n                            displayName: \"Min Font\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        maxFontSize: {\r\n                            displayName: \"Max Font\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        isBrokenText: {\r\n                            displayName: \"Word-breaking\",\r\n                            type: { bool: true }\r\n                        },\r\n                        isRemoveStopWords: {\r\n                            displayName: \"Stop Words\",\r\n                            type: { bool: true }\r\n                        }\r\n                    }\r\n                },\r\n                dataPoint: {\r\n                    displayName: \"Data colors\",\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: \"Fill\",\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                stopWords: {\r\n                    displayName: \"Stop Words\",\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        isDefaultStopWords: {\r\n                            displayName: \"Default Stop Words\",\r\n                            type: { bool: true }\r\n                        },\r\n                        words: {\r\n                            displayName: \"Words\",\r\n                            type: { text: true }\r\n                        }\r\n                    }\r\n                },\r\n                rotateText: {\r\n                    displayName: \"Rotate Text\",\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        minAngle: {\r\n                            displayName: \"Min Angle\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        maxAngle: {\r\n                            displayName: \"Max Angle\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        maxNumberOfOrientations: {\r\n                            displayName: \"Max number of orientations\",\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private static Punctuation: string[] = [\r\n            \"!\", \".\", \":\", \"'\", \";\", \",\", \"!\",\r\n            \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\",\r\n            \"(\", \")\", \"[\", \"]\", \"\\\"\", \"\\\\\", \"/\",\r\n            \"-\", \"_\", \"+\", \"=\"\r\n        ];\r\n\r\n        private static StopWords: string[] = [\r\n            \"a\", \"able\", \"about\", \"across\", \"after\", \"all\", \"almost\", \"also\", \"am\", \"among\", \"an\",\r\n            \"and\", \"any\", \"are\", \"as\", \"at\", \"be\", \"because\", \"been\", \"but\", \"by\", \"can\", \"cannot\",\r\n            \"could\", \"did\", \"do\", \"does\", \"either\", \"else\", \"ever\", \"every\", \"for\", \"from\", \"get\",\r\n            \"got\", \"had\", \"has\", \"have\", \"he\", \"her\", \"hers\", \"him\", \"his\", \"how\", \"however\", \"i\",\r\n            \"if\", \"in\", \"into\", \"is\", \"it\", \"its\", \"just\", \"least\", \"let\", \"like\", \"likely\", \"may\",\r\n            \"me\", \"might\", \"most\", \"must\", \"my\", \"neither\", \"no\", \"nor\", \"not\", \"of\", \"off\", \"often\",\r\n            \"on\", \"only\", \"or\", \"other\", \"our\", \"own\", \"rather\", \"said\", \"say\", \"says\", \"she\", \"should\",\r\n            \"since\", \"so\", \"some\", \"than\", \"that\", \"the\", \"their\", \"them\", \"then\", \"there\", \"these\",\r\n            \"they\", \"this\", \"tis\", \"to\", \"too\", \"twas\", \"us\", \"wants\", \"was\", \"we\", \"were\", \"what\",\r\n            \"when\", \"where\", \"which\", \"while\", \"who\", \"whom\", \"why\", \"will\", \"with\", \"would\", \"yet\",\r\n            \"you\", \"your\"\r\n        ];\r\n\r\n        private static DefaultSettings: WordCloudSettings = {\r\n            minFontSize: 20,\r\n            maxFontSize: 100,\r\n            minAngle: -60,\r\n            maxAngle: 90,\r\n            maxNumberOfOrientations: 2,\r\n            isRotateText: false,\r\n            isBrokenText: true,\r\n            isRemoveStopWords: false,\r\n            stopWordsArray: [],\r\n            stopWords: undefined,\r\n            isDefaultStopWords: false,\r\n            maxNumberOfWords: 200\r\n        };\r\n\r\n        private static RenderDelay: number = 50;\r\n\r\n        private static DefaultMargin: IMargin = {\r\n            top: 10,\r\n            right: 10,\r\n            bottom: 10,\r\n            left: 10\r\n        };\r\n\r\n        private settings: WordCloudSettings;\r\n        private wordCloudTexts: WordCloudText[];\r\n        private wordCloudDataView: WordCloudDataView;\r\n        private data: WordCloudData;\r\n        private dataBeforeRender: WordCloudDataPoint[];\r\n\r\n        private durationAnimations: number = 500;\r\n\r\n        private specialViewport: IViewport;\r\n\r\n        private fakeViewport: IViewport = {\r\n            width: 1500,\r\n            height: 1000\r\n        };\r\n\r\n        private canvasViewport: IViewport = {\r\n            width: 128,\r\n            height: 2048\r\n        };\r\n\r\n        public static colors: IDataColorPalette;\r\n        private root: D3.Selection;\r\n        private svg: D3.Selection;\r\n        private main: D3.Selection;\r\n        private wordsContainerSelection: D3.Selection;\r\n        private wordsSelection: D3.UpdateSelection;\r\n\r\n        private canvas: HTMLCanvasElement;\r\n\r\n        private fontFamily: string;\r\n\r\n        private animator: IGenericAnimator;\r\n\r\n        private layout: VisualLayout;\r\n\r\n        private hostService: IVisualHostServices;\r\n        private selectionManager: utility.SelectionManager;\r\n\r\n        private visualUpdateOptions: VisualUpdateOptions;\r\n\r\n        constructor(options?: WordCloudConstructorOptions) {\r\n            if (options) {\r\n                this.svg = options.svg || this.svg;\r\n                this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);\r\n\r\n                if (options.animator)\r\n                    this.animator = options.animator;\r\n            }\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            if (this.svg)\r\n                this.root = this.svg;\r\n            else\r\n                this.root = d3.select(options.element.get(0)).append(\"svg\");\r\n\r\n            WordCloud.colors = options.style.colorPalette.dataColors;\r\n            this.hostService = options.host;\r\n            this.selectionManager = new utility.SelectionManager({ hostServices: this.hostService });\r\n\r\n            if (!this.layout)\r\n                this.layout = new VisualLayout(null, WordCloud.DefaultMargin);\r\n\r\n            this.root.classed(WordCloud.ClassName, true);\r\n\r\n            this.root.on(\"click\", () => {\r\n                this.selectionManager.clear();\r\n                this.setSelection(this.wordsSelection);\r\n            });\r\n\r\n            this.fontFamily = this.root.style(\"font-family\");\r\n\r\n            this.main = this.root.append(\"g\");\r\n\r\n            this.wordsContainerSelection = this.main\r\n                .append(\"g\")\r\n                .classed(WordCloud.Words[\"class\"], true);\r\n\r\n            this.canvas = document.createElement(\"canvas\");\r\n        }\r\n\r\n        public converter(dataView: DataView): WordCloudData {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[0].values ||\r\n                !dataView.categorical.categories[0].values.length ||\r\n                !(dataView.categorical.categories[0].values.length > 0))\r\n                return null;\r\n\r\n            let categories: string[] = dataView.categorical.categories[0].values,\r\n                settings: WordCloudSettings = WordCloud.parseSettings(dataView, categories[0]),\r\n                frequencies: number[],\r\n                texts: WordCloudText[];\r\n            if (!settings)\r\n                return null;\r\n\r\n            if (!_.isEmpty(dataView.categorical.values) &&\r\n                !_.isEmpty(dataView.categorical.values[0]) &&\r\n                !_.isEmpty(dataView.categorical.values[0].values))\r\n                frequencies = dataView.categorical.values[0].values;\r\n\r\n            texts = categories.map((item: string, index: number) => {\r\n                let color, categoryObject = dataView.categorical.categories[0];\r\n                if (categoryObject.objects && categoryObject.objects[index])\r\n                    color = this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]);\r\n                else {\r\n                    if (this.wordCloudTexts && this.wordCloudTexts[index])\r\n                        color = this.wordCloudTexts[index].color;\r\n                    else\r\n                        color = explore.util.getRandomColor();\r\n                }\r\n\r\n                return <WordCloudText>{\r\n                    text: item,\r\n                    count: (frequencies && frequencies[index] && !isNaN(frequencies[index])) ? frequencies[index] : 1,\r\n                    index: index,\r\n                    selectionId: SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),\r\n                    color: color,\r\n                };\r\n            });\r\n\r\n            return <WordCloudData>{\r\n                settings: settings,\r\n                texts: texts\r\n            };\r\n        }\r\n\r\n        private getColor(properties: any, defaultColor: string, objects: DataViewObjects): string {\r\n            let colorHelper: ColorHelper;\r\n\r\n            colorHelper = new ColorHelper(WordCloud.colors, properties, defaultColor);\r\n\r\n            return explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, \"\"));\r\n        }\r\n\r\n        private static parseSettings(dataView: DataView, value: any): WordCloudSettings {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.columns[0])\r\n                return null;\r\n\r\n            let objects: DataViewObjects = dataView.metadata.objects,\r\n                valueFormatter: IValueFormatter,\r\n                minFontSize: number,\r\n                maxFontSize: number,\r\n                minAngle: number,\r\n                maxAngle: number,\r\n                maxNumberOfOrientations: number,\r\n                isRotateText: boolean = false,\r\n                isBrokenText: boolean = true,\r\n                isRemoveStopWords: boolean = true,\r\n                stopWords: string,\r\n                stopWordsArray: string[],\r\n                isDefaultStopWords: boolean = false,\r\n                maxNumberOfWords: number;\r\n\r\n            maxNumberOfWords = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.general.maxNumberOfWords,\r\n                WordCloud.DefaultSettings.maxNumberOfWords);\r\n\r\n            minFontSize = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.general.minFontSize,\r\n                WordCloud.DefaultSettings.minFontSize);\r\n\r\n            maxFontSize = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.general.maxFontSize,\r\n                WordCloud.DefaultSettings.maxFontSize);\r\n\r\n            minAngle = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.rotateText.minAngle,\r\n                WordCloud.DefaultSettings.minAngle);\r\n\r\n            maxAngle = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.rotateText.maxAngle,\r\n                WordCloud.DefaultSettings.maxAngle);\r\n\r\n            isRotateText = DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                WordCloud.Properties.rotateText.show,\r\n                WordCloud.DefaultSettings.isRotateText);\r\n\r\n            maxNumberOfOrientations = WordCloud.getNumberFromObjects(\r\n                objects,\r\n                WordCloud.Properties.rotateText.maxNumberOfOrientations,\r\n                WordCloud.DefaultSettings.maxNumberOfOrientations);\r\n\r\n            valueFormatter = ValueFormatter.create({\r\n                format: ValueFormatter.getFormatString(\r\n                    dataView.categorical.categories[0].source,\r\n                    WordCloud.Properties.general.formatString),\r\n                value: value\r\n            });\r\n\r\n            isBrokenText = DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                WordCloud.Properties.general.isBrokenText,\r\n                WordCloud.DefaultSettings.isBrokenText);\r\n\r\n            isRemoveStopWords = DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                WordCloud.Properties.stopWords.show,\r\n                WordCloud.DefaultSettings.isRemoveStopWords);\r\n\r\n            stopWords = DataViewObjects.getValue(\r\n                objects,\r\n                WordCloud.Properties.stopWords.words,\r\n                WordCloud.DefaultSettings.stopWords);\r\n\r\n            if (typeof stopWords === \"string\")\r\n                stopWordsArray = stopWords.split(WordCloud.StopWordsDelemiter);\r\n            else\r\n                stopWordsArray = WordCloud.DefaultSettings.stopWordsArray;\r\n\r\n            isDefaultStopWords = DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                WordCloud.Properties.stopWords.isDefaultStopWords,\r\n                WordCloud.DefaultSettings.isDefaultStopWords);\r\n\r\n            return {\r\n                minFontSize: minFontSize,\r\n                maxFontSize: maxFontSize,\r\n                minAngle: minAngle,\r\n                maxAngle: maxAngle,\r\n                maxNumberOfOrientations: maxNumberOfOrientations,\r\n                valueFormatter: valueFormatter,\r\n                isRotateText: isRotateText,\r\n                isBrokenText: isBrokenText,\r\n                isRemoveStopWords: isRemoveStopWords,\r\n                stopWords: stopWords,\r\n                stopWordsArray: stopWordsArray,\r\n                isDefaultStopWords: isDefaultStopWords,\r\n                maxNumberOfWords: maxNumberOfWords\r\n            };\r\n        }\r\n\r\n        private static getNumberFromObjects(objects: DataViewObjects, properties: any, defaultValue: number): number {\r\n            return objects ? DataViewObjects.getValue<number>(objects, properties, defaultValue) : defaultValue;\r\n        }\r\n\r\n        private parseNumber(\r\n            value: number | string,\r\n            defaultValue: number = 0,\r\n            minValue: number = -Number.MAX_VALUE,\r\n            maxValue: number = Number.MAX_VALUE): number {\r\n            let parsedValue: number = Number(value);\r\n\r\n            if (isNaN(parsedValue) || (typeof value === \"string\" && value.length === 0))\r\n                return defaultValue;\r\n\r\n            if (parsedValue < minValue)\r\n                return minValue;\r\n\r\n            if (parsedValue > maxValue)\r\n                return maxValue;\r\n\r\n            return parsedValue;\r\n        }\r\n\r\n        private computePositions(words: WordCloudDataPoint[], onPositionsComputed: (WordCloudDataView) => void): void {\r\n            let context: CanvasRenderingContext2D = this.getCanvasContext(),\r\n                surface: number[] = [],\r\n                borders: IPoint[] = null,\r\n                maxNumberOfWords: number;\r\n\r\n            if (!words || !(words.length > 0))\r\n                return null;\r\n\r\n            maxNumberOfWords = Math.abs(this.parseNumber(\r\n                this.settings.maxNumberOfWords,\r\n                WordCloud.DefaultSettings.maxNumberOfWords,\r\n                words.length * -1,\r\n                words.length));\r\n\r\n            if (words.length > maxNumberOfWords)\r\n                words = words.slice(0, maxNumberOfWords);\r\n\r\n            for (let i: number; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) {\r\n                surface[i] = 0;\r\n            }\r\n\r\n            setTimeout(() => this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0), 0);\r\n        }\r\n\r\n        private computeCycle(\r\n            words: WordCloudDataPoint[],\r\n            context: CanvasRenderingContext2D,\r\n            surface: number[],\r\n            borders: IPoint[],\r\n            onPositionsComputed: (WordCloudDataView) => void,\r\n            wordsForDraw: WordCloudDataPoint[] = [],\r\n            index: number = 0): void {\r\n            let word: WordCloudDataPoint = words[index],\r\n                ratio: number = 1;\r\n\r\n            if (words.length <= 10)\r\n                ratio = 5;\r\n            else if (words.length <= 25)\r\n                ratio = 3;\r\n            else if (words.length <= 75)\r\n                ratio = 1.5;\r\n            else if (words.length <= 100)\r\n                ratio = 1.25;\r\n\r\n            word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;\r\n            word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;\r\n\r\n            this.generateSprites(context, word, words, index);\r\n\r\n            if (word.sprite && this.findPosition(surface, word, borders)) {\r\n                wordsForDraw.push(word);\r\n\r\n                borders = this.updateBorders(word, borders);\r\n                word.x -= this.specialViewport.width >> 1;\r\n                word.y -= this.specialViewport.height >> 1;\r\n            }\r\n\r\n            if (++index < words.length && this.root)\r\n                this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);\r\n            else {\r\n                onPositionsComputed({\r\n                    data: wordsForDraw,\r\n                    leftBorder: borders && borders[0],\r\n                    rightBorder: borders && borders[1]\r\n                });\r\n            }\r\n        }\r\n\r\n        private updateBorders(word: WordCloudDataPoint, borders: IPoint[]): IPoint[] {\r\n            if (borders && borders.length === 2) {\r\n                let leftBorder: IPoint = borders[0],\r\n                    rightBorder: IPoint = borders[1];\r\n\r\n                if (word.x + word.x0 < leftBorder.x)\r\n                    leftBorder.x = word.x + word.x0;\r\n\r\n                if (word.y + word.y0 < leftBorder.y)\r\n                    leftBorder.y = word.y + word.y0;\r\n\r\n                if (word.x + word.x1 > rightBorder.x)\r\n                    rightBorder.x = word.x + word.x1;\r\n\r\n                if (word.y + word.y1 > rightBorder.y)\r\n                    rightBorder.y = word.y + word.y1;\r\n            } else {\r\n                borders = [\r\n                    {\r\n                        x: word.x + word.x0,\r\n                        y: word.y + word.y0\r\n                    }, {\r\n                        x: word.x + word.x1,\r\n                        y: word.y + word.y1\r\n                    }\r\n                ];\r\n            }\r\n\r\n            return borders;\r\n        }\r\n\r\n        private generateSprites(\r\n            context: CanvasRenderingContext2D,\r\n            currentWord: WordCloudDataPoint,\r\n            words: WordCloudDataPoint[],\r\n            index: number): void {\r\n            if (currentWord.sprite)\r\n                return;\r\n\r\n            context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);\r\n\r\n            let x: number = 0,\r\n                y: number = 0,\r\n                maxHeight: number = 0,\r\n                quantityOfWords: number = words.length,\r\n                pixels: Uint8ClampedArray,\r\n                sprite: number[] = [];\r\n\r\n            for (let i: number = index; i < quantityOfWords; i++) {\r\n                let currentWordData: WordCloudDataPoint = words[i],\r\n                    widthOfWord: number = 0,\r\n                    heightOfWord: number = 0;\r\n\r\n                context.save();\r\n                context.font = \"normal normal \" + (currentWordData.size + 1) + WordCloud.Size + \" \" + this.fontFamily;\r\n\r\n                widthOfWord = context.measureText(currentWordData.text + \"m\").width;\r\n                heightOfWord = currentWordData.size << 1;\r\n\r\n                if (currentWordData.rotate) {\r\n                    let sr: number = Math.sin(currentWordData.rotate * WordCloud.Radians),\r\n                        cr: number = Math.cos(currentWordData.rotate * WordCloud.Radians),\r\n                        widthCr: number = widthOfWord * cr,\r\n                        widthSr: number = widthOfWord * sr,\r\n                        heightCr: number = heightOfWord * cr,\r\n                        heightSr: number = heightOfWord * sr;\r\n\r\n                    widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;\r\n                    heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));\r\n                } else\r\n                    widthOfWord = (widthOfWord + 31) >> 5 << 5;\r\n\r\n                if (heightOfWord > maxHeight)\r\n                    maxHeight = heightOfWord;\r\n\r\n                if (x + widthOfWord >= (this.canvasViewport.width << 5)) {\r\n                    x = 0;\r\n                    y += maxHeight;\r\n                    maxHeight = 0;\r\n                }\r\n\r\n                context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));\r\n\r\n                if (currentWordData.rotate)\r\n                    context.rotate(currentWordData.rotate * WordCloud.Radians);\r\n\r\n                context.fillText(currentWordData.text, 0, 0);\r\n\r\n                if (currentWordData.padding) {\r\n                    context.lineWidth = 2 * currentWordData.padding;\r\n                    context.strokeText(currentWordData.text, 0, 0);\r\n                }\r\n\r\n                context.restore();\r\n\r\n                currentWordData.width = widthOfWord;\r\n                currentWordData.height = heightOfWord;\r\n                currentWordData.xOff = x;\r\n                currentWordData.yOff = y;\r\n                currentWordData.x1 = widthOfWord >> 1;\r\n                currentWordData.y1 = heightOfWord >> 1;\r\n                currentWordData.x0 = -currentWordData.x1;\r\n                currentWordData.y0 = -currentWordData.y1;\r\n\r\n                x += widthOfWord;\r\n            }\r\n\r\n            pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;\r\n\r\n            sprite = [];\r\n\r\n            for (let i = quantityOfWords - 1; i >= 0; i--) {\r\n                let currentWordData: WordCloudDataPoint = words[i],\r\n                    width: number = currentWordData.width,\r\n                    width32: number = width >> 5,\r\n                    height: number = currentWordData.y1 - currentWordData.y0,\r\n                    x: number = 0,\r\n                    y: number = 0,\r\n                    seen: number = 0,\r\n                    seenRow: number = 0;\r\n\r\n                if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||\r\n                    currentWordData.yOff + height >= this.canvasViewport.height) {\r\n                    currentWordData.sprite = null;\r\n\r\n                    continue;\r\n                }\r\n\r\n                for (let j = 0; j < height * width32; j++) {\r\n                    sprite[j] = 0;\r\n                }\r\n\r\n                if (currentWordData.xOff !== null)\r\n                    x = currentWordData.xOff;\r\n                else\r\n                    return;\r\n\r\n                y = currentWordData.yOff;\r\n\r\n                seen = 0;\r\n                seenRow = -1;\r\n\r\n                for (let j = 0; j < height; j++) {\r\n                    for (let k = 0; k < width; k++) {\r\n                        let l: number = width32 * j + (k >> 5),\r\n                            index: number = ((y + j) * (this.canvasViewport.width << 5) + (x + k)) << 2,\r\n                            m: number = pixels[index]\r\n                                ? 1 << (31 - (k % 32))\r\n                                : 0;\r\n\r\n                        sprite[l] |= m;\r\n                        seen |= m;\r\n                    }\r\n\r\n                    if (seen)\r\n                        seenRow = j;\r\n                    else {\r\n                        currentWordData.y0++;\r\n                        height--;\r\n                        j--;\r\n                        y++;\r\n                    }\r\n                }\r\n\r\n                currentWordData.y1 = currentWordData.y0 + seenRow;\r\n                currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);\r\n            }\r\n        }\r\n\r\n        private findPosition(surface: number[], word: WordCloudDataPoint, borders: IPoint[]): boolean {\r\n            let startPoint: IPoint = { x: word.x, y: word.y },\r\n                delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height),\r\n                point: IPoint,\r\n                dt: number = Math.random() < 0.5 ? 1 : -1,\r\n                shift: number = -dt,\r\n                dx: number,\r\n                dy: number;\r\n\r\n            while (true) {\r\n                shift += dt;\r\n\r\n                point = this.archimedeanSpiral(shift);\r\n\r\n                dx = Math.floor(point.x);\r\n                dy = Math.floor(point.y);\r\n\r\n                if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta)\r\n                    break;\r\n\r\n                word.x = startPoint.x + dx;\r\n                word.y = startPoint.y + dy;\r\n\r\n                if (word.x + word.x0 < 0 ||\r\n                    word.y + word.y0 < 0 ||\r\n                    word.x + word.x1 > this.specialViewport.width ||\r\n                    word.y + word.y1 > this.specialViewport.height)\r\n                    continue;\r\n\r\n                if (!borders || !this.checkIntersect(word, surface)) {\r\n                    if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {\r\n                        let sprite: number[] = word.sprite,\r\n                            width: number = word.width >> 5,\r\n                            shiftWidth: number = this.specialViewport.width >> 5,\r\n                            lx: number = word.x - (width << 4),\r\n                            sx: number = lx & 127,\r\n                            msx: number = 32 - sx,\r\n                            height: number = word.y1 - word.y0,\r\n                            x: number = (word.y + word.y0) * shiftWidth + (lx >> 5);\r\n\r\n                        for (let i: number = 0; i < height; i++) {\r\n                            let lastSprite: number = 0;\r\n\r\n                            for (let j: number = 0; j <= width; j++) {\r\n                                let leftMask: number = lastSprite << msx,\r\n                                    rightMask: number;\r\n\r\n                                if (j < width)\r\n                                    lastSprite = sprite[i * width + j];\r\n\r\n                                rightMask = j < width\r\n                                    ? lastSprite >>> sx\r\n                                    : 0;\r\n\r\n                                surface[x + j] |= leftMask | rightMask;\r\n                            }\r\n\r\n                            x += shiftWidth;\r\n                        }\r\n\r\n                        word.sprite = null;\r\n\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private archimedeanSpiral(value: number): IPoint {\r\n            let ratio: number = this.specialViewport.width / this.specialViewport.height;\r\n\r\n            value = value * 0.1;\r\n\r\n            return {\r\n                x: ratio * value * Math.cos(value),\r\n                y: value * Math.sin(value)\r\n            };\r\n        }\r\n\r\n        private checkIntersect(word: WordCloudDataPoint, surface: number[]): boolean {\r\n            let shiftWidth: number = this.specialViewport.width >> 5,\r\n                sprite: number[] = word.sprite,\r\n                widthOfWord = word.width >> 5,\r\n                lx: number = word.x - (widthOfWord << 4),\r\n                sx: number = lx & 127,\r\n                msx: number = 32 - sx,\r\n                heightOfWord = word.y1 - word.y0,\r\n                x: number = (word.y + word.y0) * shiftWidth + (lx >> 5);\r\n\r\n            for (let i = 0; i < heightOfWord; i++) {\r\n                let lastSprite: number = 0;\r\n\r\n                for (let j = 0; j <= widthOfWord; j++) {\r\n                    let mask: number = 0,\r\n                        leftMask: number,\r\n                        intersectMask: number = 0;\r\n\r\n                    leftMask = lastSprite << msx;\r\n\r\n                    if (j < widthOfWord)\r\n                        lastSprite = sprite[i * widthOfWord + j];\r\n\r\n                    mask = j < widthOfWord\r\n                        ? lastSprite >>> sx\r\n                        : 0;\r\n\r\n                    intersectMask = (leftMask | mask) & surface[x + j];\r\n\r\n                    if (intersectMask)\r\n                        return true;\r\n                }\r\n\r\n                x += shiftWidth;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private checkIntersectOfRectangles(word: WordCloudDataPoint, leftBorder: IPoint, rightBorder: IPoint): boolean {\r\n            return (word.x + word.x1) > leftBorder.x &&\r\n                (word.x + word.x0) < rightBorder.x &&\r\n                (word.y + word.y1) > leftBorder.y &&\r\n                (word.y + word.y0) < rightBorder.y;\r\n        }\r\n\r\n        private getCanvasContext(): CanvasRenderingContext2D {\r\n            if (!this.canvasViewport)\r\n                return null;\r\n\r\n            this.canvas.width = 1;\r\n            this.canvas.height = 1;\r\n\r\n            let context: CanvasRenderingContext2D = this.canvas.getContext(\"2d\");\r\n\r\n            this.canvas.width = this.canvasViewport.width << 5;\r\n            this.canvas.height = this.canvasViewport.height;\r\n\r\n            context = this.canvas.getContext(\"2d\");\r\n            context.fillStyle = context.strokeStyle = \"red\";\r\n            context.textAlign = \"center\";\r\n\r\n            return context;\r\n        }\r\n\r\n        private getReducedText(texts: WordCloudText[]): WordCloudText[] {\r\n            let brokenStrings: WordCloudText[] = [];\r\n            brokenStrings = this.getBrokenWords(texts);\r\n\r\n            return brokenStrings.reduce((previousValue: WordCloudText[], currentValue: WordCloudText) => {\r\n                if (!previousValue.some((value: WordCloudText) => {\r\n                    if (value.index !== currentValue.index && value.text === currentValue.text) {\r\n                        value.count += currentValue.count;\r\n\r\n                        return true;\r\n                    }\r\n\r\n                    return false;\r\n                })) {\r\n                    previousValue.push(currentValue);\r\n                }\r\n\r\n                return previousValue;\r\n            }, []);\r\n        }\r\n\r\n        private getBrokenWords(words: WordCloudText[]): WordCloudText[] {\r\n            let brokenStrings: WordCloudText[] = [],\r\n                whiteSpaceRegExp: RegExp = /\\s/,\r\n                punctuatuinRegExp: RegExp;\r\n\r\n            if (!this.settings.isBrokenText)\r\n                return words;\r\n\r\n            punctuatuinRegExp = new RegExp(`[${WordCloud.Punctuation.join(\"\\\\\")}]`, \"gim\");\r\n\r\n            words.forEach((item: WordCloudText) => {\r\n                if (typeof item.text === \"string\") {\r\n                    let words: string[];\r\n\r\n                    words = item.text.replace(punctuatuinRegExp, \" \").split(whiteSpaceRegExp);\r\n\r\n                    if (this.settings.isRemoveStopWords) {\r\n                        let stopWords: string[] = this.settings.stopWordsArray;\r\n\r\n                        if (this.settings.isDefaultStopWords)\r\n                            stopWords = stopWords.concat(WordCloud.StopWords);\r\n\r\n                        words = words.filter((value: string) => {\r\n                            return value.length > 0 && !stopWords.some((removeWord: string) => {\r\n                                return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();\r\n                            });\r\n                        });\r\n                    }\r\n\r\n                    words.forEach((element: string) => {\r\n                        if (element.length > 0 && !whiteSpaceRegExp.test(element)) {\r\n                            brokenStrings.push({\r\n                                text: element,\r\n                                count: item.count,\r\n                                index: item.index,\r\n                                selectionId: item.selectionId,\r\n                                color: item.color\r\n                            });\r\n                        }\r\n                    });\r\n                } else\r\n                    brokenStrings.push(item);\r\n            });\r\n\r\n            return brokenStrings;\r\n        }\r\n\r\n        private getWords(values: WordCloudText[]): WordCloudDataPoint[] {\r\n            let sortedValues: WordCloudText[],\r\n                minValue: number = 0,\r\n                maxValue: number = 0,\r\n                valueFormatter: IValueFormatter = this.settings.valueFormatter;\r\n\r\n            if (!values || !(values.length >= 1))\r\n                return [];\r\n\r\n            sortedValues = values.sort((a: WordCloudText, b: WordCloudText) => {\r\n                return b.count - a.count;\r\n            });\r\n\r\n            minValue = sortedValues[sortedValues.length - 1].count;\r\n            maxValue = sortedValues[0].count;\r\n            let returnValues = values.map((value: WordCloudText) => {\r\n                return <WordCloudDataPoint>{\r\n                    text: valueFormatter.format(value.text),\r\n                    size: this.getFontSize(value.count, minValue, maxValue),\r\n                    x: 0,\r\n                    y: 0,\r\n                    rotate: this.getAngle(),\r\n                    padding: 1,\r\n                    width: 0,\r\n                    height: 0,\r\n                    xOff: 0,\r\n                    yOff: 0,\r\n                    x0: 0,\r\n                    y0: 0,\r\n                    x1: 0,\r\n                    y1: 0,\r\n                    color: value.color,\r\n                    selectionId: value.selectionId,\r\n                    wordIndex: value.index\r\n                };\r\n            });\r\n            this.dataBeforeRender = returnValues;\r\n            return returnValues;\r\n        }\r\n\r\n        private getFontSize(\r\n            value: number,\r\n            minValue: number,\r\n            maxValue: number,\r\n            scaleType: WordCloudScaleType = WordCloudScaleType.value) {\r\n            let weight: number,\r\n                fontSize: number,\r\n                maxFontSize: number,\r\n                minFontSize: number;\r\n\r\n            minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize));\r\n            maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize));\r\n\r\n            if (minFontSize > maxFontSize) {\r\n                let buffer: number = minFontSize;\r\n\r\n                minFontSize = maxFontSize;\r\n                maxFontSize = buffer;\r\n            }\r\n\r\n            switch (scaleType) {\r\n                case WordCloudScaleType.logn: {\r\n                    weight = Math.log(value);\r\n                }\r\n                case WordCloudScaleType.sqrt: {\r\n                    weight = Math.sqrt(value);\r\n                }\r\n                case WordCloudScaleType.value: {\r\n                    weight = value;\r\n                }\r\n            }\r\n\r\n            fontSize = weight > minValue\r\n                ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)\r\n                : 0;\r\n\r\n            fontSize = (fontSize * 100) / maxFontSize;\r\n\r\n            fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;\r\n\r\n            return fontSize;\r\n        }\r\n\r\n        private getAngle(): number {\r\n            if (!this.settings ||\r\n                !this.settings.isRotateText)\r\n                return 0;\r\n\r\n            let minAngle: number,\r\n                maxAngle: number,\r\n                maxNumberOfOrientations: number,\r\n                angle: number;\r\n\r\n            maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0));\r\n\r\n            minAngle = this.parseNumber(\r\n                this.settings.minAngle,\r\n                0,\r\n                WordCloud.MinAngle,\r\n                WordCloud.MaxAngle);\r\n\r\n            maxAngle = this.parseNumber(\r\n                this.settings.maxAngle,\r\n                0,\r\n                WordCloud.MinAngle,\r\n                WordCloud.MaxAngle);\r\n\r\n            if (minAngle > maxAngle) {\r\n                let buffer: number = minAngle;\r\n\r\n                minAngle = maxAngle;\r\n                maxAngle = buffer;\r\n            }\r\n\r\n            angle = Math.abs(((maxAngle - minAngle) / maxNumberOfOrientations) * Math.floor(Math.random() * maxNumberOfOrientations));\r\n\r\n            return maxNumberOfOrientations !== 0 ? minAngle + angle : 0;\r\n        }\r\n\r\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\r\n            if (!visualUpdateOptions ||\r\n                !visualUpdateOptions.viewport ||\r\n                !visualUpdateOptions.dataViews ||\r\n                !visualUpdateOptions.dataViews[0] ||\r\n                !visualUpdateOptions.viewport ||\r\n                !(visualUpdateOptions.viewport.height >= 0) ||\r\n                !(visualUpdateOptions.viewport.width >= 0))\r\n                return;\r\n\r\n            this.visualUpdateOptions = visualUpdateOptions;\r\n\r\n            this.layout.viewport = this.visualUpdateOptions.viewport;\r\n            let dataView: DataView = visualUpdateOptions.dataViews[0];\r\n\r\n            if (this.layout.viewportInIsZero)\r\n                return;\r\n\r\n            this.durationAnimations = getAnimationDuration(\r\n                this.animator,\r\n                visualUpdateOptions.suppressAnimations);\r\n            this.UpdateSize();\r\n\r\n            this.data = this.converter(dataView);\r\n            if (!this.data)\r\n                return;\r\n\r\n            this.settings = this.data.settings;\r\n            this.wordCloudTexts = this.data.texts;\r\n\r\n            this.computePositions(\r\n                this.getWords(this.getReducedText(this.data.texts)),\r\n                (wordCloudDataView: WordCloudDataView) => this.render(wordCloudDataView));\r\n\r\n            if (visualUpdateOptions !== this.visualUpdateOptions)\r\n                this.update(this.visualUpdateOptions);\r\n        }\r\n\r\n        private UpdateSize(): void {\r\n            let fakeWidth: number,\r\n                fakeHeight: number,\r\n                ratio: number;\r\n\r\n            ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)\r\n                / (this.layout.viewportIn.width * this.layout.viewportIn.height));\r\n\r\n            if (isNaN(ratio))\r\n                fakeHeight = fakeWidth = 1;\r\n            else {\r\n                fakeHeight = this.layout.viewportIn.height * ratio;\r\n                fakeWidth = this.layout.viewportIn.width * ratio;\r\n            }\r\n\r\n            this.specialViewport = {\r\n                height: fakeHeight,\r\n                width: fakeWidth\r\n            };\r\n\r\n            this.root.attr({\r\n                \"height\": this.layout.viewport.height,\r\n                \"width\": this.layout.viewport.width\r\n            });\r\n        }\r\n\r\n        private render(wordCloudDataView: WordCloudDataView): void {\r\n            if (!wordCloudDataView ||\r\n                !wordCloudDataView.data)\r\n                return;\r\n\r\n            this.wordCloudDataView = wordCloudDataView;\r\n\r\n            let animatedWordSelection: D3.Selection,\r\n                wordElements: D3.Selection = this.main\r\n                    .select(WordCloud.Words.selector)\r\n                    .selectAll(WordCloud.Word.selector);\r\n\r\n            this.wordsSelection = wordElements.data(wordCloudDataView.data);\r\n\r\n            (<D3.UpdateSelection>this.animation(this.wordsSelection, this.durationAnimations))\r\n                .attr(\"transform\", (item: WordCloudDataPoint) => `${SVGUtil.translate(item.x, item.y)}rotate(${item.rotate})`)\r\n                .style({\r\n                    \"font-size\": ((item: WordCloudDataPoint): string => `${item.size}${WordCloud.Size}`),\r\n                    \"fill\": ((item: WordCloudDataPoint): string => item.color),\r\n                });\r\n\r\n            animatedWordSelection = this.wordsSelection\r\n                .enter()\r\n                .append(\"svg:text\")\r\n                .attr(\"transform\", (item: WordCloudDataPoint) => `${SVGUtil.translate(item.x, item.y)}rotate(${item.rotate})`)\r\n                .style(\"font-size\", \"1px\");\r\n\r\n            this.wordsSelection.on(\"click\", (item: WordCloudDataPoint) => {\r\n                this.selectionManager\r\n                    .select(item.selectionId, d3.event.ctrlKey)\r\n                    .then(() => this.setSelection(this.wordsSelection));\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            (<D3.UpdateSelection>this.animation(animatedWordSelection, this.durationAnimations))\r\n                .style({\r\n                    \"font-size\": ((item: WordCloudDataPoint): string => `${item.size}${WordCloud.Size}`),\r\n                    \"fill\": ((item: WordCloudDataPoint): string => item.color),\r\n                });\r\n\r\n            this.wordsSelection\r\n                .text((item: WordCloudDataPoint) => item.text)\r\n                .classed(WordCloud.Word[\"class\"], true);\r\n\r\n            this.wordsSelection.exit().remove();\r\n            this.setSelection(this.wordsSelection);\r\n\r\n            setTimeout(() => {\r\n                if (this.root)\r\n                    this.scaleMainView(wordCloudDataView, wordElements[0].length && this.durationAnimations);\r\n\r\n            }, this.durationAnimations + WordCloud.RenderDelay);\r\n        }\r\n\r\n        private setSelection(selection: D3.Selection): void {\r\n            let selectionIds: SelectionId[] = this.selectionManager.getSelectionIds();\r\n\r\n            if (selectionIds.some(x => !selection.data().some((d: WordCloudDataPoint) => d.selectionId.getKey() === x.getKey()))) {\r\n                this.selectionManager.clear();\r\n                selectionIds = [];\r\n            }\r\n\r\n            if (!selectionIds.length) {\r\n                this.setOpacity(selection, WordCloud.MaxOpacity, true);\r\n                return;\r\n            }\r\n\r\n            let selectedColumns: D3.UpdateSelection = selection.filter((x: WordCloudDataPoint) =>\r\n                selectionIds.some((y: SelectionId) => y.getKey() === x.selectionId.getKey()));\r\n\r\n            this.setOpacity(selection, WordCloud.MinOpacity);\r\n            this.setOpacity(selectedColumns, WordCloud.MaxOpacity);\r\n        }\r\n\r\n        private setOpacity(element: D3.Selection, opacityValue: number, disableAnimation: boolean = false): void {\r\n            let elementAnimation = disableAnimation ? element : this.animation(element);\r\n            elementAnimation.style(\"fill-opacity\", opacityValue);\r\n        }\r\n\r\n        private scaleMainView(wordCloudDataView: WordCloudDataView, durationAnimation: number = 0): void {\r\n            if (!wordCloudDataView ||\r\n                !wordCloudDataView.leftBorder ||\r\n                !wordCloudDataView.rightBorder)\r\n                return;\r\n\r\n            let scale: number = 1,\r\n                mainSVGRect: SVGRect = this.main.node()[\"getBBox\"](),\r\n                leftBorder: IPoint = wordCloudDataView.leftBorder,\r\n                rightBorder: IPoint = wordCloudDataView.rightBorder,\r\n                width2: number,\r\n                height2: number,\r\n                scaleByX: number,\r\n                scaleByY: number;\r\n\r\n            scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x);\r\n            scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y);\r\n\r\n            scale = Math.min(scaleByX, scaleByY);\r\n\r\n            width2 = this.layout.margin.left + (mainSVGRect.x * scale * -1)\r\n                + (this.layout.viewportIn.width - (mainSVGRect.width * scale)) / 2;\r\n            height2 = this.layout.margin.top + (mainSVGRect.y * scale * -1)\r\n                + (this.layout.viewportIn.height - (mainSVGRect.height * scale)) / 2;\r\n\r\n            (<D3.Selection>this.animation(this.main, durationAnimation))\r\n                .attr(\"transform\", `${SVGUtil.translate(width2, height2)}scale(${scale})`);\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            let instances: VisualObjectInstance[] = [];\r\n\r\n            if (!this.settings)\r\n                return instances;\r\n\r\n            switch (options.objectName) {\r\n                case \"general\": {\r\n                    let general: VisualObjectInstance = {\r\n                        objectName: \"general\",\r\n                        displayName: \"general\",\r\n                        selector: null,\r\n                        properties: {\r\n                            maxNumberOfWords: this.settings.maxNumberOfWords,\r\n                            minFontSize: this.settings.minFontSize,\r\n                            maxFontSize: this.settings.maxFontSize,\r\n                            isBrokenText: this.settings.isBrokenText\r\n                        }\r\n                    };\r\n\r\n                    instances.push(general);\r\n                    break;\r\n                }\r\n                case \"dataPoint\": {\r\n                    if (!this.wordCloudDataView ||\r\n                        !this.wordCloudDataView.data)\r\n                        return;\r\n\r\n                    let dataPoints: WordCloudDataPoint[] = this.dataBeforeRender;\r\n                    let wordCategoriesIndex: number[] = [];\r\n                    dataPoints.forEach((item: WordCloudDataPoint) => {\r\n                        if (wordCategoriesIndex.indexOf(item.wordIndex) === -1) {\r\n                            wordCategoriesIndex.push(item.wordIndex);\r\n                            instances.push({\r\n                                objectName: \"dataPoint\",\r\n                                displayName: this.data.texts[item.wordIndex].text,\r\n                                selector: ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),\r\n                                properties: {\r\n                                    fill: { solid: { color: item.color } }\r\n                                }\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    break;\r\n                }\r\n                case \"rotateText\": {\r\n                    let rotateText: VisualObjectInstance = {\r\n                        objectName: \"rotateText\",\r\n                        displayName: \"Rotate Text\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.settings.isRotateText,\r\n                            minAngle: this.settings.minAngle,\r\n                            maxAngle: this.settings.maxAngle,\r\n                            maxNumberOfOrientations: this.settings.maxNumberOfOrientations\r\n                        }\r\n                    };\r\n\r\n                    instances.push(rotateText);\r\n                    break;\r\n                }\r\n                case \"stopWords\": {\r\n                    let stopWords: VisualObjectInstance = {\r\n                        objectName: \"stopWords\",\r\n                        displayName: \"Stop Words\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.settings.isRemoveStopWords,\r\n                            isDefaultStopWords: this.settings.isDefaultStopWords,\r\n                            words: this.settings.stopWords ||\r\n                            this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)\r\n                        }\r\n                    };\r\n\r\n                    instances.push(stopWords);\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return instances;\r\n        }\r\n\r\n        private animation(\r\n            element: D3.Selection,\r\n            duration: number = 0,\r\n            callback?: (data: any, index: number) => void): D3.Transition.Transition | D3.Selection {\r\n            return element\r\n                .transition()\r\n                .duration(duration)\r\n                .each(\"end\", callback);\r\n        }\r\n\r\n        public destroy(): void {\r\n            this.root = null;\r\n            this.canvas = null;\r\n        }\r\n    }\r\n\r\n    module explore.util {\r\n        export function hexToRgb(hex): string {\r\n            // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n            let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n            hex = hex.replace(shorthandRegex, function (m, r, g, b) {\r\n                return r + r + g + g + b + b;\r\n            });\r\n\r\n            let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n            return result ? `rgb(${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)})` : null;\r\n        }\r\n\r\n        export function getRandomColor(): string {\r\n            let red: number = Math.floor(Math.random() * 255),\r\n                green: number = Math.floor(Math.random() * 255),\r\n                blue: number = Math.floor(Math.random() * 255);\r\n\r\n            return `rgb(${red},${green},${blue})`;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/wordCloud/visual/wordCloud.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    export interface ITableView {\r\n        data(data: any[], dataIdFunction: (d) => {}, dataAppended: boolean): ITableView;\r\n        rowHeight(rowHeight: number): ITableView;\r\n        columnWidth(columnWidth: number): ITableView;\r\n        orientation(orientation: string): ITableView;\r\n        rows(rows: number): ITableView;\r\n        columns(columns: number): ITableView;\r\n        viewport(viewport: IViewport): ITableView;\r\n        render(): void;\r\n        empty(): void;\r\n    }\r\n\r\n    export module TableViewFactory {\r\n        export function createTableView(options): ITableView {\r\n            return new TableView(options);\r\n        }\r\n    }\r\n\r\n    export interface TableViewViewOptions {\r\n        enter: (selection: D3.Selection) => void;\r\n        exit: (selection: D3.Selection) => void;\r\n        update: (selection: D3.Selection) => void;\r\n        loadMoreData: () => void;\r\n        baseContainer: D3.Selection;\r\n        rowHeight: number;\r\n        columnWidth: number;\r\n        orientation: string;\r\n        rows: number;\r\n        columns: number;\r\n        viewport: IViewport;\r\n        scrollEnabled: boolean;\r\n    }\r\n\r\n    /**\r\n     * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.\r\n     * It can create lists containing either HTML or SVG elements.\r\n     */\r\n    class TableView implements ITableView {\r\n        private getDatumIndex: (d: any) => {};\r\n        private _data: any[];\r\n        private _totalRows: number;\r\n        private _totalColumns: number;\r\n\r\n        private options: TableViewViewOptions;\r\n        private visibleGroupContainer: D3.Selection;\r\n        private scrollContainer: D3.Selection;\r\n\r\n        private static defaultRowHeight = 0;\r\n        private static defaultColumns = 1;\r\n\r\n        public constructor(options: TableViewViewOptions) {\r\n            // make a copy of options so that it is not modified later by caller\r\n            this.options = $.extend(true, {}, options);\r\n\r\n            this.options.baseContainer\r\n                .style('overflow-y', 'auto')\r\n                .attr('drag-resize-disabled', true);\r\n\r\n            this.scrollContainer = options.baseContainer\r\n                .append('div')\r\n                .attr('class', 'scrollRegion');\r\n            this.visibleGroupContainer = this.scrollContainer\r\n                .append('div')\r\n                .attr('class', 'visibleGroup');\r\n\r\n            TableView.SetDefaultOptions(options);\r\n        }\r\n\r\n        private static SetDefaultOptions(options: TableViewViewOptions) {\r\n            options.rowHeight = options.rowHeight || TableView.defaultRowHeight;\r\n        }\r\n\r\n        public rowHeight(rowHeight: number): TableView {\r\n            this.options.rowHeight = Math.ceil(rowHeight);\r\n            return this;\r\n        }\r\n        public columnWidth(columnWidth: number): TableView {\r\n            this.options.columnWidth = Math.ceil(columnWidth);\r\n            return this;\r\n        }\r\n\r\n        public orientation(orientation: string): TableView {\r\n            this.options.orientation = orientation;\r\n            return this;\r\n        }\r\n\r\n        public rows(rows: number): TableView {\r\n            this.options.rows = Math.ceil(rows);\r\n            return this;\r\n        }\r\n\r\n        public columns(columns: number): TableView {\r\n            this.options.columns = Math.ceil(columns);\r\n            return this;\r\n        }\r\n\r\n        public data(data: any[], getDatumIndex: (d) => {}, dataReset: boolean = false): ITableView {\r\n            this._data = data;\r\n            this.getDatumIndex = getDatumIndex;\r\n            this.setTotalRows();\r\n            if (dataReset) {\r\n                $(this.options.baseContainer.node()).scrollTop(0);\r\n            }\r\n            return this;\r\n        }\r\n\r\n        public viewport(viewport: IViewport): ITableView {\r\n            this.options.viewport = viewport;\r\n            return this;\r\n        }\r\n\r\n        public empty(): void {\r\n            this._data = [];\r\n            this.render();\r\n        }\r\n\r\n        private setTotalRows(): void {\r\n            var count = this._data.length;\r\n            var rows = Math.min(this.options.rows, count);\r\n            var columns = Math.min(this.options.columns, count);\r\n\r\n            if ((columns > 0) && (rows > 0)) {\r\n                this._totalColumns = columns;\r\n                this._totalRows = rows;\r\n            } else if (rows > 0) {\r\n                this._totalRows = rows;\r\n                this._totalColumns = Math.ceil(count / rows);\r\n            } else if (columns > 0) {\r\n                this._totalColumns = columns;\r\n                this._totalRows = Math.ceil(count / columns);\r\n            } else {\r\n                this._totalColumns = TableView.defaultColumns;\r\n                this._totalRows = Math.ceil(count / TableView.defaultColumns);\r\n            }\r\n        }\r\n\r\n        public render(): void {\r\n            var options = this.options;\r\n            var visibleGroupContainer = this.visibleGroupContainer;\r\n            var rowHeight = options.rowHeight || TableView.defaultRowHeight;\r\n            var groupedData: any[] = [];\r\n            var totalRows = options.rows;\r\n            var totalColumns = options.columns;\r\n            var totalItems: number = this._data.length;\r\n            var totalRows = options.rows > totalItems ? totalItems : options.rows;\r\n            var totalColumns = options.columns > totalItems ? totalItems : options.columns;\r\n\r\n            if (totalColumns === 0 && totalRows === 0) {\r\n                if (options.orientation === Orientation.HORIZONTAL)\r\n                {\r\n                    totalColumns = totalItems;\r\n                    totalRows = 1;\r\n                }\r\n                else\r\n                {\r\n                    totalColumns = 1;\r\n                    totalRows = totalItems;\r\n                }\r\n            }\r\n            else if (totalColumns === 0 && totalRows > 0)\r\n                totalColumns = Math.ceil(totalItems / totalRows);\r\n            else if (totalColumns > 0 && totalRows === 0)\r\n                totalRows = Math.ceil(totalItems / totalColumns);\r\n\r\n            if (this.options.orientation === Orientation.VERTICAL)\r\n            {\r\n                var n = totalRows;\r\n                totalRows = totalColumns;\r\n                totalColumns = n;\r\n            }\r\n\r\n            else if (this.options.orientation === Orientation.HORIZONTAL)\r\n            {\r\n                if (totalRows === 0) totalRows = this._totalRows;\r\n                if (totalColumns === 0) totalColumns = this._totalColumns;\r\n            }\r\n\r\n            var m: number = 0;\r\n            var k: number = 0;\r\n            for (var i: number = 0; i < totalRows; i++) {\r\n                if (this.options.orientation === Orientation.VERTICAL && options.rows === 0 && totalItems % options.columns > 0 && options.columns <= totalItems)\r\n                {\r\n                    if (totalItems % options.columns > i)\r\n                    {\r\n                        m = i * Math.ceil(totalItems / options.columns);\r\n                        k = m + Math.ceil(totalItems / options.columns);\r\n                        groupedData.push(this._data.slice(m, k));\r\n                    }\r\n                    else\r\n                    {\r\n                        groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns)));\r\n                        k = k + Math.floor(totalItems / options.columns);\r\n                    }\r\n                }\r\n                else if (this.options.orientation === Orientation.HORIZONTAL && options.columns === 0 && totalItems % options.rows > 0 && options.rows <= totalItems)\r\n                {\r\n                    if (totalItems % options.rows > i)\r\n                    {\r\n                        m = i * Math.ceil(totalItems / options.rows);\r\n                        k = m + Math.ceil(totalItems / options.rows);\r\n                        groupedData.push(this._data.slice(m, k));\r\n                    }\r\n                    else\r\n                    {\r\n                        groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows)));\r\n                        k = k + Math.floor(totalItems / options.rows);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    var k: number = i * totalColumns;\r\n                    groupedData.push(this._data.slice(k, k + totalColumns));\r\n                }\r\n            }\r\n\r\n            visibleGroupContainer.selectAll(\".row\").remove();\r\n            var cellSelection = visibleGroupContainer.selectAll(\".row\")\r\n                .data(groupedData)\r\n                .enter()\r\n                .append(\"div\")\r\n                .classed('row', true)\r\n                .selectAll(\".cell\")\r\n                .data(d => d);\r\n\r\n            cellSelection\r\n                .enter()\r\n                .append('div')\r\n                .classed('cell', true)\r\n                .call(d => options.enter(d));\r\n            cellSelection.order();\r\n\r\n            var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');\r\n\r\n            cellUpdateSelection.call(d => options.update(d));\r\n            cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });\r\n\r\n            if (this.options.orientation === Orientation.VERTICAL)\r\n            {\r\n                var realColumnNumber = 0;\r\n                for (var i: number = 0; i < groupedData.length; i++)\r\n                {\r\n                    if (groupedData[i].length !== 0)\r\n                        realColumnNumber = i+1;\r\n                }\r\n\r\n                cellUpdateSelection.style({ 'width': '100%' });\r\n                var rowUpdateSelection = visibleGroupContainer.selectAll('div.row');\r\n                rowUpdateSelection.style({ 'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / realColumnNumber) + '%' });\r\n            }\r\n            else\r\n                cellUpdateSelection.style({\r\n                    'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / totalColumns) + '%'\r\n                });\r\n\r\n            cellSelection\r\n                .exit()\r\n                .call(d => options.exit(d))\r\n                .remove();\r\n        }\r\n    }\r\n\r\n    // TODO: Generate these from above, defining twice just introduces potential for error\r\n    export var chicletSlicerProps = {\r\n        general: {\r\n            orientation: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'orientation' },\r\n            columns: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'columns' },\r\n            rows: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'rows' },\r\n            showDisabled: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'showDisabled' },\r\n            multiselect: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'multiselect' },\r\n            selection: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'selection' },\r\n        },\r\n        header: {\r\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'show' },\r\n            title: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'title' },\r\n            fontColor: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'fontColor' },\r\n            background: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'background' },\r\n            outline: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outline' },\r\n            textSize: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'textSize' },\r\n            outlineColor: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outlineColor' },\r\n            outlineWeight: <DataViewObjectPropertyIdentifier>{ objectName: 'header', propertyName: 'outlineWeight' }\r\n        },\r\n        rows: {\r\n            fontColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'fontColor' },\r\n            textSize: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'textSize' },\r\n            height: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'height' },\r\n            width: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'width' },\r\n            background: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'background' },\r\n            transparency: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'transparency' },\r\n            selectedColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'selectedColor' },\r\n            hoverColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'hoverColor' },\r\n            unselectedColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'unselectedColor' },\r\n            disabledColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'disabledColor' },\r\n            outline: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outline' },\r\n            outlineColor: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outlineColor' },\r\n            outlineWeight: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'outlineWeight' },\r\n            borderStyle: <DataViewObjectPropertyIdentifier>{ objectName: 'rows', propertyName: 'borderStyle' },\r\n        },\r\n        images: {\r\n            imageSplit: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'imageSplit' },\r\n            stretchImage: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'stretchImage' },\r\n            bottomImage: <DataViewObjectPropertyIdentifier>{ objectName: 'images', propertyName: 'bottomImage' },\r\n        },\r\n        selectedPropertyIdentifier: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'selected' },\r\n        filterPropertyIdentifier: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'filter' },\r\n        formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\r\n        hasSavedSelection: true,\r\n    };\r\n\r\n    module ChicletBorderStyle {\r\n        export var ROUNDED: string = 'Rounded';\r\n        export var CUT: string = 'Cut';\r\n        export var SQUARE: string = 'Square';\r\n\r\n        export var type: IEnumType = createEnumType([\r\n            { value: ROUNDED, displayName: ChicletBorderStyle.ROUNDED },\r\n            { value: CUT, displayName: ChicletBorderStyle.CUT },\r\n            { value: SQUARE, displayName: ChicletBorderStyle.SQUARE },\r\n        ]);\r\n    }\r\n\r\n    module ChicletSlicerShowDisabled {\r\n        export var INPLACE: string = 'Inplace';\r\n        export var BOTTOM: string = 'Bottom';\r\n        export var HIDE: string = 'Hide';\r\n\r\n        export var type: IEnumType = createEnumType([\r\n            { value: INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },\r\n            { value: BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },\r\n            { value: HIDE, displayName: ChicletSlicerShowDisabled.HIDE },\r\n        ]);\r\n    }\r\n\r\n    module Orientation {\r\n        export var HORIZONTAL: string = 'Horizontal';\r\n        export var VERTICAL: string = 'Vertical';\r\n\r\n        export var type: IEnumType = createEnumType([\r\n            { value: HORIZONTAL, displayName: HORIZONTAL },\r\n            { value: VERTICAL, displayName: VERTICAL }\r\n        ]);\r\n    }\r\n\r\n    export interface ChicletSlicerConstructorOptions {\r\n        behavior?: ChicletSlicerWebBehavior;\r\n    }\r\n\r\n    export interface ChicletSlicerData {\r\n        categorySourceName: string;\r\n        formatString: string;\r\n        slicerDataPoints: ChicletSlicerDataPoint[];\r\n        slicerSettings: ChicletSlicerSettings;\r\n        hasSelectionOverride?: boolean;\r\n    }\r\n\r\n    export interface ChicletSlicerDataPoint extends SelectableDataPoint {\r\n        category?: string;\r\n        value?: number;\r\n        mouseOver?: boolean;\r\n        mouseOut?: boolean;\r\n        isSelectAllDataPoint?: boolean;\r\n        imageURL?: string;\r\n        selectable?: boolean;\r\n    }\r\n\r\n    export interface ChicletSlicerSettings {\r\n        general: {\r\n            orientation: string;\r\n            columns: number;\r\n            rows: number;\r\n            multiselect: boolean;\r\n            showDisabled: string;\r\n            selection: string;\r\n            getSavedSelection?: () => string[];\r\n            setSavedSelection?: (selectionIds: string[]) => void;\r\n        };\r\n        margin: IMargin;\r\n        header: {\r\n            borderBottomWidth: number;\r\n            show: boolean;\r\n            outline: string;\r\n            fontColor: string;\r\n            background?: string;\r\n            textSize: number;\r\n            outlineColor: string;\r\n            outlineWeight: number;\r\n            title: string;\r\n        };\r\n        headerText: {\r\n            marginLeft: number;\r\n            marginTop: number;\r\n        };\r\n        slicerText: {\r\n            textSize: number;\r\n            height: number;\r\n            width: number;\r\n            fontColor: string;\r\n            selectedColor: string;\r\n            hoverColor: string;\r\n            unselectedColor: string;\r\n            disabledColor: string;\r\n            marginLeft: number;\r\n            outline: string;\r\n            background?: string;\r\n            transparency: number;\r\n            outlineColor: string;\r\n            outlineWeight: number;\r\n            borderStyle: string;\r\n        };\r\n        slicerItemContainer: {\r\n            marginTop: number;\r\n            marginLeft: number;\r\n        };\r\n        images: {\r\n            imageSplit: number;\r\n            stretchImage: boolean;\r\n            bottomImage: boolean;\r\n        };\r\n    }\r\n\r\n    export class ChicletSlicer implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Category',\r\n                },\r\n                {\r\n                    name: 'Values',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Values',\r\n                },\r\n                {\r\n                    name: 'Image',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Image',\r\n                },\r\n            ],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        selection: {\r\n                            displayName: \"Selection\",\r\n                            type: { text: true }\r\n                        },\r\n                        orientation: {\r\n                            displayName: 'Orientation',\r\n                            type: { enumeration: Orientation.type }\r\n                        },\r\n                        columns: {\r\n                            displayName: 'Columns',\r\n                            type: { numeric: true }\r\n                        },\r\n                        rows: {\r\n                            displayName: 'Rows',\r\n                            type: { numeric: true }\r\n                        },\r\n                        showDisabled: {\r\n                            displayName: 'Show Disabled',\r\n                            type: { enumeration: ChicletSlicerShowDisabled.type }\r\n                        },\r\n                        multiselect: {\r\n                            displayName: 'Multiple selection',\r\n                            type: { bool: true }\r\n                        },\r\n                        selected: {\r\n                            type: { bool: true }\r\n                        },\r\n                        filter: {\r\n                            type: { filter: {} },\r\n                        },\r\n                        selfFilter: {\r\n                            type: { filter: { selfFilter: true } },\r\n                        },\r\n                        selfFilterEnabled: {\r\n                            type: { operations: { searchEnabled: true } }\r\n                        },\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                header: {\r\n                    displayName: data.createDisplayNameGetter('Visual_Header'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        title: {\r\n                            displayName: 'Title',\r\n                            type: { text: true }\r\n                        },\r\n                        fontColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_FontColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        background: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Background'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        outline: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\r\n                            type: { formatting: { outline: true } }\r\n                        },\r\n                        textSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        outlineColor: {\r\n                            displayName: 'Outline Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        outlineWeight: {\r\n                            displayName: 'Outline Weight',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                },\r\n                rows: {\r\n                    displayName: 'Chiclets',\r\n                    properties: {\r\n                        fontColor: {\r\n                            displayName: 'Text color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        textSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        height: {\r\n                            displayName: 'Height',\r\n                            type: { numeric: true }\r\n                        },\r\n                        width: {\r\n                            displayName: 'Width',\r\n                            type: { numeric: true }\r\n                        },\r\n                        selectedColor: {\r\n                            displayName: 'Selected Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        hoverColor: {\r\n                            displayName: 'Hover Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        unselectedColor: {\r\n                            displayName: 'Unselected Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        disabledColor: {\r\n                            displayName: 'Disabled Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        background: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Background'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        transparency: {\r\n                            displayName: \"Transparency\",\r\n                            description: \"Set transparency for background color\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        outline: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\r\n                            type: { formatting: { outline: true } }\r\n                        },\r\n                        outlineColor: {\r\n                            displayName: 'Outline Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        outlineWeight: {\r\n                            displayName: 'Outline Weight',\r\n                            type: { numeric: true }\r\n                        },\r\n                        borderStyle: {\r\n                            displayName: 'Outline Style',\r\n                            type: { enumeration: ChicletBorderStyle.type }\r\n                        },\r\n                    }\r\n                },\r\n                images: {\r\n                    displayName: 'Images',\r\n                    properties: {\r\n                        imageSplit: {\r\n                            displayName: 'Image Split',\r\n                            type: { numeric: true }\r\n                        },\r\n                        stretchImage: {\r\n                            displayName: 'Stretch image',\r\n                            type: { bool: true }\r\n                        },\r\n                        bottomImage: {\r\n                            displayName: 'Bottom image',\r\n                            type: { bool: true }\r\n                        },\r\n                    }\r\n                },\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: { count: 10000 } }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Image',\r\n                            select: [{ bind: { to: 'Values' } },\r\n                            ],\r\n                           dataReductionAlgorithm: { top: { count: 10000 } }\r\n                        }\r\n                    },\r\n                    includeEmptyGroups: true\r\n                }\r\n            }],\r\n            supportsHighlight: true,\r\n            sorting: {\r\n                default: {},\r\n            },\r\n            suppressDefaultTitle: true,\r\n        };\r\n        private element: JQuery;\r\n        private currentViewport: IViewport;\r\n        private dataView: DataView;\r\n        private slicerHeader: D3.Selection;\r\n        private slicerBody: D3.Selection;\r\n        private tableView: ITableView;\r\n        private slicerData: ChicletSlicerData;\r\n        private settings: ChicletSlicerSettings;\r\n        private interactivityService: IInteractivityService;\r\n        private behavior: ChicletSlicerWebBehavior;\r\n        private hostServices: IVisualHostServices;\r\n        private waitingForData: boolean;\r\n        private isSelectionLoaded: boolean;\r\n        private isSelectionSaved: boolean;\r\n\r\n        public static DefaultFontFamily: string = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';\r\n        public static DefaultFontSizeInPt: number = 11;\r\n        private static cellTotalInnerPaddings = 8;\r\n        private static cellTotalInnerBorders = 2;\r\n        private static chicletTotalInnerRightLeftPaddings = 14;\r\n\r\n        private static ItemContainer: ClassAndSelector = createClassAndSelector('slicerItemContainer');\r\n        private static HeaderText: ClassAndSelector = createClassAndSelector('headerText');\r\n        private static Container: ClassAndSelector = createClassAndSelector('chicletSlicer');\r\n        private static LabelText: ClassAndSelector = createClassAndSelector('slicerText');\r\n        private static Header: ClassAndSelector = createClassAndSelector('slicerHeader');\r\n        private static Input: ClassAndSelector = createClassAndSelector('slicerCheckbox');\r\n        private static Clear: ClassAndSelector = createClassAndSelector('clear');\r\n        private static Body: ClassAndSelector = createClassAndSelector('slicerBody');\r\n\r\n        public static DefaultStyleProperties(): ChicletSlicerSettings {\r\n            return {\r\n                general: {\r\n                    orientation: Orientation.VERTICAL,\r\n                    columns: 3,\r\n                    rows: 0,\r\n                    multiselect: true,\r\n                    showDisabled: ChicletSlicerShowDisabled.INPLACE,\r\n                    selection: null,\r\n                },\r\n                margin: {\r\n                    top: 50,\r\n                    bottom: 50,\r\n                    right: 50,\r\n                    left: 50\r\n                },\r\n                header: {\r\n                    borderBottomWidth: 1,\r\n                    show: true,\r\n                    outline: 'BottomOnly',\r\n                    fontColor: '#a6a6a6',\r\n                    background: null,\r\n                    textSize: 10,\r\n                    outlineColor: '#a6a6a6',\r\n                    outlineWeight: 1,\r\n                    title: '',\r\n                },\r\n                headerText: {\r\n                    marginLeft: 8,\r\n                    marginTop: 0\r\n                },\r\n                slicerText: {\r\n                    textSize: 10,\r\n                    height: 0,\r\n                    width: 0,\r\n                    fontColor: '#666666',\r\n                    hoverColor: '#212121',\r\n                    selectedColor: '#BDD7EE',\r\n                    unselectedColor: '#ffffff',\r\n                    disabledColor: 'grey',\r\n                    marginLeft: 8,\r\n                    outline: 'Frame',\r\n                    background: null,\r\n                    transparency: 0,\r\n                    outlineColor: '#000000',\r\n                    outlineWeight: 1,\r\n                    borderStyle: 'Cut',\r\n\r\n                },\r\n                slicerItemContainer: {\r\n                    // The margin is assigned in the less file. This is needed for the height calculations.\r\n                    marginTop: 5,\r\n                    marginLeft: 0,\r\n                },\r\n                images: {\r\n                    imageSplit: 50,\r\n                    stretchImage: false,\r\n                    bottomImage: false\r\n                }\r\n            };\r\n        }\r\n\r\n        constructor(options?: ChicletSlicerConstructorOptions) {\r\n            if (options) {\r\n                if (options.behavior) {\r\n                    this.behavior = options.behavior;\r\n                }\r\n            }\r\n            if (!this.behavior) {\r\n                this.behavior = new ChicletSlicerWebBehavior();\r\n            }\r\n        }\r\n\r\n        public static converter(dataView: DataView, localizedSelectAllText: string, interactivityService: IInteractivityService): ChicletSlicerData {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[0].values ||\r\n                !(dataView.categorical.categories[0].values.length > 0)) {\r\n                return;\r\n            }\r\n            var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);\r\n            converter.convert();\r\n            var slicerData: ChicletSlicerData;\r\n            var defaultSettings: ChicletSlicerSettings = this.DefaultStyleProperties();\r\n            var objects: DataViewObjects = dataView.metadata.objects;\r\n            if (objects) {\r\n                defaultSettings.general.orientation = DataViewObjects.getValue<string>(objects, chicletSlicerProps.general.orientation, defaultSettings.general.orientation);\r\n                defaultSettings.general.columns = DataViewObjects.getValue<number>(objects, chicletSlicerProps.general.columns, defaultSettings.general.columns);\r\n                defaultSettings.general.rows = DataViewObjects.getValue<number>(objects, chicletSlicerProps.general.rows, defaultSettings.general.rows);\r\n                defaultSettings.general.multiselect = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);\r\n                defaultSettings.general.showDisabled = DataViewObjects.getValue<string>(objects, chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);\r\n                defaultSettings.general.selection = DataViewObjects.getValue(dataView.metadata.objects, chicletSlicerProps.general.selection, defaultSettings.general.selection);\r\n\r\n                defaultSettings.header.show = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.header.show, defaultSettings.header.show);\r\n                defaultSettings.header.title = DataViewObjects.getValue<string>(objects, chicletSlicerProps.header.title, defaultSettings.header.title);\r\n                defaultSettings.header.fontColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);\r\n                defaultSettings.header.background = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.background, defaultSettings.header.background);\r\n                defaultSettings.header.textSize = DataViewObjects.getValue<number>(objects, chicletSlicerProps.header.textSize, defaultSettings.header.textSize);\r\n                defaultSettings.header.outline = DataViewObjects.getValue<string>(objects, chicletSlicerProps.header.outline, defaultSettings.header.outline);\r\n                defaultSettings.header.outlineColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);\r\n                defaultSettings.header.outlineWeight = DataViewObjects.getValue<number>(objects, chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);\r\n\r\n                defaultSettings.slicerText.textSize = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);\r\n                defaultSettings.slicerText.height = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.height, defaultSettings.slicerText.height);\r\n                defaultSettings.slicerText.width = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.width, defaultSettings.slicerText.width);\r\n                defaultSettings.slicerText.selectedColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);\r\n                defaultSettings.slicerText.hoverColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.hoverColor, defaultSettings.slicerText.hoverColor);\r\n                defaultSettings.slicerText.unselectedColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);\r\n                defaultSettings.slicerText.disabledColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);\r\n                defaultSettings.slicerText.background = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.background, defaultSettings.slicerText.background);\r\n                defaultSettings.slicerText.transparency = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);\r\n                defaultSettings.slicerText.fontColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);\r\n                defaultSettings.slicerText.outline = DataViewObjects.getValue<string>(objects, chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);\r\n                defaultSettings.slicerText.outlineColor = DataViewObjects.getFillColor(objects, chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);\r\n                defaultSettings.slicerText.outlineWeight = DataViewObjects.getValue<number>(objects, chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);\r\n                defaultSettings.slicerText.borderStyle = DataViewObjects.getValue<string>(objects, chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);\r\n\r\n                defaultSettings.images.imageSplit = DataViewObjects.getValue<number>(objects, chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);\r\n                defaultSettings.images.stretchImage = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);\r\n                defaultSettings.images.bottomImage = DataViewObjects.getValue<boolean>(objects, chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);\r\n            }\r\n\r\n            var categories: DataViewCategoricalColumn = dataView.categorical.categories[0];\r\n            slicerData = {\r\n                categorySourceName: categories.source.displayName,\r\n                formatString: valueFormatter.getFormatString(categories.source, chicletSlicerProps.formatString),\r\n                slicerSettings: defaultSettings,\r\n                slicerDataPoints: converter.dataPoints,\r\n            };\r\n\r\n            // Override hasSelection if a objects contained more scopeIds than selections we found in the data\r\n            slicerData.hasSelectionOverride = converter.hasSelectionOverride;\r\n\r\n            return slicerData;\r\n        }\r\n\r\n       public init(options: VisualInitOptions): void {\r\n            this.element = options.element;\r\n            this.currentViewport = options.viewport;\r\n            if (this.behavior) {\r\n                this.interactivityService = createInteractivityService(options.host);\r\n            }\r\n            this.hostServices = options.host;\r\n            this.hostServices.canSelect = ChicletSlicer.canSelect;\r\n            this.settings = ChicletSlicer.DefaultStyleProperties();\r\n\r\n            this.initContainer();\r\n        }\r\n\r\n        private static canSelect(args: SelectEventArgs): boolean {\r\n            var selectors = args.data;\r\n\r\n            // We can't have multiple selections if any include more than one identity\r\n            if (selectors.length > 1) {\r\n                if (selectors.some((value: data.Selector) => value && value.data && value.data.length > 1)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Todo: check for cases of trying to select a category and a series (not the intersection)\r\n            return true;\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options ||\r\n                !options.dataViews ||\r\n                !options.dataViews[0] ||\r\n                !options.viewport) {\r\n                return;\r\n            }\r\n\r\n            var existingDataView = this.dataView;\r\n            this.dataView = options.dataViews[0];\r\n\r\n            var resetScrollbarPosition: boolean = true;\r\n            if (existingDataView) {\r\n                resetScrollbarPosition = !DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);\r\n            }\r\n\r\n            if (options.viewport.height === this.currentViewport.height\r\n                && options.viewport.width === this.currentViewport.width) {\r\n                this.waitingForData = false;\r\n            }\r\n            else {\r\n                this.currentViewport = options.viewport;\r\n            }\r\n\r\n            this.updateInternal(resetScrollbarPosition);\r\n        }\r\n\r\n        public onResizing(finalViewport: IViewport): void {\r\n            this.currentViewport = finalViewport;\r\n            this.updateInternal(false /* resetScrollbarPosition */);\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            var data: ChicletSlicerData = this.slicerData;\r\n            if (!data) {\r\n                return;\r\n            }\r\n\r\n            var objectName = options.objectName;\r\n            switch (objectName) {\r\n                case 'rows':\r\n                    return this.enumerateRows(data);\r\n                case 'header':\r\n                    return this.enumerateHeader(data);\r\n                case 'general':\r\n                    return this.enumerateGeneral(data);\r\n                case 'images':\r\n                    return this.enumerateImages(data);\r\n            }\r\n        }\r\n\r\n        private enumerateHeader(data: ChicletSlicerData): VisualObjectInstance[] {\r\n            var slicerSettings: ChicletSlicerSettings = this.settings;\r\n            return [{\r\n                selector: null,\r\n                objectName: 'header',\r\n                properties: {\r\n                    show: slicerSettings.header.show,\r\n                    title: slicerSettings.header.title,\r\n                    fontColor: slicerSettings.header.fontColor,\r\n                    background: slicerSettings.header.background,\r\n                    textSize: slicerSettings.header.textSize,\r\n                    outline: slicerSettings.header.outline,\r\n                    outlineColor: slicerSettings.header.outlineColor,\r\n                    outlineWeight: slicerSettings.header.outlineWeight\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateRows(data: ChicletSlicerData): VisualObjectInstance[] {\r\n            var slicerSettings: ChicletSlicerSettings = this.settings;\r\n            return [{\r\n                selector: null,\r\n                objectName: 'rows',\r\n                properties: {\r\n                    textSize: slicerSettings.slicerText.textSize,\r\n                    height: slicerSettings.slicerText.height,\r\n                    width: slicerSettings.slicerText.width,\r\n                    background: slicerSettings.slicerText.background,\r\n                    transparency: slicerSettings.slicerText.transparency,\r\n                    selectedColor: slicerSettings.slicerText.selectedColor,\r\n                    hoverColor: slicerSettings.slicerText.hoverColor,\r\n                    unselectedColor: slicerSettings.slicerText.unselectedColor,\r\n                    disabledColor: slicerSettings.slicerText.disabledColor,\r\n                    outline: slicerSettings.slicerText.outline,\r\n                    outlineColor: slicerSettings.slicerText.outlineColor,\r\n                    outlineWeight: slicerSettings.slicerText.outlineWeight,\r\n                    fontColor: slicerSettings.slicerText.fontColor,\r\n                    borderStyle: slicerSettings.slicerText.borderStyle,\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateGeneral(data: ChicletSlicerData): VisualObjectInstance[] {\r\n            var slicerSettings: ChicletSlicerSettings = this.settings;\r\n\r\n            return [{\r\n                selector: null,\r\n                objectName: 'general',\r\n                properties: {\r\n                    orientation: slicerSettings.general.orientation,\r\n                    columns: slicerSettings.general.columns,\r\n                    rows: slicerSettings.general.rows,\r\n                    showDisabled: slicerSettings.general.showDisabled,\r\n                    multiselect: slicerSettings.general.multiselect,\r\n                }\r\n            }];\r\n        }\r\n\r\n        private enumerateImages(data: ChicletSlicerData): VisualObjectInstance[] {\r\n            var slicerSettings: ChicletSlicerSettings = this.settings;\r\n            return [{\r\n                selector: null,\r\n                objectName: 'images',\r\n                properties: {\r\n                    imageSplit: slicerSettings.images.imageSplit,\r\n                    stretchImage: slicerSettings.images.stretchImage,\r\n                    bottomImage: slicerSettings.images.bottomImage,\r\n                }\r\n            }];\r\n        }\r\n        private updateInternal(resetScrollbarPosition: boolean) {\r\n            this.updateSlicerBodyDimensions();\r\n\r\n            var localizedSelectAllText: string = 'Select All';\r\n            var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);\r\n            if (!data) {\r\n                this.tableView.empty();\r\n                return;\r\n            }\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(data.slicerDataPoints);\r\n            }\r\n\r\n            data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;\r\n            data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight;\r\n\r\n            data.slicerSettings.general.getSavedSelection = () => {\r\n                    try\r\n                    {\r\n                        return JSON.parse(this.slicerData.slicerSettings.general.selection) || [];\r\n                    }\r\n                    catch(ex)\r\n                    {\r\n                        return [];\r\n                    }\r\n                };\r\n            data.slicerSettings.general.setSavedSelection = (selectionIds: string[]) => {\r\n                this.isSelectionSaved = true;\r\n                this.hostServices.persistProperties(<VisualObjectInstancesToPersist>{\r\n                        merge: [{\r\n                        objectName: \"general\",\r\n                        selector: null,\r\n                        properties: { selection: selectionIds && JSON.stringify(selectionIds) || \"\" }\r\n                    }]});\r\n                };\r\n\r\n            if(this.slicerData) {\r\n                if(this.isSelectionSaved) {\r\n                     this.isSelectionLoaded = true;\r\n                } else {\r\n                   this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection;\r\n                }\r\n            } else {\r\n                this.isSelectionLoaded = false;\r\n            }\r\n\r\n            this.slicerData = data;\r\n            this.settings = this.slicerData.slicerSettings;\r\n            if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {\r\n                data.slicerDataPoints.sort(function (a, b) {\r\n                    if (a.selectable === b.selectable) {\r\n                        return 0;\r\n                    } else if (a.selectable && !b.selectable) {\r\n                        return -1;\r\n                    } else {\r\n                        return 1;\r\n                    }\r\n                });\r\n            } else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {\r\n                data.slicerDataPoints = data.slicerDataPoints.filter(x => x.selectable);\r\n            }\r\n\r\n            var height: number = this.settings.slicerText.height;\r\n            if (height === 0) {\r\n                var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders;\r\n                var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);\r\n                height = TextMeasurementService.estimateSvgTextHeight(textProperties) + TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;\r\n                var hasImage = _.any(data.slicerDataPoints, x=> x.imageURL !== '' && typeof x.imageURL !== \"undefined\");\r\n                if (hasImage)\r\n                    height += 100;\r\n            }\r\n\r\n            this.tableView\r\n                .rowHeight(height)\r\n                .columnWidth(this.settings.slicerText.width)\r\n                .orientation(this.settings.general.orientation)\r\n                .rows(this.settings.general.rows)\r\n                .columns(this.settings.general.columns)\r\n                .data(data.slicerDataPoints,\r\n                (d: ChicletSlicerDataPoint) => $.inArray(d, data.slicerDataPoints),\r\n                resetScrollbarPosition)\r\n                .viewport(this.getSlicerBodyViewport(this.currentViewport))\r\n                .render();\r\n\r\n            // if(!selectedItems.length  &&  String(savedSelection).length && this.slicerData && this.slicerData.hasSelectionOverride){\r\n            //     var arrSelection = String(savedSelection).split('&');\r\n            //     var arrSelected = jQuery.map(data.slicerDataPoints, function (d, index) {\r\n            //         if (arrSelection.indexOf(d.category) > -1) return d;\r\n            //     });\r\n            //     data.slicerDataPoints.forEach(function (d, index) {\r\n            //         if (arrSelection.indexOf(d.category) > -1){\r\n            //             d.selected = true;\r\n            //             // console.error('>>>>@@@', d, index);\r\n            //         }\r\n            //     });\r\n            //     if(!arrSelection.length){\r\n            //         this.slicerData.hasSelectionOverride = false\r\n            //     }\r\n            //     // console.error('>>> 2', 'RESTORE',   savedSelection,     arrSelected,     data.slicerDataPoints )\r\n            // }\r\n        }\r\n\r\n        private initContainer() {\r\n            var settings: ChicletSlicerSettings = this.settings;\r\n            var slicerBodyViewport: IViewport = this.getSlicerBodyViewport(this.currentViewport);\r\n            var slicerContainer: D3.Selection = d3.select(this.element.get(0))\r\n                .append('div')\r\n                .classed(ChicletSlicer.Container.class, true);\r\n\r\n            this.slicerHeader = slicerContainer\r\n                .append('div')\r\n                .classed(ChicletSlicer.Header.class, true);\r\n\r\n            this.slicerHeader\r\n                .append('span')\r\n                .classed(ChicletSlicer.Clear.class, true)\r\n                .attr('title', 'Clear');\r\n\r\n            this.slicerHeader\r\n                .append('div')\r\n                .classed(ChicletSlicer.HeaderText.class, true)\r\n                .style({\r\n                    'margin-left': PixelConverter.toString(settings.headerText.marginLeft),\r\n                    'margin-top': PixelConverter.toString(settings.headerText.marginTop),\r\n                    'border-style': this.getBorderStyle(settings.header.outline),\r\n                    'border-color': settings.header.outlineColor,\r\n                    'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\r\n                    'font-size': PixelConverter.fromPoint(settings.header.textSize),\r\n                });\r\n\r\n            this.slicerBody = slicerContainer\r\n                .append('div').classed(ChicletSlicer.Body.class, true)\r\n                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\r\n                .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL)\r\n                .style({\r\n                    'height': PixelConverter.toString(slicerBodyViewport.height),\r\n                    'width': '100%',\r\n                });\r\n\r\n            var rowEnter = (rowSelection: D3.Selection) => {\r\n                var settings: ChicletSlicerSettings = this.settings;\r\n                var listItemElement = rowSelection.append('li')\r\n                    .classed(ChicletSlicer.ItemContainer.class, true)\r\n                    .style({\r\n                        'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),\r\n                    });\r\n\r\n                listItemElement.append('div')\r\n                    .classed('slicer-img-wrapper', true);\r\n\r\n                listItemElement.append('div')\r\n                    .classed('slicer-text-wrapper', true)\r\n                    .append('span')\r\n                    .classed(ChicletSlicer.LabelText.class, true)\r\n                    .style({\r\n                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\r\n                    });\r\n            };\r\n\r\n            var rowUpdate = (rowSelection: D3.Selection) => {\r\n                var settings: ChicletSlicerSettings = this.settings;\r\n                var data = this.slicerData;\r\n                if (data && settings) {\r\n                    this.slicerHeader.classed('hidden', !settings.header.show);\r\n                    this.slicerHeader.select(ChicletSlicer.HeaderText.selector)\r\n                        .text(settings.header.title.trim() !== \"\" ? settings.header.title.trim() : this.slicerData.categorySourceName)\r\n                        .style({\r\n                            'border-style': this.getBorderStyle(settings.header.outline),\r\n                            'border-color': settings.header.outlineColor,\r\n                            'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),\r\n                            'color': settings.header.fontColor,\r\n                            'background-color': settings.header.background,\r\n                            'font-size': PixelConverter.fromPoint(settings.header.textSize),\r\n                        });\r\n\r\n                    this.slicerBody\r\n                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)\r\n                        .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL);\r\n\r\n                    var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);\r\n                    var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);\r\n\r\n                    var formatString = data.formatString;\r\n                    slicerText.text((d: ChicletSlicerDataPoint) => {\r\n                        var text = valueFormatter.format(d.category, formatString);\r\n                        textProperties.text = text;\r\n                        if (this.settings.slicerText.width === 0)\r\n                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, (this.currentViewport.width / this.settings.general.columns) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);\r\n                        else\r\n                            return TextMeasurementService.getTailoredTextOrDefault(textProperties, this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);\r\n                    });\r\n\r\n                    var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');\r\n                    slicerImg\r\n                        .style('height', settings.images.imageSplit + '%')\r\n                        .classed('hidden', (d: ChicletSlicerDataPoint) => {\r\n                            if (!(d.imageURL)) {\r\n                                return true;\r\n                            }\r\n                            if (settings.images.imageSplit < 10) {\r\n                                return true;\r\n                            }\r\n                        })\r\n                        .style('display', (d: ChicletSlicerDataPoint) => (d.imageURL) ? 'flex' : 'none')\r\n                        .classed('stretchImage', settings.images.stretchImage)\r\n                        .classed('bottomImage', settings.images.bottomImage)\r\n                        .style('background-image', (d: ChicletSlicerDataPoint) => {\r\n                            return d.imageURL ? `url(${d.imageURL})` : '';\r\n                        });\r\n\r\n                    rowSelection.selectAll('.slicer-text-wrapper')\r\n                        .style('height', (d: ChicletSlicerDataPoint) => {\r\n                            return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';\r\n                        })\r\n                        .classed('hidden', (d: ChicletSlicerDataPoint) => {\r\n                            if (settings.images.imageSplit > 90) {\r\n                                return true;\r\n                            }\r\n                        });\r\n\r\n                    rowSelection.selectAll('.slicerItemContainer').style({\r\n                        'color': settings.slicerText.fontColor,\r\n                        'border-style': this.getBorderStyle(settings.slicerText.outline),\r\n                        'border-color': settings.slicerText.outlineColor,\r\n                        'border-width': this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),\r\n                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),\r\n                        'border-radius': this.getBorderRadius(settings.slicerText.borderStyle),\r\n                    });\r\n\r\n                    if (settings.slicerText.background)\r\n                        this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));\r\n                    else\r\n                        this.slicerBody.style('background-color',null);\r\n\r\n                    if (this.interactivityService && this.slicerBody) {\r\n                        var slicerBody = this.slicerBody.attr('width', this.currentViewport.width);\r\n                        var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);\r\n                        var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);\r\n                        var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);\r\n                        var slicerClear = this.slicerHeader.select(ChicletSlicer.Clear.selector);\r\n\r\n                        var behaviorOptions: ChicletSlicerBehaviorOptions = {\r\n                            dataPoints: data.slicerDataPoints,\r\n                            slicerItemContainers: slicerItemContainers,\r\n                            slicerItemLabels: slicerItemLabels,\r\n                            slicerItemInputs: slicerItemInputs,\r\n                            slicerClear: slicerClear,\r\n                            interactivityService: this.interactivityService,\r\n                            slicerSettings: data.slicerSettings,\r\n                            isSelectionLoaded: this.isSelectionLoaded\r\n                        };\r\n\r\n                        this.interactivityService.bind(data.slicerDataPoints, this.behavior, behaviorOptions, {\r\n                            overrideSelectionFromData: true,\r\n                            hasSelectionOverride: data.hasSelectionOverride,\r\n                        });\r\n                        this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector),\r\n                            this.interactivityService.hasSelection());\r\n                    }\r\n                    else {\r\n                        this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);\r\n                    }\r\n                }\r\n            };\r\n\r\n            var rowExit = (rowSelection: D3.Selection) => {\r\n                rowSelection.remove();\r\n            };\r\n\r\n            var tableViewOptions: TableViewViewOptions = {\r\n                rowHeight: this.getRowHeight(),\r\n                columnWidth: this.settings.slicerText.width,\r\n                orientation: this.settings.general.orientation,\r\n                rows: this.settings.general.rows,\r\n                columns: this.settings.general.columns,\r\n                enter: rowEnter,\r\n                exit: rowExit,\r\n                update: rowUpdate,\r\n                loadMoreData: () => this.onLoadMoreData(),\r\n                scrollEnabled: true,\r\n                viewport: this.getSlicerBodyViewport(this.currentViewport),\r\n                baseContainer: this.slicerBody,\r\n            };\r\n\r\n            this.tableView = TableViewFactory.createTableView(tableViewOptions);\r\n        }\r\n\r\n        private onLoadMoreData(): void {\r\n            if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {\r\n                this.hostServices.loadMoreData();\r\n                this.waitingForData = true;\r\n            }\r\n        }\r\n\r\n        private getSlicerBodyViewport(currentViewport: IViewport): IViewport {\r\n            var settings = this.settings;\r\n            var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;\r\n            var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);\r\n            return {\r\n                height: slicerBodyHeight,\r\n                width: currentViewport.width\r\n            };\r\n        }\r\n\r\n        private updateSlicerBodyDimensions(): void {\r\n            var slicerViewport: IViewport = this.getSlicerBodyViewport(this.currentViewport);\r\n            this.slicerBody\r\n                .style({\r\n                    'height': PixelConverter.toString(slicerViewport.height),\r\n                    'width': '100%',\r\n                });\r\n        }\r\n\r\n        public static getChicletTextProperties(textSize?: number): TextProperties {\r\n            return <TextProperties>{\r\n                fontFamily: ChicletSlicer.DefaultFontFamily,\r\n                fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),\r\n            };\r\n        }\r\n\r\n        private getHeaderHeight(): number {\r\n            return TextMeasurementService.estimateSvgTextHeight(\r\n                ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));\r\n        }\r\n\r\n        private getRowHeight(): number {\r\n            var textSettings = this.settings.slicerText;\r\n            return textSettings.height !== 0\r\n                ? textSettings.height\r\n                : TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));\r\n        }\r\n\r\n        private getBorderStyle(outlineElement: string): string {\r\n            return outlineElement === '0px' ? 'none' : 'solid';\r\n        }\r\n\r\n        private getBorderWidth(outlineElement: string, outlineWeight: number): string {\r\n            switch (outlineElement) {\r\n                case 'None':\r\n                    return '0px';\r\n                case 'BottomOnly':\r\n                    return '0px 0px ' + outlineWeight + 'px 0px';\r\n                case 'TopOnly':\r\n                    return outlineWeight + 'px 0px 0px 0px';\r\n                case 'TopBottom':\r\n                    return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';\r\n                case 'LeftRight':\r\n                    return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';\r\n                case 'Frame':\r\n                    return outlineWeight + 'px';\r\n                default:\r\n                    return outlineElement.replace(\"1\", outlineWeight.toString());\r\n            }\r\n        }\r\n\r\n        private getBorderRadius(borderType: string): string {\r\n            switch (borderType) {\r\n                case ChicletBorderStyle.ROUNDED:\r\n                    return \"10px\";\r\n                case ChicletBorderStyle.SQUARE:\r\n                    return \"0px\";\r\n                default:\r\n                    return \"5px\";\r\n            }\r\n        }\r\n    }\r\n\r\n    module ChicletSlicerChartConversion {\r\n        export class ChicletSlicerConverter {\r\n            private dataViewCategorical: DataViewCategorical;\r\n            private dataViewMetadata: DataViewMetadata;\r\n            private category: DataViewCategoryColumn;\r\n            private categoryIdentities: DataViewScopeIdentity[];\r\n            private categoryValues: any[];\r\n            private categoryColumnRef: data.SQExpr[];\r\n            private categoryFormatString: string;\r\n            private interactivityService: IInteractivityService;\r\n\r\n            public numberOfCategoriesSelectedInData: number;\r\n            public dataPoints: ChicletSlicerDataPoint[];\r\n            public hasSelectionOverride: boolean;\r\n\r\n            public constructor(dataView: DataView, interactivityService: IInteractivityService) {\r\n\r\n                var dataViewCategorical = dataView.categorical;\r\n                this.dataViewCategorical = dataViewCategorical;\r\n                this.dataViewMetadata = dataView.metadata;\r\n\r\n                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\r\n                    this.category = dataViewCategorical.categories[0];\r\n                    this.categoryIdentities = this.category.identity;\r\n                    this.categoryValues = this.category.values;\r\n                    this.categoryColumnRef = <data.SQExpr[]> this.category.identityFields;\r\n                    this.categoryFormatString = valueFormatter.getFormatString(this.category.source, chicletSlicerProps.formatString);\r\n                }\r\n\r\n                this.dataPoints = [];\r\n\r\n                this.interactivityService = interactivityService;\r\n                this.hasSelectionOverride = false;\r\n            }\r\n\r\n            public convert(): void {\r\n                this.dataPoints = [];\r\n                this.numberOfCategoriesSelectedInData = 0;\r\n                // If category exists, we render labels using category values. If not, we render labels\r\n                // using measure labels.\r\n                if (this.categoryValues) {\r\n                    var objects = this.dataViewMetadata ? <any>this.dataViewMetadata.objects : undefined;\r\n\r\n                    var isInvertedSelectionMode = undefined;\r\n                    var numberOfScopeIds: number;\r\n                    if (objects && objects.general && objects.general.filter) {\r\n                        if (!this.categoryColumnRef)\r\n                            return;\r\n                        var filter = <powerbi.data.SemanticFilter>objects.general.filter;\r\n                        var scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);\r\n                        if (scopeIds) {\r\n                            isInvertedSelectionMode = scopeIds.isNot;\r\n                            numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;\r\n                        }\r\n                        else {\r\n                            isInvertedSelectionMode = false;\r\n                        }\r\n                    }\r\n\r\n                    if (this.interactivityService) {\r\n                        if (isInvertedSelectionMode === undefined) {\r\n                            // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual\r\n                            isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();\r\n                        }\r\n                        else {\r\n                            this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);\r\n                        }\r\n                    }\r\n\r\n                    var hasSelection: boolean = undefined;\r\n\r\n                    for (var idx = 0; idx < this.categoryValues.length; idx++) {\r\n                        var selected = isCategoryColumnSelected(chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);\r\n                        if (selected != null) {\r\n                            hasSelection = selected;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    var dataViewCategorical = this.dataViewCategorical;\r\n                    var formatStringProp = chicletSlicerProps.formatString;\r\n                    var value: number = -Infinity;\r\n                    var imageURL: string = '';\r\n\r\n                    for (var categoryIndex: number = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {\r\n                        var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;\r\n                        var categoryIsSelected = isCategoryColumnSelected(chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);\r\n                        var selectable: boolean = true;\r\n\r\n                        if (hasSelection != null) {\r\n                            if (isInvertedSelectionMode) {\r\n                                if (this.category.objects == null)\r\n                                    categoryIsSelected = undefined;\r\n\r\n                                if (categoryIsSelected != null) {\r\n                                    categoryIsSelected = hasSelection;\r\n                                }\r\n                                else if (categoryIsSelected == null)\r\n                                    categoryIsSelected = !hasSelection;\r\n                            }\r\n                            else {\r\n                                if (categoryIsSelected == null) {\r\n                                    categoryIsSelected = !hasSelection;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (categoryIsSelected) {\r\n                            this.numberOfCategoriesSelectedInData++;\r\n                        }\r\n\r\n                        var categoryValue = this.categoryValues[categoryIndex];\r\n                        var categoryLabel = valueFormatter.format(categoryValue, this.categoryFormatString);\r\n\r\n                        if (this.dataViewCategorical.values) {\r\n\r\n                            // Series are either measures in the multi-measure case, or the single series otherwise\r\n                            for (var seriesIndex: number = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {\r\n                                var seriesData = dataViewCategorical.values[seriesIndex];\r\n                                if (seriesData.values[categoryIndex] != null) {\r\n                                    value = seriesData.values[categoryIndex];\r\n                                    if (seriesData.highlights) {\r\n                                        selectable = !(seriesData.highlights[categoryIndex] === null);\r\n                                    }\r\n                                    if (seriesData.source.groupName && seriesData.source.groupName !== '') {\r\n                                        imageURL = converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);\r\n                                        if (!/^(ftp|http|https):\\/\\/[^ \"]+$/.test(imageURL)) {\r\n                                            imageURL = undefined;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        this.dataPoints.push({\r\n                            identity: SelectionId.createWithId(categoryIdentity),\r\n                            category: categoryLabel,\r\n                            imageURL: imageURL,\r\n                            value: value,\r\n                            selected: categoryIsSelected,\r\n                            selectable: selectable\r\n                        });\r\n                    }\r\n                    if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {\r\n                        this.hasSelectionOverride = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //TODO: This module should be removed once TextMeasruementService exports the \"estimateSvgTextBaselineDelta\" function.\r\n    export module ChicletSlicerTextMeasurementHelper {\r\n        interface CanvasContext {\r\n            font: string;\r\n            measureText(text: string): { width: number };\r\n        }\r\n\r\n        interface CanvasElement extends HTMLElement {\r\n            getContext(name: string);\r\n        }\r\n\r\n        var spanElement: JQuery;\r\n        var svgTextElement: D3.Selection;\r\n        var canvasCtx: CanvasContext;\r\n\r\n        export function estimateSvgTextBaselineDelta(textProperties: TextProperties): number {\r\n            var rect = estimateSvgTextRect(textProperties);\r\n            return rect.y + rect.height;\r\n        }\r\n\r\n        function ensureDOM(): void {\r\n            if (spanElement)\r\n                return;\r\n\r\n            spanElement = $('<span/>');\r\n            $('body').append(spanElement);\r\n            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.\r\n            svgTextElement = d3.select($('body').get(0))\r\n                .append('svg')\r\n                .style({\r\n                    'height': '0px',\r\n                    'width': '0px',\r\n                    'position': 'absolute'\r\n                })\r\n                .append('text');\r\n            canvasCtx = (<CanvasElement>$('<canvas/>').get(0)).getContext(\"2d\");\r\n        }\r\n\r\n        function measureSvgTextRect(textProperties: TextProperties): SVGRect {\r\n            debug.assertValue(textProperties, 'textProperties');\r\n\r\n            ensureDOM();\r\n\r\n            svgTextElement.style(null);\r\n            svgTextElement\r\n                .text(textProperties.text)\r\n                .attr({\r\n                    'visibility': 'hidden',\r\n                    'font-family': textProperties.fontFamily,\r\n                    'font-size': textProperties.fontSize,\r\n                    'font-weight': textProperties.fontWeight,\r\n                    'font-style': textProperties.fontStyle,\r\n                    'white-space': textProperties.whiteSpace || 'nowrap'\r\n                });\r\n\r\n            // We're expecting the browser to give a synchronous measurement here\r\n            // We're using SVGTextElement because it works across all browsers\r\n            return svgTextElement.node<SVGTextElement>().getBBox();\r\n        }\r\n\r\n        function estimateSvgTextRect(textProperties: TextProperties): SVGRect {\r\n            debug.assertValue(textProperties, 'textProperties');\r\n\r\n            var estimatedTextProperties: TextProperties = {\r\n                fontFamily: textProperties.fontFamily,\r\n                fontSize: textProperties.fontSize,\r\n                text: \"M\",\r\n            };\r\n\r\n            var rect = measureSvgTextRect(estimatedTextProperties);\r\n\r\n            return rect;\r\n        }\r\n    }\r\n\r\n    export interface ChicletSlicerBehaviorOptions {\r\n        slicerItemContainers: D3.Selection;\r\n        slicerItemLabels: D3.Selection;\r\n        slicerItemInputs: D3.Selection;\r\n        slicerClear: D3.Selection;\r\n        dataPoints: ChicletSlicerDataPoint[];\r\n        interactivityService: IInteractivityService;\r\n        slicerSettings: ChicletSlicerSettings;\r\n        isSelectionLoaded: boolean;\r\n    }\r\n\r\n    export class ChicletSlicerWebBehavior implements IInteractiveBehavior {\r\n        private slicers: D3.Selection;\r\n        private slicerItemLabels: D3.Selection;\r\n        private slicerItemInputs: D3.Selection;\r\n        private dataPoints: ChicletSlicerDataPoint[];\r\n        private interactivityService: IInteractivityService;\r\n        private slicerSettings: ChicletSlicerSettings;\r\n        private options: ChicletSlicerBehaviorOptions;\r\n\r\n        public bindEvents(options: ChicletSlicerBehaviorOptions, selectionHandler: ISelectionHandler): void {\r\n            var filterPropertyId = chicletSlicerProps.filterPropertyIdentifier;\r\n            var slicers = this.slicers = options.slicerItemContainers;\r\n            this.slicerItemLabels = options.slicerItemLabels;\r\n            this.slicerItemInputs = options.slicerItemInputs;\r\n            var slicerClear = options.slicerClear;\r\n            this.dataPoints = options.dataPoints;\r\n            this.interactivityService = options.interactivityService;\r\n            this.slicerSettings = options.slicerSettings;\r\n            this.options = options;\r\n\r\n            if(!this.options.isSelectionLoaded) {\r\n                this.loadSelection(selectionHandler);\r\n            }\r\n\r\n            slicers.on(\"mouseover\", (d: ChicletSlicerDataPoint) => {\r\n                if (d.selectable) {\r\n                    d.mouseOver = true;\r\n                    d.mouseOut = false;\r\n                    this.renderMouseover();\r\n                }\r\n            });\r\n\r\n            slicers.on(\"mouseout\", (d: ChicletSlicerDataPoint) => {\r\n                if (d.selectable) {\r\n                    d.mouseOver = false;\r\n                    d.mouseOut = true;\r\n                    this.renderMouseover();\r\n                }\r\n            });\r\n\r\n            slicers.on(\"click\", (d: ChicletSlicerDataPoint, index) => {\r\n                if (!d.selectable) {\r\n                    return;\r\n                }\r\n                var settings: ChicletSlicerSettings = this.slicerSettings;\r\n                d3.event.preventDefault();\r\n                if (d3.event.altKey && settings.general.multiselect) {\r\n                    var selectedIndexes = jQuery.map(this.dataPoints, function (d, index) { if (d.selected) return index; });\r\n                    var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;\r\n                    if (selIndex > index) {\r\n                        var temp = index;\r\n                        index = selIndex;\r\n                        selIndex = temp;\r\n                    }\r\n                    selectionHandler.handleClearSelection();\r\n                    for (var i = selIndex; i <= index; i++) {\r\n                        selectionHandler.handleSelection(this.dataPoints[i], true /* isMultiSelect */);\r\n                    }\r\n                }\r\n                else if (d3.event.ctrlKey && settings.general.multiselect) {\r\n                    selectionHandler.handleSelection(d, true /* isMultiSelect */);\r\n                }\r\n                else {\r\n                    selectionHandler.handleSelection(d, false /* isMultiSelect */);\r\n                }\r\n                selectionHandler.persistSelectionFilter(filterPropertyId);\r\n                this.saveSelection(selectionHandler);\r\n            });\r\n\r\n            slicerClear.on(\"click\", (d: SelectableDataPoint) => {\r\n                selectionHandler.handleClearSelection();\r\n                selectionHandler.persistSelectionFilter(filterPropertyId);\r\n                this.saveSelection(selectionHandler);\r\n            });\r\n        }\r\n\r\n        public loadSelection(selectionHandler: ISelectionHandler): void {\r\n            selectionHandler.handleClearSelection();\r\n            var savedSelectionIds =  this.slicerSettings.general.getSavedSelection();\r\n            if(savedSelectionIds.length) {\r\n                var selectedDataPoints = this.dataPoints.filter(d => savedSelectionIds.some(x => d.identity.getKey() === x));\r\n                selectedDataPoints.forEach(x => selectionHandler.handleSelection(x, true));\r\n                selectionHandler.persistSelectionFilter(chicletSlicerProps.filterPropertyIdentifier);\r\n            }\r\n        }\r\n\r\n        public saveSelection(selectionHandler: ISelectionHandler): void {\r\n            var selectionIdKeys = (<SelectionId[]>(<any>selectionHandler).selectedIds).map(x=>x.getKey());\r\n            this.slicerSettings.general.setSavedSelection(selectionIdKeys);\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean): void {\r\n            if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {\r\n                this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);\r\n            }\r\n            else {\r\n                this.styleSlicerInputs(this.slicers, hasSelection);\r\n            }\r\n        }\r\n\r\n        private renderMouseover(): void {\r\n            this.slicerItemLabels.style({\r\n                'color': (d: ChicletSlicerDataPoint) => {\r\n                    if (d.mouseOver)\r\n                        return this.slicerSettings.slicerText.hoverColor;\r\n\r\n                    if (d.mouseOut) {\r\n                        if (d.selected)\r\n                            return this.slicerSettings.slicerText.fontColor;\r\n                        else\r\n                            return this.slicerSettings.slicerText.fontColor;\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        public styleSlicerInputs(slicers: D3.Selection, hasSelection: boolean) {\r\n            var settings = this.slicerSettings;\r\n            var selectedItems = [];\r\n            slicers.each(function (d: ChicletSlicerDataPoint) {\r\n                // get selected items\r\n                if (d.selectable && d.selected) {\r\n                    selectedItems.push(d);\r\n                }\r\n\r\n                d3.select(this).style({\r\n                    'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)\r\n                        : settings.slicerText.disabledColor\r\n                });\r\n                d3.select(this).classed('slicerItem-disabled', !d.selectable);\r\n            });\r\n        }\r\n    }\r\n\r\n    module explore.util {\r\n        export function hexToRGBString(hex: string, transparency?: number): string {\r\n\r\n            // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\r\n            var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\r\n            hex = hex.replace(shorthandRegex, function (m, r, g, b) {\r\n                return r + r + g + g + b + b;\r\n            });\r\n\r\n            // Hex format which return the format r-g-b\r\n            var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n\r\n            var rgb = result ? {\r\n                r: parseInt(result[1], 16),\r\n                g: parseInt(result[2], 16),\r\n                b: parseInt(result[3], 16)\r\n            } : null;\r\n\r\n            // Wrong input\r\n            if (rgb === null) {\r\n                return '';\r\n            }\r\n\r\n            if (!transparency && transparency !== 0) {\r\n                return \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\r\n            }\r\n            else {\r\n                return \"rgba(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \",\" + transparency + \")\";\r\n            }\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/chicletSlicer/visual/chicletSlicer.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n\r\n    export interface ChordChartData {\r\n        dataMatrix: number[][];\r\n        labelDataPoints: ChordArcDescriptor[];\r\n        legendData?: LegendData;\r\n        labelFontSize: number;\r\n        tooltipData: ChordTooltipData[][];\r\n        sliceTooltipData: ChordTooltipData[];\r\n        tickUnit: number;\r\n        differentFromTo: boolean;\r\n        defaultDataPointColor?: string;\r\n        prevAxisVisible: boolean;\r\n        showAllDataPoints?: boolean;\r\n        showLabels: boolean;\r\n        showAxis: boolean;\r\n    }\r\n\r\n    export interface ChordArcDescriptor extends D3.Layout.ArcDescriptor {\r\n        data: ChordArcLabelData;\r\n    }\r\n\r\n    export interface ChordArcLabelData extends LabelEnabledDataPoint, SelectableDataPoint {\r\n        label: string;\r\n        labelColor: string;\r\n        barColor: string;\r\n        isCategory: boolean;\r\n    }\r\n\r\n    export interface ChordTooltipData {\r\n        tooltipInfo: TooltipDataItem[];\r\n    }\r\n\r\n    export class ChordChart implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'From',\r\n                }, {\r\n                    name: 'Series',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'To',\r\n                }, {\r\n                    name: 'Y',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Values'),\r\n                }\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Series': { max: 0 } },\r\n                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },\r\n                    { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 } },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Series',\r\n                            select: [{ bind: { to: 'Y' } }],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        },\r\n                    },\r\n                    rowCount: { preferred: { min: 2 }, supported: { min: 1 } }\r\n                },\r\n            }],\r\n            objects: {\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\r\n                    properties: {\r\n                        defaultColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        showAllDataPoints: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                    },\r\n                },\r\n                axis: {\r\n                    displayName: 'Axis',\r\n                    properties: {\r\n                        show: {\r\n                            type: { bool: true }\r\n                        },\r\n                    },\r\n                },\r\n                labels: {\r\n                    displayName: 'Labels',\r\n                    properties: {\r\n                        show: {\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter(\"Visual_Reference_Line_Data_Label_Color\"),\r\n                            description: data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } },\r\n                        },\r\n                    },\r\n                }\r\n            }\r\n        };\r\n\r\n        public static chordChartProps = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{ objectName: 'general', propertyName: 'formatString' },\r\n            },\r\n            dataPoint: {\r\n                defaultColor: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'defaultColor' },\r\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\r\n                showAllDataPoints: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'showAllDataPoints' },\r\n            },\r\n            axis: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'axis', propertyName: 'show' },\r\n            },\r\n            labels: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\r\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\r\n            },\r\n        };\r\n\r\n        public static PolylineOpacity = 0.5;\r\n\r\n        private static OuterArcRadiusRatio = 0.9;\r\n        private static InnerArcRadiusRatio = 0.8;\r\n        private static DefaultLabelColor = \"#777777\";\r\n        private static DefaultLabelsFontSize = 12;\r\n\r\n        private static VisualClassName = 'chordChart';\r\n\r\n        private static sliceClass: ClassAndSelector = {\r\n            class: 'slice',\r\n            selector: '.slice',\r\n        };\r\n\r\n        private static chordClass: ClassAndSelector = {\r\n            class: 'chord',\r\n            selector: '.chord',\r\n        };\r\n\r\n        private static sliceTicksClass: ClassAndSelector = {\r\n            class: 'slice-ticks',\r\n            selector: '.slice-ticks'\r\n        };\r\n\r\n        private static tickPairClass: ClassAndSelector = {\r\n            class: 'tick-pair',\r\n            selector: '.tick-pair'\r\n        };\r\n\r\n        private static tickLineClass: ClassAndSelector = {\r\n            class: 'tick-line',\r\n            selector: '.tick-line'\r\n        };\r\n\r\n        private static tickTextClass: ClassAndSelector = {\r\n            class: 'tick-text',\r\n            selector: '.tick-text'\r\n        };\r\n\r\n        private static labelGraphicsContextClass: ClassAndSelector = {\r\n            class: 'labels',\r\n            selector: '.labels',\r\n        };\r\n\r\n        private static labelsClass: ClassAndSelector = {\r\n            class: 'data-labels',\r\n            selector: '.data-labels',\r\n        };\r\n\r\n        private static linesGraphicsContextClass: ClassAndSelector = {\r\n            class: 'lines',\r\n            selector: '.lines',\r\n        };\r\n\r\n        private static lineClass: ClassAndSelector = {\r\n            class: 'line-label',\r\n            selector: '.line-label',\r\n        };\r\n\r\n        private chordLayout: D3.Layout.ChordLayout;\r\n        private element: JQuery;\r\n\r\n        private svg: D3.Selection;\r\n        private mainGraphicsContext: D3.Selection;\r\n\r\n        private data: ChordChartData;\r\n        private colors: IDataColorPalette;\r\n        private selectionManager: utility.SelectionManager;\r\n        private dataView: DataView;\r\n        \r\n        /* Convert a DataView into a view model */\r\n        public static converter(dataView: DataView, colors: IDataColorPalette, prevAxisVisible: boolean): ChordChartData {\r\n            let catDv: DataViewCategorical = dataView.categorical;\r\n\r\n            let defaultDataPointColor: string = ChordChart.getDefaultDataPointColor(dataView).solid.color;\r\n            let labelColor = ChordChart.getLabelsColor(dataView);\r\n            let labelFontSize = ChordChart.getLabelsFontSize(dataView);\r\n\r\n            if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {\r\n\r\n                let cat: DataViewCategoryColumn = catDv.categories[0];\r\n                let catValues = cat.values;\r\n                let values = catDv.values;\r\n                let dataMatrix: number[][] = [];\r\n\r\n                let legendData: LegendData = {\r\n                    dataPoints: [],\r\n                    title: values[0] && values[0].source ? values[0].source.displayName : \"\",\r\n                };\r\n\r\n                let toolTipData: ChordTooltipData[][] = [];\r\n                let sliceTooltipData: ChordTooltipData[] = [];\r\n\r\n                let max: number = 1000;\r\n\r\n                let seriesName: string[] = [];  /* series name array */\r\n                let seriesIndex: number[] = []; /* series index array */\r\n\r\n                let catIndex: number[] = [];    /* index array for category names */\r\n\r\n                let isDiffFromTo: boolean = false;  /* boolean variable indicates that From and To are different */\r\n\r\n                let labelData: ChordArcLabelData[] = [];    /* label data: !important */\r\n\r\n                let colorHelper = new ColorHelper(colors,\r\n                    ChordChart.chordChartProps.dataPoint.fill,\r\n                    defaultDataPointColor);\r\n\r\n                for (let i: number = 0, iLen = catValues.length; i < iLen; i++) {\r\n                    catIndex[catValues[i]] = i;\r\n                }\r\n\r\n                for (let i: number = 0, iLen = values.length; i < iLen; i++) {\r\n                    let seriesNameStr: string = converterHelper.getSeriesName(values[i].source);\r\n\r\n                    seriesName.push(seriesNameStr);\r\n                    seriesIndex[seriesNameStr] = i;\r\n                }\r\n\r\n                let totalFields: any[] = this.union_arrays(catValues, seriesName);\r\n\r\n                if (ChordChart.getValidArrayLength(totalFields) ===\r\n                    ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName)) {\r\n                    isDiffFromTo = true;\r\n                }\r\n\r\n                let formatStringProp = ChordChart.chordChartProps.general.formatString;\r\n                let categorySourceFormatString = valueFormatter.getFormatString(cat.source, formatStringProp);\r\n\r\n                for (let i: number = 0, iLen = totalFields.length; i < iLen; i++) {\r\n                    let id: SelectionId = null;\r\n                    let color: string = '';\r\n                    let isCategory: boolean = false;\r\n\r\n                    if (catIndex[totalFields[i]] !== undefined) {\r\n                        let index = catIndex[totalFields[i]];\r\n                        id = SelectionIdBuilder\r\n                            .builder()\r\n                            .withCategory(cat, catIndex[totalFields[i]])\r\n                            .createSelectionId();\r\n                        isCategory = true;\r\n                        let thisCategoryObjects = cat.objects ? cat.objects[index] : undefined;\r\n\r\n                        color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues[index]);\r\n\r\n                    } else if (seriesIndex[totalFields[i]] !== undefined) {\r\n                        let index = seriesIndex[totalFields[i]];\r\n\r\n                        let seriesData = values[index];\r\n                        let seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];\r\n                        let seriesNameStr = converterHelper.getSeriesName(seriesData.source);\r\n\r\n                        id = SelectionId.createWithId(seriesData.identity);\r\n                        isCategory = false;\r\n\r\n                        color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);\r\n                    }\r\n\r\n                    labelData.push({\r\n                        label: totalFields[i],\r\n                        labelColor: labelColor,\r\n                        barColor: color,\r\n                        isCategory: isCategory,\r\n                        identity: id,\r\n                        selected: false\r\n                    });\r\n\r\n                    dataMatrix.push([]);\r\n                    toolTipData.push([]);\r\n\r\n                    let formattedCategoryValue = valueFormatter.format(catValues[i], categorySourceFormatString);\r\n\r\n                    for (let j = 0, jLen = totalFields.length; j < jLen; j++) {\r\n                        let elementValue: number = 0;\r\n                        let tooltipInfo: TooltipDataItem[] = [];\r\n\r\n                        if (catIndex[totalFields[i]] !== undefined &&\r\n                            seriesIndex[totalFields[j]] !== undefined) {\r\n                            let row: number = catIndex[totalFields[i]];\r\n                            let col: number = seriesIndex[totalFields[j]];\r\n                            if (values[col].values[row] !== null) {\r\n                                elementValue = values[col].values[row];\r\n\r\n                                if (elementValue > max)\r\n                                    max = elementValue;\r\n\r\n                                tooltipInfo = TooltipBuilder.createTooltipInfo(\r\n                                    formatStringProp,\r\n                                    catDv,\r\n                                    formattedCategoryValue,\r\n                                    elementValue,\r\n                                    null,\r\n                                    null,\r\n                                    col,\r\n                                    row);\r\n                            }\r\n                        } else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&\r\n                            seriesIndex[totalFields[i]] !== undefined) {\r\n                            let row: number = catIndex[totalFields[j]];\r\n                            let col: number = seriesIndex[totalFields[i]];\r\n                            if (values[col].values[row] !== null) {\r\n                                elementValue = values[col].values[row];\r\n                            }\r\n                        }\r\n\r\n                        dataMatrix[i].push(elementValue);\r\n                        toolTipData[i].push({\r\n                            tooltipInfo: tooltipInfo\r\n                        });\r\n                    }\r\n\r\n                    let totalSum = d3.sum(dataMatrix[i]);\r\n\r\n                    sliceTooltipData.push({\r\n                        tooltipInfo: [{\r\n                            displayName: totalFields[i],\r\n                            value: (ChordChart.isInt(totalSum)) ? totalSum.toFixed(0) : totalSum.toFixed(2)\r\n                        }]\r\n                    });\r\n                }\r\n\r\n                let chordLayout = d3.layout.chord()\r\n                    .padding(0.1)\r\n                    .matrix(dataMatrix);\r\n\r\n                let unitLength: number = Math.round(max / 5).toString().length - 1;\r\n\r\n                return {\r\n                    dataMatrix: dataMatrix,\r\n                    labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),\r\n                    legendData: legendData,\r\n                    tooltipData: toolTipData,\r\n                    sliceTooltipData: sliceTooltipData,\r\n                    tickUnit: Math.pow(10, unitLength),\r\n                    differentFromTo: isDiffFromTo,\r\n                    defaultDataPointColor: defaultDataPointColor,\r\n                    prevAxisVisible: prevAxisVisible,\r\n                    showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\r\n                    showLabels: ChordChart.getLabelsShow(dataView),\r\n                    showAxis: ChordChart.getAxisShow(dataView),\r\n                    labelFontSize: labelFontSize,\r\n                };\r\n            } else {\r\n                return {\r\n                    dataMatrix: [],\r\n                    labelDataPoints: [],\r\n                    legendData: null,\r\n                    tooltipData: [],\r\n                    sliceTooltipData: [],\r\n                    tickUnit: 1000,\r\n                    differentFromTo: false,\r\n                    defaultDataPointColor: defaultDataPointColor,\r\n                    prevAxisVisible: prevAxisVisible,\r\n                    showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),\r\n                    showLabels: ChordChart.getLabelsShow(dataView),\r\n                    showAxis: ChordChart.getAxisShow(dataView),\r\n                    labelFontSize: labelFontSize,\r\n                };\r\n            }\r\n        }\r\n\r\n        /* Check every element of the array and returns the count of elements which are valid(not undefined) */\r\n        public static getValidArrayLength(array: any[]): number {\r\n            let len = 0;\r\n            for (let i: number = 0, iLen = array.length; i < iLen; i++) {\r\n                if (array[i] !== undefined) {\r\n                    len++;\r\n                }\r\n            }\r\n            return len;\r\n        }\r\n\r\n        /* Convert ChordLayout to ChordArcDescriptor */\r\n        public static convertToChordArcDescriptor(groups: D3.Layout.ArcDescriptor[], datum: ChordArcLabelData[]): ChordArcDescriptor[] {\r\n            let labelDataPoints: ChordArcDescriptor[] = [];\r\n            for (let i: number = 0, iLen = groups.length; i < iLen; i++) {\r\n                let labelDataPoint: ChordArcDescriptor = groups[i];\r\n                labelDataPoint.data = datum[i];\r\n                labelDataPoints.push(labelDataPoint);\r\n            }\r\n\r\n            return labelDataPoints;\r\n        }\r\n\r\n        /* Calculate radius */\r\n        private calculateRadius(viewport: IViewport): number {\r\n            if (this.data && this.data.showLabels) {\r\n                // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.\r\n                // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.\r\n                let hw = viewport.height / viewport.width;\r\n                let denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));\r\n                return Math.min(viewport.height, viewport.width) / denom;\r\n            }\r\n\r\n            // no labels\r\n            return Math.min(viewport.height, viewport.width) / 2;\r\n        }\r\n        \r\n        /* Draw category labels */\r\n        public static drawDefaultCategoryLabels(graphicsContext: D3.Selection, chordData: ChordChartData, radius: number, viewport: IViewport): void {\r\n            /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */\r\n\r\n            let arc: D3.Svg.Arc = d3.svg.arc()\r\n                .innerRadius(0)\r\n                .outerRadius(radius * ChordChart.InnerArcRadiusRatio);\r\n\r\n            let outerArc: D3.Svg.Arc = d3.svg.arc()\r\n                .innerRadius(radius * ChordChart.OuterArcRadiusRatio)\r\n                .outerRadius(radius * ChordChart.OuterArcRadiusRatio);\r\n\r\n            if (chordData.showLabels) {\r\n                let labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);\r\n                ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints,\r\n                    graphicsContext,\r\n                    labelLayout, viewport,\r\n                    radius, arc, outerArc);\r\n            }\r\n            else\r\n                dataLabelUtils.cleanDataLabels(graphicsContext, true);\r\n        }\r\n\r\n        /* One time setup*/\r\n        public init(options: VisualInitOptions): void {\r\n            let element = this.element = options.element;\r\n            this.selectionManager = new utility.SelectionManager({ hostServices: options.host });\r\n\r\n            this.svg = d3.select(element.get(0))\r\n                .append('svg')\r\n                .style('position', 'absolute')\r\n                .classed(ChordChart.VisualClassName, true);\r\n\r\n            this.mainGraphicsContext = this.svg\r\n                .append('g');\r\n\r\n            this.mainGraphicsContext\r\n                .append('g')\r\n                .classed('slices', true);\r\n\r\n            this.mainGraphicsContext\r\n                .append('g')\r\n                .classed('ticks', true);\r\n\r\n            this.mainGraphicsContext\r\n                .append('g')\r\n                .classed('chords', true);\r\n\r\n            this.colors = options.style.colorPalette.dataColors;\r\n        }\r\n    \r\n        /* Called for data, size, formatting changes*/\r\n        public update(options: VisualUpdateOptions) {\r\n            // assert dataView           \r\n            if (!options.dataViews || !options.dataViews[0]) return;\r\n            \r\n            // get animation duration\r\n            let duration = options.suppressAnimations ? 0 : AnimatorCommon.MinervaAnimationDuration;\r\n\r\n            let dataView = this.dataView = options.dataViews[0];\r\n            let prevAxisShow: boolean = (this.data) ? this.data.showAxis : !ChordChart.getAxisShow(dataView);\r\n\r\n            let data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow);\r\n\r\n            let viewport = options.viewport;\r\n\r\n            let chordLayout = this.chordLayout = d3.layout.chord()\r\n                .padding(0.1)\r\n                //.sortGroups(d3.descending)\r\n                .matrix(data.dataMatrix);\r\n\r\n            let width = viewport.width;\r\n            let height = viewport.height;\r\n\r\n            let radius = this.calculateRadius(viewport);\r\n            let sm = this.selectionManager;\r\n\r\n            let innerRadius: number = radius;\r\n            let outerRadius: number = radius * ChordChart.InnerArcRadiusRatio;\r\n\r\n            let arc: D3.Svg.Arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);\r\n\r\n            this.svg\r\n                .attr({\r\n                    'width': width,\r\n                    'height': height\r\n                });\r\n\r\n            let mainGraphicsContext = this.mainGraphicsContext\r\n                .attr('transform', SVGUtil.translate(width / 2, height / 2));\r\n\r\n            let sliceShapes = this.svg.select('.slices')\r\n                .selectAll('path' + ChordChart.sliceClass.selector)\r\n                .data(chordLayout.groups);\r\n\r\n            sliceShapes.enter()\r\n                .insert(\"path\")\r\n                .classed(ChordChart.sliceClass.class, true);\r\n\r\n            sliceShapes.style('fill', (d, i) => data.labelDataPoints[i].data.barColor)\r\n                .style(\"stroke\", (d, i) => data.labelDataPoints[i].data.barColor)\r\n                .on('click', function(d, i) {\r\n                    sm.select(data.labelDataPoints[i].data.identity).then(ids=> {\r\n                        if (ids.length > 0) {\r\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\r\n                                .style(\"opacity\", 1);\r\n\r\n                            mainGraphicsContext.selectAll(\".slices path.slice\")\r\n                                .style('opacity', 0.3);\r\n\r\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\r\n                                .filter(function(d) { return d.source.index !== i && d.target.index !== i; })\r\n                                .style(\"opacity\", 0.3);\r\n\r\n                            d3.select(this).style('opacity', 1);\r\n                        } else {\r\n                            sliceShapes.style('opacity', 1);\r\n                            mainGraphicsContext.selectAll(\".chords path.chord\")\r\n                                .filter(function(d) { return d.source.index !== i && d.target.index !== i; })\r\n                                .style(\"opacity\", 1);\r\n                        }\r\n                    });\r\n\r\n                    d3.event.stopPropagation();\r\n                })\r\n                .transition()\r\n                .duration(duration)\r\n                .attr(\"d\", arc);\r\n\r\n            sliceShapes.exit()\r\n                .remove();\r\n\r\n            TooltipManager.addTooltip(sliceShapes, (tooltipEvent: TooltipEvent) => {\r\n                return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;\r\n            });\r\n\r\n            let chordShapes = this.svg.select('.chords')\r\n                .selectAll('path' + ChordChart.chordClass.selector)\r\n                .data(chordLayout.chords);\r\n\r\n            chordShapes\r\n                .enter().insert(\"path\")\r\n                .classed(ChordChart.chordClass.class, true);\r\n\r\n            chordShapes.style(\"fill\", (d, i) => data.labelDataPoints[d.target.index].data.barColor)\r\n                .style(\"opacity\", 1)\r\n                .transition()\r\n                .duration(duration)\r\n                .attr(\"d\", d3.svg.chord().radius(innerRadius));\r\n\r\n            chordShapes.exit()\r\n                .remove();\r\n\r\n            this.svg\r\n                .on('click', () => this.selectionManager.clear().then(() => {\r\n                    sliceShapes.style('opacity', 1);\r\n                    chordShapes.style('opacity', 1);\r\n                }));\r\n\r\n            ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport);\r\n            ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport);\r\n\r\n            TooltipManager.addTooltip(chordShapes, (tooltipEvent: TooltipEvent) => {\r\n                let tooltipInfo: TooltipDataItem[] = [];\r\n                if (data.differentFromTo) {\r\n                    tooltipInfo = data.tooltipData[tooltipEvent.data.source.index]\r\n                    [tooltipEvent.data.source.subindex]\r\n                        .tooltipInfo;\r\n                } else {\r\n                    tooltipInfo.push({\r\n                        displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label\r\n                        + '->' + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,\r\n                        value: data.dataMatrix[tooltipEvent.data.source.index]\r\n                        [tooltipEvent.data.source.subindex].toString()\r\n                    });\r\n                    tooltipInfo.push({\r\n                        displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label\r\n                        + '->' + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,\r\n                        value: data.dataMatrix[tooltipEvent.data.target.index]\r\n                        [tooltipEvent.data.target.subindex].toString()\r\n                    });\r\n                }\r\n                return tooltipInfo;\r\n            });\r\n        }\r\n\r\n        /*About to remove your visual, do clean up here */\r\n        public destroy() {\r\n\r\n        }\r\n\r\n        /* Clean ticks */\r\n        public static cleanTicks(context: D3.Selection) {\r\n            let empty = [];\r\n            let tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);\r\n            tickLines.exit().remove();\r\n\r\n            let tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);\r\n            tickTexts.exit().remove();\r\n\r\n            context.selectAll(ChordChart.tickPairClass.selector).remove();\r\n            context.selectAll(ChordChart.sliceTicksClass.selector).remove();\r\n        }\r\n        \r\n        /* Draw axis(ticks) around the arc */\r\n        public static drawTicks(graphicsContext: D3.Selection, chordData: ChordChartData, chordLayout: D3.Layout.ChordLayout, outerRadius: number, duration: number, viewport: IViewport): void {\r\n\r\n            if (chordData.showAxis) {\r\n                let tickShapes = graphicsContext.select('.ticks')\r\n                    .selectAll('g' + ChordChart.sliceTicksClass.selector)\r\n                    .data(chordLayout.groups);\r\n                let animDuration = (chordData.prevAxisVisible === chordData.showAxis) ? duration : 0;\r\n\r\n                tickShapes.enter().insert('g')\r\n                    .classed(ChordChart.sliceTicksClass.class, true);\r\n\r\n                let tickPairs = tickShapes.selectAll('g' + ChordChart.tickPairClass.selector)\r\n                    .data(function(d) {\r\n                        let k = (d.endAngle - d.startAngle) / d.value;\r\n                        let range = d3.range(0, d.value, d.value - 1 < 0.15 ? 0.15 : d.value - 1);\r\n                        let retval =\r\n                            range.map(function(v, i) {\r\n                                let divider: number = 1000;\r\n                                let unitStr: string = 'k';\r\n\r\n                                if (chordData.tickUnit >= 1000 * 1000) {\r\n                                    divider = 1000 * 1000;\r\n                                    unitStr = 'm';\r\n                                }\r\n                                else if (chordData.tickUnit >= 1000) {\r\n                                    divider = 1000;\r\n                                    unitStr = 'k';\r\n                                } else {\r\n                                    divider = 1;\r\n                                    unitStr = '';\r\n                                }\r\n                                let retv =\r\n                                    {\r\n                                        angle: v * k + d.startAngle,\r\n                                        label: Math.floor(v / divider) + unitStr\r\n                                    };\r\n                                return retv;\r\n\r\n                            });\r\n                        return retval;\r\n                    });\r\n\r\n                tickPairs.enter().insert('g')\r\n                    .classed(ChordChart.tickPairClass.class, true);\r\n\r\n                tickPairs.transition()\r\n                    .duration(animDuration)\r\n                    .attr('transform', function(d) {\r\n                        return 'rotate(' + (d.angle * 180 / Math.PI - 90) + ')'\r\n                            + 'translate(' + outerRadius + ',0)';\r\n                    });\r\n\r\n                tickPairs.selectAll('line' + ChordChart.tickLineClass.selector)\r\n                    .data((d) => [d])\r\n                    .enter().insert('line')\r\n                    .classed(ChordChart.tickLineClass.class, true)\r\n                    .style(\"stroke\", \"#000\")\r\n                    .attr(\"x1\", 1)\r\n                    .attr(\"y1\", 0)\r\n                    .attr(\"x2\", 5)\r\n                    .attr(\"y2\", 0);\r\n\r\n                tickPairs.selectAll('text' + ChordChart.tickTextClass.selector)\r\n                    .data((d) => [d])\r\n                    .enter().insert('text')\r\n                    .classed(ChordChart.tickTextClass.class, true)\r\n                    .style(\"text-anchor\", function(d) { return d.angle > Math.PI ? \"end\" : null; })\r\n                    .text(function(d) { return d.label; })\r\n                    .attr(\"transform\", function(d) { return d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null; })\r\n                    .attr(\"x\", 8)\r\n                    .attr(\"dy\", \".35em\");\r\n\r\n                tickPairs.exit()\r\n                    .remove();\r\n\r\n                tickShapes.exit()\r\n                    .remove();\r\n\r\n            } else {\r\n                ChordChart.cleanTicks(graphicsContext);\r\n            }\r\n\r\n        }\r\n\r\n        /* Get format parameter axis whether it determines show ticks or not. Default value is true */\r\n        private static getAxisShow(dataView: DataView): boolean {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n                if (objects) {\r\n                    let axis = objects['axis'];\r\n                    if (axis && axis.hasOwnProperty('show')) {\r\n                        return <boolean>axis['show'];\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        /* Get format parameter labels whether it determines show labels or not. Default value is true */\r\n        private static getLabelsShow(dataView: DataView): boolean {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n                if (objects) {\r\n                    let labels = objects['labels'];\r\n                    if (labels && labels.hasOwnProperty('show')) {\r\n                        return <boolean>labels['show'];\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        /* Get format parameter labels whether it determines show labels or not. Default value is true */\r\n        private static getLabelsColor(dataView: DataView): string {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n                if (objects) {\r\n                    let labels = objects['labels'];\r\n                    if (labels && labels.hasOwnProperty('color'))\r\n                        return labels['color'].solid.color;\r\n                }\r\n            }\r\n            return ChordChart.DefaultLabelColor;\r\n        }\r\n\r\n        private static getLabelsFontSize(dataView: DataView): number {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n                if (objects) {\r\n                    let labels = objects['labels'];\r\n                    if (labels && labels.hasOwnProperty('fontSize'))\r\n                        return labels['fontSize'];\r\n                }\r\n            }\r\n            return ChordChart.DefaultLabelsFontSize;\r\n        }\r\n       \r\n        /* Select labels */\r\n        public static selectLabels(filteredData: LabelEnabledDataPoint[], context: D3.Selection, isDonut: boolean = false, forAnimation: boolean = false): D3.UpdateSelection {\r\n\r\n            // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'\r\n            if (filteredData.length === 0) {\r\n                dataLabelUtils.cleanDataLabels(context, true);\r\n                return null;\r\n            }\r\n\r\n            if (context.select(ChordChart.labelGraphicsContextClass.selector).empty())\r\n                context.append('g').classed(ChordChart.labelGraphicsContextClass.class, true);\r\n\r\n            // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity\r\n            let hasKey: boolean = (<any>filteredData)[0].key !== null;\r\n            let hasDataPointIdentity: boolean = (<any>filteredData)[0].identity !== null;\r\n            let getIdentifier = hasKey ?\r\n                (d: any) => d.key\r\n                : hasDataPointIdentity ?\r\n                    (d: SelectableDataPoint) => d.identity.getKey()\r\n                    : undefined;\r\n\r\n            let labels = isDonut ?\r\n                context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, (d: DonutArcDescriptor) => d.data.identity.getKey())\r\n                : getIdentifier !== null ?\r\n                    context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)\r\n                    : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData);\r\n\r\n            let newLabels = labels.enter()\r\n                .append('text')\r\n                .classed(ChordChart.labelsClass.class, true);\r\n            if (forAnimation)\r\n                newLabels.style('opacity', 0);\r\n\r\n            return labels;\r\n        }\r\n        \r\n        /* Draw labels */\r\n        public static drawDefaultLabelsForChordChart(data: any[], context: D3.Selection, layout: ILabelLayout, viewport: IViewport, radius: number, arc: D3.Svg.Arc, outerArc: D3.Svg.Arc) {\r\n            // Hide and reposition labels that overlap\r\n            let dataLabelManager = new DataLabelManager();\r\n            let filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout,/* addTransform */ true);\r\n\r\n            let labels: D3.UpdateSelection = ChordChart.selectLabels(filteredData, context, true);\r\n\r\n            if (!labels) {\r\n                return;\r\n            }\r\n\r\n            labels\r\n                .attr({ x: (d: LabelEnabledDataPoint) => d.labelX, y: (d: LabelEnabledDataPoint) => d.labelY, dy: '.35em' })\r\n                .text((d: LabelEnabledDataPoint) => d.labeltext)\r\n                .style(layout.style);\r\n\r\n            labels\r\n                .exit()\r\n                .remove();\r\n\r\n            if (context.select(ChordChart.linesGraphicsContextClass.selector).empty()) {\r\n                context\r\n                    .append('g')\r\n                    .classed(ChordChart.linesGraphicsContextClass.class, true);\r\n            }\r\n\r\n            let lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll('polyline')\r\n                .data(filteredData, (d: ChordArcDescriptor) => d.data.identity.getKey());\r\n            let innerLinePointMultiplier = 2.05;\r\n\r\n            let midAngle = function(d: ChordArcDescriptor) {\r\n                return d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n            };\r\n\r\n            lines.enter()\r\n                .append('polyline')\r\n                .classed(ChordChart.lineClass.class, true);\r\n\r\n            lines\r\n                .attr('points', function(d) {\r\n                    let textPoint = outerArc.centroid(d);\r\n                    textPoint[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);\r\n                    let midPoint = outerArc.centroid(d);\r\n                    let chartPoint = arc.centroid(d);\r\n                    chartPoint[0] *= innerLinePointMultiplier;\r\n                    chartPoint[1] *= innerLinePointMultiplier;\r\n                    return [chartPoint, midPoint, textPoint];\r\n                }).\r\n                style({\r\n                    'opacity': (d: ChordArcDescriptor) => ChordChart.PolylineOpacity,\r\n                    'stroke': (d: ChordArcDescriptor) => d.data.labelColor,\r\n                });\r\n\r\n            lines\r\n                .exit()\r\n                .remove();\r\n        }\r\n        \r\n        /* Get label layout */\r\n        public static getChordChartLabelLayout(radius: number, outerArc: D3.Svg.Arc, viewport: IViewport, labelFontSize: number): ILabelLayout {\r\n            let midAngle = function(d: ChordArcDescriptor) {\r\n                return d.startAngle + (d.endAngle - d.startAngle) / 2;\r\n            };\r\n\r\n            let spaceAvaliableForLabels: number = viewport.width / 2 - radius;\r\n            let minAvailableSpace: number = Math.min(spaceAvaliableForLabels, dataLabelUtils.maxLabelWidth);\r\n            var PixelConverter = jsCommon.PixelConverter;\r\n\r\n            return {\r\n                labelText: (d: DonutArcDescriptor) => {\r\n                    // show only category label\r\n                    return dataLabelUtils.getLabelFormattedText({\r\n                        label: d.data.label,\r\n                        maxWidth: minAvailableSpace,\r\n                        fontSize: labelFontSize,\r\n                    });\r\n                },\r\n                labelLayout: {\r\n                    x: (d: ChordArcDescriptor) => {\r\n                        return radius * (midAngle(d) < Math.PI ? 1 : -1);\r\n                    },\r\n                    y: (d: ChordArcDescriptor) => {\r\n                        let pos = outerArc.centroid(d);\r\n                        return pos[1];\r\n                    },\r\n                },\r\n                filter: (d: ChordArcDescriptor) => (d !== null && d.data !== null && d.data.label !== null),\r\n                style: {\r\n                    'fill': (d: ChordArcDescriptor) => d.data.labelColor,\r\n                    'text-anchor': (d: ChordArcDescriptor) => midAngle(d) < Math.PI ? 'start' : 'end',\r\n                    'font-size': (d: ChordArcDescriptor) => PixelConverter.fromPointToPixel(labelFontSize),\r\n                },\r\n            };\r\n        }\r\n        \r\n        /* Get Default Datapoint color */\r\n        private static getDefaultDataPointColor(dataView: DataView, defaultValue?: string): Fill {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n                if (objects) {\r\n                    let dataPoint = objects['dataPoint'];\r\n                    if (dataPoint && dataPoint.hasOwnProperty('defaultColor')) {\r\n                        let defaultColor = <Fill>dataPoint['defaultColor'];\r\n                        if (defaultColor) {\r\n                            return defaultColor;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return { solid: { color: defaultValue } };\r\n        }\r\n\r\n        /* Get format paramter value (showAllDataPoints)  */\r\n        private static getShowAllDataPoints(dataView: DataView): boolean {\r\n            if (!dataView || !dataView.metadata || !dataView.metadata.objects)\r\n                return false;\r\n\r\n            let objects: DataViewObjects = dataView.metadata.objects;\r\n            let dataPoint = objects['dataPoint'];\r\n            if (dataPoint && dataPoint.hasOwnProperty('showAllDataPoints')) {\r\n                return <boolean>dataPoint['showAllDataPoints'];\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /* Enumerate format values */\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            let instances: VisualObjectInstance[] = [];\r\n            let axis: VisualObjectInstance;\r\n\r\n            switch (options.objectName) {\r\n                case 'axis':\r\n                    axis = {\r\n                        objectName: 'axis',\r\n                        displayName: 'Axis',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: ChordChart.getAxisShow(this.dataView)\r\n                        }\r\n                    };\r\n\r\n                    instances.push(axis);\r\n                    break;\r\n                case 'labels':\r\n                    axis = {\r\n                        objectName: 'labels',\r\n                        displayName: 'Labels',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: ChordChart.getLabelsShow(this.dataView),\r\n                            color: ChordChart.getLabelsColor(this.dataView),\r\n                            fontSize: ChordChart.getLabelsFontSize(this.dataView),\r\n                        }\r\n                    };\r\n                    instances.push(axis);\r\n                    break;\r\n                case 'dataPoint':\r\n                    let defaultColor: VisualObjectInstance = {\r\n                        objectName: 'dataPoint',\r\n                        selector: null,\r\n                        properties: {\r\n                            defaultColor: {\r\n                                solid: { color: (this.data && this.data.defaultDataPointColor) ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value }\r\n                            }\r\n                        }\r\n                    };\r\n\r\n                    instances.push(defaultColor);\r\n\r\n                    let showAllDataPoints: VisualObjectInstance = {\r\n                        objectName: 'dataPoint',\r\n                        selector: null,\r\n                        properties: {\r\n                            showAllDataPoints: this.data ? !!this.data.showAllDataPoints : false,\r\n                        }\r\n                    };\r\n\r\n                    instances.push(showAllDataPoints);\r\n\r\n                    if (this.data && this.data.labelDataPoints) {\r\n                        for (let i: number = 0, iLen = this.data.labelDataPoints.length; i < iLen; i++) {\r\n                            let labelDataPoint: ChordArcLabelData = this.data.labelDataPoints[i].data;\r\n\r\n                            if (labelDataPoint.isCategory) {\r\n                                let colorInstance: VisualObjectInstance = {\r\n                                    objectName: 'dataPoint',\r\n                                    displayName: labelDataPoint.label,\r\n                                    selector: ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),\r\n                                    properties: {\r\n                                        fill: { solid: { color: labelDataPoint.barColor } }\r\n                                    }\r\n                                };\r\n\r\n                                instances.push(colorInstance);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n            return instances;\r\n        }\r\n\r\n        /* Utility function for checking if it is integer or float */\r\n        public static isInt(n: number): boolean {\r\n            return n % 1 === 0;\r\n        }\r\n        \r\n        /* Utility function for union two arrays without duplicates */\r\n        public static union_arrays(x: any[], y: any[]): any[] {\r\n            let obj: Object = {};\r\n\r\n            for (let i: number = 0; i < x.length; i++) {\r\n                obj[x[i]] = x[i];\r\n            }\r\n\r\n            for (let i: number = 0; i < y.length; i++) {\r\n                obj[y[i]] = y[i];\r\n            }\r\n\r\n            let res: string[] = [];\r\n\r\n            for (let k in obj) {\r\n                if (obj.hasOwnProperty(k)) {  // <-- optional\r\n                    res.push(obj[k]);\r\n                }\r\n            }\r\n            return res;\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/chordChart/visual/chordChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    interface ScatterChartMeasureMetadata {\r\n        idx: {\r\n            x?: number;\r\n            y?: number;\r\n            size?: number;\r\n            colorFill?: number;\r\n            shape?: number;\r\n            image?: number;\r\n            rotation?: number;\r\n            backdrop?: number;\r\n            xStart?: number;\r\n            xEnd?: number;\r\n            yStart?: number;\r\n            yEnd?: number;\r\n        };\r\n        cols: {\r\n            x?: DataViewMetadataColumn;\r\n            y?: DataViewMetadataColumn;\r\n            size?: DataViewMetadataColumn;\r\n            colorFill?: DataViewMetadataColumn;\r\n            shape?: DataViewMetadataColumn;\r\n            image?: DataViewMetadataColumn;\r\n            rotation?: DataViewMetadataColumn;\r\n            backdrop?: DataViewMetadataColumn;\r\n            xStart?: DataViewMetadataColumn;\r\n            xEnd?: DataViewMetadataColumn;\r\n            yStart?: DataViewMetadataColumn;\r\n            yEnd?: DataViewMetadataColumn;\r\n        };\r\n        axesLabels: ChartAxesLabels;\r\n    }\r\n\r\n    export interface EnhancedScatterChartDataPoint extends SelectableDataPoint, TooltipEnabledDataPoint {\r\n        x: any;\r\n        y: any;\r\n        size: any;\r\n        radius: RadiusData;\r\n        fill: string;\r\n        labelFill?: string;\r\n        labelFontSize: any;\r\n        contentPosition: ContentPositions;\r\n        formattedCategory: jsCommon.Lazy<string>;\r\n        colorFill?: string;\r\n        svgurl?: string;\r\n        shapeSymbolType?: (number) => string;\r\n        rotation: number;\r\n        backdrop?: string;\r\n        xStart?: number;\r\n        xEnd?: number;\r\n        yStart?: number;\r\n        yEnd?: number;\r\n    }\r\n\r\n    export interface EnhancedScatterChartData extends ScatterBehaviorChartData {\r\n        useShape: boolean;\r\n        useCustomColor: boolean;\r\n        backdrop?: {\r\n            show: boolean;\r\n            url: string;\r\n        };\r\n        outline?: boolean;\r\n        crosshair?: boolean;\r\n        xCol: DataViewMetadataColumn;\r\n        yCol: DataViewMetadataColumn;\r\n        dataPoints: EnhancedScatterChartDataPoint[];\r\n        legendData: LegendData;\r\n        axesLabels: ChartAxesLabels;\r\n        size?: DataViewMetadataColumn;\r\n        sizeRange: NumberRange;\r\n        dataLabelsSettings: PointDataLabelsSettings;\r\n        defaultDataPointColor?: string;\r\n        showAllDataPoints?: boolean;\r\n        hasDynamicSeries?: boolean;\r\n        fillPoint?: boolean;\r\n        colorBorder?: boolean;\r\n        colorByCategory?: boolean;\r\n        selectedIds: SelectionId[];\r\n    }\r\n\r\n    export class EnhancedScatterChart implements IVisual {\r\n        private AxisGraphicsContextClassName = 'axisGraphicsContext';\r\n        public static DefaultBubbleOpacity = 0.85;\r\n        public static DimmedBubbleOpacity = 0.4;\r\n        private static ClassName = 'enhancedScatterChart';\r\n        private static MainGraphicsContextClassName = 'mainGraphicsContext';\r\n        private static LegendLabelFontSizeDefault: number = 9;\r\n        private static LabelDisplayUnitsDefault: number = 0;\r\n        private static AxisFontSize = 11;\r\n\r\n        private static DotClasses: ClassAndSelector = {\r\n            class: 'dot',\r\n            selector: '.dot'\r\n        };\r\n        private static ImageClasses: ClassAndSelector = {\r\n            class: 'img',\r\n            selector: '.img'\r\n        };\r\n\r\n        private legend: ILegend;\r\n        private svgScrollable: D3.Selection;\r\n        private axisGraphicsContext: D3.Selection;\r\n        private axisGraphicsContextScrollable: D3.Selection;\r\n        private xAxisGraphicsContext: D3.Selection;\r\n        private backgroundGraphicsContext: D3.Selection;\r\n        private y1AxisGraphicsContext: D3.Selection;\r\n        private svg: D3.Selection;\r\n        private element: JQuery;\r\n        private mainGraphicsContext: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private mainGraphicsG: D3.Selection;\r\n\r\n        private style: IVisualStyle;\r\n        private data: EnhancedScatterChartData;\r\n        private dataView: DataView;\r\n\r\n        private xAxisProperties: IAxisProperties;\r\n        private yAxisProperties: IAxisProperties;\r\n        private colors: IDataColorPalette;\r\n        private options: VisualInitOptions;\r\n        private interactivity: InteractivityOptions;\r\n        private interactivityService: IInteractivityService;\r\n        private categoryAxisProperties: DataViewObject;\r\n        private valueAxisProperties: DataViewObject;\r\n        private yAxisOrientation: string;\r\n        private scrollY: boolean;\r\n        private scrollX: boolean;\r\n\r\n        private dataViews: DataView[];\r\n        private legendObjectProperties: DataViewObject;\r\n        private hostServices: IVisualHostServices;\r\n        private layerLegendData: LegendData;\r\n        private legendLabelFontSize: number;\r\n        private cartesianSmallViewPortProperties: CartesianSmallViewPortProperties;\r\n        private hasCategoryAxis: boolean;\r\n        private yAxisIsCategorical: boolean;\r\n        private bottomMarginLimit: number;\r\n        private leftRightMarginLimit: number;\r\n        private isXScrollBarVisible: boolean;\r\n        private isYScrollBarVisible: boolean;\r\n        private ScrollBarWidth = 10;\r\n        private categoryAxisHasUnitType: boolean;\r\n        private valueAxisHasUnitType: boolean;\r\n        private svgDefaultImage: string;\r\n        private oldBackdrop: string;\r\n        private textProperties: TextProperties = {\r\n            fontFamily: 'wf_segoe-ui_normal',\r\n            fontSize: PixelConverter.toString(EnhancedScatterChart.AxisFontSize),\r\n        };\r\n        private behavior: IInteractiveBehavior;\r\n        private animator: IGenericAnimator;\r\n        private keyArray: string[];\r\n\r\n        private _margin: IMargin;\r\n        private get margin(): IMargin {\r\n            return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };\r\n        }\r\n\r\n        private set margin(value: IMargin) {\r\n            this._margin = $.extend({}, value);\r\n            this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\r\n        }\r\n\r\n        private _viewport: IViewport;\r\n        private get viewport(): IViewport {\r\n            return this._viewport || { width: 0, height: 0 };\r\n        }\r\n\r\n        private set viewport(value: IViewport) {\r\n            this._viewport = $.extend({}, value);\r\n            this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);\r\n        }\r\n\r\n        private _viewportIn: IViewport;\r\n        private get viewportIn(): IViewport {\r\n            return this._viewportIn || this.viewport;\r\n        }\r\n\r\n        private get legendViewport(): IViewport {\r\n            return this.legend.getMargins();\r\n        }\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Details'),\r\n                }, {\r\n                    name: 'Series',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Legend'),\r\n                }, {\r\n                    name: 'X',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_X'),\r\n                }, {\r\n                    name: 'Y',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Y'),\r\n                }, {\r\n                    name: 'Size',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Size'),\r\n                }, {\r\n                    name: 'Gradient',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Gradient'),\r\n                }, {\r\n                    name: 'ColorFill',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Customized Color',\r\n                }, {\r\n                    name: 'Shape',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Shape',\r\n                }, {\r\n                    name: 'Image',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Image',\r\n                }, {\r\n                    name: 'Rotation',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Rotation',\r\n                }, {\r\n                    name: 'Backdrop',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Backdrop',\r\n                }, {\r\n                    name: 'X Start',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'X Start',\r\n                }, {\r\n                    name: 'X End',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'X End',\r\n                }, {\r\n                    name: 'Y Start',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Y Start',\r\n                }, {\r\n                    name: 'Y End',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Y End',\r\n                }\r\n            ],\r\n\r\n            dataViewMappings: [{\r\n                conditions: [{\r\n                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\r\n                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\r\n                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\r\n                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\r\n                }, {\r\n                        'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\r\n                        'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },\r\n                        'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\r\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\r\n                    }, {\r\n                        'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },\r\n                        'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\r\n                        'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\r\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\r\n                    }, {\r\n                        'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },\r\n                        'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },\r\n                        'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },\r\n                        'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }\r\n                    }],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { sample: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Series',\r\n                            select: [\r\n                                { bind: { to: 'X' } },\r\n                                { bind: { to: 'Y' } },\r\n                                { bind: { to: 'Size' } },\r\n                                { bind: { to: 'Gradient' } },\r\n                                { bind: { to: 'ColorFill' } },\r\n                                { bind: { to: 'Shape' } },\r\n                                { bind: { to: 'Image' } },\r\n                                { bind: { to: 'Rotation' } },\r\n                                { bind: { to: 'Backdrop' } },\r\n                                { bind: { to: 'X Start' } },\r\n                                { bind: { to: 'X End' } },\r\n                                { bind: { to: 'Y Start' } },\r\n                                { bind: { to: 'Y End' } },\r\n                            ],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        }\r\n                    },\r\n                    rowCount: { preferred: { min: 2 } }\r\n                },\r\n            }],\r\n\r\n            objects: {\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\r\n                    properties: {\r\n                        defaultColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        showAllDataPoints: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\r\n                            type: { bool: true }\r\n                        },\r\n                        useShape: {\r\n                            displayName: data.createDisplayNameGetter('Visual_UseImage'),\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fillRule: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\r\n                            type: { fillRule: {} },\r\n                            rule: {\r\n                                inputRole: 'Gradient',\r\n                                output: {\r\n                                    property: 'fill',\r\n                                    selector: ['Category'],\r\n                                },\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                categoryAxis: {\r\n                    displayName: data.createDisplayNameGetter('Visual_XAxis'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        axisScale: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\r\n                            type: { formatting: { axisScale: true } }\r\n                        },\r\n                        start: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        end: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\r\n                            type: { bool: true }\r\n                        },\r\n                        axisStyle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\r\n                            type: { formatting: { axisStyle: true } }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: 'Display Units',\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                        },\r\n                    }\r\n                },\r\n                valueAxis: {\r\n                    displayName: data.createDisplayNameGetter('Visual_YAxis'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_YAxis_Position'),\r\n                            type: { formatting: { yAxisPosition: true } }\r\n                        },\r\n                        axisScale: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Scale'),\r\n                            type: { formatting: { axisScale: true } }\r\n                        },\r\n                        start: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Start'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        end: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_End'),\r\n                            type: { numeric: true }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Title'),\r\n                            type: { bool: true }\r\n                        },\r\n                        axisStyle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Axis_Style'),\r\n                            type: { formatting: { axisStyle: true } }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: 'Display Units',\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                        }\r\n                    }\r\n                },\r\n                legend: {\r\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\r\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\r\n                            type: { enumeration: legendPosition.type },\r\n                        },\r\n                        showTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\r\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: 'Legend Name',\r\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\r\n                            type: { text: true }\r\n                        },\r\n                        labelColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                categoryLabels: {\r\n                    displayName: data.createDisplayNameGetter('Visual_CategoryLabels'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    },\r\n                },\r\n                fillPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_FillPoint'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { bool: true }\r\n                        },\r\n                    },\r\n                },\r\n                backdrop: {\r\n                    displayName: 'Backdrop',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        url: {\r\n                            displayName: 'Image URL',\r\n                            type: { text: true }\r\n                        },\r\n                    },\r\n                },\r\n                crosshair: {\r\n                    displayName: 'Crosshair',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Crosshair',\r\n                            type: { bool: true }\r\n                        },\r\n                    },\r\n                },\r\n                outline: {\r\n                    displayName: 'Outline',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Outline'),\r\n                            type: { bool: true }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private static substractMargin(viewport: IViewport, margin: IMargin): IViewport {\r\n            return {\r\n                width: Math.max(viewport.width - (margin.left + margin.right), 0),\r\n                height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\r\n            };\r\n        }\r\n\r\n        private static getCustomSymbolType(shape: any): (number) => string {\r\n            let customSymbolTypes = d3.map({\r\n                \"circle\": (size) => {\r\n                    let r = Math.sqrt(size / Math.PI);\r\n                    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + (-r) + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\r\n                },\r\n\r\n                \"cross\": function (size) {\r\n                    let r = Math.sqrt(size / 5) / 2;\r\n                    return \"M\" + -3 * r + \",\" + -r\r\n                        + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\r\n                },\r\n\r\n                \"diamond\": (size) => {\r\n                    let ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))),\r\n                        rx = ry * Math.tan(Math.PI / 6);\r\n                    return \"M0,\" + -ry\r\n                        + \"L\" + rx + \",0\"\r\n                        + \" 0,\" + ry\r\n                        + \" \" + -rx + \",0\"\r\n                        + \"Z\";\r\n                },\r\n\r\n                \"square\": (size) => {\r\n                    let r = Math.sqrt(size) / 2;\r\n                    return \"M\" + -r + \",\" + -r\r\n                        + \"L\" + r + \",\" + -r\r\n                        + \" \" + r + \",\" + r\r\n                        + \" \" + -r + \",\" + r\r\n                        + \"Z\";\r\n                },\r\n\r\n                \"triangle-up\": (size) => {\r\n                    let rx = Math.sqrt(size / Math.sqrt(3)),\r\n                        ry = rx * Math.sqrt(3) / 2;\r\n                    return \"M0,\" + -ry\r\n                        + \"L\" + rx + \",\" + ry\r\n                        + \" \" + -rx + \",\" + ry\r\n                        + \"Z\";\r\n                },\r\n\r\n                \"triangle-down\": (size) => {\r\n                    let rx = Math.sqrt(size / Math.sqrt(3)),\r\n                        ry = rx * Math.sqrt(3) / 2;\r\n                    return \"M0,\" + ry\r\n                        + \"L\" + rx + \",\" + -ry\r\n                        + \" \" + -rx + \",\" + -ry\r\n                        + \"Z\";\r\n                },\r\n\r\n                'star': (size) => {\r\n                    let outerRadius = Math.sqrt(size / 2);\r\n                    let innerRadius = Math.sqrt(size / 10);\r\n                    let results = \"\";\r\n                    let angle = Math.PI / 5;\r\n                    for (let i = 0; i < 10; i++) {\r\n                        // Use outer or inner radius depending on what iteration we are in.\r\n                        let r = (i & 1) === 0 ? outerRadius : innerRadius;\r\n                        let currX = Math.cos(i * angle) * r;\r\n                        let currY = Math.sin(i * angle) * r;\r\n                        // Our first time we simply append the coordinates, subsequet times\r\n                        // we append a \", \" to distinguish each coordinate pair.\r\n                        if (i === 0) {\r\n                            results = \"M\" + currX + \",\" + currY + \"L\";\r\n                        } else {\r\n                            results += \" \" + currX + \",\" + currY;\r\n                        }\r\n                    }\r\n                    return results + \"Z\";\r\n                },\r\n\r\n                'hexagon': (size) => {\r\n                    let r = Math.sqrt(size / (6 * Math.sqrt(3)));\r\n                    let r2 = Math.sqrt(size / (2 * Math.sqrt(3)));\r\n\r\n                    return \"M0,\" + (2 * r) + \"L\" + (-r2) + \",\" + r + \" \" + (-r2) + \",\" + (-r) + \" 0,\" + (-2 * r) + \" \" + r2 + \",\" + (-r) + \" \" + r2 + \",\" + r + \"Z\";\r\n                },\r\n\r\n                'x': (size) => {\r\n                    let r = Math.sqrt(size / 10);\r\n                    return \"M0,\" + r + \"L\" + (-r) + \",\" + 2 * r + \" \" + (-2 * r) + \",\" + r + \" \" + (-r) + \",0 \" + (-2 * r) + \",\" + (-r) + \" \" + (-r) + \",\" + (-2 * r) + \" 0,\" + (-r) + \" \" + r + \",\" + (-2 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",0 \" + (2 * r) + \",\" + r + \" \" + r + \",\" + (2 * r) + \"Z\";\r\n                },\r\n\r\n                'uparrow': (size) => {\r\n                    let r = Math.sqrt(size / 12);\r\n                    return \"M\" + r + \",\" + (3 * r) + \"L\" + (-r) + \",\" + (3 * r) + \" \" + (-r) + \",\" + (-r) + \" \" + (-2 * r) + \",\" + (-r) + \" 0,\" + (-3 * r) + \" \" + (2 * r) + \",\" + (-r) + \" \" + r + \",\" + (-r) + \"Z\";\r\n                },\r\n\r\n                'downarrow': (size) => {\r\n                    let r = Math.sqrt(size / 12);\r\n                    return \"M0,\" + (3 * r) + \"L\" + (-2 * r) + \",\" + r + \" \" + (-r) + \",\" + r + \" \" + (-r) + \",\" + (-3 * r) + \" \" + r + \",\" + (-3 * r) + \" \" + r + \",\" + r + \" \" + (2 * r) + \",\" + r + \"Z\";\r\n                }\r\n            });\r\n\r\n            let defaultValue = customSymbolTypes.entries()[0].value;\r\n            if (!shape) {\r\n                return defaultValue;\r\n            } else if (isNaN(shape)) {\r\n                return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;\r\n            } else {\r\n                let result = customSymbolTypes.entries()[Math.floor(shape)];\r\n                return result ? result.value : defaultValue;\r\n            }\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            this.options = options;\r\n            this.animator = new BaseAnimator();\r\n            this.behavior = new CartesianChartBehavior([new ScatterChartWebBehavior()]);\r\n            let element = this.element = options.element;\r\n            this.viewport = _.clone(options.viewport);\r\n            this.style = options.style;\r\n            this.hostServices = options.host;\r\n            this.colors = this.style.colorPalette.dataColors;\r\n            this.interactivity = options.interactivity;\r\n            this.margin = {\r\n                top: 1,\r\n                right: 1,\r\n                bottom: 1,\r\n                left: 1\r\n            };\r\n\r\n            this.yAxisOrientation = yAxisPosition.left;\r\n            this.adjustMargins();\r\n\r\n            let showLinesOnX = this.scrollY = true;\r\n\r\n            let showLinesOnY = this.scrollX = true;\r\n\r\n            let svg = this.svg = d3.select(element.get(0))\r\n                .append('svg')\r\n                .style('position', 'absolute')\r\n                .classed(EnhancedScatterChart.ClassName, true);\r\n\r\n            let axisGraphicsContext = this.axisGraphicsContext = svg.append('g')\r\n                .classed(this.AxisGraphicsContextClassName, true);\r\n\r\n            this.svgScrollable = svg.append('svg')\r\n                .classed('svgScrollable', true)\r\n                .style('overflow', 'hidden');\r\n\r\n            let axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')\r\n                .classed(this.AxisGraphicsContextClassName, true);\r\n\r\n            this.clearCatcher = appendClearCatcher(this.axisGraphicsContextScrollable);\r\n            let axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;\r\n\r\n            this.backgroundGraphicsContext = axisGraphicsContext.append('svg:image');\r\n            this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');\r\n            this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');\r\n\r\n            this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);\r\n            this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);\r\n\r\n            this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);\r\n            this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);\r\n            this.interactivityService = createInteractivityService(this.hostServices);\r\n\r\n            this.legend = createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);\r\n\r\n            this.mainGraphicsG = this.axisGraphicsContextScrollable.append('g')\r\n                .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);\r\n\r\n            this.mainGraphicsContext = this.mainGraphicsG.append('svg');\r\n            this.svgDefaultImage = \"http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg\";\r\n            this.keyArray = [];\r\n        }\r\n\r\n        private adjustMargins(): void {\r\n            // Adjust margins if ticks are not going to be shown on either axis\r\n            let xAxis = this.element.find('.x.axis');\r\n\r\n            if (AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0\r\n                && AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {\r\n                this.margin = {\r\n                    top: 0,\r\n                    right: 0,\r\n                    bottom: 0,\r\n                    left: 0\r\n                };\r\n                xAxis.hide();\r\n            } else {\r\n                xAxis.show();\r\n            }\r\n        }\r\n\r\n        private getValueAxisProperties(dataViewMetadata: DataViewMetadata, axisTitleOnByDefault?: boolean): DataViewObject {\r\n            let toReturn: DataViewObject = {};\r\n            if (!dataViewMetadata)\r\n                return toReturn;\r\n\r\n            let objects = dataViewMetadata.objects;\r\n\r\n            if (objects) {\r\n                let valueAxisObject = objects['valueAxis'];\r\n                if (valueAxisObject) {\r\n                    toReturn = {\r\n                        show: valueAxisObject['show'],\r\n                        position: valueAxisObject['position'],\r\n                        axisScale: valueAxisObject['axisScale'],\r\n                        start: valueAxisObject['start'],\r\n                        end: valueAxisObject['end'],\r\n                        showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],\r\n                        axisStyle: valueAxisObject['axisStyle'],\r\n                        axisColor: valueAxisObject['axisColor'],\r\n                        secShow: valueAxisObject['secShow'],\r\n                        secPosition: valueAxisObject['secPosition'],\r\n                        secAxisScale: valueAxisObject['secAxisScale'],\r\n                        secStart: valueAxisObject['secStart'],\r\n                        secEnd: valueAxisObject['secEnd'],\r\n                        secShowAxisTitle: valueAxisObject['secShowAxisTitle'],\r\n                        secAxisStyle: valueAxisObject['secAxisStyle'],\r\n                        labelDisplayUnits: valueAxisObject['labelDisplayUnits'],\r\n                    };\r\n                }\r\n            }\r\n            return toReturn;\r\n        }\r\n\r\n        private getCategoryAxisProperties(dataViewMetadata: DataViewMetadata, axisTitleOnByDefault?: boolean): DataViewObject {\r\n            let toReturn: DataViewObject = {};\r\n            if (!dataViewMetadata)\r\n                return toReturn;\r\n\r\n            let objects = dataViewMetadata.objects;\r\n\r\n            if (objects) {\r\n                let categoryAxisObject = objects['categoryAxis'];\r\n\r\n                if (categoryAxisObject) {\r\n                    toReturn = {\r\n                        show: categoryAxisObject['show'],\r\n                        axisType: categoryAxisObject['axisType'],\r\n                        axisScale: categoryAxisObject['axisScale'],\r\n                        axisColor: categoryAxisObject['axisColor'],\r\n                        start: categoryAxisObject['start'],\r\n                        end: categoryAxisObject['end'],\r\n                        showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],\r\n                        axisStyle: categoryAxisObject['axisStyle'],\r\n                        labelDisplayUnits: categoryAxisObject['labelDisplayUnits']\r\n                    };\r\n                }\r\n            }\r\n            return toReturn;\r\n        }\r\n\r\n        public static converter(dataView: DataView, currentViewport: IViewport, colorPalette: IDataColorPalette, interactivityService?: IInteractivityService, categoryAxisProperties?: DataViewObject, valueAxisProperties?: DataViewObject): EnhancedScatterChartData {\r\n            let categoryValues: any[],\r\n                categoryFormatter: IValueFormatter,\r\n                categoryObjects: DataViewObjects[],\r\n                categoryIdentities: DataViewScopeIdentity[],\r\n                categoryQueryName: string;\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n            let dataViewMetadata: DataViewMetadata = dataView.metadata;\r\n\r\n            if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {\r\n                categoryValues = dataViewCategorical.categories[0].values;\r\n                categoryFormatter = valueFormatter.create({ format: valueFormatter.getFormatString(dataViewCategorical.categories[0].source, scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });\r\n                categoryIdentities = dataViewCategorical.categories[0].identity;\r\n                categoryObjects = dataViewCategorical.categories[0].objects;\r\n                categoryQueryName = dataViewCategorical.categories[0].source.queryName;\r\n            }\r\n            else {\r\n                categoryValues = [null];\r\n                // creating default formatter for null value (to get the right string of empty value from the locale)\r\n                categoryFormatter = valueFormatter.createDefaultFormatter(null);\r\n            }\r\n            let categories = dataViewCategorical.categories;\r\n            let dataValues = dataViewCategorical.values;\r\n            let hasDynamicSeries = !!dataValues.source;\r\n            let grouped = dataValues.grouped();\r\n            let useShape = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image') >= 0)) ? false : true;\r\n            let useCustomColor = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill') >= 0)) ? true : false;\r\n            let dvSource = dataValues.source;\r\n            let scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource);\r\n            let dataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();\r\n            let fillPoint = false;\r\n            let backdrop = { show: false, url: \"\" };\r\n            let crosshair = false;\r\n            let outline = false;\r\n            let defaultDataPointColor = \"\";\r\n            let showAllDataPoints = true;\r\n\r\n            if (dataViewMetadata && dataViewMetadata.objects) {\r\n                let objects = dataViewMetadata.objects;\r\n\r\n                defaultDataPointColor = DataViewObjects.getFillColor(objects, columnChartProps.dataPoint.defaultColor);\r\n                showAllDataPoints = DataViewObjects.getValue<boolean>(objects, columnChartProps.dataPoint.showAllDataPoints);\r\n                /*if(objects['dataPoint']){\r\n                    let shapeObj = objects['dataPoint'];\r\n                    if(shapeObj['useShape']){\r\n                        shape = <boolean>shapeObj['useShape'];\r\n                    }\r\n                }*/\r\n\r\n                let labelsObj = objects['categoryLabels'];\r\n                if (labelsObj) {\r\n                    dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? <boolean>labelsObj['show'] : dataLabelsSettings.show;\r\n                    dataLabelsSettings.fontSize = (labelsObj['fontSize'] !== undefined) ? <number>labelsObj['fontSize'] : dataLabelsSettings.fontSize;\r\n                    if (labelsObj['color'] !== undefined) {\r\n                        dataLabelsSettings.labelColor = (<Fill>labelsObj['color']).solid.color;\r\n                    }\r\n                }\r\n\r\n                fillPoint = DataViewObjects.getValue<boolean>(objects, scatterChartProps.fillPoint.show, fillPoint);\r\n\r\n                let backdropObject = objects['backdrop'];\r\n                if (backdropObject !== undefined) {\r\n                    backdrop.show = <boolean>backdropObject['show'];\r\n                    if (backdrop.show) {\r\n                        backdrop.url = <string>backdropObject['url'];\r\n                    }\r\n                }\r\n                let crosshairObject = objects['crosshair'];\r\n                if (crosshairObject !== undefined) {\r\n                    crosshair = <boolean>crosshairObject['show'];\r\n                }\r\n                let outlineObject = objects['outline'];\r\n                if (outlineObject !== undefined) {\r\n                    outline = <boolean>outlineObject['show'];\r\n                }\r\n            }\r\n\r\n            let dataPoints = EnhancedScatterChart.createDataPoints(\r\n                dataValues,\r\n                scatterMetadata,\r\n                categories,\r\n                categoryValues,\r\n                categoryFormatter,\r\n                categoryIdentities,\r\n                categoryObjects,\r\n                colorPalette,\r\n                hasDynamicSeries,\r\n                dataLabelsSettings,\r\n                defaultDataPointColor,\r\n                categoryQueryName);\r\n\r\n            if (interactivityService) {\r\n                interactivityService.applySelectionStateToData(dataPoints);\r\n            }\r\n\r\n            let legendItems = hasDynamicSeries\r\n                ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, valueFormatter.getFormatString(dvSource, scatterChartProps.general.formatString), defaultDataPointColor)\r\n                : [];\r\n\r\n            let legendTitle = dataValues && dvSource ? dvSource.displayName : \"\";\r\n            if (!legendTitle) {\r\n                legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : \"\";\r\n            }\r\n\r\n            let legendData = { title: legendTitle, dataPoints: legendItems };\r\n\r\n            let sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);\r\n\r\n            if (categoryAxisProperties && categoryAxisProperties[\"showAxisTitle\"] !== null && categoryAxisProperties[\"showAxisTitle\"] === false) {\r\n                scatterMetadata.axesLabels.x = null;\r\n            }\r\n            if (valueAxisProperties && valueAxisProperties[\"showAxisTitle\"] !== null && valueAxisProperties[\"showAxisTitle\"] === false) {\r\n                scatterMetadata.axesLabels.y = null;\r\n            }\r\n\r\n            if (dataPoints && dataPoints[0]) {\r\n                let point = dataPoints[0];\r\n                if (point.backdrop != null) {\r\n                    backdrop.show = true;\r\n                    backdrop.url = point.backdrop;\r\n                }\r\n                if (point.xStart != null) {\r\n                    categoryAxisProperties['start'] = point.xStart;\r\n                }\r\n                if (point.xEnd != null) {\r\n                    categoryAxisProperties['end'] = point.xEnd;\r\n                }\r\n                if (point.yStart != null) {\r\n                    valueAxisProperties['start'] = point.yStart;\r\n                }\r\n                if (point.yEnd != null) {\r\n                    valueAxisProperties['end'] = point.yEnd;\r\n                }\r\n            }\r\n\r\n            return {\r\n                xCol: scatterMetadata.cols.x,\r\n                yCol: scatterMetadata.cols.y,\r\n                dataPoints: dataPoints,\r\n                legendData: legendData,\r\n                axesLabels: scatterMetadata.axesLabels,\r\n                selectedIds: [],\r\n                size: scatterMetadata.cols.size,\r\n                sizeRange: sizeRange,\r\n                dataLabelsSettings: dataLabelsSettings,\r\n                defaultDataPointColor: defaultDataPointColor,\r\n                hasDynamicSeries: hasDynamicSeries,\r\n                showAllDataPoints: showAllDataPoints,\r\n                fillPoint: fillPoint,\r\n                useShape: useShape,\r\n                useCustomColor: useCustomColor,\r\n                backdrop: backdrop,\r\n                crosshair: crosshair,\r\n                outline: outline\r\n            };\r\n        }\r\n\r\n        private static createSeriesLegend(\r\n            dataValues: DataViewValueColumns,\r\n            colorPalette: IDataColorPalette,\r\n            categorical: DataViewValueColumns,\r\n            formatString: string,\r\n            defaultDataPointColor: string): LegendDataPoint[] {\r\n\r\n            let grouped = dataValues.grouped();\r\n            let colorHelper = new ColorHelper(colorPalette, scatterChartProps.dataPoint.fill, defaultDataPointColor);\r\n\r\n            let legendItems: LegendDataPoint[] = [];\r\n            for (let i = 0, len = grouped.length; i < len; i++) {\r\n                let grouping = grouped[i];\r\n                let color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\r\n\r\n                legendItems.push({\r\n                    color: color,\r\n                    icon: LegendIcon.Circle,\r\n                    label: valueFormatter.format(grouping.name, formatString),\r\n                    identity: grouping.identity ? SelectionId.createWithId(grouping.identity) : SelectionId.createNull(),\r\n                    selected: false,\r\n                });\r\n            }\r\n\r\n            return legendItems;\r\n        }\r\n\r\n        private static getSizeRangeForGroups(\r\n            dataViewValueGroups: DataViewValueColumnGroup[],\r\n            sizeColumnIndex: number): NumberRange {\r\n\r\n            let result: NumberRange = {};\r\n            if (dataViewValueGroups) {\r\n                dataViewValueGroups.forEach((group) => {\r\n                    let sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);\r\n                    let currentRange: NumberRange = AxisHelper.getRangeForColumn(sizeColumn);\r\n                    if (result.min == null || result.min > currentRange.min) {\r\n                        result.min = currentRange.min;\r\n                    }\r\n                    if (result.max == null || result.max < currentRange.max) {\r\n                        result.max = currentRange.max;\r\n                    }\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private static getMetadata(grouped: DataViewValueColumnGroup[], source: DataViewMetadataColumn): ScatterChartMeasureMetadata {\r\n            let xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');\r\n            let yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');\r\n            let sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');\r\n\r\n            let gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');\r\n            let colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill');\r\n            let shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Shape');\r\n            let imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image');\r\n            let rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Rotation');\r\n            let backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Backdrop');\r\n            let xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X Start');\r\n            let xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X End');\r\n            let yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y Start');\r\n            let yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y End');\r\n            let xCol: DataViewMetadataColumn;\r\n            let yCol: DataViewMetadataColumn;\r\n            let sizeCol: DataViewMetadataColumn;\r\n            let colorFillCol: DataViewMetadataColumn;\r\n            let shapeCol: DataViewMetadataColumn;\r\n            let imageCol: DataViewMetadataColumn;\r\n            let rotationCol: DataViewMetadataColumn;\r\n            let backdropCol: DataViewMetadataColumn;\r\n            let xStartCol: DataViewMetadataColumn;\r\n            let xEndCol: DataViewMetadataColumn;\r\n            let yStartCol: DataViewMetadataColumn;\r\n            let yEndCol: DataViewMetadataColumn;\r\n            let xAxisLabel = \"\";\r\n            let yAxisLabel = \"\";\r\n\r\n            if (grouped && grouped.length) {\r\n                let firstGroup = grouped[0],\r\n                    measureCount = firstGroup.values.length;\r\n\r\n                if (!(xIndex >= 0))\r\n                    xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(yIndex >= 0))\r\n                    yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(sizeIndex >= 0))\r\n                    sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(colorFillIndex >= 0))\r\n                    colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(shapeIndex >= 0))\r\n                    shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(imageIndex >= 0)) {\r\n                    imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                }\r\n                if (!(rotationIndex >= 0))\r\n                    rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(backdropIndex >= 0))\r\n                    backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(xStartIndex >= 0))\r\n                    xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex]);\r\n                if (!(xEndIndex >= 0))\r\n                    xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex]);\r\n                if (!(yStartIndex >= 0))\r\n                    yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex]);\r\n                if (!(yEndIndex >= 0))\r\n                    yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex]);\r\n\r\n                if (xIndex >= 0) {\r\n                    xCol = firstGroup.values[xIndex].source;\r\n                    xAxisLabel = firstGroup.values[xIndex].source.displayName;\r\n                }\r\n                if (yIndex >= 0) {\r\n                    yCol = firstGroup.values[yIndex].source;\r\n                    yAxisLabel = firstGroup.values[yIndex].source.displayName;\r\n                }\r\n                if (sizeIndex >= 0) {\r\n                    sizeCol = firstGroup.values[sizeIndex].source;\r\n                }\r\n                if (colorFillIndex >= 0) {\r\n                    colorFillCol = firstGroup.values[colorFillIndex].source;\r\n                }\r\n                if (shapeIndex >= 0) {\r\n                    shapeCol = firstGroup.values[shapeIndex].source;\r\n                }\r\n                if (imageIndex >= 0) {\r\n                    imageCol = firstGroup.values[imageIndex].source;\r\n                }\r\n                if (rotationIndex >= 0) {\r\n                    rotationCol = firstGroup.values[rotationIndex].source;\r\n                }\r\n\r\n                if (backdropIndex >= 0) {\r\n                    backdropCol = firstGroup.values[backdropIndex].source;\r\n                }\r\n                if (xStartIndex >= 0) {\r\n                    xStartCol = firstGroup.values[xStartIndex].source;\r\n                }\r\n                if (xEndIndex >= 0) {\r\n                    xEndCol = firstGroup.values[xEndIndex].source;\r\n                }\r\n                if (yStartIndex >= 0) {\r\n                    yStartCol = firstGroup.values[yStartIndex].source;\r\n                }\r\n                if (yEndIndex >= 0) {\r\n                    yEndCol = firstGroup.values[yEndIndex].source;\r\n                }\r\n            }\r\n\r\n            return {\r\n                idx: {\r\n                    x: xIndex,\r\n                    y: yIndex,\r\n                    size: sizeIndex,\r\n                    colorFill: colorFillIndex,\r\n                    shape: shapeIndex,\r\n                    image: imageIndex,\r\n                    rotation: rotationIndex,\r\n                    backdrop: backdropIndex,\r\n                    xStart: xStartIndex,\r\n                    xEnd: xEndIndex,\r\n                    yStart: yStartIndex,\r\n                    yEnd: yEndIndex,\r\n                },\r\n                cols: {\r\n                    x: xCol,\r\n                    y: yCol,\r\n                    size: sizeCol,\r\n                    colorFill: colorFillCol,\r\n                    shape: shapeCol,\r\n                    image: imageCol,\r\n                    rotation: rotationCol,\r\n                    backdrop: backdropCol,\r\n                    xStart: xStartCol,\r\n                    xEnd: xEndCol,\r\n                    yStart: yStartCol,\r\n                    yEnd: yEndCol,\r\n                },\r\n                axesLabels: {\r\n                    x: xAxisLabel,\r\n                    y: yAxisLabel\r\n                }\r\n            };\r\n        }\r\n\r\n        private static getDefaultMeasureIndex(count: number, usedIndexes: number[]): number {\r\n            for (let i = 0; i < count; i++) {\r\n                let found = true;\r\n                for (let j = 0; j < usedIndexes.length; j++) {\r\n                    if (i === usedIndexes[j]) {\r\n                        found = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (found === true) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        public static createLazyFormattedCategory(formatter: IValueFormatter, value: string): jsCommon.Lazy<string> {\r\n            return new jsCommon.Lazy(() => formatter.format(value));\r\n        }\r\n\r\n        private static createDataPoints(\r\n            dataValues: DataViewValueColumns,\r\n            metadata: ScatterChartMeasureMetadata,\r\n            categories: DataViewCategoryColumn[],\r\n            categoryValues: any[],\r\n            categoryFormatter: IValueFormatter,\r\n            categoryIdentities: DataViewScopeIdentity[],\r\n            categoryObjects: DataViewObjects[],\r\n            colorPalette: IDataColorPalette,\r\n            hasDynamicSeries: boolean,\r\n            labelSettings: PointDataLabelsSettings,\r\n            defaultDataPointColor?: string,\r\n            categoryQueryName?: string): EnhancedScatterChartDataPoint[] {\r\n\r\n            let dataPoints: EnhancedScatterChartDataPoint[] = [],\r\n                indicies = metadata.idx,\r\n                formatStringProp = scatterChartProps.general.formatString,\r\n                dataValueSource = dataValues.source,\r\n                grouped = dataValues.grouped(),\r\n                fontSizeInPx: string = PixelConverter.fromPoint(labelSettings.fontSize);\r\n\r\n            let colorHelper = new ColorHelper(colorPalette, scatterChartProps.dataPoint.fill, defaultDataPointColor);\r\n\r\n            for (let categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {\r\n                let categoryValue = categoryValues[categoryIdx];\r\n\r\n                for (let seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {\r\n                    let grouping = grouped[seriesIdx];\r\n                    let seriesValues = grouping.values;\r\n                    let measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);\r\n                    let measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);\r\n                    let measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);\r\n                    let measureColorFill = ScatterChart.getMeasureValue(indicies.colorFill, seriesValues);\r\n                    let measureShape = ScatterChart.getMeasureValue(indicies.shape, seriesValues);\r\n                    let measureImage = ScatterChart.getMeasureValue(indicies.image, seriesValues);\r\n                    let measureRotation = ScatterChart.getMeasureValue(indicies.rotation, seriesValues);\r\n                    let measureBackdrop = ScatterChart.getMeasureValue(indicies.backdrop, seriesValues);\r\n                    let measureXStart = ScatterChart.getMeasureValue(indicies.xStart, seriesValues);\r\n                    let measureXEnd = ScatterChart.getMeasureValue(indicies.xEnd, seriesValues);\r\n                    let measureYStart = ScatterChart.getMeasureValue(indicies.yStart, seriesValues);\r\n                    let measureYEnd = ScatterChart.getMeasureValue(indicies.yEnd, seriesValues);\r\n\r\n                    let xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null;\r\n                    let yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;\r\n                    let size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;\r\n                    let colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null;\r\n                    let shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]);\r\n                    let image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null;\r\n                    let rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0;\r\n                    let backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null;\r\n                    let xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null;\r\n                    let xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null;\r\n                    let yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null;\r\n                    let yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null;\r\n\r\n                    let hasNullValue = (xVal == null) || (yVal == null);\r\n\r\n                    if (hasNullValue)\r\n                        continue;\r\n\r\n                    let color: string;\r\n                    if (hasDynamicSeries) {\r\n                        color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);\r\n                    } else {\r\n                        // If we have no Size measure then use a blank query name\r\n                        let measureSource = (measureSize != null)\r\n                            ? measureSize.source.queryName\r\n                            : '';\r\n                        color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);\r\n                    }\r\n\r\n                    let category = categories && categories.length > 0 ? categories[0] : null;\r\n                    let identity = SelectionIdBuilder.builder()\r\n                        .withCategory(category, categoryIdx)\r\n                        .withSeries(dataValues, grouping)\r\n                        .createSelectionId();\r\n\r\n                    let seriesData: TooltipSeriesDataItem[] = [];\r\n                    if (dataValueSource) {\r\n                        // Dynamic series\r\n                        seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });\r\n                    }\r\n                    if (measureX) {\r\n                        seriesData.push({ value: xVal, metadata: measureX });\r\n                    }\r\n                    if (measureY) {\r\n                        seriesData.push({ value: yVal, metadata: measureY });\r\n                    }\r\n                    if (measureSize && measureSize.values && measureSize.values.length > 0) {\r\n                        seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });\r\n                    }\r\n                    if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {\r\n                        seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });\r\n                    }\r\n                    if (measureShape && measureShape.values && measureShape.values.length > 0) {\r\n                        seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });\r\n                    }\r\n                    if (measureImage && measureImage.values && measureImage.values.length > 0) {\r\n                        seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });\r\n                    }\r\n                    if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {\r\n                        seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });\r\n                    }\r\n\r\n                    if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {\r\n                        seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });\r\n                    }\r\n                    if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {\r\n                        seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });\r\n                    }\r\n                    if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {\r\n                        seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });\r\n                    }\r\n                    if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {\r\n                        seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });\r\n                    }\r\n                    if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {\r\n                        seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });\r\n                    }\r\n\r\n                    let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);\r\n\r\n                    let dataPoint: EnhancedScatterChartDataPoint = {\r\n                        x: xVal,\r\n                        y: yVal,\r\n                        size: size,\r\n                        radius: { sizeMeasure: measureSize, index: categoryIdx },\r\n                        fill: color,\r\n                        formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),\r\n                        selected: false,\r\n                        identity: identity,\r\n                        tooltipInfo: tooltipInfo,\r\n                        labelFill: labelSettings.labelColor,\r\n                        labelFontSize: fontSizeInPx,\r\n                        contentPosition: ContentPositions.MiddleLeft, // 8\r\n                        colorFill: colorFill,\r\n                        shapeSymbolType: shapeSymbolType,\r\n                        svgurl: image,\r\n                        rotation: rotation,\r\n                        backdrop: backdrop,\r\n                        xStart: xStart,\r\n                        xEnd: xEnd,\r\n                        yStart: yStart,\r\n                        yEnd: yEnd\r\n                    };\r\n\r\n                    dataPoints.push(dataPoint);\r\n                }\r\n            }\r\n            return dataPoints;\r\n        }\r\n\r\n        public setData(dataViews: DataView[]) {\r\n            this.data = {\r\n                xCol: undefined,\r\n                yCol: undefined,\r\n                dataPoints: [],\r\n                legendData: { dataPoints: [] },\r\n                axesLabels: { x: '', y: '' },\r\n                selectedIds: [],\r\n                sizeRange: [],\r\n                dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),\r\n                defaultDataPointColor: null,\r\n                hasDynamicSeries: false,\r\n                useShape: true,\r\n                useCustomColor: false,\r\n            };\r\n\r\n            if (dataViews.length > 0) {\r\n                let dataView = dataViews[0];\r\n\r\n                if (dataView) {\r\n                    this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);\r\n                    this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);\r\n                    this.dataView = dataView;\r\n\r\n                    if (dataView.categorical && dataView.categorical.values) {\r\n                        this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViews = this.dataViews = options.dataViews;\r\n            this.viewport = _.clone(options.viewport);\r\n\r\n            if (!dataViews) return;\r\n\r\n            if (dataViews && dataViews.length > 0) {\r\n                let warnings = getInvalidValueWarnings(\r\n                    dataViews,\r\n                    false /*supportsNaN*/,\r\n                    false /*supportsNegativeInfinity*/,\r\n                    false /*supportsPositiveInfinity*/);\r\n\r\n                if (warnings && warnings.length > 0)\r\n                    this.hostServices.setWarnings(warnings);\r\n\r\n                this.populateObjectProperties(dataViews);\r\n            }\r\n\r\n            this.setData(dataViews);\r\n            \r\n            // Note: interactive legend shouldn't be rendered explicitly here\r\n            // The interactive legend is being rendered in the render method of ICartesianVisual\r\n            if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {\r\n                this.renderLegend();\r\n            }\r\n\r\n            this.render(options.suppressAnimations);\r\n\r\n        }\r\n\r\n        private populateObjectProperties(dataViews: DataView[]) {\r\n            if (dataViews && dataViews.length > 0) {\r\n                let dataViewMetadata = dataViews[0].metadata;\r\n\r\n                if (dataViewMetadata) {\r\n                    this.legendObjectProperties = DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});\r\n                }\r\n                else {\r\n                    this.legendObjectProperties = {};\r\n                }\r\n                this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);\r\n                this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);\r\n                let axisPosition = this.valueAxisProperties['position'];\r\n                this.yAxisOrientation = axisPosition ? axisPosition.toString() : yAxisPosition.left;\r\n            }\r\n        }\r\n\r\n        private renderLegend(): void {\r\n            let legendData: LegendData = { title: \"\", dataPoints: [] };\r\n            let legend: ILegend = this.legend;\r\n\r\n            this.layerLegendData = this.data.legendData;\r\n            if (this.layerLegendData) {\r\n                legendData.title = this.layerLegendData.title || \"\";\r\n                legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);\r\n                legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;\r\n                if (this.layerLegendData.grouped) {\r\n                    legendData.grouped = true;\r\n                }\r\n            }\r\n\r\n            let legendProperties = this.legendObjectProperties;\r\n\r\n            if (legendProperties) {\r\n                LegendData.update(legendData, legendProperties);\r\n                let position = <string>legendProperties[legendProps.position];\r\n\r\n                if (position)\r\n                    legend.changeOrientation(LegendPosition[position]);\r\n            }\r\n            else {\r\n                legend.changeOrientation(LegendPosition.Top);\r\n            }\r\n\r\n            if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {\r\n                legendData.dataPoints = [];\r\n            }\r\n\r\n            let viewport = this.viewport;\r\n            legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\r\n            Legend.positionChartArea(this.svg, legend);\r\n        }\r\n        private hideLegends(): boolean {\r\n            if (this.cartesianSmallViewPortProperties) {\r\n                if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private shouldRenderAxis(axisProperties: IAxisProperties, propertyName: string = \"show\"): boolean {\r\n            if (!axisProperties) {\r\n                return false;\r\n            }\r\n            else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {\r\n                return axisProperties.values && axisProperties.values.length > 0;\r\n            }\r\n            else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {\r\n                return axisProperties.values && axisProperties.values.length > 0;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        private getMaxMarginFactor(): number {\r\n            return this.options.style.maxMarginFactor || 0.25;\r\n        }\r\n\r\n        private adjustViewportbyBackdrop(): void {\r\n            let img = new Image();\r\n            let that = this;\r\n            img.src = this.data.backdrop.url;\r\n            img.onload = function () {\r\n                if (that.oldBackdrop !== this.src) {\r\n                    that.render(true);\r\n                    that.oldBackdrop = this.src;\r\n                }\r\n            };\r\n\r\n            if (img.width > 0 && img.height > 0) {\r\n                if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {\r\n                    let deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;\r\n                    this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };\r\n                } else {\r\n                    let deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;\r\n                    this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };\r\n                }\r\n            }\r\n        }\r\n\r\n        public render(suppressAnimations: boolean): void {\r\n            this.viewport.height -= this.legendViewport.height;\r\n            this.viewport.width -= this.legendViewport.width;\r\n\r\n            if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {\r\n                return;\r\n            }\r\n\r\n            let maxMarginFactor = this.getMaxMarginFactor();\r\n            this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;\r\n            let bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));\r\n\r\n            // reset defaults\r\n            this.margin.top = 8;\r\n            this.margin.bottom = bottomMarginLimit;\r\n            this.margin.right = 0;\r\n\r\n            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\r\n\r\n            this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;\r\n            this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;\r\n\r\n            let renderXAxis = this.shouldRenderAxis(this.xAxisProperties);\r\n            let renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);\r\n\r\n            let mainAxisScale;\r\n            this.isXScrollBarVisible = false;\r\n            this.isYScrollBarVisible = false;\r\n            let tickLabelMargins;\r\n            let axisLabels: ChartAxesLabels;\r\n            let chartHasAxisLabels: boolean;\r\n\r\n            let yAxisOrientation = this.yAxisOrientation;\r\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\r\n\r\n            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\r\n\r\n            let doneWithMargins = false,\r\n                maxIterations = 2,\r\n                numIterations = 0;\r\n\r\n            while (!doneWithMargins && numIterations < maxIterations) {\r\n                numIterations++;\r\n                tickLabelMargins = AxisHelper.getTickLabelMargins(\r\n                    { width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit,\r\n                    TextMeasurementService.measureSvgTextWidth, TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties },\r\n                    this.bottomMarginLimit, this.textProperties,\r\n                    this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight,\r\n                    renderXAxis, renderY1Axis, false);\r\n\r\n                // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\r\n                let maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\r\n                    maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\r\n                    xMax = tickLabelMargins.xMax;\r\n\r\n                maxMainYaxisSide += 10;\r\n                maxSecondYaxisSide += 10;\r\n                xMax += 12;\r\n                if (showY1OnRight && renderY1Axis) {\r\n                    maxSecondYaxisSide += 20;\r\n                }\r\n\r\n                if (!showY1OnRight && renderY1Axis) {\r\n                    maxMainYaxisSide += 20;\r\n                }\r\n\r\n                if (this.hideAxisLabels()) {\r\n                    this.xAxisProperties.axisLabel = null;\r\n                    this.yAxisProperties.axisLabel = null;\r\n                }\r\n\r\n                this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\r\n\r\n                axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\r\n                chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\r\n\r\n                if (axisLabels.x != null)\r\n                    xMax += 18;\r\n\r\n                if (axisLabels.y != null)\r\n                    maxMainYaxisSide += 20;\r\n\r\n                if (axisLabels.y2 != null)\r\n                    maxSecondYaxisSide += 20;\r\n\r\n                this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\r\n                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\r\n                this.margin.bottom = xMax;\r\n\r\n                // re-calculate the axes with the new margins\r\n                let previousTickCountY1 = this.yAxisProperties.values.length;\r\n\r\n                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\r\n\r\n                // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\r\n                // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\r\n                if (this.yAxisProperties.values.length === previousTickCountY1)\r\n                    doneWithMargins = true;\r\n            }\r\n            // we have to do the above process again since changes are made to viewport.\r\n            \r\n            if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\r\n                this.adjustViewportbyBackdrop();\r\n\r\n                doneWithMargins = false;\r\n                maxIterations = 2;\r\n                numIterations = 0;\r\n\r\n                while (!doneWithMargins && numIterations < maxIterations) {\r\n                    numIterations++;\r\n                    tickLabelMargins = AxisHelper.getTickLabelMargins(\r\n                        { width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit,\r\n                        TextMeasurementService.measureSvgTextWidth, TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties },\r\n                        this.bottomMarginLimit, this.textProperties,\r\n                        this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight,\r\n                        renderXAxis, renderY1Axis, false);\r\n\r\n                    // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side\r\n                    let maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft,\r\n                        maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight,\r\n                        xMax = tickLabelMargins.xMax;\r\n\r\n                    maxMainYaxisSide += 10;\r\n                    if (showY1OnRight && renderY1Axis)\r\n                        maxSecondYaxisSide += 15;\r\n                    xMax += 12;\r\n\r\n                    if (this.hideAxisLabels()) {\r\n                        this.xAxisProperties.axisLabel = null;\r\n                        this.yAxisProperties.axisLabel = null;\r\n                    }\r\n\r\n                    this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);\r\n\r\n                    axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };\r\n                    chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);\r\n\r\n                    if (axisLabels.x != null)\r\n                        xMax += 18;\r\n\r\n                    if (axisLabels.y != null)\r\n                        maxMainYaxisSide += 20;\r\n\r\n                    if (axisLabels.y2 != null)\r\n                        maxSecondYaxisSide += 20;\r\n\r\n                    this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;\r\n                    this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;\r\n                    this.margin.bottom = xMax;\r\n\r\n                    // re-calculate the axes with the new margins\r\n                    let previousTickCountY1 = this.yAxisProperties.values.length;\r\n\r\n                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);\r\n\r\n                    // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again\r\n                    // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.\r\n                    if (this.yAxisProperties.values.length === previousTickCountY1)\r\n                        doneWithMargins = true;\r\n                }\r\n            }\r\n\r\n            this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);\r\n\r\n            this.updateAxis();\r\n\r\n            if (!this.data)\r\n                return;\r\n\r\n            let data = this.data;\r\n            let dataPoints = this.data.dataPoints;\r\n\r\n            let hasSelection = this.interactivityService && this.interactivityService.hasSelection();\r\n\r\n            this.mainGraphicsContext.attr('width', this.viewportIn.width)\r\n                .attr('height', this.viewportIn.height);\r\n\r\n            let sortedData = dataPoints.sort(function (a, b) {\r\n                return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;\r\n            });\r\n\r\n            let duration = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\r\n            let scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);\r\n\r\n            let dataLabelsSettings = this.data.dataLabelsSettings;\r\n            if (dataLabelsSettings.show) {\r\n                let layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);\r\n                let clonedDataPoints: Array<EnhancedScatterChartDataPoint> = this.cloneDataPoints(dataPoints);\r\n                //fix bug 3863: drawDefaultLabelsForDataPointChart add to datapoints[xxx].size = object , which causes when\r\n                //category labels is on and Fill Points option off to fill the points when mouse click occures because of default size\r\n                //is set to datapoints.\r\n                let labels: D3.UpdateSelection = dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);\r\n                if (labels)\r\n                    labels.attr('transform', (d) => SVGUtil.translate(d.size.width / 2, 0));\r\n            }\r\n            else {\r\n                dataLabelUtils.cleanDataLabels(this.mainGraphicsG);\r\n            }\r\n            let behaviorOptions: ScatterBehaviorOptions = undefined;\r\n            if (this.interactivityService) {\r\n                behaviorOptions = {\r\n                    dataPointsSelection: scatterMarkers,\r\n                    data: this.data,\r\n                    plotContext: this.mainGraphicsContext,\r\n                };\r\n            }\r\n\r\n            TooltipManager.addTooltip(scatterMarkers, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo);\r\n\r\n            SVGUtil.flushAllD3TransitionsIfNeeded(this.options);\r\n\r\n            if (this.behavior) {\r\n                let layerBehaviorOptions: any[] = [];\r\n                layerBehaviorOptions.push(behaviorOptions);\r\n\r\n                if (this.interactivityService) {\r\n                    let cbehaviorOptions: CartesianBehaviorOptions = {\r\n                        layerOptions: layerBehaviorOptions,\r\n                        clearCatcher: this.clearCatcher,\r\n                    };\r\n                    this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);\r\n                }\r\n            }\r\n        }\r\n\r\n        private cloneDataPoints(dataPoints: Array<EnhancedScatterChartDataPoint>): Array<EnhancedScatterChartDataPoint> {\r\n            let clonedDataPoints: Array<EnhancedScatterChartDataPoint> = new Array<EnhancedScatterChartDataPoint>();\r\n\r\n            for (let dataPoint of dataPoints) {\r\n                let clonedDataPoint: EnhancedScatterChartDataPoint = _.clone(dataPoint);\r\n                clonedDataPoints.push(clonedDataPoint);\r\n            }\r\n\r\n            return clonedDataPoints;\r\n        }\r\n\r\n        private darkenZeroLine(g: D3.Selection): void {\r\n            let zeroTick = g.selectAll('g.tick').filter((data) => data === 0).node();\r\n            if (zeroTick) {\r\n                d3.select(zeroTick).select('line').classed('zero-line', true);\r\n            }\r\n        }\r\n\r\n        private getCategoryAxisFill(): Fill {\r\n            if (this.dataView && this.dataView.metadata.objects) {\r\n                let label = this.dataView.metadata.objects['categoryAxis'];\r\n                if (label) {\r\n                    return <Fill>label['axisColor'];\r\n                }\r\n            }\r\n            return { solid: { color: '#333' } };\r\n        }\r\n\r\n        private getEnhanchedScatterChartLabelLayout(labelSettings: PointDataLabelsSettings,\r\n            viewport: IViewport,\r\n            sizeRange: NumberRange): ILabelLayout {\r\n\r\n            let xScale = this.xAxisProperties.scale;\r\n            let yScale = this.yAxisProperties.scale;\r\n            let fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);\r\n            let fontFamily: string = dataLabelUtils.LabelTextProperties.fontFamily;\r\n\r\n            return {\r\n                labelText: (d: EnhancedScatterChartDataPoint) => {\r\n                    return dataLabelUtils.getLabelFormattedText({\r\n                        label: d.formattedCategory.getValue(),\r\n                        fontSize: labelSettings.fontSize,\r\n                        maxWidth: viewport.width,\r\n                    });\r\n                },\r\n                labelLayout: {\r\n                    x: (d: EnhancedScatterChartDataPoint) => xScale(d.x),\r\n                    y: (d: EnhancedScatterChartDataPoint) => {\r\n                        let margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;\r\n                        return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;\r\n                    },\r\n                },\r\n                filter: (d: EnhancedScatterChartDataPoint) => (d != null && d.formattedCategory.getValue() != null),\r\n                style: {\r\n                    'fill': (d: EnhancedScatterChartDataPoint) => d.labelFill,\r\n                    'font-size': fontSizeInPx,\r\n                    'font-family': fontFamily,\r\n                },\r\n            };\r\n        }\r\n\r\n        private getValueAxisFill(): Fill {\r\n            if (this.dataView && this.dataView.metadata.objects) {\r\n                let label = this.dataView.metadata.objects['valueAxis'];\r\n                if (label)\r\n                    return <Fill>label['axisColor'];\r\n            }\r\n\r\n            return { solid: { color: '#333' } };\r\n        }\r\n\r\n        private renderCrossHair() {\r\n            let xScale = <D3.Scale.LinearScale>this.xAxisProperties.scale;\r\n            let yScale = <D3.Scale.LinearScale>this.yAxisProperties.scale;\r\n            let mainGraphicsContext = this.mainGraphicsContext;\r\n            mainGraphicsContext.selectAll(\".crosshairCanvas\").remove();\r\n            if (this.data.crosshair) {\r\n                let canvas = mainGraphicsContext.append(\"g\").attr(\"class\", \"crosshairCanvas\").attr(\"id\", \"crosshairCanvas\");\r\n                let crossHair = canvas.append(\"g\").attr(\"class\", \"crosshair\");\r\n                let hLine = crossHair.append(\"line\").attr(\"id\", \"h_crosshair\") // horizontal cross hair\r\n                    .attr(\"x1\", 0)\r\n                    .attr(\"y1\", 0)\r\n                    .attr(\"x2\", 0)\r\n                    .attr(\"y2\", 0)\r\n                    .style(\"stroke\", \"gray\")\r\n                    .style(\"stroke-width\", \"1px\")\r\n                    .style(\"stroke-dasharray\", \"5,5\")\r\n                    .style(\"display\", \"none\");\r\n\r\n                let vLine = crossHair.append(\"line\").attr(\"id\", \"v_crosshair\") // vertical cross hair\r\n                    .attr(\"x1\", 0)\r\n                    .attr(\"y1\", 0)\r\n                    .attr(\"x2\", 0)\r\n                    .attr(\"y2\", 0)\r\n                    .style(\"stroke\", \"gray\")\r\n                    .style(\"stroke-width\", \"1px\")\r\n                    .style(\"stroke-dasharray\", \"5,5\")\r\n                    .style(\"display\", \"none\");\r\n\r\n                let text = crossHair.append(\"text\").attr(\"id\", \"crosshair_text\") // text label for cross hair\r\n                    .style(\"font-size\", \"10px\")\r\n                    .style(\"stroke\", \"gray\")\r\n                    .style(\"stroke-width\", \"0.5px\");\r\n\r\n                let addCrossHair = (xCoord, yCoord) => {\r\n                    \r\n                    // Update horizontal cross hair\r\n                    hLine.attr(\"x1\", 0)\r\n                        .attr(\"y1\", yCoord)\r\n                        .attr(\"x2\", this.viewportIn.width)\r\n                        .attr(\"y2\", yCoord)\r\n                        .style(\"display\", \"block\");\r\n                    \r\n                    // Update vertical cross hair\r\n                    vLine.attr(\"x1\", xCoord)\r\n                        .attr(\"y1\", 0)\r\n                        .attr(\"x2\", xCoord)\r\n                        .attr(\"y2\", this.viewportIn.height)\r\n                        .style(\"display\", \"block\");\r\n\r\n                    // Update text label\r\n                    text.attr(\"transform\", \"translate(\" + (xCoord + 5) + \",\" + (yCoord - 5) + \")\")\r\n                        .text(\"(\" + Math.round(xScale.invert(xCoord) * 100) / 100 + \" , \" + Math.round(yScale.invert(yCoord) * 100) / 100 + \")\");\r\n                };\r\n\r\n                this.axisGraphicsContextScrollable.on(\"mousemove\", function () {\r\n                    let coordinates = d3.mouse(this);\r\n                    let svgNode = this.viewportElement;\r\n                    let scaledRect = svgNode.getBoundingClientRect();\r\n                    let domRect = svgNode.getBBox();\r\n                    let ratioX = scaledRect.width / domRect.width;\r\n                    let ratioY = scaledRect.height / domRect.height;\r\n                    if (domRect.width > 0 && !Double.equalWithPrecision(ratioX, 1.0, 0.00001)) {\r\n                        coordinates[0] = coordinates[0] / ratioX;\r\n                    }\r\n                    if (domRect.height > 0 && !Double.equalWithPrecision(ratioY, 1.0, 0.00001)) {\r\n                        coordinates[1] = coordinates[1] / ratioY;\r\n                    }\r\n                    addCrossHair(coordinates[0], coordinates[1]);\r\n                })\r\n                    .on(\"mouseover\", function () {\r\n                        d3.selectAll(\".crosshair\").style(\"display\", \"block\");\r\n                    })\r\n                    .on(\"mouseout\", function () {\r\n                        d3.selectAll(\".crosshair\").style(\"display\", \"none\");\r\n                    });\r\n            }\r\n        }\r\n\r\n        private renderBackground() {\r\n            if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {\r\n                this.backgroundGraphicsContext\r\n                    .attr(\"xlink:href\", this.data.backdrop.url)\r\n                    .attr('x', 0)\r\n                    .attr('y', 0)\r\n                    .attr('width', this.viewportIn.width)\r\n                    .attr('height', this.viewportIn.height);\r\n            } else {\r\n                this.backgroundGraphicsContext\r\n                    .attr('width', 0)\r\n                    .attr('height', 0);\r\n            }\r\n        }\r\n\r\n        private renderChart(\r\n            mainAxisScale: any,\r\n            xAxis: IAxisProperties,\r\n            yAxis: IAxisProperties,\r\n            tickLabelMargins: any,\r\n            chartHasAxisLabels: boolean,\r\n            axisLabels: ChartAxesLabels,\r\n            suppressAnimations: boolean,\r\n            scrollScale?: any,\r\n            extent?: number[]) {\r\n\r\n            let bottomMarginLimit = this.bottomMarginLimit;\r\n            let leftRightMarginLimit = this.leftRightMarginLimit;\r\n            let duration = AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);\r\n\r\n            this.renderBackground();\r\n            \r\n            //hide show x-axis here\r\n            if (this.shouldRenderAxis(xAxis)) {\r\n                xAxis.axis.orient(\"bottom\");\r\n                if (!xAxis.willLabelsFit)\r\n                    xAxis.axis.tickPadding(5);\r\n\r\n                let xAxisGraphicsElement = this.xAxisGraphicsContext;\r\n                if (duration) {\r\n                    xAxisGraphicsElement\r\n                        .transition()\r\n                        .duration(duration)\r\n                        .call(xAxis.axis)\r\n                        .call(this.darkenZeroLine);\r\n                }\r\n                else {\r\n                    xAxisGraphicsElement\r\n                        .call(xAxis.axis)\r\n                        .call(this.darkenZeroLine);\r\n                }\r\n                let xZeroTick = xAxisGraphicsElement.selectAll('g.tick').filter((data) => data === 0);\r\n                if (xZeroTick) {\r\n                    let xZeroColor = this.getValueAxisFill();\r\n                    if (xZeroColor)\r\n                        xZeroTick.selectAll('line').style({ 'stroke': xZeroColor.solid.color });\r\n                }\r\n\r\n                let xAxisTextNodes = xAxisGraphicsElement.selectAll('text');\r\n                if (xAxis.willLabelsWordBreak) {\r\n                    xAxisTextNodes\r\n                        .call(AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);\r\n                } else {\r\n                    xAxisTextNodes\r\n                        .call(AxisHelper.LabelLayoutStrategy.rotate,\r\n                        bottomMarginLimit,\r\n                        TextMeasurementService.getTailoredTextOrDefault,\r\n                        CartesianChart.AxisTextProperties,\r\n                        !xAxis.willLabelsFit,\r\n                        bottomMarginLimit === tickLabelMargins.xMax,\r\n                        xAxis,\r\n                        this.margin,\r\n                        this.isXScrollBarVisible || this.isYScrollBarVisible);\r\n                }\r\n            }\r\n            else {\r\n                this.xAxisGraphicsContext.selectAll('*').remove();\r\n            }\r\n\r\n            if (this.shouldRenderAxis(yAxis)) {\r\n                let yAxisOrientation = this.yAxisOrientation;\r\n\r\n                yAxis.axis\r\n                    .tickSize(-this.viewportIn.width)\r\n                    .tickPadding(10)\r\n                    .orient(yAxisOrientation.toLowerCase());\r\n\r\n                let y1AxisGraphicsElement = this.y1AxisGraphicsContext;\r\n                if (duration) {\r\n                    y1AxisGraphicsElement\r\n                        .transition()\r\n                        .duration(duration)\r\n                        .call(yAxis.axis)\r\n                        .call(this.darkenZeroLine);\r\n                }\r\n                else {\r\n                    y1AxisGraphicsElement\r\n                        .call(yAxis.axis)\r\n                        .call(this.darkenZeroLine);\r\n                }\r\n\r\n                let yZeroTick = y1AxisGraphicsElement.selectAll('g.tick').filter((data) => data === 0);\r\n                if (yZeroTick) {\r\n                    let yZeroColor = this.getCategoryAxisFill();\r\n                    if (yZeroColor) {\r\n                        yZeroTick.selectAll('line').style({ 'stroke': yZeroColor.solid.color });\r\n                    }\r\n                }\r\n\r\n                if (tickLabelMargins.yLeft >= leftRightMarginLimit) {\r\n                    y1AxisGraphicsElement.selectAll('text')\r\n                        .call(AxisHelper.LabelLayoutStrategy.clip,\r\n                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations\r\n                        leftRightMarginLimit - 10,\r\n                        TextMeasurementService.svgEllipsis);\r\n                }\r\n\r\n                // TODO: clip (svgEllipsis) the Y2 labels\r\n            }\r\n            else {\r\n                this.y1AxisGraphicsContext.selectAll('*').remove();\r\n            }\r\n            // Axis labels\r\n            //TODO: Add label for second Y axis for combo chart\r\n            if (chartHasAxisLabels) {\r\n                let hideXAxisTitle = !this.shouldRenderAxis(xAxis, \"showAxisTitle\");\r\n                let hideYAxisTitle = !this.shouldRenderAxis(yAxis, \"showAxisTitle\");\r\n                let hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties[\"secShowAxisTitle\"] != null && this.valueAxisProperties[\"secShowAxisTitle\"] === false;\r\n\r\n                this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);\r\n            }\r\n            else {\r\n                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\r\n                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\r\n            }\r\n            this.renderCrossHair();\r\n        }\r\n\r\n        private renderAxesLabels(axisLabels: ChartAxesLabels, legendMargin: number, hideXAxisTitle: boolean, hideYAxisTitle: boolean, hideY2AxisTitle: boolean): void {\r\n            this.axisGraphicsContext.selectAll('.xAxisLabel').remove();\r\n            this.axisGraphicsContext.selectAll('.yAxisLabel').remove();\r\n\r\n            let margin = this.margin;\r\n            let width = this.viewportIn.width;\r\n            let height = this.viewport.height;\r\n            let fontSize = EnhancedScatterChart.AxisFontSize;\r\n            let yAxisOrientation = this.yAxisOrientation;\r\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\r\n\r\n            if (!hideXAxisTitle) {\r\n                let xAxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(axisLabels.x)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function () {\r\n                            let text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"xAxisLabel\",\r\n                                \"transform\": SVGUtil.translate(width / 2, height - fontSize - 2)\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    width,\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n\r\n            if (!hideYAxisTitle) {\r\n                let yAxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(axisLabels.y)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function () {\r\n                            let text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"yAxisLabel\",\r\n                                \"transform\": \"rotate(-90)\",\r\n                                \"y\": showY1OnRight ? width + margin.right - fontSize : -margin.left,\r\n                                \"x\": -((height - margin.top - legendMargin) / 2),\r\n                                \"dy\": \"1em\"\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    height - (margin.bottom + margin.top),\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n\r\n            if (!hideY2AxisTitle && axisLabels.y2) {\r\n                let y2AxisLabel = this.axisGraphicsContext.append(\"text\")\r\n                    .style(\"text-anchor\", \"middle\")\r\n                    .text(axisLabels.y2)\r\n                    .call((text: D3.Selection) => {\r\n                        text.each(function () {\r\n                            let text = d3.select(this);\r\n                            text.attr({\r\n                                \"class\": \"yAxisLabel\",\r\n                                \"transform\": \"rotate(-90)\",\r\n                                \"y\": showY1OnRight ? -margin.left : width + margin.right - fontSize,\r\n                                \"x\": -((height - margin.top - legendMargin) / 2),\r\n                                \"dy\": \"1em\"\r\n                            });\r\n                        });\r\n                    });\r\n\r\n                y2AxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    height - (margin.bottom + margin.top),\r\n                    TextMeasurementService.svgEllipsis);\r\n            }\r\n        }\r\n\r\n        private updateAxis(): void {\r\n            this.adjustMargins();\r\n\r\n            let yAxisOrientation = this.yAxisOrientation;\r\n            let showY1OnRight = yAxisOrientation === yAxisPosition.right;\r\n\r\n            this.xAxisGraphicsContext\r\n                .attr('transform', SVGUtil.translate(0, this.viewportIn.height));\r\n\r\n            this.y1AxisGraphicsContext\r\n                .attr('transform', SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));\r\n\r\n            this.svg.attr({\r\n                'width': this.viewport.width,\r\n                'height': this.viewport.height\r\n            });\r\n\r\n            this.svgScrollable.attr({\r\n                'width': this.viewport.width,\r\n                'height': this.viewport.height\r\n            });\r\n\r\n            this.svgScrollable.attr({\r\n                'x': 0\r\n            });\r\n\r\n            let left: number = this.margin.left;\r\n            let top: number = this.margin.top;\r\n\r\n            this.axisGraphicsContext.attr('transform', SVGUtil.translate(left, top));\r\n            this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(left, top));\r\n            this.clearCatcher.attr('transform', SVGUtil.translate(-left, -top));\r\n\r\n            if (this.isXScrollBarVisible) {\r\n                this.svgScrollable.attr({\r\n                    'x': left\r\n                });\r\n                this.axisGraphicsContextScrollable.attr('transform', SVGUtil.translate(0, top));\r\n                this.svgScrollable.attr('width', this.viewportIn.width);\r\n                this.svg.attr('width', this.viewport.width)\r\n                    .attr('height', this.viewport.height + this.ScrollBarWidth);\r\n            }\r\n            else if (this.isYScrollBarVisible) {\r\n                this.svgScrollable.attr('height', this.viewportIn.height + top);\r\n                this.svg.attr('width', this.viewport.width + this.ScrollBarWidth)\r\n                    .attr('height', this.viewport.height);\r\n            }\r\n        }\r\n\r\n        private getUnitType(xAxis: IAxisProperties) {\r\n            if (xAxis.formatter &&\r\n                xAxis.formatter.displayUnit &&\r\n                xAxis.formatter.displayUnit.value > 1)\r\n                return xAxis.formatter.displayUnit.title;\r\n            return null;\r\n        }\r\n\r\n        private addUnitTypeToAxisLabel(xAxis: IAxisProperties, yAxis: IAxisProperties): void {\r\n            let unitType = this.getUnitType(xAxis);\r\n            if (xAxis.isCategoryAxis) {\r\n                this.categoryAxisHasUnitType = unitType !== null;\r\n            }\r\n            else {\r\n                this.valueAxisHasUnitType = unitType !== null;\r\n            }\r\n\r\n            if (xAxis.axisLabel && unitType) {\r\n                if (xAxis.isCategoryAxis) {\r\n                    xAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);\r\n                }\r\n                else {\r\n                    xAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);\r\n                }\r\n            }\r\n\r\n            unitType = this.getUnitType(yAxis);\r\n\r\n            if (!yAxis.isCategoryAxis) {\r\n                this.valueAxisHasUnitType = unitType !== null;\r\n            }\r\n            else {\r\n                this.categoryAxisHasUnitType = unitType !== null;\r\n            }\r\n\r\n            if (yAxis.axisLabel && unitType) {\r\n                if (!yAxis.isCategoryAxis) {\r\n                    yAxis.axisLabel = AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);\r\n                }\r\n                else {\r\n                    yAxis.axisLabel = AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);\r\n                }\r\n            }\r\n        }\r\n\r\n        private hideAxisLabels(): boolean {\r\n            if (this.cartesianSmallViewPortProperties) {\r\n                if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort\r\n                    && ((this.viewport.height + this.legendViewport.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible)\r\n                    && !this.options.interactivity.isInteractiveLegend) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private drawScatterMarkers(scatterData: EnhancedScatterChartDataPoint[], hasSelection: boolean, sizeRange: NumberRange, duration: number) {\r\n            let xScale = this.xAxisProperties.scale;\r\n            let yScale = this.yAxisProperties.scale;\r\n            let shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;\r\n\r\n            let markers;\r\n            let useCustomColor = this.data.useCustomColor;\r\n            if (this.data.useShape) {\r\n                this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove();\r\n                markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, (d: EnhancedScatterChartDataPoint) => d.identity.getKey());\r\n                markers.enter()\r\n                    .append('path')\r\n                    .classed(EnhancedScatterChart.DotClasses.class, true).attr('id', 'markershape');\r\n                markers\r\n                    .style({\r\n                        'stroke-opacity': (d: EnhancedScatterChartDataPoint) => ScatterChart.getBubbleOpacity(d, hasSelection),\r\n                        'stroke-width': '1px',\r\n                        'stroke': (d: EnhancedScatterChartDataPoint) => {\r\n                            let color = useCustomColor ? d.colorFill : d.fill;\r\n                            if (this.data.outline) {\r\n                                return d3.rgb(color).darker();\r\n                            } else {\r\n                                return d3.rgb(color);\r\n                            }\r\n                        },\r\n                        'fill': (d: EnhancedScatterChartDataPoint) => d3.rgb(useCustomColor ? d.colorFill : d.fill),\r\n                        'fill-opacity': (d: EnhancedScatterChartDataPoint) => (d.size != null || shouldEnableFill) ? ScatterChart.getBubbleOpacity(d, hasSelection) : 0,\r\n                    })\r\n                    .attr(\"d\", (d: EnhancedScatterChartDataPoint) => {\r\n                        let r = ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport);\r\n                        let area = 4 * r * r;\r\n                        return d.shapeSymbolType(area);\r\n                    })\r\n                    .transition()\r\n                    .duration((d) => {\r\n                        if (this.keyArray.indexOf(d.identity.getKey()) >= 0) {\r\n                            return duration;\r\n                        } else {\r\n                            return 0;\r\n                        }\r\n                    })\r\n                    .attr(\"transform\", function (d) { return \"translate(\" + xScale(d.x) + \",\" + yScale(d.y) + \") rotate(\" + d.rotation + \")\"; });\r\n            } else {\r\n                this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove();\r\n                markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, (d: EnhancedScatterChartDataPoint) => d.identity.getKey());\r\n                markers.enter().append(\"svg:image\")\r\n                    .classed(EnhancedScatterChart.ImageClasses.class, true).attr('id', 'markerimage');\r\n                markers\r\n                    .attr(\"xlink:href\", (d) => {\r\n                        if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== \"\") {\r\n                            return d.svgurl;\r\n                        } else {\r\n                            return this.svgDefaultImage;\r\n                        }\r\n                    })\r\n                    .attr(\"width\", (d) => {\r\n                        return ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport) * 2;\r\n                    })\r\n                    .attr(\"height\", (d) => {\r\n                        return ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport) * 2;\r\n                    })\r\n                    .transition()\r\n                    .duration((d) => {\r\n                        if (this.keyArray.indexOf(d.identity.getKey()) >= 0) {\r\n                            return duration;\r\n                        } else {\r\n                            return 0;\r\n                        }\r\n                    })\r\n                    .attr(\"transform\", (d) => {\r\n                        let radius = ScatterChart.getBubbleRadius(d.radius, sizeRange, this.viewport);\r\n                        return \"translate(\" + (xScale(d.x) - radius) + \",\" + (yScale(d.y) - radius) + \") rotate(\" + d.rotation + \",\" + radius + \",\" + radius + \")\";\r\n                    });\r\n            }\r\n\r\n            markers.exit().remove();\r\n            this.keyArray = [];\r\n            for (let i = 0; i < scatterData.length; i++) {\r\n                this.keyArray.push(scatterData[i].identity.getKey());\r\n            }\r\n\r\n            return markers;\r\n        }\r\n\r\n        public calculateAxes(\r\n            categoryAxisProperties: DataViewObject,\r\n            valueAxisProperties: DataViewObject,\r\n            textProperties: TextProperties,\r\n            scrollbarVisible: boolean): IAxisProperties[] {\r\n\r\n            let visualOptions: CalculateScaleAndDomainOptions = {\r\n                viewport: this.viewport,\r\n                margin: this.margin,\r\n                forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],\r\n                forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,\r\n                showCategoryAxisLabel: false,\r\n                showValueAxisLabel: false,\r\n                categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? <string>categoryAxisProperties['axisScale'] : null,\r\n                valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? <string>valueAxisProperties['axisScale'] : null,\r\n                valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? <number>valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\r\n                categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? <number>categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,\r\n                trimOrdinalDataOnOverflow: false\r\n            };\r\n\r\n            if (valueAxisProperties) {\r\n                visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);\r\n            }\r\n\r\n            visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);\r\n\r\n            visualOptions.showValueAxisLabel = true;\r\n\r\n            let width = this.viewport.width - (this.margin.left + this.margin.right);\r\n\r\n            let axes = this.calculateAxesProperties(visualOptions);\r\n            axes[0].willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\r\n                axes[0],\r\n                width,\r\n                TextMeasurementService.measureSvgTextWidth,\r\n                textProperties);\r\n\r\n            // If labels do not fit and we are not scrolling, try word breaking\r\n            axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\r\n                axes[0], this.margin, width, TextMeasurementService.measureSvgTextWidth,\r\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\r\n                textProperties);\r\n            return axes;\r\n        }\r\n\r\n        public calculateAxesProperties(options: CalculateScaleAndDomainOptions): IAxisProperties[] {\r\n            let data = this.data;\r\n            let dataPoints = data.dataPoints;\r\n            this.margin = options.margin;\r\n            this.viewport = options.viewport;\r\n\r\n            let minY = 0,\r\n                maxY = 10,\r\n                minX = 0,\r\n                maxX = 10;\r\n            if (dataPoints.length > 0) {\r\n                minY = d3.min<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.y);\r\n                maxY = d3.max<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.y);\r\n                minX = d3.min<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.x);\r\n                maxX = d3.max<EnhancedScatterChartDataPoint, number>(dataPoints, d => d.x);\r\n            }\r\n\r\n            let xDomain = [minX, maxX];\r\n            let combinedXDomain = AxisHelper.combineDomain(options.forcedXDomain, xDomain);\r\n\r\n            this.xAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: this.viewportIn.width,\r\n                dataDomain: combinedXDomain,\r\n                metaDataColumn: data.xCol,\r\n                formatString: valueFormatter.getFormatString(data.xCol, scatterChartProps.general.formatString),\r\n                outerPadding: 0,\r\n                isScalar: true,\r\n                isVertical: false,\r\n                forcedTickCount: options.forcedTickCount,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: true, //scatter doesn't have a categorical axis, but this is needed for the pane to react correctly to the x-axis toggle one/off\r\n                scaleType: options.categoryAxisScaleType,\r\n                axisDisplayUnits: options.categoryAxisDisplayUnits\r\n            });\r\n            this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);\r\n            this.xAxisProperties.axisLabel = this.data.axesLabels.x;\r\n\r\n            let combinedDomain = AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);\r\n\r\n            this.yAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: this.viewportIn.height,\r\n                dataDomain: combinedDomain,\r\n                metaDataColumn: data.yCol,\r\n                formatString: valueFormatter.getFormatString(data.yCol, scatterChartProps.general.formatString),\r\n                outerPadding: 0,\r\n                isScalar: true,\r\n                isVertical: true,\r\n                forcedTickCount: options.forcedTickCount,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: false,\r\n                scaleType: options.valueAxisScaleType,\r\n                axisDisplayUnits: options.valueAxisDisplayUnits\r\n            });\r\n            this.yAxisProperties.axisLabel = this.data.axesLabels.y;\r\n\r\n            return [this.xAxisProperties, this.yAxisProperties];\r\n        }\r\n\r\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder): void {\r\n            let data = this.data;\r\n            if (!data)\r\n                return;\r\n\r\n            let seriesCount = data.dataPoints.length;\r\n\r\n            if (!data.hasDynamicSeries) {\r\n                // Add default color and show all slices\r\n                enumeration.pushInstance({\r\n                    objectName: 'dataPoint',\r\n                    selector: null,\r\n                    properties: {\r\n                        defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }\r\n                    }\r\n                }).pushInstance({\r\n                    objectName: 'dataPoint',\r\n                    selector: null,\r\n                    properties: {\r\n                        showAllDataPoints: !!data.showAllDataPoints\r\n                    }\r\n                });\r\n\r\n                for (let i = 0; i < seriesCount; i++) {\r\n                    let seriesDataPoints = data.dataPoints[i];\r\n                    enumeration.pushInstance({\r\n                        objectName: 'dataPoint',\r\n                        displayName: seriesDataPoints.formattedCategory.getValue(),\r\n                        selector: ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),\r\n                        properties: {\r\n                            fill: { solid: { color: seriesDataPoints.fill } }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                let legendDataPointLength = data.legendData.dataPoints.length;\r\n                for (let i = 0; i < legendDataPointLength; i++) {\r\n                    let series = data.legendData.dataPoints[i];\r\n                    enumeration.pushInstance({\r\n                        objectName: 'dataPoint',\r\n                        displayName: series.label,\r\n                        selector: ColorHelper.normalizeSelector(series.identity.getSelector()),\r\n                        properties: {\r\n                            fill: { solid: { color: series.color } }\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration = new ObjectEnumerationBuilder();\r\n\r\n            switch (options.objectName) {\r\n                case 'dataPoint':\r\n                    let categoricalDataView: DataViewCategorical = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;\r\n                    if (!GradientUtils.hasGradientRole(categoricalDataView))\r\n                        this.enumerateDataPoints(enumeration);\r\n                    break;\r\n                case 'categoryAxis':\r\n                    this.getCategoryAxisValues(enumeration);\r\n                    break;\r\n                case 'valueAxis':\r\n                    this.getValueAxisValues(enumeration);\r\n                    break;\r\n                case 'categoryLabels':\r\n                    if (this.data)\r\n                        dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);\r\n                    else\r\n                        dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);\r\n                    break;\r\n                case 'fillPoint':\r\n                    let sizeRange = this.data.sizeRange;\r\n                    // Check if the card should be shown or not\r\n                    if (sizeRange && sizeRange.min)\r\n                        break;\r\n\r\n                    enumeration.pushInstance({\r\n                        objectName: 'fillPoint',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.data.fillPoint,\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'backdrop':\r\n                    enumeration.pushInstance({\r\n                        objectName: 'backdrop',\r\n                        displayName: 'Backdrop',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.data.backdrop ? this.data.backdrop.show : false,\r\n                            url: this.data.backdrop ? this.data.backdrop.url : null\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'crosshair':\r\n                    enumeration.pushInstance({\r\n                        objectName: 'crosshair',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.data.crosshair\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'outline':\r\n                    enumeration.pushInstance({\r\n                        objectName: 'outline',\r\n                        selector: null,\r\n                        properties: {\r\n                            show: this.data.outline\r\n                        },\r\n                    });\r\n                    break;\r\n                case 'legend':\r\n                    this.getLegendValue(enumeration);\r\n                    break;\r\n            }\r\n            return enumeration.complete();\r\n        }\r\n\r\n        public hasLegend(): boolean {\r\n            return this.data && this.data.hasDynamicSeries;\r\n        }\r\n\r\n        private getLegendValue(enumeration: ObjectEnumerationBuilder): void {\r\n            if (!this.hasLegend())\r\n                return;\r\n            let show = DataViewObject.getValue<boolean>(this.legendObjectProperties, legendProps.show, this.legend.isVisible());\r\n            let showTitle = DataViewObject.getValue<boolean>(this.legendObjectProperties, legendProps.showTitle, true);\r\n            let titleText = DataViewObject.getValue<string>(this.legendObjectProperties, legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');\r\n            let legendLabelColor = DataViewObject.getValue<string>(this.legendObjectProperties, legendProps.labelColor, LegendData.DefaultLegendLabelFillColor);\r\n            this.legendLabelFontSize = DataViewObject.getValue<number>(this.legendObjectProperties, legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);\r\n\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                properties: {\r\n                    show: show,\r\n                    position: LegendPosition[this.legend.getOrientation()],\r\n                    showTitle: showTitle,\r\n                    titleText: titleText,\r\n                    labelColor: legendLabelColor,\r\n                    fontSize: this.legendLabelFontSize,\r\n                },\r\n                objectName: 'legend'\r\n            });\r\n        }\r\n\r\n        private getCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n            let supportedType = axisType.both;\r\n            let isScalar = true;\r\n            let logPossible = false;\r\n            let scaleOptions = [axisScale.log, axisScale.linear];//until options can be update in propPane, show all options\r\n\r\n            if (!isScalar) {\r\n                if (this.categoryAxisProperties) {\r\n                    this.categoryAxisProperties['start'] = null;\r\n                    this.categoryAxisProperties['end'] = null;\r\n                }\r\n            }\r\n\r\n            let instance: VisualObjectInstance = {\r\n                selector: null,\r\n                properties: {},\r\n                objectName: 'categoryAxis',\r\n                validValues: {\r\n                    axisScale: scaleOptions\r\n                }\r\n            };\r\n\r\n            instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;\r\n            if (this.yAxisIsCategorical)//in case of e.g. barChart\r\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\r\n            if (supportedType === axisType.both) {\r\n                instance.properties['axisType'] = isScalar ? axisType.scalar : axisType.categorical;\r\n            }\r\n            if (isScalar) {\r\n                instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : axisScale.linear;\r\n                instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;\r\n                instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;\r\n                instance.properties['labelDisplayUnits'] = this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\r\n            }\r\n            instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : true;\r\n\r\n            enumeration\r\n                .pushInstance(instance)\r\n                .pushInstance({\r\n                    selector: null,\r\n                    properties: {\r\n                        axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\r\n                        labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null\r\n                    },\r\n                    objectName: 'categoryAxis',\r\n                    validValues: {\r\n                        axisStyle: this.categoryAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\r\n                    }\r\n                });\r\n        }\r\n\r\n        //todo: wrap all these object getters and other related stuff into an interface\r\n        private getValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n            let scaleOptions = [axisScale.log, axisScale.linear];  //until options can be update in propPane, show all options\r\n            let logPossible = false;\r\n\r\n            let instance: VisualObjectInstance = {\r\n                selector: null,\r\n                properties: {},\r\n                objectName: 'valueAxis',\r\n                validValues: {\r\n                    axisScale: scaleOptions,\r\n                    secAxisScale: scaleOptions\r\n                }\r\n            };\r\n\r\n            instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;\r\n\r\n            if (!this.yAxisIsCategorical) {\r\n                instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : yAxisPosition.left;\r\n            }\r\n            instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : axisScale.linear;\r\n            instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;\r\n            instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;\r\n            instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : true;\r\n            instance.properties['labelDisplayUnits'] = this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;\r\n\r\n            enumeration\r\n                .pushInstance(instance)\r\n                .pushInstance({\r\n                    selector: null,\r\n                    properties: {\r\n                        axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : axisStyle.showTitleOnly,\r\n                        labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null\r\n                    },\r\n                    objectName: 'valueAxis',\r\n                    validValues: {\r\n                        axisStyle: this.valueAxisHasUnitType ? [axisStyle.showTitleOnly, axisStyle.showUnitOnly, axisStyle.showBoth] : [axisStyle.showTitleOnly]\r\n                    },\r\n                });\r\n        }\r\n\r\n        public onClearSelection(): void {\r\n            if (this.interactivityService)\r\n                this.interactivityService.clearSelection();\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/enhancedScatterChart/visual/enhancedScatterChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n \r\nvar THREE: any;\r\nvar WebGLHeatmap;\r\nvar GlobeMapCanvasLayers: JQuery[];\r\n\r\nmodule powerbi.visuals.samples {\r\n    import TouchRect = controls.TouchUtils.Rectangle;\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    interface RenderData {\r\n        lat: number;\r\n        lng: number;\r\n        height: number;\r\n        heightBySeries: number[];\r\n        seriesToolTipData: any[];\r\n        heat: number;\r\n        toolTipData: any;\r\n    }\r\n\r\n    export class GlobeMap implements IVisual {\r\n        public static MercartorSphere: any;\r\n        private viewport: IViewport;\r\n        private container: JQuery;\r\n        private domElement: HTMLElement;\r\n        private camera: any;\r\n        private renderer: any;\r\n        private scene: any;\r\n        private orbitControls: any;\r\n        private earth: any;\r\n        private settings: any;\r\n        private renderData: RenderData[] = [];\r\n        private heatmap: any;\r\n        private heatTexture: any;\r\n        private mapTextures: any[];\r\n        private barsGroup: any;\r\n        private readyToRender: boolean;\r\n        private categoricalView: any;\r\n        private deferredRenderTimerId: any;\r\n        private globeMapLocationCache: any;\r\n        private locationsToLoad: number = 0;\r\n        private locationsLoaded: number = 0;\r\n        private renderLoopEnabled = true;\r\n        private needsRender = false;\r\n        private mousePosNormalized: any;\r\n        private mousePos: any;\r\n        private rayCaster: any;\r\n        private selectedBar: any;\r\n        private hoveredBar: any;\r\n        private averageBarVector: any;\r\n        private zoomControl: any;\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Location'),\r\n                    preferredTypes: [\r\n                        { geography: { address: true } },\r\n                        { geography: { city: true } },\r\n                        { geography: { continent: true } },\r\n                        { geography: { country: true } },\r\n                        { geography: { county: true } },\r\n                        { geography: { place: true } },\r\n                        { geography: { postalCode: true } },\r\n                        { geography: { region: true } },\r\n                        { geography: { stateOrProvince: true } },\r\n                    ],\r\n                },\r\n                {\r\n                    name: 'Series',\r\n                    kind: powerbi.VisualDataRoleKind.Grouping,\r\n                    displayName: \"Legend\",\r\n                },\r\n                {\r\n                    name: 'X',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Longitude',\r\n                    description: 'Use to override the longitude of locations',\r\n                    preferredTypes: [{ geography: { longitude: true } }],\r\n                },\r\n                {\r\n                    name: 'Y',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Latitude',\r\n                    description: 'Use to override the latitude of locations',\r\n                    preferredTypes: [{ geography: { latitude: true } }],\r\n                },\r\n                {\r\n                    name: 'Height',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Bar Height',\r\n                },\r\n                {\r\n                    name: 'Heat',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Heat Intensity',\r\n                }\r\n            ],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                legend: {\r\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\r\n                            type: { formatting: { legendPosition: true } }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendTitleText'),\r\n                            type: { text: true }\r\n                        }\r\n                    }\r\n                },\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\r\n                    properties: {\r\n                        defaultColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DefaultColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        showAllDataPoints: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DataPoint_Show_All'),\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fillRule: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Gradient'),\r\n                            type: { fillRule: {} },\r\n                            rule: {\r\n                                inputRole: 'Gradient',\r\n                                output: {\r\n                                    property: 'fill',\r\n                                    selector: ['Category'],\r\n                                },\r\n                            },\r\n                        }\r\n                    }\r\n                },\r\n                categoryLabels: {\r\n                    displayName: data.createDisplayNameGetter('Visual_CategoryLabels'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Series',\r\n                            select: [\r\n                                { bind: { to: 'Height' } },\r\n                                { bind: { to: 'Heat' } },\r\n                                { bind: { to: 'X' } },\r\n                                { bind: { to: 'Y' } },\r\n                            ],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        }\r\n                    },\r\n                    rowCount: { preferred: { min: 2 } }\r\n                },\r\n            }],\r\n            sorting: {\r\n                custom: {},\r\n            }\r\n        };\r\n\r\n        public static converter(dataView: DataView): any {\r\n            return {};\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            this.container = options.element;\r\n            this.viewport = options.viewport;\r\n            this.readyToRender = false;\r\n            if (!this.globeMapLocationCache) this.globeMapLocationCache = {};\r\n\r\n            if (!THREE) {\r\n                loadGlobeMapLibs();\r\n            }\r\n\r\n            if (THREE) {\r\n                this.setup();\r\n            }\r\n        }\r\n\r\n        private setup() {\r\n            this.initSettings();\r\n            this.initTextures();\r\n            this.initMercartorSphere();\r\n            this.initZoomControl();\r\n            this.initScene();\r\n            this.initHeatmap();\r\n            this.readyToRender = true;\r\n            this.composeRenderData();\r\n            this.initRayCaster();\r\n        }\r\n\r\n        private initSettings() {\r\n            var settings = this.settings = <any>{};\r\n            settings.autoRotate = false;\r\n            settings.earthRadius = 30;\r\n            settings.cameraRadius = 100;\r\n            settings.earthSegments = 100;\r\n            settings.heatmapSize = 1000;\r\n            settings.heatPointSize = 7;\r\n            settings.heatIntensity = 10;\r\n            settings.heatmapScaleOnZoom = 0.95;\r\n            settings.barWidth = 0.3;\r\n            settings.barHeight = 5;\r\n            settings.rotateSpeed = 0.5;\r\n            settings.zoomSpeed = 0.8;\r\n            settings.cameraAnimDuration = 1000; //ms\r\n            settings.clickInterval = 200; //ms\r\n        }\r\n\r\n        private initScene() {\r\n            var viewport = this.viewport;\r\n            var settings = this.settings;\r\n            var clock = new THREE.Clock();\r\n            var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });\r\n            this.container.append(renderer.domElement);\r\n            this.domElement = renderer.domElement;\r\n            var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, 0.1, 10000);\r\n            var orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement);\r\n            var scene = this.scene = new THREE.Scene();\r\n\r\n            renderer.setSize(viewport.width, viewport.height);\r\n            renderer.setClearColor(0xbac4d2, 1);\r\n            camera.position.z = settings.cameraRadius;\r\n\r\n            orbitControls.maxDistance = settings.cameraRadius;\r\n            orbitControls.minDistance = settings.earthRadius + 1;\r\n            orbitControls.rotateSpeed = settings.rotateSpeed;\r\n            orbitControls.zoomSpeed = settings.zoomSpeed;\r\n            orbitControls.autoRotate = settings.autoRotate;\r\n\r\n            var ambientLight = new THREE.AmbientLight(0x000000);\r\n            var light1 = new THREE.DirectionalLight(0xffffff, 0.4);\r\n            var light2 = new THREE.DirectionalLight(0xffffff, 0.4);\r\n            var earth = this.earth = this.createEarth();\r\n\r\n            scene.add(ambientLight);\r\n            scene.add(light1);\r\n            scene.add(light2);\r\n            scene.add(earth);\r\n\r\n            light1.position.set(20, 20, 20);\r\n            light2.position.set(0, 0, -20);\r\n\r\n            var _zis = this;\r\n\r\n            requestAnimationFrame(function render() {\r\n                try {\r\n                    if (_zis.renderLoopEnabled) requestAnimationFrame(render);\r\n                    if (!_zis.shouldRender()) return;\r\n                    orbitControls.update(clock.getDelta());\r\n                    _zis.setEarthTexture();\r\n                    _zis.intersectBars();\r\n                    _zis.heatmap.display(); // Needed for IE/Edge to behave nicely\r\n                    renderer.render(scene, camera);\r\n                    _zis.needsRender = false;\t\r\n                    //console.log(\"render\");\t\t\t\r\n                } catch (e) {\r\n                    console.error(e);\r\n                }\r\n            });\r\n        }\r\n\r\n        private shouldRender(): boolean {\r\n            return this.readyToRender && this.needsRender;\r\n        }\r\n\r\n        private createEarth() {\r\n            var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments);\r\n            var material = new THREE.MeshPhongMaterial({\r\n                map: this.mapTextures[0],\r\n                side: THREE.DoubleSide,\r\n                shininess: 1,\r\n                emissive: 0xaaaaaa,\r\n                //wireframe: true\r\n            });\r\n            return new THREE.Mesh(geometry, material);\r\n        }\r\n\r\n        public zoomClicked(zoomDirection: any) {\r\n            if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)\r\n                return;\r\n\r\n            if (zoomDirection === -1)\r\n                this.orbitControls.constraint.dollyOut(Math.pow(0.95, this.settings.zoomSpeed));\r\n            else if (zoomDirection === 1)\r\n                this.orbitControls.constraint.dollyIn(Math.pow(0.95, this.settings.zoomSpeed));\r\n\r\n            this.orbitControls.update();\r\n            this.animateCamera(this.camera.position);\r\n        }\r\n\r\n        public rotateCam(deltaX: number, deltaY: number) {\r\n            if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)\r\n                return;\r\n\r\n            this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed);\r\n            this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed);\r\n            this.orbitControls.update();\r\n            this.animateCamera(this.camera.position);\r\n        }\r\n\r\n        private initZoomControl() {\r\n            let radius = 17;\r\n            let zoomControlWidth = radius * 8.5;\r\n            let zoomControlHeight = radius * 8.5;\r\n            let startX = radius * 3;\r\n            let startY = radius + 3;\r\n            let gap = radius * 2;\r\n\r\n            let zoomCss = {\r\n                'position': 'absolute',\r\n                'left': 'calc(100% - ' + zoomControlWidth + 'px)',\r\n                'top': 'calc(100% - ' + zoomControlHeight + 'px)',\r\n                'zIndex': '1000',\r\n            };\r\n\r\n            let zoomContainer =\r\n                d3.select(this.container[0])\r\n                    .append('div')\r\n                    .style(zoomCss);\r\n\r\n            this.zoomControl = zoomContainer.append(\"svg\")\r\n                .attr({\r\n                    \"width\": zoomControlWidth,\r\n                    \"height\": zoomControlHeight\r\n                });\r\n\r\n            let bottom = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(0, -5));\r\n\r\n            bottom.append(\"circle\").attr({\r\n                cx: startX + gap,\r\n                cy: startY + (2 * gap),\r\n                r: radius,\r\n                fill: \"white\",\r\n                opacity: 0.5,\r\n                stroke: 'gray',\r\n            });\r\n\r\n            bottom.append(\"path\").attr({\r\n                d: \"M\" + (startX + (2 * radius)) + \" \" + (startY + (radius * 4.7)) + \" l12 -20 a40,70 0 0,1 -24,0z\",\r\n                fill: \"gray\",\r\n            });\r\n\r\n            let left = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(5, 0));\r\n\r\n            left.append(\"circle\").attr({\r\n                cx: startX,\r\n                cy: startY + gap,\r\n                r: radius,\r\n                fill: \"white\",\r\n                stroke: \"gray\",\r\n                opacity: 0.5,\r\n            });\r\n\r\n            left.append(\"path\").attr({\r\n                d: \"M\" + (startX - radius / 1.5) + \" \" + (startY + (radius * 2)) + \" l20 -12 a70,40 0 0,0 0,24z\",\r\n                fill: \"gray\",\r\n            });\r\n\r\n            let top = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(0, 5));\r\n\r\n            top.append(\"circle\").attr({\r\n                cx: startX + gap,\r\n                cy: startY,\r\n                r: radius,\r\n                fill: \"white\",\r\n                stroke: \"gray\",\r\n                opacity: 0.5,\r\n            });\r\n\r\n            top.append(\"path\").attr({\r\n                d: \"M\" + (startX + (2 * radius)) + \" \" + (startY - (radius / 1.5)) + \" l12 20 a40,70 0 0,0 -24,0z\",\r\n                fill: \"gray\",\r\n            });\r\n\r\n            let right = this.zoomControl.append(\"g\").on(\"click\", () => this.rotateCam(-5, 0));\r\n\r\n            right.append(\"circle\").attr({\r\n                cx: startX + (2 * gap),\r\n                cy: startY + gap,\r\n                r: radius,\r\n                fill: \"white\",\r\n                stroke: \"gray\",\r\n                opacity: 0.5,\r\n            });\r\n\r\n            right.append(\"path\").attr({\r\n                d: \"M\" + (startX + (4.7 * radius)) + \" \" + (startY + (radius * 2)) + \" l-20 -12 a70,40 0 0,1 0,24z\",\r\n                fill: \"gray\",\r\n            });\r\n\r\n            let zoomIn = this.zoomControl.append(\"g\").on(\"click\", () => this.zoomClicked(-1));\r\n\r\n            zoomIn.append(\"circle\").attr({\r\n                cx: startX + 4 * radius,\r\n                cy: startY + 6 * radius,\r\n                r: radius,\r\n                fill: \"white\",\r\n                stroke: \"gray\",\r\n                opacity: 0.5,\r\n            });\r\n\r\n            zoomIn.append(\"rect\").attr({\r\n                x: startX + 3.5 * radius,\r\n                y: startY + 5.9 * radius,\r\n                width: radius,\r\n                height: radius / 3,\r\n                fill: \"gray\",\r\n            });\r\n            zoomIn.append(\"rect\").attr({\r\n                x: startX + (4 * radius) - radius / 6,\r\n                y: startY + 5.55 * radius,\r\n                width: radius / 3,\r\n                height: radius,\r\n                fill: \"gray\",\r\n            });\r\n\r\n            var zoomOut = this.zoomControl.append(\"g\").on(\"click\", () => this.zoomClicked(1));\r\n\r\n            zoomOut.append(\"circle\").attr({\r\n                cx: startX,\r\n                cy: startY + 6 * radius,\r\n                r: radius,\r\n                fill: \"white\",\r\n                stroke: \"gray\",\r\n                opacity: \"0.50\",\r\n            });\r\n\r\n            zoomOut.append(\"rect\").attr({\r\n                x: startX - (radius / 2),\r\n                y: startY + 5.9 * radius,\r\n                width: radius,\r\n                height: radius / 3,\r\n                fill: \"gray\",\r\n            });\r\n        }\r\n\r\n        private initTextures() {\r\n            if (!GlobeMapCanvasLayers) {\r\n                // Initialize once, since this is a CPU + Network heavy operation.\r\n                GlobeMapCanvasLayers = [];\r\n\r\n                for (var level = 2; level <= 5; ++level) {\r\n                    var canvas = this.getBingMapCanvas(level);\r\n                    GlobeMapCanvasLayers.push(canvas);\r\n                }\r\n            }\r\n\r\n            // Can't execute in for loop because variable assignement gets overwritten\r\n            var createTexture = (canvas: JQuery) => {\r\n                var texture = new THREE.Texture(canvas.get(0));\r\n                texture.needsUpdate = true;\r\n                canvas.on(\"ready\", (e, resolution) => {\r\n                    //console.log(\"level ready\", resolution, texture)\r\n                    texture.needsUpdate = true;\r\n                    this.needsRender = true;\r\n                });\r\n                return texture;\r\n\r\n            };\r\n\r\n            this.mapTextures = [];\r\n            for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {\r\n                this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));\r\n            }\r\n        }\r\n\r\n        private initHeatmap() {\r\n            var settings = this.settings;\r\n\r\n            //console.log(\"initHeatmap\");\r\n            try {\r\n                var heatmap = this.heatmap = new WebGLHeatmap({ width: settings.heatmapSize, height: settings.heatmapSize, intensityToAlpha: true });\r\n            } catch (e) {\r\n                // IE & Edge will throw an error about texImage2D, we need to ignore it\r\n                console.error(e);\r\n            }\r\n\r\n            // canvas contents will be used for a texture\r\n            var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);\r\n            texture.needsUpdate = true;\r\n\r\n            var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });\r\n            var geometry = new THREE.SphereGeometry(settings.earthRadius + 0.01, settings.earthSegments, settings.earthSegments);\r\n            var mesh = new THREE.Mesh(geometry, material);\r\n\r\n            window[\"heatmap\"] = heatmap;\r\n            window[\"heatmapTexture\"] = texture;\r\n\r\n            this.scene.add(mesh);\r\n        }\r\n\r\n        private setEarthTexture() {\r\n            //get distance as arbitrary value from 0-1\r\n            if (!this.camera) return;\r\n            var maxDistance = this.settings.cameraRadius - this.settings.earthRadius;\r\n            var distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;\r\n\r\n            var texture;\r\n            if (distance <= 1 / 5) {\r\n                texture = this.mapTextures[3];\r\n            } else if (distance <= 2 / 5) {\r\n                texture = this.mapTextures[2];\r\n            } else if (distance <= 3 / 5) {\r\n                texture = this.mapTextures[1];\r\n            } else {\r\n                texture = this.mapTextures[0];\r\n            }\r\n\r\n            if (this.earth.material.map !== texture) {\r\n                this.earth.material.map = texture;\r\n            }\r\n\r\n            if (this.selectedBar) {\r\n                this.orbitControls.rotateSpeed = this.settings.rotateSpeed;\r\n            } else {\r\n                this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;\r\n            }\r\n\r\n            //console.log(distance, this.orbitControls.rotateSpeed);\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n            this.needsRender = true;\r\n            this.cleanHeatAndBar();\r\n            if (options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {\r\n                var viewport = this.viewport = options.viewport;\r\n                if (this.camera && this.renderer) {\r\n                    this.camera.aspect = viewport.width / viewport.height;\r\n                    this.camera.updateProjectionMatrix();\r\n                    this.renderer.setSize(viewport.width, viewport.height);\r\n                }\r\n                return;\r\n            }\r\n\r\n            // PowerBI fires two update calls, one for size, one for data\r\n            if (options.dataViews[0] && options.dataViews[0].categorical) {\r\n                this.composeRenderData(options.dataViews[0].categorical);\r\n            }\r\n        }\r\n\r\n        public cleanHeatAndBar() {\r\n            this.heatmap.clear();\r\n            this.heatTexture.needsUpdate = true;\r\n            if (this.barsGroup) {\r\n                this.scene.remove(this.barsGroup);\r\n            }\r\n        }\r\n\r\n        private renderMagic() {\r\n            if (!this.readyToRender) {\r\n                //console.log(\"not ready to render\");\r\n                this.defferedRender();\r\n                return;\r\n            }\r\n\r\n            var renderData = this.renderData;\r\n            var heatmap = this.heatmap;\r\n            var settings = this.settings;\r\n\r\n            heatmap.clear();\r\n\r\n            if (this.barsGroup) {\r\n                this.scene.remove(this.barsGroup);\r\n            }\r\n\r\n            this.barsGroup = new THREE.Object3D();\r\n            this.scene.add(this.barsGroup);\r\n\r\n            //colors for stacked vector by series values\r\n            var barMaterials = [\r\n                new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0xffff1a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0x00ffff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0x994d00, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0xb3cccc, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0xace600, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n                new THREE.MeshPhongMaterial({ color: 0x52527a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),\r\n            ];\r\n\r\n            this.averageBarVector = new THREE.Vector3();\r\n\r\n            for (var i = 0, len = renderData.length; i < len; ++i) {\r\n                var renderDatum = renderData[i];\r\n\r\n                if (!renderDatum.lat || !renderDatum.lng) continue;\r\n\r\n                if (renderDatum.heat > 0.001) {\r\n                    if (renderDatum.heat < 0.1) renderDatum.heat = 0.1;\r\n                    var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize;\r\n                    var y = (1 - ((90 + renderDatum.lat) / 180)) * settings.heatmapSize;\r\n                    heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);\r\n                }\r\n\r\n                if (renderDatum.height >= 0) {\r\n                    if (renderDatum.height < 0.01) renderDatum.height = 0.01;\r\n                    var latRadians = renderDatum.lat / 180 * Math.PI; //radians\r\n                    var lngRadians = renderDatum.lng / 180 * Math.PI;\r\n\r\n                    var x = Math.cos(lngRadians) * Math.cos(latRadians);\r\n                    var z = -Math.sin(lngRadians) * Math.cos(latRadians);\r\n                    var y = Math.sin(latRadians);\r\n                    var v = new THREE.Vector3(x, y, z);\r\n\r\n                    this.averageBarVector.add(v);\r\n\r\n                    var barHeight = settings.barHeight * renderDatum.height;\r\n                    //this array holds the relative series values to the actual measure for example [0.2,0.3,0.5]\r\n                    //this is how we draw the vectors relativly to the complete value one on top of another. \r\n                    var measuresBySeries = [];\r\n                    //this array holds the original values of the series for the tool tips\r\n                    var dataPointToolTip = [];\r\n                    if (renderDatum.heightBySeries) {\r\n                        for (var c = 0; c < renderDatum.heightBySeries.length; c++) {\r\n                            if (renderDatum.heightBySeries[c])\r\n                                measuresBySeries.push(renderDatum.heightBySeries[c]);\r\n                            dataPointToolTip.push(renderDatum.seriesToolTipData[c]);\r\n                        }\r\n                    } else {\r\n                        //no category series so we'll just draw one value\r\n                        measuresBySeries.push(1);\r\n                    }\r\n\r\n                    var previousMeasureValue = 0;\r\n                    for (var j = 0; j < measuresBySeries.length; j++) {\r\n                        previousMeasureValue += measuresBySeries[j];\r\n                        var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]);\r\n                        var bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);\r\n                        bar.position = v.clone().multiplyScalar(settings.earthRadius + ((barHeight / 2) * previousMeasureValue));\r\n                        bar.lookAt(v);\r\n                        bar.toolTipData = dataPointToolTip.length === 0 ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]);\r\n                        this.barsGroup.add(bar);\r\n                        previousMeasureValue += measuresBySeries[j];\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.barsGroup.children.length > 0 && this.camera) {\r\n                this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);\r\n                if (this.locationsLoaded === this.locationsToLoad) {\r\n                    this.animateCamera(this.averageBarVector);\r\n                }\r\n            }\r\n\r\n            heatmap.update();\r\n            heatmap.blur();\r\n            this.heatTexture.needsUpdate = true;\r\n            this.needsRender = true;\t\t\t\r\n\r\n            //console.log(\"renderMagic done! locations:\", this.barsGroup.children.length, \"toload/loaded\", this.locationsToLoad, this.locationsLoaded)\r\n        }\r\n\r\n        private getToolTipDataForSeries(toolTipData, dataPointToolTip): any {\r\n            var result = jQuery.extend(true, {\r\n                series: { displayName: dataPointToolTip.displayName, value: dataPointToolTip.value }\r\n            }, toolTipData);\r\n            result.height.value = dataPointToolTip.dataPointValue;\r\n            return result;\r\n        }\r\n\r\n        private composeRenderData(categoricalView?) {\r\n            // memoize last value\r\n            if (categoricalView) {\r\n                this.categoricalView = categoricalView;\r\n            } else {\r\n                categoricalView = this.categoricalView;\r\n            }\r\n\r\n            this.renderData = [];\r\n            var locations = [];\r\n            var globeMapLocationCache = this.globeMapLocationCache;\r\n\r\n            //console.log(\"categoricalView\", categoricalView)\r\n            if (!categoricalView) return;\r\n            var categories = categoricalView.categories;\r\n            var grouped = categoricalView.values.grouped();\r\n            var heightIndex = 0;\r\n            var intensityIndex = 0;\r\n            try {\r\n                heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Height\");\r\n                intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Heat\");\r\n                var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"X\");\r\n                var latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, \"Y\");\r\n            } catch (e) { }\r\n\r\n            var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;\r\n\r\n            if (heightIndex !== undefined && categoricalView.values[heightIndex] && categoricalView.values !== undefined) {\r\n                var locationCategory = categories[0];\r\n                locations = locationCategory.values;\r\n                locationDispName = locationCategory.source.displayName;\r\n                if (locationCategory.source.type.category) {\r\n                    locationType = locationCategory.source.type.category.toLowerCase();\r\n                } else {\r\n                    locationType = \"\";\r\n                }\r\n            } else {\r\n                locations = [];\r\n            }\r\n\r\n            // For debugging since devTools - salesByCountry isn't really sales by country\r\n            //var places = [\"kenya\", \"india\", \"united states\", \"london\", \"australia\", \"canada\"]\r\n            //heightIndex = 0;\r\n\r\n            if (heightIndex !== undefined && categoricalView.values[heightIndex]) {\r\n                // heights = categoricalView.values[heightIndex].values;\r\n                heightDispName = categoricalView.values[heightIndex].source.displayName;\r\n                heightFormat = categoricalView.values[heightIndex].source.format;\r\n                if (grouped.length > 1) {\r\n                    heights = new Array(locations.length);\r\n                    heightsBySeries = new Array(locations.length);\r\n                    toolTipDataBySeries = new Array(locations.length);\r\n                    //creating a matrix for drawing values by series later.\r\n                    for (var i = 0; i < grouped.length; i++) {\r\n                        var values = grouped[i].values[heightIndex].values;\r\n                        for (var j = 0; j < values.length; j++) {\r\n                            if (!heights[j]) heights[j] = 0;\r\n                            heights[j] += values[j] ? values[j] : 0;\r\n                            if (!heightsBySeries[j]) heightsBySeries[j] = [];\r\n                            heightsBySeries[j][i] = values[j];\r\n                            if (!toolTipDataBySeries[j]) toolTipDataBySeries[j] = [];\r\n                            toolTipDataBySeries[j][i] = { displayName: categoricalView.values.source.displayName, value: grouped[i].name, dataPointValue: values[j] };\r\n                        }\r\n                    }\r\n                    for (var i = 0; i < grouped.length; i++) {\r\n                        var values = grouped[i].values[heightIndex].values;\r\n                        for (var j = 0; j < values.length; j++) { \r\n                            //calculating relative size of series\r\n                            heightsBySeries[j][i] = values[j] / heights[j];\r\n                        }\r\n                    }\r\n                } else {\r\n                    heights = categoricalView.values[heightIndex].values;\r\n                    heightsBySeries = new Array(grouped.length);\r\n                }\r\n\r\n            } else {\r\n                heightsBySeries = new Array(locations.length);\r\n                heights = new Array(locations.length);\r\n            }\r\n\r\n            if (intensityIndex !== undefined && categoricalView.values[intensityIndex]) {\r\n                if (grouped.length > 1) {\r\n                    heats = new Array(locations.length);\r\n                    for (var i = 0; i < grouped.length; i++) {\r\n                        var values = grouped[i].values[intensityIndex].values;\r\n                        for (var j = 0; j < values.length; j++) {\r\n                            if (!heats[j]) heats[j] = 0;\r\n                            heats[j] += values[j] ? values[j] : 0;\r\n                        }\r\n                    }\r\n                } else {\r\n                    heats = categoricalView.values[intensityIndex].values;\r\n                }\r\n                heatDispName = categoricalView.values[intensityIndex].source.displayName;\r\n                heatFormat = categoricalView.values[intensityIndex].source.format;\r\n            } else {\r\n                heats = new Array(locations.length);\r\n            }\r\n\r\n            if (longitudeIndex !== undefined && categoricalView.values[longitudeIndex]\r\n                && latitudeIndex !== undefined && categoricalView.values[latitudeIndex]) {\r\n                longitudes = categoricalView.values[longitudeIndex].values;\r\n                latitudes = categoricalView.values[latitudeIndex].values;\r\n            }\r\n            else {\r\n                longitudes = null;\r\n                latitudes = null;\r\n            }\r\n\r\n            var maxHeight = Math.max.apply(null, heights) || 1;\r\n            var maxHeat = Math.max.apply(null, heats) || 1;\r\n            var heatFormatter = valueFormatter.create({ format: heatFormat, value: heats[0], value2: heats[1] });\r\n            var heightFormatter = valueFormatter.create({ format: heightFormat, value: heights[0], value2: heights[1] });\r\n\r\n            for (var i = 0, len = locations.length; i < len; ++i) {\r\n                var place = locations[i];\r\n                var lat, lng, latlng, height, heat;\r\n\r\n                //place = places[i];\r\n\r\n                if (place && typeof (place) === \"string\") {\r\n                    place = place.toLowerCase();\r\n                    var placeKey = place + \"/\" + locationType;\r\n\r\n                    if (!longitudes && globeMapLocationCache[placeKey]) {\r\n                        latlng = globeMapLocationCache[placeKey];\r\n                        lat = latlng.latitude;\r\n                        lng = latlng.longitude;\r\n                    }\r\n                    else if (longitudes) {\r\n                        lat = latitudes[i];\r\n                        lng = longitudes[i];\r\n                    }\r\n\r\n                    height = heights[i] / maxHeight;\r\n                    heat = heats[i] / maxHeat;\r\n\r\n                    var renderDatum = {\r\n                        lat: lat,\r\n                        lng: lng,\r\n                        height: height ? height || 0.01 : undefined,\r\n                        heightBySeries: heightsBySeries[i],\r\n                        seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : undefined,\r\n                        heat: heat || 0,\r\n                        toolTipData: {\r\n                            location: { displayName: locationDispName, value: locations[i] },\r\n                            height: { displayName: heightDispName, value: heightFormatter.format(heights[i]) },\r\n                            heat: { displayName: heatDispName, value: heatFormatter.format(heats[i]) }\r\n                        }\r\n                    };\r\n\r\n                    this.renderData.push(renderDatum);\r\n\r\n                    if (!longitudes && !latlng) {\r\n                        this.geocodeRenderDatum(renderDatum, place, locationType);\r\n                    }\r\n                }\r\n            }\r\n\r\n            try {\r\n                this.renderMagic();\r\n            } catch (e) {\r\n                console.error(e);\r\n            }\r\n        }\r\n\r\n        private geocodeRenderDatum(renderDatum, place, locationType) {\r\n            var placeKey = place + \"/\" + locationType;\r\n            this.globeMapLocationCache[placeKey] = {}; //store empty object so we don't send AJAX request again\r\n            this.locationsToLoad++;\r\n\r\n            try {\r\n                var geocoder = powerbi.visuals[\"BI\"].Services.GeocodingManager.geocode;\r\n            } catch (e) {\r\n                geocoder = services.geocode;\r\n            }\r\n\r\n            if (geocoder) {\r\n                geocoder(place, locationType).always((latlng: any) => {\r\n                    // we use always because we want to cache unknown values. \r\n                    // No point asking bing again and again when it tells us it doesn't know about a location\r\n                    this.globeMapLocationCache[placeKey] = latlng;\r\n                    this.locationsLoaded++;\r\n                    //console.log(place, latlng);\r\n\r\n                    if (latlng.latitude && latlng.longitude) {\r\n                        renderDatum.lat = latlng.latitude;\r\n                        renderDatum.lng = latlng.longitude;\r\n\r\n                        this.defferedRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        private defferedRender() {\r\n            if (!this.deferredRenderTimerId) {\r\n                this.deferredRenderTimerId = setTimeout(() => {\r\n                    this.deferredRenderTimerId = null;\r\n                    this.composeRenderData();\r\n                }, 500);\r\n            }\r\n        }\r\n\r\n        private initRayCaster() {\r\n            this.rayCaster = new THREE.Raycaster();\r\n            var settings = this.settings;\r\n            var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();\r\n            var mousePos = this.mousePos = new THREE.Vector2();\r\n            var element = this.container.get(0);\r\n            var mouseDownTime;\r\n\r\n            $(this.domElement).on(\"mousemove\", (event) => {\r\n                // get coordinates in -1 to +1 space\r\n                var rect = element.getBoundingClientRect();\r\n                mousePos.x = event.clientX;\r\n                mousePos.y = event.clientY;\r\n                mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\r\n                mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\r\n                this.needsRender = true;\r\n            }).on(\"mousedown\", (event) => {\r\n                mouseDownTime = Date.now();\r\n            }).on(\"mouseup\", (event) => {\r\n                // Debounce slow clicks\r\n                if ((Date.now() - mouseDownTime) > settings.clickInterval) return;\r\n                if (this.hoveredBar && event.shiftKey) {\r\n                    this.selectedBar = this.hoveredBar;\r\n                    this.animateCamera(this.selectedBar.position, () => {\r\n                        if (!this.selectedBar) return;\r\n                        this.orbitControls.center.copy(this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius));\r\n                        this.orbitControls.minDistance = 1;\r\n                    });\r\n                } else {\r\n                    if (this.selectedBar) {\r\n                        this.animateCamera(this.selectedBar.position, () => {\r\n                            this.orbitControls.center.set(0, 0, 0);\r\n                            this.orbitControls.minDistance = settings.earthRadius + 1;\r\n                        });\r\n                        this.selectedBar = null;\r\n                    }\r\n                }\r\n            }).on(\"mousewheel DOMMouseScroll\", (e: any) => {\r\n                this.needsRender = true;\r\n                if (this.orbitControls.enabled && this.orbitControls.enableZoom) {\r\n                    this.heatTexture.needsUpdate = true;\r\n                    e = e.originalEvent;\r\n                    var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1;\r\n                    var scale = delta > 0 ? this.settings.heatmapScaleOnZoom : (1 / this.settings.heatmapScaleOnZoom);\r\n                    this.heatmap.multiply(scale);\r\n                    this.heatmap.update();\r\n                }\r\n            });\r\n        }\r\n\r\n        private intersectBars() {\r\n            if (!this.rayCaster || !this.barsGroup) return;\r\n            var rayCaster = this.rayCaster;\r\n            rayCaster.setFromCamera(this.mousePosNormalized, this.camera);\r\n            var intersects = rayCaster.intersectObjects(this.barsGroup.children);\r\n\r\n            if (intersects && intersects.length > 0) {\r\n                //console.log(intersects[0], this.mousePos.x, this.mousePos.y);\r\n                var object = intersects[0].object;\r\n                if (!object || !object.toolTipData) return;\r\n                var toolTipData = object.toolTipData;\r\n                var toolTipItems: TooltipDataItem[] = [];\r\n                if (toolTipData.location.displayName) toolTipItems.push(toolTipData.location);\r\n                if (toolTipData.series) toolTipItems.push(toolTipData.series);\r\n                if (toolTipData.height.displayName) toolTipItems.push(toolTipData.height);\r\n                if (toolTipData.heat.displayName) toolTipItems.push(toolTipData.heat);\r\n                this.hoveredBar = object;\r\n                TooltipManager.ToolTipInstance.show(toolTipItems, <TouchRect>{ x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });\r\n            } else {\r\n                this.hoveredBar = null;\r\n                TooltipManager.ToolTipInstance.hide();\r\n            }\r\n        }\r\n\r\n        private animateCamera(to: any, done?: Function) {\r\n            if (!this.camera) return;\r\n            var startTime = Date.now();\r\n            var duration = this.settings.cameraAnimDuration;\r\n            var endTime = startTime + duration;\r\n            var startPos = this.camera.position.clone().normalize();\r\n            var endPos = to.clone().normalize();\r\n            var length = this.camera.position.length();\r\n\r\n            var easeInOut = function (t) {\r\n                t *= 2;\r\n                if (t < 1) return (t * t * t) / 2;\r\n                t -= 2;\r\n                return (t * t * t + 2) / 2;\r\n            };\r\n\r\n            var onUpdate = () => {\r\n                var now = Date.now();\r\n                var t = (now - startTime) / duration;\r\n                if (t > 1) t = 1;\r\n                t = easeInOut(t);\r\n\r\n                var pos = new THREE.Vector3()\r\n                    .add(startPos.clone().multiplyScalar(1 - t))\r\n                    .add(endPos.clone().multiplyScalar(t))\r\n                    .normalize()\r\n                    .multiplyScalar(length);\r\n\r\n                this.camera.position = pos;\r\n\r\n                if (now < endTime) {\r\n                    requestAnimationFrame(onUpdate);\r\n                } else if (done) {\r\n                    done();\r\n                }\r\n\r\n                this.needsRender = true;\r\n            };\r\n            requestAnimationFrame(onUpdate);\r\n        }\r\n\r\n        public destroy() {\r\n            clearTimeout(this.deferredRenderTimerId);\r\n            this.renderLoopEnabled = false;\r\n            this.scene = null;\r\n            this.heatmap = null;\r\n            this.heatTexture = null;\r\n            this.camera = null;\r\n            if (this.renderer) {\r\n                if (this.renderer.context) {\r\n                    let extension = this.renderer.context.getExtension('WEBGL_lose_context');\r\n                    if (extension)\r\n                        extension.loseContext();\r\n                    this.renderer.context = null;\r\n                }\r\n                this.renderer.domElement = null;\r\n            }\r\n            this.renderer = null;\r\n            this.renderData = null;\r\n            this.barsGroup = null;\r\n            if (this.orbitControls) this.orbitControls.dispose();\r\n            this.orbitControls = null;\r\n            if (this.domElement) $(this.domElement)\r\n                .off(\"mousemove mouseup mousedown mousewheel DOMMouseScroll\");\r\n            this.domElement = null;\r\n            if (this.container) this.container.empty();\r\n        }\r\n\r\n        private initMercartorSphere() {\r\n            if (GlobeMap.MercartorSphere) return;\r\n\r\n            var MercartorSphere = function (radius, widthSegments, heightSegments) {\r\n                THREE.Geometry.call(this);\r\n\r\n                this.radius = radius;\r\n                this.widthSegments = widthSegments;\r\n                this.heightSegments = heightSegments;\r\n\r\n                this.t = 0;\r\n\r\n                var x, y, vertices = [], uvs = [];\r\n\r\n                function interplolate(a, b, t) {\r\n                    return (1 - t) * a + t * b;\r\n                }\r\n\r\n                // interpolates between sphere and plane\r\n                function interpolateVertex(u, v, t) {\r\n                    var maxLng = Math.PI * 2;\r\n                    var maxLat = Math.PI;\r\n                    var radius = this.radius;\r\n\r\n                    var sphereX = - radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);\r\n                    var sphereY = - radius * Math.cos(v * maxLat);\r\n                    var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);\r\n\r\n                    var planeX = u * radius * 2 - radius;\r\n                    var planeY = v * radius * 2 - radius;\r\n                    var planeZ = 0;\r\n\r\n                    var x = interplolate(sphereX, planeX, t);\r\n                    var y = interplolate(sphereY, planeY, t);\r\n                    var z = interplolate(sphereZ, planeZ, t);\r\n\r\n                    return new THREE.Vector3(x, y, z);\r\n                }\r\n\r\n                // http://mathworld.wolfram.com/MercatorProjection.html\r\n                // Mercator projection goes form +85.05 to -85.05 degrees\r\n                function interpolateUV(u, v, t) {\r\n                    var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians\r\n                    var sin = Math.sin(lat);\r\n                    var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\r\n                    return new THREE.Vector2(u, normalizedV);//interplolate(normalizedV1, v, t))\r\n                }\r\n\r\n                for (y = 0; y <= heightSegments; y++) {\r\n\r\n                    var verticesRow = [];\r\n                    var uvsRow = [];\r\n\r\n                    for (x = 0; x <= widthSegments; x++) {\r\n\r\n                        var u = x / widthSegments;\r\n                        var v = y / heightSegments;\r\n\r\n                        this.vertices.push(interpolateVertex.call(this, u, v, this.t));\r\n                        uvsRow.push(interpolateUV.call(this, u, v, this.t));\r\n                        verticesRow.push(this.vertices.length - 1);\r\n                    }\r\n\r\n                    vertices.push(verticesRow);\r\n                    uvs.push(uvsRow);\r\n\r\n                }\r\n\r\n                //console.log(vertices, uvs);\r\n\r\n                for (y = 0; y < this.heightSegments; y++) {\r\n\r\n                    for (x = 0; x < this.widthSegments; x++) {\r\n\r\n                        var v1 = vertices[y][x + 1];\r\n                        var v2 = vertices[y][x];\r\n                        var v3 = vertices[y + 1][x];\r\n                        var v4 = vertices[y + 1][x + 1];\r\n\r\n                        var n1 = this.vertices[v1].clone().normalize();\r\n                        var n2 = this.vertices[v2].clone().normalize();\r\n                        var n3 = this.vertices[v3].clone().normalize();\r\n                        var n4 = this.vertices[v4].clone().normalize();\r\n\r\n                        var uv1 = uvs[y][x + 1].clone();\r\n                        var uv2 = uvs[y][x].clone();\r\n                        var uv3 = uvs[y + 1][x].clone();\r\n                        var uv4 = uvs[y + 1][x + 1].clone();\r\n\r\n                        var normals = [n1, n2, n3, n4];\r\n\r\n                        this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));\r\n                        this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);\r\n                    }\r\n\r\n                }\r\n\r\n                this.computeCentroids();\r\n                this.computeFaceNormals();\r\n\r\n                this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);\r\n            };\r\n\r\n            MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);\r\n            GlobeMap.MercartorSphere = MercartorSphere;\r\n        }\r\n\r\n        private getBingMapCanvas(resolution): JQuery {\r\n            var tileSize = 256;\r\n            var numSegments = Math.pow(2, resolution);\r\n            var numTiles = numSegments * numSegments;\r\n            var tilesLoaded = 0;\r\n            var canvasSize = tileSize * numSegments;\r\n            var canvas: JQuery = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });\r\n            var canvasElem: any = canvas.get(0);\r\n            var canvasContext = canvasElem.getContext(\"2d\");\r\n\r\n            function generateQuads(res, quad) {\r\n                if (res <= resolution) {\r\n                    if (res === resolution) {\r\n                        loadTile(quad);\r\n                        //console.log(res, maxResolution, quad);\r\n                    }\r\n\r\n                    generateQuads(res + 1, quad + \"0\");\r\n                    generateQuads(res + 1, quad + \"1\");\r\n                    generateQuads(res + 1, quad + \"2\");\r\n                    generateQuads(res + 1, quad + \"3\");\r\n                }\r\n            }\r\n\r\n            function loadTile(quad) {\r\n                var template: any = \"https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}\";\r\n                var numServers = 7;\r\n                var server = Math.round(Math.random() * numServers);\r\n                var language = (navigator[\"languages\"] && navigator[\"languages\"].length) ? navigator[\"languages\"][0] : navigator.language;\r\n                var url = template.replace(\"{server}\", server)\r\n                    .replace(\"{quad}\", quad)\r\n                    .replace(\"{language}\", language);\r\n                var coords = getCoords(quad);\r\n                //console.log(quad, coords.x, coords.y)\r\n\r\n                var tile = new Image();\r\n                tile.onload = function () {\r\n                    tilesLoaded++;\r\n                    canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);\r\n                    if (tilesLoaded === numTiles) {\r\n                        canvas.trigger(\"ready\", resolution);\r\n                    }\r\n                };\r\n\r\n                // So the canvas doesn't get tainted\r\n                tile.crossOrigin = '';\r\n                tile.src = url;\r\n            }\r\n\r\n            function getCoords(quad) {\r\n                var x = 0;\r\n                var y = 0;\r\n                var last = quad.length - 1;\r\n\r\n                for (var i = last; i >= 0; i--) {\r\n                    var chr = quad.charAt(i);\r\n                    var pow = Math.pow(2, last - i);\r\n\r\n                    if (chr === \"1\") {\r\n                        x += pow;\r\n                    } else if (chr === \"2\") {\r\n                        y += pow;\r\n                    } else if (chr === \"3\") {\r\n                        x += pow;\r\n                        y += pow;\r\n                    }\r\n                }\r\n\r\n                return { x: x, y: y };\r\n            }\r\n\r\n            generateQuads(0, \"\");\r\n            return canvas;\r\n        }\r\n    }\r\n}\r\n\r\nfunction loadGlobeMapLibs() {\r\n    // include GlobeMapLibs.js\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/globeMap/visual/globeMap.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    export interface RadarChartConstructorOptions {\r\n        animator?: IGenericAnimator;\r\n        svg?: D3.Selection;\r\n        margin?: IMargin;\r\n    }\r\n\r\n    export interface RadarChartDatapoint extends SelectableDataPoint {\r\n        x: number;\r\n        y: number;\r\n        y0?: number;\r\n        color?: string;\r\n        value?: number;\r\n        tooltipInfo?: TooltipDataItem[];\r\n        labelFormatString?: string;\r\n        labelFontSize?: string;\r\n    }\r\n\r\n    export interface RadarChartData {\r\n        legendData: LegendData;\r\n        series: RadarChartSeries[];\r\n        settings: RadarChartSettings;\r\n        dataLabelsSettings: PointDataLabelsSettings;\r\n    }\r\n\r\n    export interface RadarChartSeries {\r\n        fill: string;\r\n        name: string;\r\n        data: RadarChartDatapoint[];\r\n        identity: SelectionId;\r\n    }\r\n\r\n    export interface RadarChartSettings {\r\n        showLegend?: boolean;\r\n    }\r\n\r\n    export interface RadarChartBehaviorOptions {\r\n        selection: D3.Selection;\r\n        clearCatcher: D3.Selection;\r\n    }\r\n\r\n    /**\r\n     * RadarChartBehavior\r\n     */\r\n    export class RadarChartWebBehavior implements IInteractiveBehavior {\r\n        private selection: D3.Selection;\r\n\r\n        public bindEvents(options: RadarChartBehaviorOptions, selectionHandler: ISelectionHandler): void {\r\n            let selection = this.selection = options.selection;\r\n            let clearCatcher = options.clearCatcher;\r\n\r\n            selection.on('click', function (d: SelectableDataPoint) {\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            clearCatcher.on('click', function () {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean): void {\r\n            this.selection.style(\"opacity\", (d: SelectableDataPoint) => (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.NodeFillOpacity);\r\n        }\r\n    }\r\n\r\n    export class RadarChart implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    displayName: 'Category',\r\n                    name: 'Category',\r\n                    kind: powerbi.VisualDataRoleKind.Grouping,\r\n                },\r\n                {\r\n                    displayName: 'Y Axis',\r\n                    name: 'Y',\r\n                    kind: powerbi.VisualDataRoleKind.Measure,\r\n                },\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [{ 'Category': { min: 1, max: 1 } }],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        select: [{ bind: { to: 'Y' } }]\r\n                    }\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                legend: {\r\n                    displayName: data.createDisplayNameGetter('Visual_Legend'),\r\n                    description: data.createDisplayNameGetter('Visual_LegendDescription'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendPosition'),\r\n                            description: data.createDisplayNameGetter('Visual_LegendPositionDescription'),\r\n                            type: { enumeration: legendPosition.type }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendShowTitle'),\r\n                            description: data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendName'),\r\n                            description: data.createDisplayNameGetter('Visual_LegendNameDescription'),\r\n                            type: { text: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelColor: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LegendTitleColor'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPoint'),\r\n                    description: data.createDisplayNameGetter('Visual_DataPointDescription'),\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\r\n                    description: data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),\r\n                    properties: {\r\n                        show: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Show'),\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_LabelsFill'),\r\n                            description: data.createDisplayNameGetter('Visual_LabelsFillDescription'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: data.createDisplayNameGetter('Visual_DisplayUnits'),\r\n                            description: data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                            suppressFormatPainterCopy: true,\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Precision'),\r\n                            description: data.createDisplayNameGetter('Visual_PrecisionDescription'),\r\n                            placeHolderText: data.createDisplayNameGetter('Visual_Precision_Auto'),\r\n                            type: { numeric: true },\r\n                            suppressFormatPainterCopy: true,\r\n                        },\r\n                        fontSize: {\r\n                            displayName: data.createDisplayNameGetter('Visual_TextSize'),\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        /** Note: Public for testability */\r\n        public static formatStringProp: DataViewObjectPropertyIdentifier = {\r\n            objectName: 'general',\r\n            propertyName: 'formatString',\r\n        };\r\n\r\n        private static Properties: any = {\r\n            legend: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'show' }\r\n            },\r\n            dataPoint: {\r\n                fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' }\r\n            },\r\n            labels: {\r\n                show: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'show' },\r\n                color: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'color' },\r\n                displayUnits: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelDisplayUnits' },\r\n                precision: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'labelPrecision' },\r\n                fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'labels', propertyName: 'fontSize' },\r\n            }\r\n        };\r\n\r\n        private static VisualClassName = 'radarChart';\r\n        private static Segments: ClassAndSelector = CreateClassAndSelector('segments');\r\n        private static SegmentNode: ClassAndSelector = CreateClassAndSelector('segmentNode');\r\n        private static ZeroSegment: ClassAndSelector = CreateClassAndSelector('zeroSegment');\r\n        private static ZeroSegmentNode: ClassAndSelector = CreateClassAndSelector('zeroSegmentNode');\r\n        private static ZeroLabel: ClassAndSelector = CreateClassAndSelector('zeroLabel');\r\n        private static Axis: ClassAndSelector = CreateClassAndSelector('axis');\r\n        private static AxisNode: ClassAndSelector = CreateClassAndSelector('axisNode');\r\n        private static AxisLabel: ClassAndSelector = CreateClassAndSelector('axisLabel');\r\n        private static Chart: ClassAndSelector = CreateClassAndSelector('chart');\r\n        private static ChartNode: ClassAndSelector = CreateClassAndSelector('chartNode');\r\n        private static ChartArea: ClassAndSelector = CreateClassAndSelector('chartArea');\r\n        private static ChartPolygon: ClassAndSelector = CreateClassAndSelector('chartPolygon');\r\n        private static ChartDot: ClassAndSelector = CreateClassAndSelector('chartDot');\r\n\r\n        private svg: D3.Selection;\r\n        private segments: D3.Selection;\r\n        private zeroSegment: D3.Selection;\r\n        private axis: D3.Selection;\r\n        private chart: D3.Selection;\r\n\r\n        private mainGroupElement: D3.Selection;\r\n        private colors: IDataColorPalette;\r\n        private viewport: IViewport;\r\n        private interactivityService: IInteractivityService;\r\n\r\n        private animator: IGenericAnimator;\r\n        private margin: IMargin;\r\n        private legend: ILegend;\r\n        private legendObjectProperties: DataViewObject;\r\n        private radarChartData: RadarChartData;\r\n        private isInteractiveChart: boolean;\r\n        private zeroPointRadius: number;\r\n\r\n        private static DefaultMargin: IMargin = {\r\n            top: 50,\r\n            bottom: 50,\r\n            right: 100,\r\n            left: 100\r\n        };\r\n\r\n        private static SegmentLevels: number = 6;\r\n        private static SegmentFactor: number = 1;\r\n        private static Radians: number = 2 * Math.PI;\r\n        private static Scale: number = 1;\r\n        public static NodeFillOpacity = 1;\r\n        public static AreaFillOpacity = 0.6;\r\n        public static DimmedAreaFillOpacity = 0.4;\r\n        private angle: number;\r\n        private radius: number;\r\n\r\n        public static AxesLabelsFontFamily: string = \"sans-serif\";\r\n        public static AxesLabelsfontSize: string = \"11px\";\r\n        public static AxesLabelsMaxWidth: number = 200;\r\n\r\n        public static converter(dataView: DataView, colors: IDataColorPalette): RadarChartData {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !(dataView.categorical.categories.length > 0) ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.values ||\r\n                !(dataView.categorical.values.length > 0) ||\r\n                !colors) {\r\n                return {\r\n                    legendData: {\r\n                        dataPoints: []\r\n                    },\r\n                    settings: {\r\n                        showLegend: true\r\n                    },\r\n                    series: [],\r\n                    dataLabelsSettings: dataLabelUtils.getDefaultPointLabelSettings(),\r\n                };\r\n            }\r\n\r\n            let catDv: DataViewCategorical = dataView.categorical,\r\n                values: DataViewValueColumns = catDv.values,\r\n                grouped: DataViewValueColumnGroup[] = catDv && catDv.values ? catDv.values.grouped() : null,\r\n                series: RadarChartSeries[] = [],\r\n                colorHelper = new ColorHelper(colors, RadarChart.Properties.dataPoint.fill);\r\n\r\n            let legendData: LegendData = {\r\n                fontSize: 8.25,\r\n                dataPoints: [],\r\n                title: \"\"\r\n            };\r\n\r\n            //Parse legend settings          \r\n            let legendSettings: RadarChartSettings = RadarChart.parseSettings(dataView);\r\n            let dataLabelsSettings: PointDataLabelsSettings = RadarChart.parseLabelSettings(dataView);\r\n\r\n            for (let i = 0, iLen = values.length; i < iLen; i++) {\r\n                let color = colors.getColorByIndex(i).value,\r\n                    serieIdentity: SelectionId,\r\n                    queryName: string,\r\n                    displayName: string,\r\n                    dataPoints: RadarChartDatapoint[] = [];\r\n\r\n                let columnGroup: DataViewValueColumnGroup = grouped\r\n                    && grouped.length > i && grouped[i].values? grouped[i] : null;\r\n\r\n                if (values[i].source) {\r\n                    let source = values[i].source;\r\n\r\n                    if (source.queryName) {\r\n                        queryName = source.queryName;\r\n                        serieIdentity = SelectionId.createWithMeasure(queryName);\r\n                    }\r\n\r\n                    if (source.displayName)\r\n                        displayName = source.displayName;\r\n\r\n                    if (source.objects) {\r\n                        let objects: any = source.objects;\r\n                        color = colorHelper.getColorForMeasure(objects, queryName);\r\n                    }\r\n                }\r\n\r\n                legendData.dataPoints.push({\r\n                    label: displayName,\r\n                    color: color,\r\n                    icon: LegendIcon.Box,\r\n                    selected: false,\r\n                    identity: serieIdentity\r\n                });\r\n\r\n                for (let k = 0, kLen = values[i].values.length; k < kLen; k++) {\r\n                    let dataPointIdentity: SelectionId = SelectionIdBuilder\r\n                        .builder()\r\n                        .withMeasure(queryName)\r\n                        .withCategory(catDv.categories[0], k)\r\n                        .withSeries(dataView.categorical.values, columnGroup)\r\n                        .createSelectionId();\r\n\r\n                    let tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp,\r\n                        catDv,\r\n                        catDv.categories[0].values[k],\r\n                        values[i].values[k],\r\n                        null,\r\n                        null,\r\n                        i);\r\n\r\n                    let labelFormatString = valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp);\r\n                    let fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);\r\n\r\n                    dataPoints.push({\r\n                        x: k,\r\n                        y: values[i].values[k],\r\n                        color: color,\r\n                        identity: dataPointIdentity,\r\n                        selected: false,\r\n                        tooltipInfo: tooltipInfo,\r\n                        value: values[i].values[k],\r\n                        labelFormatString: labelFormatString,\r\n                        labelFontSize: fontSizeInPx,\r\n                    });\r\n                }\r\n\r\n                if (dataPoints.length > 0)\r\n                    series.push({\r\n                        fill: color,\r\n                        name: displayName,\r\n                        data: dataPoints,\r\n                        identity: serieIdentity,\r\n                    });\r\n            }\r\n\r\n            return {\r\n                legendData: legendData,\r\n                settings: legendSettings,\r\n                series: series,\r\n                dataLabelsSettings: dataLabelsSettings,\r\n            };\r\n        }\r\n\r\n        public constructor(options?: RadarChartConstructorOptions) {\r\n            if (options) {\r\n                if (options.svg)\r\n                    this.svg = options.svg;\r\n\r\n                if (options.animator)\r\n                    this.animator = options.animator;\r\n\r\n                if (options.margin)\r\n                    this.margin = options.margin;\r\n            }\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            let element = options.element;\r\n\r\n            if (!this.svg) {\r\n                this.svg = d3.select(element.get(0)).append('svg');\r\n                this.svg.style('position', 'absolute');\r\n            }\r\n\r\n            if (!this.margin)\r\n                this.margin = RadarChart.DefaultMargin;\r\n\r\n            this.svg.classed(RadarChart.VisualClassName, true);\r\n            this.interactivityService = visuals.createInteractivityService(options.host);\r\n            this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\r\n            this.legend = createLegend(element,\r\n                this.isInteractiveChart,\r\n                this.interactivityService,\r\n                true,\r\n                LegendPosition.Top);\r\n            this.colors = options.style.colorPalette.dataColors;\r\n            this.mainGroupElement = this.svg.append('g');\r\n\r\n            this.segments = this.mainGroupElement\r\n                .append('g')\r\n                .classed(RadarChart.Segments.class, true);\r\n\r\n            this.zeroSegment = this.mainGroupElement\r\n                .append('g')\r\n                .classed(RadarChart.ZeroSegment.class, true);\r\n\r\n            this.axis = this.mainGroupElement\r\n                .append('g')\r\n                .classed(RadarChart.Axis.class, true);\r\n\r\n            this.chart = this.mainGroupElement\r\n                .append('g')\r\n                .classed(RadarChart.Chart.class, true);\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions): void {\r\n            if (!options.dataViews || !options.dataViews[0])\r\n                return;\r\n\r\n            let dataView = options.dataViews[0];\r\n            this.radarChartData = RadarChart.converter(dataView, this.colors);\r\n            let categories: any[] = [],\r\n                series = this.radarChartData.series,\r\n                dataViewMetadataColumn: DataViewMetadataColumn,\r\n                duration = AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);\r\n\r\n            if (dataView.categorical &&\r\n                dataView.categorical.categories &&\r\n                dataView.categorical.categories[0] &&\r\n                dataView.categorical.categories[0].values)\r\n                categories = dataView.categorical.categories[0].values;\r\n\r\n            if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)\r\n                dataViewMetadataColumn = dataView.metadata.columns[0];\r\n\r\n            this.viewport = {\r\n                height: options.viewport.height > 0 ? options.viewport.height : 0,\r\n                width: options.viewport.width > 0 ? options.viewport.width : 0\r\n            };\r\n\r\n            this.parseLegendProperties(dataView);\r\n            this.renderLegend(this.radarChartData);\r\n            this.updateViewport();\r\n\r\n            this.svg\r\n                .attr({\r\n                    'height': this.viewport.height,\r\n                    'width': this.viewport.width\r\n                });\r\n\r\n            let mainGroup = this.mainGroupElement;\r\n            mainGroup.attr('transform', SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\r\n\r\n            let width: number = this.viewport.width - this.margin.left - this.margin.right;\r\n            let height: number = this.viewport.height - this.margin.top - this.margin.bottom;\r\n\r\n            this.angle = RadarChart.Radians / categories.length;\r\n            this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;\r\n\r\n            this.drawCircularSegments(categories);\r\n            this.drawAxes(categories);\r\n            this.drawAxesLabels(categories, dataViewMetadataColumn);\r\n            this.drawChart(series, duration);\r\n            this.drawDataLabels(series);\r\n            this.drawZeroCircularSegment(categories);\r\n\r\n            if (this.zeroPointRadius !== 0)\r\n                this.drawZeroLabel();\r\n            else\r\n                this.mainGroupElement.selectAll(RadarChart.ZeroLabel.selector).remove();\r\n        }\r\n\r\n        private getRadarChartLabelLayout(labelSettings: PointDataLabelsSettings, allDataPoints: RadarChartDatapoint[]): ILabelLayout {\r\n            let formattersCache = dataLabelUtils.createColumnFormatterCacheManager();\r\n            let angle: number = this.angle;\r\n            let viewport = this.viewport;\r\n            let halfHeight = this.viewport.height / 2;\r\n            let halfWidth = this.viewport.width / 2;\r\n            let y: any = this.calculateChartDomain(this.radarChartData.series);\r\n\r\n            return {\r\n                labelText: (d: RadarChartDatapoint) => {\r\n\r\n                    let formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);\r\n\r\n                    if (labelSettings.displayUnits === 0) {\r\n                        let maxDataPoint: RadarChartDatapoint = _.max(allDataPoints, d => d.value);\r\n                        let maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;\r\n\r\n                        formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);\r\n                    }\r\n                    return dataLabelUtils.getLabelFormattedText({ label: formmater.format(d.value), maxWidth: viewport.width, fontSize: labelSettings.fontSize });\r\n                },\r\n                labelLayout: {\r\n                    x: (d: RadarChartDatapoint) => -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth,\r\n                    y: (d: RadarChartDatapoint) => -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 7,\r\n                },\r\n                filter: (d: RadarChartDatapoint) => {\r\n                    return (d != null && d.value != null);\r\n                },\r\n                style: {\r\n                    'fill': labelSettings.labelColor,\r\n                    'font-size': (d: RadarChartDatapoint) => PixelConverter.fromPoint(labelSettings.fontSize),\r\n                },\r\n            };\r\n        }\r\n\r\n        private drawCircularSegments(values: string[]): void {\r\n            let data = [];\r\n            let angle: number = this.angle,\r\n                factor: number = RadarChart.SegmentFactor,\r\n                levels: number = RadarChart.SegmentLevels,\r\n                radius: number = this.radius;\r\n\r\n            for (let level = 0; level < levels - 1; level++) {\r\n                let levelFactor: number = radius * ((level + 1) / levels);\r\n                let transform: number = -1 * levelFactor;\r\n\r\n                for (let i = 0; i < values.length; i++)\r\n                    data.push({\r\n                        x1: levelFactor * (1 - factor * Math.sin(i * angle)),\r\n                        y1: levelFactor * (1 - factor * Math.cos(i * angle)),\r\n                        x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),\r\n                        y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),\r\n                        translate: SVGUtil.translate(transform, transform)\r\n                    });\r\n            }\r\n\r\n            let selection = this.mainGroupElement\r\n                .select(RadarChart.Segments.selector)\r\n                .selectAll(RadarChart.SegmentNode.selector)\r\n                .data(data);\r\n\r\n            selection\r\n                .enter()\r\n                .append('svg:line')\r\n                .classed(RadarChart.SegmentNode.class, true);\r\n            selection\r\n                .attr({\r\n                    'x1': item => item.x1,\r\n                    'y1': item => item.y1,\r\n                    'x2': item => item.x2,\r\n                    'y2': item => item.y2,\r\n                    'transform': item => item.translate\r\n                });\r\n\r\n            selection.exit().remove();\r\n        }\r\n\r\n        private drawDataLabels(series: RadarChartSeries[]): void {\r\n            let allDataPoints: RadarChartDatapoint[] = this.getAllDataPointsList(series);\r\n\r\n            if (this.radarChartData.dataLabelsSettings.show) {\r\n                let layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints);\r\n                let viewport = this.viewport;\r\n\r\n                let labels = dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);\r\n                labels.attr('transform', SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));\r\n            }\r\n            else\r\n                dataLabelUtils.cleanDataLabels(this.mainGroupElement);\r\n        }\r\n\r\n        private drawAxes(values: string[]): void {\r\n            let angle: number = this.angle,\r\n                radius: number = -1 * this.radius;\r\n\r\n            let selection: D3.Selection = this.mainGroupElement\r\n                .select(RadarChart.Axis.selector)\r\n                .selectAll(RadarChart.AxisNode.selector);\r\n\r\n            let axis = selection.data(values);\r\n\r\n            axis\r\n                .enter()\r\n                .append('svg:line');\r\n            axis\r\n                .attr({\r\n                    'x1': 0,\r\n                    'y1': 0,\r\n                    'x2': (name, i) => radius * Math.sin(i * angle),\r\n                    'y2': (name, i) => radius * Math.cos(i * angle)\r\n                })\r\n                .classed(RadarChart.AxisNode.class, true);\r\n\r\n            axis.exit().remove();\r\n        }\r\n\r\n        private drawAxesLabels(values: string[], dataViewMetadataColumn?: DataViewMetadataColumn): void {\r\n            let angle: number = this.angle,\r\n                radius: number = -1 * this.radius,\r\n                length: number = values.length;\r\n\r\n            let formatter = valueFormatter.create({\r\n                format: valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),\r\n                value: values[0],\r\n                value2: values[length - 1],\r\n            });\r\n\r\n            let selection: D3.Selection = this.mainGroupElement\r\n                .select(RadarChart.Axis.selector)\r\n                .selectAll(RadarChart.AxisLabel.selector);\r\n\r\n            let labels = selection.data(values);\r\n\r\n            labels\r\n                .enter()\r\n                .append('svg:text');\r\n\r\n            labels\r\n                .attr({\r\n                    'text-anchor': 'middle',\r\n                    'dy': '1.5em',\r\n                    'transform': SVGUtil.translate(0, -10),\r\n                    'x': (name, i) => { return (radius - 30) * Math.sin(i * angle); },\r\n                    'y': (name, i) => { return (radius - 20) * Math.cos(i * angle); }\r\n                })\r\n                .text(item => {\r\n                    let properties: TextProperties = {\r\n                        fontFamily: RadarChart.AxesLabelsFontFamily,\r\n                        fontSize: RadarChart.AxesLabelsfontSize,\r\n                        text: formatter.format(item)\r\n                    };\r\n                    return TextMeasurementService.getTailoredTextOrDefault(properties, Math.min(RadarChart.AxesLabelsMaxWidth, this.viewport.width));\r\n                })\r\n                .classed(RadarChart.AxisLabel.class, true);\r\n\r\n            labels.exit().remove();\r\n        }\r\n\r\n        private drawChart(series: RadarChartSeries[], duration: number): void {\r\n            let angle: number = this.angle,\r\n                dotRadius: number = 5,\r\n                dataPoints: RadarChartDatapoint[][] = this.getDataPoints(series);\r\n\r\n            let stack = d3.layout.stack();\r\n            let layers = stack(dataPoints);\r\n            let y: any = this.calculateChartDomain(series);\r\n\r\n            let calculatePoints = (points) => {\r\n                return points.map((value) => {\r\n                    let x1 = -1 * y(value.y) * Math.sin(value.x * angle);\r\n                    let y1 = -1 * y(value.y) * Math.cos(value.x * angle);\r\n                    return `${x1},${y1}`;\r\n                }).join(' ');\r\n            };\r\n\r\n            let areas = this.chart.selectAll(RadarChart.ChartArea.selector).data(layers);\r\n\r\n            areas\r\n                .enter()\r\n                .append('g')\r\n                .classed(RadarChart.ChartArea.class, true);\r\n\r\n            let polygon = areas.selectAll(RadarChart.ChartPolygon.selector).data(d => {\r\n                if (d && d.length > 0) {\r\n                    return [d];\r\n                }\r\n\r\n                return [];\r\n            });\r\n            polygon\r\n                .enter()\r\n                .append('polygon')\r\n                .classed(RadarChart.ChartPolygon.class, true);\r\n            polygon\r\n                .style('fill', d => d[0].color)\r\n                .style('opacity', RadarChart.DimmedAreaFillOpacity)\r\n                .on('mouseover', function (d) {\r\n                    d3.select(this).transition()\r\n                        .duration(duration)\r\n                        .style('opacity', RadarChart.AreaFillOpacity);\r\n                })\r\n                .on('mouseout', function (d) {\r\n                    d3.select(this).transition()\r\n                        .duration(duration)\r\n                        .style('opacity', RadarChart.DimmedAreaFillOpacity);\r\n                })\r\n                .attr('points', calculatePoints);\r\n            polygon.exit().remove();\r\n\r\n            areas.exit().remove();\r\n            let selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);\r\n\r\n            selection\r\n                .enter()\r\n                .append('g')\r\n                .classed(RadarChart.ChartNode.class, true);\r\n\r\n            let dots = selection.selectAll(RadarChart.ChartDot.selector)\r\n                .data((d: RadarChartDatapoint[]) => { return d.filter(d => d.y != null); });\r\n\r\n            dots.enter()\r\n                .append('svg:circle')\r\n                .classed(RadarChart.ChartDot.class, true);\r\n            dots.attr('r', dotRadius)\r\n                .attr({\r\n                    'cx': (value) => -1 * y(value.y) * Math.sin(value.x * angle),\r\n                    'cy': (value) => -1 * y(value.y) * Math.cos(value.x * angle)\r\n                })\r\n                .style('fill', d => d.color);\r\n\r\n            dots.exit().remove();\r\n            TooltipManager.addTooltip(dots, (tooltipEvent: TooltipEvent) => tooltipEvent.data.tooltipInfo, true);\r\n\r\n            selection.exit().remove();\r\n            let behaviorOptions: RadarChartBehaviorOptions = undefined;\r\n\r\n            if (this.interactivityService) {\r\n                // Register interactivity\r\n                let dataPointsToBind = this.getAllDataPointsList(series);\r\n\r\n                behaviorOptions = { selection: dots, clearCatcher: this.svg };\r\n                this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);\r\n            }\r\n        }\r\n\r\n        private calculateChartDomain(series: RadarChartSeries[]): any {\r\n            let radius: number = this.radius,\r\n                dataPointsList: RadarChartDatapoint[] = this.getAllDataPointsList(series);\r\n\r\n            let minValue: number = d3.min(dataPointsList, (d) => { return d.y; });\r\n            let maxValue: number = d3.max(dataPointsList, (d) => { return d.y; });\r\n\r\n            if (this.isPercentChart(dataPointsList)) {\r\n                minValue = minValue >= 0 ? 0 : -1;\r\n                maxValue = maxValue <= 0 ? 0 : 1;\r\n            }\r\n\r\n            let y = d3.scale.linear()\r\n                .domain([minValue, maxValue]).range([0, radius]);\r\n\r\n            // Calculate zero ring radius\r\n            this.zeroPointRadius = ((minValue < 0) && (maxValue > 0)) ? y(0) : 0;\r\n\r\n            return y;\r\n        }\r\n\r\n        private renderLegend(radarChartData: RadarChartData): void {\r\n            if (!radarChartData.legendData)\r\n                return;\r\n\r\n            let legendData: LegendData = radarChartData.legendData;\r\n\r\n            if (this.legendObjectProperties) {\r\n                LegendData.update(legendData, this.legendObjectProperties);\r\n                let position = <string>this.legendObjectProperties[legendProps.position];\r\n\r\n                if (position)\r\n                    this.legend.changeOrientation(LegendPosition[position]);\r\n            }\r\n            else\r\n                this.legend.changeOrientation(LegendPosition.Top);\r\n\r\n            let viewport = this.viewport;\r\n            this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\r\n            Legend.positionChartArea(this.svg, this.legend);\r\n        }\r\n\r\n        private drawZeroCircularSegment(values: string[]): void {\r\n            let data = [];\r\n            let angle: number = this.angle,\r\n                factor: number = RadarChart.SegmentFactor,\r\n                radius: number = this.zeroPointRadius,\r\n                transform: number = -1 * radius;\r\n\r\n            for (let i = 0; i < values.length; i++)\r\n                data.push({\r\n                    x1: radius * (1 - factor * Math.sin(i * angle)),\r\n                    y1: radius * (1 - factor * Math.cos(i * angle)),\r\n                    x2: radius * (1 - factor * Math.sin((i + 1) * angle)),\r\n                    y2: radius * (1 - factor * Math.cos((i + 1) * angle)),\r\n                    translate: SVGUtil.translate(transform, transform)\r\n                });\r\n\r\n            let selection = this.mainGroupElement\r\n                .select(RadarChart.ZeroSegment.selector)\r\n                .selectAll(RadarChart.ZeroSegmentNode.selector)\r\n                .data(data);\r\n\r\n            selection\r\n                .enter()\r\n                .append('svg:line')\r\n                .classed(RadarChart.ZeroSegmentNode.class, true);\r\n            selection\r\n                .attr({\r\n                    'x1': item => item.x1,\r\n                    'y1': item => item.y1,\r\n                    'x2': item => item.x2,\r\n                    'y2': item => item.y2,\r\n                    'transform': item => item.translate\r\n                });\r\n\r\n            selection.exit().remove();\r\n        }\r\n\r\n        private drawZeroLabel() {\r\n            let data = [];\r\n            data.push({\r\n                'x': this.zeroPointRadius * (1 - RadarChart.SegmentFactor) + 5,\r\n                'y': -1 * this.zeroPointRadius\r\n            });\r\n\r\n            let zeroLabel = this.mainGroupElement\r\n                .select(RadarChart.ZeroSegment.selector)\r\n                .selectAll(RadarChart.ZeroLabel.selector).data(data);\r\n\r\n            zeroLabel\r\n                .enter()\r\n                .append('text')\r\n                .classed(RadarChart.ZeroLabel.class, true).text(\"0\");\r\n            zeroLabel\r\n                .attr({\r\n                    'x': item => item.x,\r\n                    'y': item => item.y\r\n                });\r\n        }\r\n\r\n        private getDataPoints(series: RadarChartSeries[]): RadarChartDatapoint[][] {\r\n            let dataPoints: RadarChartDatapoint[][] = [];\r\n\r\n            for (let serie of series) {\r\n                dataPoints.push(serie.data);\r\n            }\r\n\r\n            return dataPoints;\r\n        }\r\n\r\n        private getAllDataPointsList(series: RadarChartSeries[]): RadarChartDatapoint[] {\r\n            let dataPoints: RadarChartDatapoint[] = [];\r\n\r\n            for (let serie of series) {\r\n                dataPoints = dataPoints.concat(serie.data);\r\n            }\r\n\r\n            return dataPoints;\r\n        }\r\n\r\n        private isPercentChart(dataPointsList: RadarChartDatapoint[]): boolean {\r\n\r\n            for (let dataPoint of dataPointsList) {\r\n                if (dataPoint.labelFormatString.indexOf(\"%\") === -1)\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        private parseLegendProperties(dataView: DataView): void {\r\n            if (!dataView || !dataView.metadata) {\r\n                this.legendObjectProperties = {};\r\n                return;\r\n            }\r\n\r\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, \"legend\", {});\r\n        }\r\n\r\n        private static parseSettings(dataView: DataView): RadarChartSettings {\r\n            let objects: DataViewObjects;\r\n\r\n            if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)\r\n                objects = null;\r\n            else\r\n                objects = dataView.metadata.objects;\r\n\r\n            return {\r\n                showLegend: DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)\r\n            };\r\n        }\r\n\r\n        private static parseLabelSettings(dataView: DataView): PointDataLabelsSettings {\r\n            let objects: DataViewObjects;\r\n\r\n            if (!dataView || !dataView.metadata || !dataView.metadata.objects)\r\n                objects = null;\r\n            else\r\n                objects = dataView.metadata.objects;\r\n\r\n            let dataLabelsSettings: PointDataLabelsSettings = dataLabelUtils.getDefaultPointLabelSettings();\r\n\r\n            let labelsObj: PointDataLabelsSettings = {\r\n                show: DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),\r\n                labelColor: DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),\r\n                displayUnits: DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),\r\n                precision: DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),\r\n                fontSize: DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),\r\n                position: dataLabelsSettings.position\r\n            };\r\n\r\n            return labelsObj;\r\n        }\r\n\r\n        // This function returns the values to be displayed in the property pane for each object.\r\n        // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\r\n        // validation and return other values/defaults\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration = new ObjectEnumerationBuilder();\r\n            let settings: RadarChartSettings;\r\n\r\n            if (!this.radarChartData || !this.radarChartData.settings)\r\n                return [];\r\n\r\n            settings = this.radarChartData.settings;\r\n\r\n            switch (options.objectName) {\r\n                case \"legend\":\r\n                    enumeration.pushInstance(this.enumerateLegend(settings));\r\n                    break;\r\n                case \"dataPoint\":\r\n                    this.enumerateDataPoint(enumeration);\r\n                    break;\r\n                case 'labels':\r\n                    this.enumerateDataLabels(enumeration);\r\n                    break;\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private getLabelSettingsOptions(enumeration: ObjectEnumerationBuilder, labelSettings: PointDataLabelsSettings): VisualDataLabelsSettingsOptions {\r\n            return {\r\n                enumeration: enumeration,\r\n                dataLabelsSettings: labelSettings,\r\n                show: true,\r\n                displayUnits: true,\r\n                precision: true,\r\n                fontSize: true,\r\n            };\r\n        }\r\n\r\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder): void {\r\n            let labelSettings = this.radarChartData.dataLabelsSettings;\r\n\r\n            //Draw default settings\r\n            dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));\r\n        }\r\n\r\n        private enumerateLegend(settings: RadarChartSettings): VisualObjectInstance {\r\n            let showTitle: boolean = true,\r\n                titleText: string = \"\",\r\n                legend: VisualObjectInstance,\r\n                labelColor: DataColorPalette,\r\n                fontSize: number = 8;\r\n\r\n            showTitle = DataViewObject.getValue(this.legendObjectProperties, legendProps.showTitle, showTitle);\r\n            titleText = DataViewObject.getValue(this.legendObjectProperties, legendProps.titleText, titleText);\r\n            labelColor = DataViewObject.getValue(this.legendObjectProperties, legendProps.labelColor, labelColor);\r\n            fontSize = DataViewObject.getValue(this.legendObjectProperties, legendProps.fontSize, fontSize);\r\n            legend = {\r\n                objectName: \"legend\",\r\n                displayName: \"legend\",\r\n                selector: null,\r\n                properties: {\r\n                    show: settings.showLegend,\r\n                    position: LegendPosition[this.legend.getOrientation()],\r\n                    showTitle: showTitle,\r\n                    titleText: titleText,\r\n                    labelColor: labelColor,\r\n                    fontSize: fontSize,\r\n                }\r\n            };\r\n\r\n            return legend;\r\n        }\r\n\r\n        private enumerateDataPoint(enumeration: ObjectEnumerationBuilder): void {\r\n            if (!this.radarChartData || !this.radarChartData.series)\r\n                return;\r\n\r\n            let series: RadarChartSeries[] = this.radarChartData.series;\r\n\r\n            for (let serie of series) {\r\n                enumeration.pushInstance({\r\n                    objectName: \"dataPoint\",\r\n                    displayName: serie.name,\r\n                    selector: ColorHelper.normalizeSelector(serie.identity.getSelector(), false),\r\n                    properties: {\r\n                        fill: { solid: { color: serie.fill } }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        private updateViewport(): void {\r\n            let legendMargins: IViewport = this.legend.getMargins(),\r\n                legendPosition: LegendPosition;\r\n\r\n            legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\r\n\r\n            switch (legendPosition) {\r\n                case LegendPosition.Top:\r\n                case LegendPosition.TopCenter:\r\n                case LegendPosition.Bottom:\r\n                case LegendPosition.BottomCenter:\r\n                    this.viewport.height -= legendMargins.height;\r\n                    break;\r\n\r\n                case LegendPosition.Left:\r\n                case LegendPosition.LeftCenter:\r\n                case LegendPosition.Right:\r\n                case LegendPosition.RightCenter:\r\n                    this.viewport.width -= legendMargins.width;\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/radarChart/visual/radarChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import SelectionManager = utility.SelectionManager;\r\n    import ValueFormatter = powerbi.visuals.valueFormatter;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\r\n    import createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    type D3Element =\r\n        D3.UpdateSelection |\r\n        D3.Selection |\r\n        D3.Selectors |\r\n        D3.Transition.Transition;\r\n\r\n    export interface HistogramConstructorOptions {\r\n        svg?: D3.Selection;\r\n        animator?: IGenericAnimator;\r\n        margin?: IMargin;\r\n    }\r\n\r\n    export interface HistogramSettings {\r\n        displayName?: string;\r\n        fillColor?: string;\r\n        frequency: boolean;\r\n        bins?: number;\r\n        precision: number;\r\n        xAxisColor?: string;\r\n        xDisplayUnits?: number;\r\n        xPrecision?: number;\r\n        xTitle?: boolean;\r\n        xShow?: boolean;\r\n        xStyle?: string;\r\n        yAxisColor?: string;\r\n        yTitle?: boolean;\r\n        yDisplayUnits?: number;\r\n        yPrecision?: number;\r\n        yShow?: boolean;\r\n        yStyle?: string;\r\n        yStart?: number;\r\n        yEnd?: number;\r\n        yPosition?: string;\r\n        labelShow?: boolean;\r\n        labelColor?: string;\r\n        labelDisplayUnit?: number;\r\n        labelPrecision?: number;\r\n        labelFontSize?: number;\r\n        maxX?: number;\r\n    }\r\n\r\n    export interface HistogramData extends D3.Layout.Bin, TooltipEnabledDataPoint {\r\n        range: number[];\r\n        selectionIds: SelectionId[];\r\n    }\r\n\r\n    export interface HistogramDataView {\r\n        data: HistogramData[];\r\n        xScale?: D3.Scale.LinearScale;\r\n        yScale?: D3.Scale.LinearScale;\r\n        settings: HistogramSettings;\r\n        formatter: IValueFormatter;\r\n        xLabelFormatter?: IValueFormatter;\r\n        yLabelFormatter?: IValueFormatter;\r\n    }\r\n\r\n    interface HistogramValue {\r\n        value: number;\r\n        selectionId: SelectionId;\r\n        frequency: number;\r\n    }\r\n\r\n    interface Legend {\r\n        text: string;\r\n        transform?: string;\r\n        dx?: string;\r\n        dy?: string;\r\n    }\r\n\r\n    interface Brackets {\r\n        left: string;\r\n        right: string;\r\n    }\r\n\r\n    interface HistogramProperty {\r\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\r\n    }\r\n\r\n    interface HistogramProperties {\r\n        [objectName: string]: HistogramProperty;\r\n    }\r\n\r\n    export class HistogramChartWarning {\r\n        public static ErrorInvalidDataValues: string = \"Some data values are invalid or too big\";\r\n\r\n        private message: string;\r\n        constructor(message: string) {\r\n            this.message = message;\r\n        }\r\n\r\n        public get code(): string {\r\n            return \"BulletChartWarning\";\r\n        }\r\n\r\n        public getMessages(resourceProvider: jsCommon.IStringResourceProvider): IVisualErrorMessage {\r\n            return {\r\n                message: this.message,\r\n                title: resourceProvider.get(\"\"),\r\n                detail: resourceProvider.get(\"\")\r\n            };\r\n        }\r\n    }\r\n\r\n    export class Histogram implements IVisual {\r\n        private static ClassName: string = \"histogram\";\r\n        private static FrequencyText: string = \"Frequency\";\r\n        private static DensityText: string = \"Density\";\r\n\r\n        private static Properties: HistogramProperties = {\r\n            general: {\r\n                bins: {\r\n                    objectName: \"general\",\r\n                    propertyName: \"bins\"\r\n                },\r\n                frequency: {\r\n                    objectName: \"general\",\r\n                    propertyName: \"frequency\"\r\n                },\r\n                formatString: {\r\n                    objectName: \"general\",\r\n                    propertyName: \"formatString\"\r\n                }\r\n            },\r\n            dataPoint: {\r\n                fill: {\r\n                    objectName: \"dataPoint\",\r\n                    propertyName: \"fill\"\r\n                }\r\n            },\r\n            labels: {\r\n                show: {\r\n                    objectName: \"labels\",\r\n                    propertyName: \"show\"\r\n                },\r\n                color: {\r\n                    objectName: \"labels\",\r\n                    propertyName: \"color\"\r\n                },\r\n                labelDisplayUnits: {\r\n                    objectName: \"labels\",\r\n                    propertyName: \"labelDisplayUnits\"\r\n                },\r\n                labelPrecision: {\r\n                    objectName: \"labels\",\r\n                    propertyName: \"labelPrecision\"\r\n                },\r\n                fontSize: {\r\n                    objectName: \"labels\",\r\n                    propertyName: \"fontSize\"\r\n                }\r\n            },\r\n            xAxis: {\r\n                show: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"show\"\r\n                },\r\n                axisColor: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"axisColor\"\r\n                },\r\n                title: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"title\"\r\n                },\r\n                displayUnits: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"displayUnits\"\r\n                },\r\n                precision: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"precision\"\r\n                },\r\n                style: {\r\n                    objectName: \"xAxis\",\r\n                    propertyName: \"style\"\r\n                }\r\n            },\r\n            yAxis: {\r\n                show: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"show\"\r\n                },\r\n                axisColor: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"axisColor\"\r\n                },\r\n                title: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"title\"\r\n                },\r\n                displayUnits: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"displayUnits\"\r\n                },\r\n                precision: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"precision\"\r\n                },\r\n                style: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"style\"\r\n                },\r\n                start: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"start\"\r\n                },\r\n                end: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"end\"\r\n                },\r\n                position: {\r\n                    objectName: \"yAxis\",\r\n                    propertyName: \"position\"\r\n                }\r\n            }\r\n        };\r\n\r\n        private static DefaultHistogramSettings: HistogramSettings = {\r\n            frequency: true,\r\n            displayName: \"Histogram\",\r\n            bins: null,\r\n            fillColor: \"#5f9ea0\",\r\n            precision: 2,\r\n            xShow: true,\r\n            xAxisColor: \"#5f9ea0\",\r\n            yAxisColor: \"#5f9ea0\",\r\n            xTitle: true,\r\n            xDisplayUnits: 0,\r\n            xPrecision: 2,\r\n            xStyle: axisStyle.showTitleOnly,\r\n            yTitle: true,\r\n            yDisplayUnits: 0,\r\n            yPrecision: 2,\r\n            yShow: true,\r\n            yStyle: axisStyle.showTitleOnly,\r\n            yStart: 0,\r\n            yPosition: yAxisPosition.left,\r\n            labelShow: false,\r\n            labelColor: \"#5f9ea0\",\r\n            labelDisplayUnit: 0,\r\n            labelPrecision: 2,\r\n            labelFontSize: 9\r\n        };\r\n\r\n        private static Axes: ClassAndSelector = createClassAndSelector('axes');\r\n        private static Axis: ClassAndSelector = createClassAndSelector('axis');\r\n        private static Labels: ClassAndSelector = createClassAndSelector('labels');\r\n        private static Columns: ClassAndSelector = createClassAndSelector('columns');\r\n        private static Column: ClassAndSelector = createClassAndSelector('column');\r\n        private static Legends: ClassAndSelector = createClassAndSelector('legends');\r\n        private static Legend: ClassAndSelector = createClassAndSelector('legend');\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [{\r\n                name: \"Values\",\r\n                kind: VisualDataRoleKind.Grouping,\r\n                displayName: data.createDisplayNameGetter(\"Role_DisplayName_Values\")\r\n            }, {\r\n                    name: \"Frequency\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: \"Frequency\"\r\n                }],\r\n            dataViewMappings: [{\r\n                conditions: [{ \"Values\": { min: 1, max: 1 }, \"Frequency\": { min: 0, max: 1 } }],\r\n                categorical: {\r\n                    categories: {\r\n                        bind: { to: \"Values\" },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: { for: { in: \"Frequency\" } }\r\n                }\r\n            }],\r\n            sorting: {\r\n                implicit: {\r\n                    clauses: [{ role: \"Values\", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit\r\n                }\r\n            },\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\r\n                    properties: {\r\n                        formatString: { type: { formatting: { formatString: true } } },\r\n                        bins: {\r\n                            displayName: \"Bins\",\r\n                            type: { numeric: true }\r\n                        },\r\n                        frequency: {\r\n                            displayName: \"Frequency\",\r\n                            type: { bool: true }\r\n                        }\r\n                    },\r\n                },\r\n                dataPoint: {\r\n                    displayName: data.createDisplayNameGetter(\"Visual_DataPoint\"),\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                xAxis: {\r\n                    displayName: 'X-Axis',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true },\r\n                        },\r\n                        axis: {\r\n                            displayName: 'Axis',\r\n                            type: { bool: true }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: \"Color\",\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        title: {\r\n                            displayName: \"Title\",\r\n                            type: { bool: true }\r\n                        },\r\n                        displayUnits: {\r\n                            displayName: \"Display Units\",\r\n                            type: { formatting: { labelDisplayUnits: true } }\r\n                        },\r\n                        precision: {\r\n                            displayName: \"Decimal Places\",\r\n                            type: { numeric: true },\r\n                        },\r\n                        style: {\r\n                            displayName: \"Style\",\r\n                            type: { enumeration: axisStyle.type }\r\n                        },\r\n                    }\r\n                },\r\n                yAxis: {\r\n                    displayName: 'Y-Axis',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true },\r\n                        },\r\n                        axis: {\r\n                            displayName: 'yAxis',\r\n                            type: { bool: true }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: \"Color\",\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        title: {\r\n                            displayName: \"Title\",\r\n                            type: { bool: true }\r\n                        },\r\n                        displayUnits: {\r\n                            displayName: \"Display Units\",\r\n                            type: { formatting: { labelDisplayUnits: true } }\r\n                        },\r\n                        precision: {\r\n                            displayName: \"Decimal Places\",\r\n                            type: { numeric: true },\r\n                        },\r\n                        style: {\r\n                            displayName: \"Style\",\r\n                            type: { enumeration: axisStyle.type }\r\n                        },\r\n                        start: {\r\n                            displayName: \"Start\",\r\n                            type: { numeric: true },\r\n                            placeHolderText: \"Start\",\r\n                            suppressFormatPainterCopy: true,\r\n                        },\r\n                        end: {\r\n                            displayName: \"End\",\r\n                            type: { numeric: true },\r\n                            placeHolderText: \"End\",\r\n                            suppressFormatPainterCopy: true,\r\n                        },\r\n                        position: {\r\n                            displayName: \"Position\",\r\n                            type: { enumeration: yAxisPosition.type },\r\n                        },\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: \"Data Labels\",\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: \"Color\",\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: \"Display Units\",\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: \"Decimal Places\",\r\n                            type: { numeric: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        fontSize: {\r\n                            displayName: \"Text Size\",\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    },\r\n                },\r\n            }\r\n        };\r\n\r\n        private ColumnPadding: number = 1;\r\n        private MinColumnHeight: number = 1;\r\n        private MinOpacity: number = 0.3;\r\n        private MaxOpacity: number = 1;\r\n        private MinNumberOfBins: number = 0;\r\n        private MaxNumberOfBins: number = 100;\r\n        private MinPrecision: number = 0;\r\n        private MaxPrecision: number = 17; // max number of decimals in float\r\n        private TooltipDisplayName: string = \"Range\";\r\n        private SeparatorNumbers: string = \", \";\r\n        private LegendSize: number = 50;\r\n        private YLegendSize: number = 50;\r\n        private XLegendSize: number = 50;\r\n        private AxisSize: number = 30;\r\n        private DataLabelMargin: number = 0;\r\n        private widthOfColumn: number = 0;\r\n        private yTitleMargin: number = 0;\r\n        private outerPadding: number = 5;\r\n        private xAxisProperties: IAxisProperties;\r\n        private yAxisProperties: IAxisProperties;\r\n\r\n        private ExcludeBrackets: Brackets = {\r\n            left: \"(\",\r\n            right: \")\"\r\n        };\r\n\r\n        private IncludeBrackets: Brackets = {\r\n            left: \"[\",\r\n            right: \"]\"\r\n        };\r\n\r\n        private margin: IMargin = {\r\n            top: 10,\r\n            right: 10,\r\n            bottom: 10,\r\n            left: 10\r\n        };\r\n\r\n        private durationAnimations: number = 200;\r\n        private oldInnerPaddingRatio: number = CartesianChart.InnerPaddingRatio;\r\n        private oldMinOrdinalRectThickness: number = CartesianChart.MinOrdinalRectThickness;\r\n\r\n        private viewport: IViewport;\r\n        private hostService: IVisualHostServices;\r\n        private selectionManager: SelectionManager;\r\n        private colors: IDataColorPalette;\r\n\r\n        private root: D3.Selection;\r\n        private svg: D3.Selection;\r\n        private main: D3.Selection;\r\n        private axes: D3.Selection;\r\n        private axisX: D3.Selection;\r\n        private axisY: D3.Selection;\r\n        private legend: D3.Selection;\r\n        private columns: D3.Selection;\r\n        private labels: D3.Selection;\r\n\r\n        private histogramDataView: HistogramDataView;\r\n\r\n        private animator: IGenericAnimator;\r\n\r\n        private get columnsSelection(): D3.Selection {\r\n            return this.main.select(Histogram.Columns.selector)\r\n                .selectAll(Histogram.Column.selector);\r\n        }\r\n\r\n        private textProperties: TextProperties = {\r\n            fontFamily: 'wf_segoe-ui_normal',\r\n            fontSize: jsCommon.PixelConverter.toString(9),\r\n        };\r\n\r\n        constructor(histogramConstructorOptions?: HistogramConstructorOptions) {\r\n\r\n            if (histogramConstructorOptions) {\r\n                if (histogramConstructorOptions.svg) {\r\n                    this.svg = histogramConstructorOptions.svg;\r\n                }\r\n\r\n                if (histogramConstructorOptions.animator) {\r\n                    this.animator = histogramConstructorOptions.animator;\r\n                }\r\n\r\n                this.margin = histogramConstructorOptions.margin || this.margin;\r\n            }\r\n        }\r\n\r\n        public init(visualsOptions: VisualInitOptions): void {\r\n            this.hostService = visualsOptions.host;\r\n\r\n            if (this.svg) {\r\n                this.root = this.svg;\r\n            } else {\r\n                this.root = d3.select(visualsOptions.element.get(0))\r\n                    .append(\"svg\");\r\n            }\r\n\r\n            let style: IVisualStyle = visualsOptions.style;\r\n\r\n            this.colors = style && style.colorPalette\r\n                ? style.colorPalette.dataColors\r\n                : new DataColorPalette();\r\n\r\n            this.root.classed(Histogram.ClassName, true);\r\n\r\n            this.main = this.root.append(\"g\");\r\n\r\n            this.axes = this.main\r\n                .append(\"g\")\r\n                .classed(Histogram.Axes[\"class\"], true);\r\n\r\n            this.axisX = this.axes\r\n                .append(\"g\")\r\n                .classed(Histogram.Axis[\"class\"], true);\r\n\r\n            this.axisY = this.axes\r\n                .append(\"g\")\r\n                .classed(Histogram.Axis[\"class\"], true);\r\n\r\n            this.legend = this.main\r\n                .append(\"g\")\r\n                .classed(Histogram.Legends[\"class\"], true);\r\n\r\n            this.columns = this.main\r\n                .append(\"g\")\r\n                .classed(Histogram.Columns[\"class\"], true);\r\n\r\n            this.labels = this.main\r\n                .append(\"g\")\r\n                .classed(Histogram.Labels[\"class\"], true);\r\n            this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });\r\n        }\r\n\r\n        public converter(dataView: DataView): HistogramDataView {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[0].values ||\r\n                !(dataView.categorical.categories[0].values.length > 0)) {\r\n                return null;\r\n            }\r\n\r\n            let settings: HistogramSettings,\r\n                histogramLayout: D3.Layout.HistogramLayout,\r\n                values: HistogramValue[],\r\n                numericalValues: number[] = [],\r\n                data: D3.Layout.Bin[],\r\n                xScale: D3.Scale.LinearScale,\r\n                yScale: D3.Scale.LinearScale,\r\n                valueFormatter: IValueFormatter,\r\n                frequencies: number[] = [],\r\n                identities: DataViewScopeIdentity[] = [],\r\n                shiftByValues: number = 0,\r\n                sumFrequency: number = 0,\r\n                xLabelFormatter: IValueFormatter,\r\n                yLabelFormatter: IValueFormatter;\r\n\r\n            if (dataView.categorical.values &&\r\n                dataView.categorical.values[0] &&\r\n                dataView.categorical.values[0].values) {\r\n                frequencies = dataView.categorical.values[0].values;\r\n            }\r\n\r\n            if (dataView.categorical.categories[0].identity\r\n                && dataView.categorical.categories[0].identity.length > 0) {\r\n                identities = dataView.categorical.categories[0].identity;\r\n            }\r\n\r\n            settings = this.parseSettings(dataView);\r\n\r\n            if (!settings) {\r\n                return null;\r\n            }\r\n\r\n            values = this.getValuesByFrequencies(\r\n                dataView.categorical.categories[0].values,\r\n                frequencies,\r\n                identities);\r\n            values.forEach((value: HistogramValue) => {\r\n                numericalValues.push(value.value);\r\n                sumFrequency += value.frequency;\r\n            });\r\n\r\n            histogramLayout = d3.layout.histogram();\r\n\r\n            if (settings.bins && settings.bins > this.MinNumberOfBins) {\r\n                histogramLayout = histogramLayout.bins(settings.bins);\r\n            }\r\n\r\n            data = histogramLayout.frequency(settings.frequency)(numericalValues);\r\n\r\n            data.forEach((bin: D3.Layout.Bin, index: number) => {\r\n                let filteredValues: HistogramValue[],\r\n                    frequency: number;\r\n\r\n                filteredValues = values.filter((value: HistogramValue) => {\r\n                    return this.isValueContainedInRange(value, bin, index);\r\n                });\r\n\r\n                frequency = filteredValues.reduce((previousValue: number, currentValue: HistogramValue): number => {\r\n                    return previousValue + currentValue.frequency;\r\n                }, 0);\r\n\r\n                bin.y = settings.frequency\r\n                    ? frequency\r\n                    : frequency / sumFrequency;\r\n\r\n                shiftByValues += bin.length;\r\n            });\r\n\r\n            let maxYvalue = settings.yEnd !== null && settings.yEnd > settings.yStart ? settings.yEnd : d3.max(data, (item: D3.Layout.Bin) => item.y);\r\n            let minYValue = settings.yStart < maxYvalue ? settings.yStart : 0;\r\n            settings.yEnd = maxYvalue;\r\n            settings.yStart = minYValue;\r\n            settings.maxX = d3.max(data, (item: D3.Layout.Bin) => d3.max(item));\r\n\r\n            xScale = d3.scale.linear()\r\n                .domain([\r\n                    d3.min(data, (item: D3.Layout.Bin) => d3.min(item)),\r\n                    d3.max(data, (item: D3.Layout.Bin) => d3.max(item))\r\n                ])\r\n                .range([0, this.viewport.width - this.YLegendSize - this.AxisSize]);\r\n\r\n            yScale = d3.scale.linear()\r\n                .domain([\r\n                    minYValue,\r\n                    maxYvalue\r\n                ])\r\n                .range([this.viewport.height - this.LegendSize, this.outerPadding]);\r\n\r\n            valueFormatter = ValueFormatter.create({\r\n                format: ValueFormatter.getFormatString(\r\n                    dataView.categorical.categories[0].source, Histogram.Properties[\"general\"][\"formatString\"]),\r\n                value: values[0].value,\r\n                value2: values[values.length - 1].value,\r\n                precision: settings.precision\r\n            });\r\n\r\n            xLabelFormatter = ValueFormatter.create({\r\n                value: settings.xDisplayUnits === 0 ? values[values.length - 1].value : settings.xDisplayUnits,\r\n                precision: settings.xPrecision\r\n            });\r\n\r\n            yLabelFormatter = ValueFormatter.create({\r\n                value: settings.yDisplayUnits,\r\n                precision: settings.yPrecision\r\n            });\r\n\r\n            return {\r\n                xScale: xScale,\r\n                yScale: yScale,\r\n                settings: settings,\r\n                data: this.getData(values, numericalValues, data, settings, yLabelFormatter, xLabelFormatter),\r\n                formatter: valueFormatter,\r\n                xLabelFormatter: xLabelFormatter,\r\n                yLabelFormatter: yLabelFormatter\r\n            };\r\n        }\r\n\r\n        private getValuesByFrequencies(sourceValues: number[], frequencies: number[], identities: DataViewScopeIdentity[]): HistogramValue[] {\r\n            let values: HistogramValue[] = [];\r\n\r\n            sourceValues.forEach((item: number, index: number) => {\r\n                let frequency: number = 1,\r\n                    value: number = Number(item);\r\n\r\n                value = isNaN(value) ? 0 : value;\r\n\r\n                if (frequencies\r\n                    && frequencies[index]\r\n                    && !isNaN(frequencies[index])\r\n                    && frequencies[index] > 1) {\r\n                    frequency = frequencies[index];\r\n                }\r\n\r\n                values.push({\r\n                    value: value,\r\n                    frequency: frequency,\r\n                    selectionId: SelectionId.createWithId(identities[index])\r\n                });\r\n            });\r\n\r\n            return values;\r\n        }\r\n\r\n        private getData(\r\n            values: HistogramValue[],\r\n            numericalValues: number[],\r\n            data: D3.Layout.Bin[],\r\n            settings: HistogramSettings,\r\n            yValueFormatter: IValueFormatter,\r\n            xValueFormatter: IValueFormatter): HistogramData[] {\r\n            let minValue: number = d3.min(numericalValues),\r\n                maxValue: number = d3.max(numericalValues);\r\n            let fontSizeInPx = PixelConverter.fromPoint(settings.labelFontSize);\r\n\r\n            return data.map((bin: any, index: number): HistogramData => {\r\n                bin.range = this.getRange(minValue, maxValue, bin.dx, index);\r\n                bin.tooltipInfo = this.getTooltipData(bin.y, bin.range, settings, index === 0, yValueFormatter, xValueFormatter);\r\n                bin.selectionIds = this.getSelectionIds(values, bin, index);\r\n                bin.labelFontSize = fontSizeInPx;\r\n                return bin;\r\n            });\r\n        }\r\n\r\n        private getRange(minValue: number, maxValue: number, step: number, index: number): number[] {\r\n            let leftBorder: number = minValue + index * step,\r\n                rightBorder: number = leftBorder + step;\r\n\r\n            return [leftBorder, rightBorder];\r\n        }\r\n\r\n        private getTooltipData(\r\n            value: number,\r\n            range: number[],\r\n            settings: HistogramSettings,\r\n            includeLeftBorder: boolean,\r\n            yValueFormatter: IValueFormatter,\r\n            xValueFormatter: IValueFormatter): TooltipDataItem[] {\r\n\r\n            return [{\r\n                displayName: this.getLegendText(settings),\r\n                value: yValueFormatter.format(value)\r\n            }, {\r\n                    displayName: this.TooltipDisplayName,\r\n                    value: this.rangeToString(range, includeLeftBorder, xValueFormatter)\r\n                }];\r\n        }\r\n\r\n        private getSelectionIds(values: HistogramValue[], bin: HistogramData, index: number): SelectionId[] {\r\n            let selectionIds: SelectionId[] = [];\r\n\r\n            values.forEach((value: HistogramValue) => {\r\n                if (this.isValueContainedInRange(value, bin, index)) {\r\n                    selectionIds.push(value.selectionId);\r\n                }\r\n            });\r\n\r\n            return selectionIds;\r\n        }\r\n\r\n        private isValueContainedInRange(value: HistogramValue, bin: D3.Layout.Bin, index: number): boolean {\r\n            return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;\r\n        }\r\n\r\n        private parseSettings(dataView: DataView): HistogramSettings {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.columns[0]) {\r\n                return null;\r\n            }\r\n\r\n            let histogramSettings: HistogramSettings = <HistogramSettings>{},\r\n                objects: DataViewObjects,\r\n                colorHelper: ColorHelper;\r\n\r\n            colorHelper = new ColorHelper(\r\n                this.colors,\r\n                Histogram.Properties[\"dataPoint\"][\"fill\"],\r\n                Histogram.DefaultHistogramSettings.fillColor);\r\n\r\n            histogramSettings.displayName =\r\n            dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;\r\n\r\n            objects = this.getObjectsFromDataView(dataView);\r\n\r\n            histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, \"\");\r\n            histogramSettings.bins = this.getBins(objects);\r\n            histogramSettings.frequency = this.getFrequency(objects);\r\n            histogramSettings.precision = this.getPrecision(objects);\r\n            histogramSettings.xAxisColor = this.getXAxisColor(objects).solid.color;\r\n            histogramSettings.xTitle = this.getXTitle(objects);\r\n            histogramSettings.yAxisColor = this.getYAxisColor(objects).solid.color;\r\n            histogramSettings.yTitle = this.getYTitle(objects);\r\n            histogramSettings.xPrecision = this.getXPrecision(objects);\r\n            histogramSettings.xStyle = this.getXStyle(objects);\r\n            histogramSettings.xDisplayUnits = this.getXDisplayUnit(objects);\r\n            histogramSettings.displayName = this.setLegend(histogramSettings.displayName, histogramSettings.xStyle, histogramSettings.xDisplayUnits);\r\n            histogramSettings.yStyle = this.getYStyle(objects);\r\n            histogramSettings.yDisplayUnits = this.getYDisplayUnit(objects);\r\n            histogramSettings.yPrecision = this.getYPrecision(objects);\r\n            histogramSettings.xShow = this.getXAxisShow(objects);\r\n            histogramSettings.yShow = this.getYAxisShow(objects);\r\n            histogramSettings.yStart = this.getYStart(objects);\r\n            histogramSettings.yEnd = this.getYEnd(objects);\r\n            histogramSettings.yPosition = this.getYPosition(objects);\r\n            histogramSettings.labelShow = this.getLabelShow(objects);\r\n            histogramSettings.labelColor = this.getLabelColor(objects).solid.color;\r\n            histogramSettings.labelDisplayUnit = this.getLabelDisplayUnit(objects);\r\n            histogramSettings.labelPrecision = this.getLabelPrecision(objects);\r\n            histogramSettings.labelFontSize = this.getLabelFontSize(objects);\r\n\r\n            return histogramSettings;\r\n        }\r\n\r\n        private setLegend(title, style, displayUnit): string {\r\n            let retValue: string;\r\n            let formatter: IValueFormatter = ValueFormatter.create({\r\n                value: displayUnit\r\n            });\r\n\r\n            switch (style) {\r\n                case axisStyle.showTitleOnly:\r\n                    retValue = title;\r\n                    break;\r\n                case axisStyle.showUnitOnly:\r\n                    retValue = displayUnit === 0 || displayUnit === 1 ? title : formatter.displayUnit.title;\r\n                    break;\r\n                case axisStyle.showBoth:\r\n                    retValue = displayUnit === 0 || displayUnit === 1 ? title : title + \" (\" + formatter.displayUnit.title + \")\";\r\n                    break;\r\n            }\r\n            return retValue;\r\n        }\r\n\r\n        private getLabelFontSize(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"fontSize\"],\r\n                Histogram.DefaultHistogramSettings.labelFontSize\r\n            );\r\n        }\r\n\r\n        private getLabelShow(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"show\"],\r\n                Histogram.DefaultHistogramSettings.labelShow\r\n            );\r\n        }\r\n        private getLabelColor(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<Fill>(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"color\"],\r\n                {\r\n                    solid: {\r\n                        color: Histogram.DefaultHistogramSettings.labelColor\r\n                    }\r\n                }\r\n            );\r\n        }\r\n        private getLabelDisplayUnit(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"labelDisplayUnits\"],\r\n                Histogram.DefaultHistogramSettings.labelDisplayUnit\r\n            );\r\n        }\r\n        private getLabelPrecision(objects: DataViewObjects) {\r\n            let precision: number = DataViewObjects.getValue(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"labelPrecision\"],\r\n                Histogram.DefaultHistogramSettings.labelPrecision);\r\n\r\n            if (precision <= this.MinPrecision)\r\n                return this.MinPrecision;\r\n\r\n            if (precision >= this.MaxPrecision)\r\n                return this.MaxPrecision;\r\n\r\n            return precision;\r\n        }\r\n\r\n        private getXStyle(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<string>(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"style\"],\r\n                Histogram.DefaultHistogramSettings.xStyle\r\n            );\r\n        }\r\n\r\n        private getXDisplayUnit(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"displayUnits\"],\r\n                Histogram.DefaultHistogramSettings.xDisplayUnits\r\n            );\r\n        }\r\n\r\n        private getXPrecision(objects: DataViewObjects): number {\r\n            let precision: number = DataViewObjects.getValue(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"precision\"],\r\n                Histogram.DefaultHistogramSettings.xPrecision);\r\n\r\n            if (precision <= this.MinPrecision)\r\n                return this.MinPrecision;\r\n\r\n            if (precision >= this.MaxPrecision)\r\n                return this.MaxPrecision;\r\n\r\n            return precision;\r\n        }\r\n\r\n        private getXAxisShow(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"show\"],\r\n                Histogram.DefaultHistogramSettings.xShow\r\n            );\r\n        }\r\n\r\n        private getXAxisColor(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<Fill>(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"axisColor\"],\r\n                {\r\n                    solid: {\r\n                        color: Histogram.DefaultHistogramSettings.xAxisColor\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        private getXTitle(objects: DataViewObjects): boolean {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"xAxis\"][\"title\"],\r\n                Histogram.DefaultHistogramSettings.xTitle);\r\n        }\r\n\r\n        private getYStyle(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<string>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"style\"],\r\n                Histogram.DefaultHistogramSettings.yStyle\r\n            );\r\n        }\r\n\r\n        private getYPosition(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<string>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"position\"],\r\n                Histogram.DefaultHistogramSettings.yPosition\r\n            );\r\n        }\r\n\r\n        private getYAxisShow(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"show\"],\r\n                Histogram.DefaultHistogramSettings.yShow\r\n            );\r\n        }\r\n\r\n        private getYAxisColor(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<Fill>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"axisColor\"],\r\n                {\r\n                    solid: {\r\n                        color: Histogram.DefaultHistogramSettings.yAxisColor\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        private getYStart(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"start\"],\r\n                Histogram.DefaultHistogramSettings.yStart\r\n            );\r\n        }\r\n\r\n        private getYEnd(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"end\"],\r\n                Histogram.DefaultHistogramSettings.yEnd\r\n            );\r\n        }\r\n\r\n        private getYDisplayUnit(objects: DataViewObjects) {\r\n            return DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"displayUnits\"],\r\n                Histogram.DefaultHistogramSettings.yDisplayUnits\r\n            );\r\n        }\r\n\r\n        private getYPrecision(objects: DataViewObjects): number {\r\n            let precision: number = DataViewObjects.getValue(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"precision\"],\r\n                Histogram.DefaultHistogramSettings.yPrecision);\r\n\r\n            if (precision <= this.MinPrecision) {\r\n                return this.MinPrecision;\r\n            }\r\n\r\n            if (precision >= this.MaxPrecision) {\r\n                return this.MaxPrecision;\r\n            }\r\n\r\n            return precision;\r\n        }\r\n\r\n        private getYTitle(objects: DataViewObjects): boolean {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"yAxis\"][\"title\"],\r\n                Histogram.DefaultHistogramSettings.yTitle);\r\n        }\r\n\r\n        private getBins(objects: DataViewObjects): number {\r\n            let binsNumber: number;\r\n\r\n            binsNumber = Number(DataViewObjects.getValue<number>(\r\n                objects,\r\n                Histogram.Properties[\"general\"][\"bins\"],\r\n                Histogram.DefaultHistogramSettings.bins));\r\n\r\n            if (!binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins) {\r\n                return Histogram.DefaultHistogramSettings.bins;\r\n            }\r\n\r\n            if (binsNumber > this.MaxNumberOfBins) {\r\n                return this.MaxNumberOfBins;\r\n            }\r\n\r\n            return binsNumber;\r\n        }\r\n\r\n        private getFrequency(objects: DataViewObjects): boolean {\r\n            return DataViewObjects.getValue<boolean>(\r\n                objects,\r\n                Histogram.Properties[\"general\"][\"frequency\"],\r\n                Histogram.DefaultHistogramSettings.frequency);\r\n        }\r\n\r\n        private getPrecision(objects: DataViewObjects): number {\r\n            let precision: number = DataViewObjects.getValue(\r\n                objects,\r\n                Histogram.Properties[\"labels\"][\"labelPrecision\"],\r\n                Histogram.DefaultHistogramSettings.precision);\r\n\r\n            if (precision <= this.MinPrecision) {\r\n                return this.MinPrecision;\r\n            }\r\n\r\n            if (precision >= this.MaxPrecision) {\r\n                return this.MaxPrecision;\r\n            }\r\n\r\n            return precision;\r\n        }\r\n\r\n        public validateData(data: HistogramDataView): boolean {\r\n            if (data && data.data.some(x=> x.range.some(x => isNaN(x) || x === Infinity || x === -Infinity))) {\r\n                this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);\r\n                return false;\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public update(visualUpdateOptions: VisualUpdateOptions): void {\r\n            if (!visualUpdateOptions ||\r\n                !visualUpdateOptions.dataViews ||\r\n                !visualUpdateOptions.dataViews[0]) {\r\n                return;\r\n            }\r\n            CartesianChart.InnerPaddingRatio = 1;\r\n\r\n            let dataView: DataView = visualUpdateOptions.dataViews[0];\r\n\r\n            this.durationAnimations = getAnimationDuration(\r\n                this.animator,\r\n                visualUpdateOptions.suppressAnimations);\r\n\r\n            this.setSize(visualUpdateOptions.viewport);\r\n\r\n            this.histogramDataView = this.converter(dataView);\r\n            if (!this.validateData(this.histogramDataView)) {\r\n                this.histogramDataView.data = [];\r\n            }\r\n\r\n            if (!this.histogramDataView)\r\n                return;\r\n\r\n            this.YLegendSize = this.histogramDataView.settings.yTitle ? 50 : 25;\r\n            this.XLegendSize = this.histogramDataView.settings.xTitle ? 50 : 25;\r\n\r\n            this.fixXTicSize();\r\n\r\n            this.xAxisProperties = this.calculateXAxes(dataView.categorical.categories[0].source, this.textProperties, false);\r\n\r\n            let ySource = dataView.categorical.values &&\r\n                dataView.categorical.values[0] &&\r\n                dataView.categorical.values[0].values ? dataView.categorical.values[0].source : dataView.categorical.categories[0].source;\r\n\r\n            this.yAxisProperties = this.calculateYAxes(ySource, this.textProperties, false);\r\n\r\n            this.render();\r\n\r\n            CartesianChart.InnerPaddingRatio = this.oldInnerPaddingRatio;\r\n            CartesianChart.MinOrdinalRectThickness = this.oldMinOrdinalRectThickness;\r\n        }\r\n\r\n        private fixXTicSize(): void {\r\n\r\n            if (!this.histogramDataView || !this.histogramDataView.settings) {\r\n                return;\r\n            }\r\n\r\n            let ticLabel = this.histogramDataView.xLabelFormatter.format(this.histogramDataView.settings.maxX);\r\n\r\n            let textProperties: powerbi.TextProperties = {\r\n                text: ticLabel,\r\n                fontFamily: this.textProperties.fontFamily,\r\n                fontSize: this.textProperties.fontSize\r\n            };\r\n            let widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);\r\n\r\n            CartesianChart.MinOrdinalRectThickness = widthOfLabel + 3;\r\n        }\r\n\r\n        private setSize(viewport: IViewport): void {\r\n            let height: number,\r\n                width: number;\r\n\r\n            height = viewport.height -\r\n            this.margin.top -\r\n            this.margin.bottom;\r\n\r\n            width = viewport.width -\r\n            this.margin.left -\r\n            this.margin.right;\r\n\r\n            this.viewport = {\r\n                height: height,\r\n                width: width\r\n            };\r\n\r\n            this.updateElements(viewport.height, viewport.width);\r\n        }\r\n\r\n        private updateElements(height: number, width: number): void {\r\n\r\n            this.root.attr({\r\n                \"height\": height,\r\n                \"width\": width\r\n            });\r\n\r\n            this.main.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\r\n\r\n            this.legend.attr(\"transform\", SVGUtil.translate(this.margin.left, this.margin.top));\r\n\r\n            this.axisX.attr(\r\n                \"transform\",\r\n                SVGUtil.translate(0, this.viewport.height - this.XLegendSize));\r\n        }\r\n\r\n        public shouldShowYOnRight(): boolean {\r\n            return this.histogramDataView.settings.yPosition === yAxisPosition.right;\r\n        }\r\n\r\n        private columsAndAxesTransform(labelWidth: number): void {\r\n            let constMargin = 20;\r\n            let shiftToRight: number = this.shouldShowYOnRight() ? 10 :\r\n                this.histogramDataView.settings.yTitle ? this.margin.left + labelWidth + constMargin : this.margin.left + labelWidth;\r\n\r\n            this.DataLabelMargin = shiftToRight;\r\n\r\n            this.columns.attr(\"transform\", SVGUtil.translate(shiftToRight, 0));\r\n            this.axes.attr(\"transform\", SVGUtil.translate(shiftToRight, 0));\r\n\r\n            this.axisY.attr('transform', SVGUtil.translate(\r\n                this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - this.YLegendSize + 0.01 : 0, 0));\r\n\r\n            this.axisX.attr(\r\n                \"transform\",\r\n                SVGUtil.translate(0, this.viewport.height - this.XLegendSize));\r\n\r\n        }\r\n\r\n        private render(): void {\r\n            if (!this.histogramDataView || !this.histogramDataView.settings) {\r\n                return;\r\n            }\r\n\r\n            this.renderAxes();\r\n            let columnsSelection: D3.UpdateSelection = this.renderColumns();\r\n\r\n            this.adjustTransformToAxisLabels();\r\n\r\n            this.renderLegend();\r\n\r\n            if (this.histogramDataView.settings.labelShow)\r\n                this.renderLabels();\r\n            else\r\n                this.main.selectAll('.labels').selectAll('*').remove();\r\n            this.bindSelectionHandler(columnsSelection);\r\n        }\r\n        private adjustTransformToAxisLabels() {\r\n            let maxWidthOfLabael = 0;\r\n            this.main.selectAll('g.axis').filter((d, index) => index === 1).selectAll('g.tick text')\r\n                .each(function (d, i) {\r\n                    let p = powerbi.TextMeasurementService.getSvgMeasurementProperties(this);\r\n                    let textProperties: powerbi.TextProperties = {\r\n                        text: p.text,\r\n                        fontFamily: p.fontFamily,\r\n                        fontSize: p.fontSize\r\n                    };\r\n                    let widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);\r\n                    if (widthOfLabel > maxWidthOfLabael)\r\n                        maxWidthOfLabael = widthOfLabel;\r\n                });\r\n            let constMargin = 70;\r\n            this.yTitleMargin = this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - constMargin + this.YLegendSize + maxWidthOfLabael : 0;\r\n            this.columsAndAxesTransform(maxWidthOfLabael);\r\n        }\r\n\r\n        private renderColumns(): D3.UpdateSelection {\r\n            let data: HistogramData[] = this.histogramDataView.data,\r\n                yScale: D3.Scale.LinearScale = this.histogramDataView.yScale,\r\n                countOfValues: number = data.length,\r\n                widthOfColumn: number,\r\n                updateColumnsSelection: D3.UpdateSelection;\r\n\r\n            widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.YLegendSize) / countOfValues - this.ColumnPadding);\r\n\r\n            if (widthOfColumn < 0) {\r\n                widthOfColumn = 0;\r\n            }\r\n\r\n            this.widthOfColumn = widthOfColumn;\r\n            updateColumnsSelection = this.columnsSelection.data(data);\r\n\r\n            updateColumnsSelection\r\n                .enter()\r\n                .append(\"svg:rect\");\r\n\r\n            updateColumnsSelection\r\n                .attr(\"x\", this.ColumnPadding / 2)\r\n                .attr(\"width\", widthOfColumn)\r\n                .attr(\"height\", (item: HistogramData) => this.getColumnHeight(item, yScale))\r\n                .style(\"fill\", this.histogramDataView.settings.fillColor)\r\n                .attr(\"class\", Histogram.Column[\"class\"])\r\n                .attr(\"transform\", (item: HistogramData, index: number) => SVGUtil.translate(\r\n                    widthOfColumn * index + this.ColumnPadding * index,\r\n                    yScale(item.y) - this.ColumnPadding / 2.5));\r\n\r\n            if (countOfValues) {\r\n                //if data is empty, it throws for some reason\r\n                updateColumnsSelection.classed(Histogram.Column[\"class\"]);\r\n            }\r\n\r\n            updateColumnsSelection.exit().remove();\r\n\r\n            this.renderTooltip(updateColumnsSelection);\r\n\r\n            return updateColumnsSelection;\r\n        }\r\n\r\n        private renderTooltip(selection: D3.UpdateSelection): void {\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\r\n                return (<HistogramData>tooltipEvent.data).tooltipInfo;\r\n            });\r\n        }\r\n\r\n        private getColumnHeight(column: D3.Layout.Bin, y: D3.Scale.LinearScale): number {\r\n            let height: number = this.viewport.height - this.XLegendSize - y(column.y);\r\n\r\n            return height > 0 ? height : this.MinColumnHeight;\r\n        }\r\n\r\n        private renderAxes(): void {\r\n            let xAxis: D3.Svg.Axis,\r\n                yAxis: D3.Svg.Axis;\r\n\r\n            xAxis = this.xAxisProperties.axis\r\n                .tickFormat((item: number) => this.histogramDataView.xLabelFormatter.format(item))\r\n                .orient('bottom');\r\n\r\n            yAxis = this.yAxisProperties.axis\r\n                .orient(this.histogramDataView.settings.yPosition.toLowerCase())\r\n                .tickFormat((item: number) => this.histogramDataView.yLabelFormatter.format(item));\r\n\r\n            let xShow = this.histogramDataView.settings.xShow;\r\n            let yShow = this.histogramDataView.settings.yShow;\r\n\r\n            if (xShow)\r\n                this.axisX.transition().duration(1).call(xAxis);\r\n            else\r\n                this.axisX.selectAll('*').remove();\r\n\r\n            if (yShow)\r\n                this.axisY.call(yAxis);\r\n            else\r\n                this.axisY.selectAll('*').remove();\r\n\r\n            this.main.selectAll('g.axis').filter((d, index) => index === 0).selectAll('g.tick text').style({\r\n                'fill': this.histogramDataView.settings.xAxisColor,\r\n            });\r\n\r\n            this.main.selectAll('g.axis').filter((d, index) => index === 1).selectAll('g.tick text').style({\r\n                'fill': this.histogramDataView.settings.yAxisColor,\r\n            });\r\n        }\r\n\r\n        private getLabaelLayout(): ILabelLayout {\r\n            let fontSizeInPx = PixelConverter.fromPoint(this.histogramDataView.settings.labelFontSize);\r\n            let settings = this.histogramDataView.settings;\r\n            let dataLabelFormatter = ValueFormatter.create({\r\n                value: settings.labelDisplayUnit,\r\n                precision: settings.labelPrecision\r\n            });\r\n            return {\r\n                labelText: (b: D3.Layout.Bin) => {\r\n                    return dataLabelFormatter.format(b.y).toString();\r\n                },\r\n                labelLayout: {\r\n                    x: (b: D3.Layout.Bin) => this.DataLabelMargin + this.histogramDataView.xScale(b.x) + this.widthOfColumn / 2,\r\n                    y: (b: D3.Layout.Bin) => this.histogramDataView.yScale(b.y) - 5\r\n                },\r\n                filter: (b: D3.Layout.Bin) => {\r\n                    return (b != null);\r\n                },\r\n                style: {\r\n                    'fill': settings.labelColor,\r\n                    'font-size': fontSizeInPx,\r\n                },\r\n            };\r\n        }\r\n\r\n        private renderLabels(): void {\r\n            let layout = this.getLabaelLayout();\r\n            let dataPointsArray = this.histogramDataView.data;\r\n            dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray, this.main, layout, this.viewport);\r\n\r\n        }\r\n        private rangesToArray(data: HistogramData[]): number[] {\r\n            return data.reduce((previousValue: number[], currentValue: HistogramData, index: number) => {\r\n                let range: number[];\r\n\r\n                range = index === 0\r\n                    ? currentValue.range\r\n                    : currentValue.range.slice(1);\r\n\r\n                return previousValue.concat(range);\r\n            }, []);\r\n        }\r\n\r\n        private rangeToString(range: number[], includeLeftBorder: boolean, valueFormatter: IValueFormatter): string {\r\n            let leftBracket: string,\r\n                rightBracket: string = this.IncludeBrackets.right,\r\n                leftBorder: string = valueFormatter.format(range[0]),\r\n                rightBorder: string = valueFormatter.format(range[1]);\r\n\r\n            leftBracket = includeLeftBorder\r\n                ? this.IncludeBrackets.left\r\n                : this.ExcludeBrackets.left;\r\n\r\n            return `${leftBracket}${leftBorder}${this.SeparatorNumbers}${rightBorder}${rightBracket}`;\r\n        }\r\n\r\n        private renderLegend(): void {\r\n            let legendElements: D3.Selection,\r\n                legendSelection: D3.UpdateSelection,\r\n                datalegends: Legend[] = this.getDataLegends(this.histogramDataView.settings);\r\n\r\n            legendElements = this.main\r\n                .select(Histogram.Legends.selector)\r\n                .selectAll(Histogram.Legend.selector);\r\n\r\n            legendSelection = legendElements.data(datalegends);\r\n\r\n            legendSelection\r\n                .enter()\r\n                .append(\"svg:text\");\r\n\r\n            legendSelection\r\n                .attr(\"x\", 0)\r\n                .attr(\"y\", 0)\r\n                .attr(\"dx\", (item: Legend) => item.dx)\r\n                .attr(\"dy\", (item: Legend) => item.dy)\r\n                .attr(\"transform\", (item: Legend) => item.transform)\r\n                .attr(\"class\", Histogram.Legend[\"class\"])\r\n                .text((item: Legend) => item.text)\r\n                .classed(Histogram.Legend[\"class\"], true);\r\n\r\n            legendSelection\r\n                .exit()\r\n                .remove();\r\n\r\n            this.legend.select('text').style({\r\n                'display': this.histogramDataView.settings.xTitle === true ? 'block' : 'none',\r\n            });\r\n\r\n            this.legend.selectAll('text').filter((d, index) => index === 1).style({\r\n                'display': this.histogramDataView.settings.yTitle === true ? 'block' : 'none',\r\n            });\r\n        }\r\n\r\n        private getDataLegends(settings: HistogramSettings): Legend[] {\r\n            let bottomLegendText: string = this.getLegendText(settings);\r\n            bottomLegendText = this.setLegend(bottomLegendText, settings.yStyle, settings.yDisplayUnits);\r\n\r\n            return [{\r\n                transform: SVGUtil.translate(\r\n                    this.viewport.width / 2,\r\n                    this.viewport.height),\r\n                text: settings.displayName,\r\n                dx: \"1em\",\r\n                dy: \"-1em\"\r\n            }, {\r\n                    transform: SVGUtil.translateAndRotate(\r\n                        this.shouldShowYOnRight() ? this.yTitleMargin : 0,\r\n                        this.viewport.height / 2,\r\n                        0,\r\n                        0,\r\n                        270),\r\n                    text: bottomLegendText,\r\n                    dx: \"3em\"\r\n                }];\r\n        }\r\n\r\n        private getLegendText(settings: HistogramSettings): string {\r\n            return settings.frequency\r\n                ? Histogram.FrequencyText\r\n                : Histogram.DensityText;\r\n        }\r\n\r\n        private bindSelectionHandler(columnsSelection: D3.UpdateSelection): void {\r\n            this.setSelection(columnsSelection);\r\n\r\n            columnsSelection.on(\"click\", (data: HistogramData) => {\r\n                this.selectionManager.clear();\r\n\r\n                data.selectionIds.forEach((selectionId: SelectionId) => {\r\n                    this.selectionManager.select(selectionId, true).then((selectionIds: SelectionId[]) => {\r\n                        if (selectionIds.length > 0) {\r\n                            this.setSelection(columnsSelection, data);\r\n                        } else {\r\n                            this.setSelection(columnsSelection);\r\n                        }\r\n                    });\r\n                });\r\n\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            this.root.on(\"click\", () => {\r\n                this.selectionManager.clear();\r\n                this.setSelection(columnsSelection);\r\n            });\r\n        }\r\n\r\n        private setSelection(columnsSelection: D3.UpdateSelection, data?: HistogramData): void {\r\n            columnsSelection.transition()\r\n                .duration(this.durationAnimations)\r\n                .style(\"fill-opacity\", this.MaxOpacity);\r\n\r\n            if (!data) {\r\n                return;\r\n            }\r\n\r\n            columnsSelection\r\n                .filter((columnSelection: HistogramData) => {\r\n                    return columnSelection !== data;\r\n                })\r\n                .transition()\r\n                .duration(this.durationAnimations)\r\n                .style(\"fill-opacity\", this.MinOpacity);\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            let instances: VisualObjectInstance[] = [],\r\n                settings: HistogramSettings;\r\n\r\n            if (!this.histogramDataView ||\r\n                !this.histogramDataView.settings) {\r\n                return instances;\r\n            }\r\n\r\n            settings = this.histogramDataView.settings;\r\n\r\n            switch (options.objectName) {\r\n                case \"general\": {\r\n                    let general: VisualObjectInstance = {\r\n                        objectName: \"general\",\r\n                        displayName: \"general\",\r\n                        selector: null,\r\n                        properties: {\r\n                            bins: settings.bins,\r\n                            frequency: settings.frequency\r\n                        }\r\n                    };\r\n\r\n                    instances.push(general);\r\n                    break;\r\n                }\r\n                case \"dataPoint\": {\r\n                    let dataPoint: VisualObjectInstance = {\r\n                        objectName: \"dataPoint\",\r\n                        displayName: \"dataPoint\",\r\n                        selector: null,\r\n                        properties: {\r\n                            fill: settings.fillColor\r\n                        }\r\n                    };\r\n\r\n                    instances.push(dataPoint);\r\n                    break;\r\n                }\r\n                case \"labels\": {\r\n                    let labels: VisualObjectInstance = {\r\n                        objectName: \"labels\",\r\n                        displayName: \"labels\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: settings.labelShow,\r\n                            color: settings.labelColor,\r\n                            labelDisplayUnits: settings.labelDisplayUnit,\r\n                            labelPrecision: settings.labelPrecision,\r\n                            fontSize: settings.labelFontSize\r\n                        }\r\n                    };\r\n                    instances.push(labels);\r\n                    break;\r\n                }\r\n                case \"xAxis\": {\r\n                    let xAxis: VisualObjectInstance = {\r\n                        objectName: \"axis\",\r\n                        displayName: \"X Axis\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: settings.xShow,\r\n                            title: settings.xTitle,\r\n                            style: settings.xStyle,\r\n                            axisColor: settings.xAxisColor,\r\n                            displayUnits: settings.xDisplayUnits,\r\n                            precision: settings.xPrecision\r\n                        }\r\n                    };\r\n                    instances.push(xAxis);\r\n                    break;\r\n                }\r\n                case \"yAxis\": {\r\n                    let yAxis: VisualObjectInstance = {\r\n                        objectName: \"axis\",\r\n                        displayName: \"Y Axis\",\r\n                        selector: null,\r\n                        properties: {\r\n                            show: settings.yShow,\r\n                            position: settings.yPosition,\r\n                            start: settings.yStart,\r\n                            end: settings.yEnd,\r\n                            title: settings.yTitle,\r\n                            style: settings.yStyle,\r\n                            axisColor: settings.yAxisColor,\r\n                            displayUnits: settings.yDisplayUnits,\r\n                            precision: settings.yPrecision\r\n                        }\r\n                    };\r\n                    instances.push(yAxis);\r\n                    break;\r\n                }\r\n            }\r\n            return instances;\r\n        }\r\n\r\n        private getObjectsFromDataView(dataView: DataView): DataViewObjects {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.objects) {\r\n                return null;\r\n            }\r\n\r\n            return dataView.metadata.objects;\r\n        }\r\n\r\n        public destroy(): void {\r\n            this.root = null;\r\n        }\r\n        private calculateXAxes(\r\n            source: DataViewMetadataColumn,\r\n            textProperties: TextProperties,\r\n            scrollbarVisible: boolean): IAxisProperties {\r\n\r\n            let visualOptions: CalculateScaleAndDomainOptions = {\r\n                viewport: this.viewport,\r\n                margin: this.margin,\r\n                forcedXDomain: this.rangesToArray(this.histogramDataView.data),\r\n                forceMerge: true,\r\n                showCategoryAxisLabel: false,\r\n                showValueAxisLabel: false,\r\n                categoryAxisScaleType: axisScale.linear,\r\n                valueAxisScaleType: null,\r\n                trimOrdinalDataOnOverflow: false\r\n            };\r\n\r\n            let width = this.viewport.width;\r\n            let axes = this.calculateXAxesProperties(visualOptions, source);\r\n\r\n            axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\r\n                axes,\r\n                width,\r\n                TextMeasurementService.measureSvgTextWidth,\r\n                textProperties);\r\n\r\n            // If labels do not fit and we are not scrolling, try word breaking\r\n            axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\r\n                axes, this.margin, width, TextMeasurementService.measureSvgTextWidth,\r\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\r\n                textProperties);\r\n\r\n            return axes;\r\n        }\r\n        private calculateXAxesProperties(options: CalculateScaleAndDomainOptions, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\r\n            let xAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: this.viewport.width - this.YLegendSize - this.AxisSize,\r\n                dataDomain: options.forcedXDomain,\r\n                metaDataColumn: metaDataColumn,\r\n                formatString: valueFormatter.getFormatString(metaDataColumn, Histogram.Properties[\"general\"][\"formatString\"]),\r\n                outerPadding: 0,\r\n                isScalar: false,\r\n                isVertical: false,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: true,\r\n                getValueFn: (index, type) => index,\r\n                scaleType: options.categoryAxisScaleType\r\n            });\r\n\r\n            xAxisProperties.axisLabel = this.histogramDataView.settings.displayName;\r\n            return xAxisProperties;\r\n        }\r\n        private calculateYAxes(\r\n            source: DataViewMetadataColumn,\r\n            textProperties: TextProperties,\r\n            scrollbarVisible: boolean): IAxisProperties {\r\n\r\n            let visualOptions: CalculateScaleAndDomainOptions = {\r\n                viewport: this.viewport,\r\n                margin: this.margin,\r\n                forceMerge: true,\r\n                showCategoryAxisLabel: true,\r\n                showValueAxisLabel: false,\r\n                categoryAxisScaleType: axisScale.linear,\r\n                valueAxisScaleType: null,\r\n                trimOrdinalDataOnOverflow: false\r\n            };\r\n            visualOptions.forcedYDomain = AxisHelper.applyCustomizedDomain([this.histogramDataView.settings.yStart, this.histogramDataView.settings.yEnd], visualOptions.forcedYDomain);\r\n\r\n            let axes = this.calculateYAxesProperties(visualOptions, source);\r\n\r\n            return axes;\r\n        }\r\n        private calculateYAxesProperties(options: CalculateScaleAndDomainOptions, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\r\n            let yAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: this.viewport.height - this.XLegendSize + 5,\r\n                dataDomain: AxisHelper.combineDomain(options.forcedYDomain, [this.histogramDataView.settings.yStart, this.histogramDataView.settings.yEnd]),\r\n                metaDataColumn: metaDataColumn,\r\n                formatString: valueFormatter.getFormatString(metaDataColumn, Histogram.Properties[\"general\"][\"formatString\"]),\r\n                outerPadding: this.outerPadding,\r\n                isScalar: true,\r\n                isVertical: true,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: false,\r\n                getValueFn: (index, type) => index,\r\n                scaleType: options.categoryAxisScaleType\r\n            });\r\n\r\n            return yAxisProperties;\r\n        }\r\n\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/histogram/visual/histogram.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import getAnimationDuration = AnimatorCommon.GetAnimationDuration;\r\n    import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n    import AxisScale = powerbi.visuals.axisScale;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    const MaxXAxisHeight: number = 40;\r\n    const LabelMargin: number = 15;\r\n    const DefaultRadius: number = 5;\r\n    const DefaultStrokeWidth: number = 1;\r\n    const DefaultDataPointColor = \"#00B8AA\";\r\n    const MinPrecision: number = 0;\r\n    const MaxPrecision: number = 17;\r\n\r\n    export const DotPlotProperties: any = {\r\n        general: {\r\n            formatString: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"general\",\r\n                propertyName: \"formatString\"\r\n            }\r\n        },\r\n        labels: {\r\n            show: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"show\"\r\n            },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"fontSize\"\r\n            },\r\n            labelPrecision: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"labelPrecision\"\r\n            },\r\n            labelDisplayUnits: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"labelDisplayUnits\"\r\n            },\r\n            labelColor: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"labelColor\"\r\n            }\r\n        },\r\n        dataPoint: {\r\n            fill: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"dataPoint\",\r\n                propertyName: \"fill\"\r\n            }\r\n        },\r\n        categories: {\r\n            show: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"categories\",\r\n                propertyName: \"show\"\r\n            },\r\n            fontColor: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"categories\",\r\n                propertyName: \"fontColor\"\r\n            },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"categories\",\r\n                propertyName: \"fontSize\"\r\n            }\r\n        }\r\n    };\r\n\r\n    export interface DotPlotSelectors {\r\n        svgPlotSelector: ClassAndSelector;\r\n        plotSelector: ClassAndSelector;\r\n        plotGroupSelector: ClassAndSelector;\r\n        axisSelector: ClassAndSelector;\r\n        xAxisSelector: ClassAndSelector;\r\n        circleSeletor: ClassAndSelector;\r\n    }\r\n\r\n    export interface DotPlotChartCategory {\r\n        value: string;\r\n        selectionId: SelectionId;\r\n    }\r\n\r\n    export interface DotPlotConstructorOptions {\r\n        animator?: IGenericAnimator;\r\n        svg?: D3.Selection;\r\n        margin?: IMargin;\r\n        radius?: number;\r\n        strokeWidth?: number;\r\n    }\r\n\r\n    export interface DotPlotDataPoint {\r\n        x: number;\r\n        y: number;\r\n        tooltipInfo: TooltipDataItem[];\r\n    }\r\n\r\n    export interface DotPlotSettings {\r\n        labelSettings?: VisualDataLabelsSettings;\r\n        formatter?: IValueFormatter;\r\n        tooltipFormatter?: IValueFormatter;\r\n        categorySettings?: DotPlotCategorySettings;\r\n        defaultDataPointColor?: string;\r\n    }\r\n\r\n    export interface DotPlotCategorySettings {\r\n        show?: boolean;\r\n        fontColor?: string;\r\n        fontSize?: number;\r\n    }\r\n\r\n    export interface DotPlotDataGroup extends SelectableDataPoint {\r\n        label?: string;\r\n        value?: number;\r\n        color?: string;\r\n        tooltipInfo?: TooltipDataItem[];\r\n        dataPoints: DotPlotDataPoint[];\r\n        labelFontSize: string;\r\n        highlight?: boolean;\r\n    }\r\n\r\n    export interface DotPlotDataView {\r\n        displayName: string;\r\n        dataPoints: DotPlotDataGroup[];\r\n        values: any[];\r\n        settings: DotPlotSettings;\r\n        categories: DotPlotChartCategory[];\r\n    }\r\n\r\n    export class DotPlot implements IVisual {\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [{\r\n                name: 'Category',\r\n                kind: powerbi.VisualDataRoleKind.Grouping,\r\n                displayName: 'Category'\r\n            },\r\n                {\r\n                    name: \"Values\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Values'\r\n                }],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Values': { max: 1 } },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: \"Series\",\r\n                            select: [{ for: { in: \"Values\" } }],\r\n                            dataReductionAlgorithm: { top: {} }\r\n                        }\r\n                    }\r\n                },\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: 'General',\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n                dataPoint: {\r\n                    displayName: 'Data colors',\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: 'Fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: \"Data labels\",\r\n                    description: 'Display data label options',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        showSeries: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: 'Color',\r\n                            description: 'Select color for data labels',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        labelDisplayUnits: {\r\n                            displayName: 'Display units',\r\n                            description: 'Select the units (millions, billions, etc.)',\r\n                            type: { formatting: { labelDisplayUnits: true } },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelPrecision: {\r\n                            displayName: 'Decimal places',\r\n                            description: 'Select the number of decimal places to display',\r\n                            placeHolderText: 'Auto',\r\n                            type: { numeric: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        showAll: {\r\n                            displayName: 'Customize series',\r\n                            type: { bool: true }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private DefaultMargin: IMargin = {\r\n            top: 10,\r\n            bottom: 10,\r\n            right: 20,\r\n            left: 20\r\n        };\r\n\r\n        private svg: D3.Selection;\r\n        private xAxis: D3.Selection;\r\n        private dotPlot: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private behavior: IInteractiveBehavior;\r\n\r\n        private colors: IDataColorPalette;\r\n        private dataView: DataView;\r\n        private animator: IGenericAnimator;\r\n        private durationAnimations: number = 100;\r\n        private dotPlotDataView: DotPlotDataView;\r\n\r\n        private radius: number;\r\n        private strokeWidth: number;\r\n        private interactivityService: IInteractivityService;\r\n        private scaleType: string = AxisScale.linear;\r\n        private textProperties: TextProperties = {\r\n            fontFamily: 'wf_segoe-ui_normal',\r\n            fontSize: jsCommon.PixelConverter.toString(9),\r\n        };\r\n\r\n        private dotPlotSelectors: DotPlotSelectors =\r\n        {\r\n            svgPlotSelector: CreateClassAndSelector('dotplot'),\r\n            plotSelector: CreateClassAndSelector('dotplotSelector'),\r\n            plotGroupSelector: CreateClassAndSelector('dotplotGroup'),\r\n            axisSelector: CreateClassAndSelector('axisGraphicsContext'),\r\n            xAxisSelector: CreateClassAndSelector('x axis'),\r\n            circleSeletor: CreateClassAndSelector('circleSelector'),\r\n        };\r\n\r\n        private DefaultDotPlotSettings: DotPlotSettings = {\r\n            labelSettings: {\r\n                show: true,\r\n                precision: 2,\r\n                fontSize: dataLabelUtils.DefaultFontSizeInPt,\r\n                displayUnits: 0,\r\n                labelColor: dataLabelUtils.defaultLabelColor,\r\n            },\r\n            categorySettings: {\r\n                show: true,\r\n                fontColor: LegendData.DefaultLegendLabelFillColor\r\n            },\r\n            defaultDataPointColor: DefaultDataPointColor\r\n        };\r\n\r\n        private static getTooltipData(value: number): TooltipDataItem[] {\r\n            return [{\r\n                displayName: \"Value\",\r\n                value: value.toString()\r\n            }];\r\n        }\r\n\r\n        public static converter(dataView: DataView, scale: D3.Scale.OrdinalScale, defaultMargin: IMargin, defaultSetting: DotPlotSettings, colors: IDataColorPalette, viewport: IViewport, radius: number): DotPlotDataView {\r\n            let values: DataViewValueColumns = dataView.categorical.values,\r\n                dataPointsGroup: DotPlotDataGroup[] = [],\r\n                displayName: string = dataView.categorical.categories[0].source.displayName,\r\n                objects: DataViewObjects = this.getObjectsFromDataView(dataView),\r\n                settings: DotPlotSettings,\r\n                defaultColor = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\r\n\r\n            let categories: DotPlotChartCategory[] = dataView.categorical.categories[0].values.map((x, i) => <DotPlotChartCategory>{\r\n                value: x,\r\n                selectionId: SelectionId.createWithId(dataView.categorical.categories[0].identity[i])\r\n            });\r\n\r\n            settings = {\r\n                categorySettings: this.getCategorySettings(objects, defaultSetting),\r\n                defaultDataPointColor: defaultColor,\r\n                labelSettings: this.parseSettings(objects, defaultSetting)\r\n            };\r\n\r\n            let categoryColumn = dataView.categorical.categories[0];\r\n            let diameter: number = 2 * radius + 1;\r\n            let dotsTotalHeight: number = viewport.height - radius - MaxXAxisHeight;\r\n            let maxDots: number = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1;\r\n            let fontSizeInPx: string = PixelConverter.fromPoint(settings.labelSettings.fontSize);\r\n\r\n            let yScale: D3.Scale.LinearScale = d3.scale.linear()\r\n                .domain([0, maxDots])\r\n                .range([dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom]);\r\n\r\n            for (let value of values) {\r\n                let min = _.min(value.values);\r\n                let max = _.max(value.values);\r\n\r\n                let color = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);\r\n                let length = value.values.length;\r\n                let minDots = min / (max / maxDots);\r\n                let dotsScale = d3.scale.log().domain([min, max]).range([minDots === 0 ? 1 : minDots, maxDots]).clamp(true);\r\n\r\n                for (let k = 0; k < length; k++) {\r\n                    let y = dotsScale(value.values[k]);\r\n                    let dataPoints: DotPlotDataPoint[] = [];\r\n\r\n                    for (let level = 0; level < y; level++) {\r\n                        dataPoints.push({\r\n                            x: scale(categories[k].value) + scale.rangeBand() / 2,\r\n                            y: yScale(level),\r\n                            tooltipInfo: DotPlot.getTooltipData(value.values[k])\r\n                        });\r\n                    }\r\n\r\n                    let categorySelectionId = SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId();\r\n                    let tooltipInfo = DotPlot.getTooltipData(value.values[k]);\r\n\r\n                    dataPointsGroup.push({\r\n                        selected: false,\r\n                        value: value.values[k],\r\n                        label: value.values[k],\r\n                        color: color,\r\n                        identity: categorySelectionId,\r\n                        tooltipInfo: tooltipInfo,\r\n                        dataPoints: dataPoints,\r\n                        labelFontSize: fontSizeInPx,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return {\r\n                dataPoints: dataPointsGroup,\r\n                values: dataView.categorical.categories[0].values,\r\n                displayName: displayName,\r\n                categories: categories,\r\n                settings: settings\r\n            };\r\n        }\r\n\r\n        public constructor(options?: DotPlotConstructorOptions) {\r\n            if (options) {\r\n                if (options.svg) {\r\n                    this.svg = options.svg;\r\n                }\r\n                if (options.animator) {\r\n                    this.animator = options.animator;\r\n                }\r\n\r\n                this.radius = options.radius || DefaultRadius;\r\n                this.strokeWidth = options.strokeWidth || DefaultStrokeWidth;\r\n            }\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            let element = options.element;\r\n            this.behavior = new DotplotBehavior();\r\n\r\n            this.interactivityService = createInteractivityService(options.host);\r\n            this.radius = DefaultRadius;\r\n            this.strokeWidth = DefaultStrokeWidth;\r\n            this.colors = options.style.colorPalette.dataColors;\r\n\r\n            this.svg = d3.select(element.get(0)).append('svg').classed(this.dotPlotSelectors.svgPlotSelector.class, true).style('position', 'absolute');\r\n            this.clearCatcher = appendClearCatcher(this.svg);\r\n\r\n            let axisGraphicsContext = this.svg.append('g').classed(this.dotPlotSelectors.axisSelector.class, true);\r\n            this.dotPlot = this.svg.append('g').classed(this.dotPlotSelectors.plotSelector.class, true);\r\n            this.xAxis = axisGraphicsContext.append(\"g\").classed(this.dotPlotSelectors.xAxisSelector.class, true);\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions): void {\r\n            if (!options.dataViews || !options.dataViews[0]) return;\r\n\r\n            this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);\r\n            let dataView = this.dataView = options.dataViews[0];\r\n            let viewport = options.viewport;\r\n\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.values ||\r\n                dataView.categorical.values.length < 1 ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0]) {\r\n                this.clearData();\r\n                return;\r\n            }\r\n\r\n            let viewportIn: IViewport =\r\n                {\r\n                    height: (viewport.height - this.DefaultMargin.top),\r\n                    width: (viewport.width - this.DefaultMargin.left)\r\n                };\r\n\r\n            this.svg.style({\r\n                height: PixelConverter.toString(viewport.height),\r\n                width: PixelConverter.toString(viewport.width)\r\n            });\r\n\r\n            let xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, false);\r\n            let data = DotPlot.converter(dataView, <D3.Scale.OrdinalScale>xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);\r\n\r\n            this.dotPlotDataView = data;\r\n            let dataPoints = data.dataPoints;\r\n\r\n            if (this.interactivityService)\r\n                this.interactivityService.applySelectionStateToData(dataPoints);\r\n\r\n            this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations);\r\n            this.drawDotPlot(dataPoints, data.settings);\r\n\r\n            let dataLabelsSettings = data.settings.labelSettings;\r\n            if (dataLabelsSettings.show) {\r\n                let layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);\r\n                dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);\r\n            }\r\n            else {\r\n                dataLabelUtils.cleanDataLabels(this.svg);\r\n            }\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration = new ObjectEnumerationBuilder();\r\n\r\n            switch (options.objectName) {\r\n                case 'dataPoint':\r\n                    this.enumerateDataPoints(enumeration, this.dataView);\r\n                    break;\r\n                case 'labels':\r\n                    this.enumerateDataLabels(enumeration, this.dataView);\r\n                    break;\r\n                case 'categories':\r\n                    this.enumerateCategories(enumeration, this.dataView);\r\n                    break;\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private static getObjectsFromDataView(dataView: DataView): DataViewObjects {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.objects) {\r\n                return null;\r\n            }\r\n\r\n            return dataView.metadata.objects;\r\n        }\r\n\r\n        private static parseSettings(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): VisualDataLabelsSettings {\r\n            let precision = this.getPrecision(objects, defaultDotPlotSettings);\r\n\r\n            return {\r\n                show: DataViewObjects.getValue(objects, DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),\r\n                precision: precision,\r\n                fontSize: DataViewObjects.getValue(objects, DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),\r\n                displayUnits: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),\r\n                labelColor: DataViewObjects.getFillColor(objects, DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor),\r\n            };\r\n        }\r\n\r\n        private static getCategorySettings(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): DotPlotCategorySettings {\r\n            return {\r\n                show: DataViewObject.getValue<boolean>(objects, DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),\r\n                fontColor: DataViewObjects.getFillColor(objects, DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)\r\n            };\r\n        }\r\n\r\n        private static getPrecision(objects: DataViewObjects, defaultDotPlotSettings: DotPlotSettings): number {\r\n            let precision: number = DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);\r\n\r\n            if (precision <= MinPrecision)\r\n                return MinPrecision;\r\n\r\n            if (precision >= MaxPrecision)\r\n                return MaxPrecision;\r\n\r\n            return precision;\r\n        }\r\n\r\n        private drawDotPlot(data: DotPlotDataGroup[], setting: DotPlotSettings): void {\r\n            let selection: D3.UpdateSelection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data);\r\n            let hasSelection = this.interactivityService && this.interactivityService.hasSelection();\r\n\r\n            selection\r\n                .enter()\r\n                .append('g')\r\n                .attr(\r\n                {\r\n                    stroke: \"black\",\r\n                    \"stroke-width\": this.strokeWidth\r\n                }).\r\n                style(\"fill-opacity\", (item: DotPlotDataGroup) => ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, false)).\r\n                classed(this.dotPlotSelectors.plotGroupSelector.class, true);\r\n\r\n            let circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data((d: DotPlotDataGroup) => { return d.dataPoints; });\r\n            circleSelection.enter().append('circle')\r\n                .classed(this.dotPlotSelectors.circleSeletor.class, true);\r\n\r\n            circleSelection.attr(\r\n                {\r\n                    cx: (point: DotPlotDataPoint) => { return point.x; },\r\n                    cy: (point: DotPlotDataPoint) => { return point.y; },\r\n                    r: this.radius,\r\n                    fill: setting.defaultDataPointColor\r\n                });\r\n\r\n            this.renderTooltip(selection);\r\n            circleSelection.exit().remove();\r\n            selection.exit().remove();\r\n\r\n            let interactivityService = this.interactivityService;\r\n            if (interactivityService) {\r\n                interactivityService.applySelectionStateToData(data);\r\n\r\n                let behaviorOptions: DotplotBehaviorOptions = {\r\n                    columns: selection,\r\n                    clearCatcher: this.clearCatcher,\r\n                    interactivityService: this.interactivityService,\r\n                };\r\n                interactivityService.bind(data, this.behavior, behaviorOptions);\r\n            }\r\n        }\r\n\r\n        private getEnhanchedDotplotLayout(labelSettings: VisualDataLabelsSettings, viewport: IViewport): ILabelLayout {\r\n            let fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);\r\n\r\n            let formatter: IValueFormatter = valueFormatter.create({\r\n                format: valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, DotPlotProperties.general.formatString),\r\n                precision: labelSettings.precision,\r\n                value: labelSettings.displayUnits\r\n            });\r\n\r\n            return {\r\n                labelText: function (d) {\r\n                    return dataLabelUtils.getLabelFormattedText({\r\n                        label: formatter.format(d.label),\r\n                        fontSize: labelSettings.fontSize,\r\n                        maxWidth: viewport.width,\r\n                    });\r\n                },\r\n                labelLayout: {\r\n                    x: (d: DotPlotDataGroup) => d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0,\r\n                    y: (d: DotPlotDataGroup) => d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0\r\n                },\r\n                filter: function (d) {\r\n                    return (d != null && d.label != null);\r\n                },\r\n                style: {\r\n                    'fill': labelSettings.categoryLabelColor,\r\n                    'font-size': fontSizeInPx,\r\n                },\r\n            };\r\n        }\r\n\r\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\r\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\r\n            enumeration.pushInstance({\r\n                objectName: \"labels\",\r\n                displayName: \"Labels\",\r\n                selector: null,\r\n                properties: {\r\n                    show: DataViewObjects.getValue<boolean>(objects, DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),\r\n                    fontSize: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),\r\n                    labelPrecision: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),\r\n                    labelDisplayUnits: DataViewObjects.getValue<number>(objects, DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),\r\n                    labelColor: DataViewObjects.getFillColor(objects, DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)\r\n                }\r\n            });\r\n        }\r\n\r\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\r\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\r\n            let dataPointColor = DataViewObjects.getFillColor(objects, DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);\r\n            enumeration.pushInstance({\r\n                objectName: \"dataPoint\",\r\n                displayName: \"Data Points\",\r\n                selector: null,\r\n                properties: {\r\n                    fill: { solid: { color: dataPointColor } }\r\n                }\r\n            });\r\n        }\r\n\r\n        private enumerateCategories(enumeration: ObjectEnumerationBuilder, dataView: DataView): void {\r\n            let objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;\r\n            let categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);\r\n            enumeration.pushInstance({\r\n                objectName: \"categories\",\r\n                displayName: \"Categories\",\r\n                selector: null,\r\n                properties: {\r\n                    show: categoriesSettings.show,\r\n                    fontSize: categoriesSettings.fontSize,\r\n                    fontColor: categoriesSettings.fontColor\r\n                }\r\n            });\r\n        }\r\n\r\n        private clearData(): void {\r\n            this.dotPlot.selectAll(\"*\").remove();\r\n            this.xAxis.selectAll(\"*\").remove();\r\n            dataLabelUtils.cleanDataLabels(this.svg);\r\n        }\r\n\r\n        private renderTooltip(selection: D3.UpdateSelection): void {\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) =>\r\n                (<DotPlotDataGroup>tooltipEvent.data).tooltipInfo);\r\n        }\r\n\r\n        private calculateAxes(\r\n            viewportIn: IViewport,\r\n            textProperties: TextProperties,\r\n            scrollbarVisible: boolean): IAxisProperties {\r\n\r\n            let category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0\r\n                ? this.dataView.categorical.categories[0]\r\n                : {\r\n                    source: undefined,\r\n                    values: [valueFormatter.format(null)],\r\n                    identity: undefined,\r\n                };\r\n\r\n            let visualOptions: CalculateScaleAndDomainOptions = {\r\n                viewport: viewportIn,\r\n                margin: this.DefaultMargin,\r\n                forcedXDomain: this.dataView.categorical.categories[0].values,\r\n                forceMerge: false,\r\n                showCategoryAxisLabel: false,\r\n                showValueAxisLabel: false,\r\n                categoryAxisScaleType: this.scaleType,\r\n                valueAxisScaleType: null,\r\n                valueAxisDisplayUnits: 0,\r\n                categoryAxisDisplayUnits: 0,\r\n                trimOrdinalDataOnOverflow: false,\r\n            };\r\n\r\n            let width = viewportIn.width;\r\n            let axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);\r\n            axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\r\n                axes,\r\n                width,\r\n                TextMeasurementService.measureSvgTextWidth,\r\n                textProperties);\r\n\r\n            // If labels do not fit and we are not scrolling, try word breaking\r\n            axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\r\n                axes, this.DefaultMargin, width, TextMeasurementService.measureSvgTextWidth,\r\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\r\n                textProperties);\r\n\r\n            return axes;\r\n        }\r\n\r\n        private calculateAxesProperties(viewportIn: IViewport, options: CalculateScaleAndDomainOptions, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\r\n            let xAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: viewportIn.width,\r\n                dataDomain: options.forcedXDomain,\r\n                metaDataColumn: metaDataColumn,\r\n                formatString: valueFormatter.getFormatString(metaDataColumn, DotPlotProperties.general.formatString),\r\n                outerPadding: 0,\r\n                isScalar: false,\r\n                isVertical: false,\r\n                forcedTickCount: options.forcedTickCount,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: true,\r\n                getValueFn: (index, type) => index,\r\n                scaleType: options.categoryAxisScaleType,\r\n                axisDisplayUnits: options.categoryAxisDisplayUnits\r\n            });\r\n\r\n            xAxisProperties.axisLabel = \"New Label\";\r\n            return xAxisProperties;\r\n        }\r\n\r\n        private renderAxis(height: number, xAxisProperties: IAxisProperties, data: DotPlotDataView, duration: number): void {\r\n            this.xAxis.attr(\r\n                {\r\n                    transform: SVGUtil.translate(0, height)\r\n                });\r\n\r\n            let xAxis = xAxisProperties.axis;\r\n            xAxis.orient('bottom');\r\n\r\n            this.xAxis\r\n                .transition()\r\n                .duration(duration)\r\n                .call(xAxis);\r\n\r\n            let xAxisTicks: D3.Selection = this.xAxis.selectAll('.tick text');\r\n            xAxisTicks.data(xAxisProperties.values);\r\n            xAxisTicks.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                xAxisProperties.xLabelMaxWidth,\r\n                TextMeasurementService.svgEllipsis);\r\n\r\n            xAxisTicks.append('title').text((d) => d);\r\n        }\r\n    }\r\n\r\n    export interface DotplotBehaviorOptions {\r\n        columns: D3.Selection;\r\n        clearCatcher: D3.Selection;\r\n        interactivityService: IInteractivityService;\r\n    }\r\n\r\n    export class DotplotBehavior implements IInteractiveBehavior {\r\n        private columns: D3.Selection;\r\n        private clearCatcher: D3.Selection;\r\n        private interactivityService: IInteractivityService;\r\n\r\n        public bindEvents(options: DotplotBehaviorOptions, selectionHandler: ISelectionHandler): void {\r\n            this.columns = options.columns;\r\n            this.clearCatcher = options.clearCatcher;\r\n            this.interactivityService = options.interactivityService;\r\n\r\n            this.columns.on('click', (d: SelectableDataPoint, i: number) => {\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n            });\r\n\r\n            options.clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            let hasHighlights = this.interactivityService.hasSelection();\r\n            this.columns.style(\"fill-opacity\", (d: DotPlotDataGroup) => ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights));\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/dotPlot/visual/dotPlot.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/*\r\n *  This file is based on or incorporates material from the projects listed below (Third Party IP). \r\n *  The original copyright notice and the license under which Microsoft received such Third Party IP, \r\n *  are set forth below. Such licenses and notices are provided for informational purposes only. \r\n *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product. \r\n *  Microsoft reserves all other rights not expressly granted under this agreement, whether by \r\n *  implication, estoppel or otherwise.\r\n *  \r\n *  d3 Force Layout\r\n *  Copyright (c) 2010-2015, Michael Bostock\r\n *  All rights reserved.\r\n *  \r\n *  Redistribution and use in source and binary forms, with or without\r\n *  modification, are permitted provided that the following conditions are met:\r\n *  \r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *    list of conditions and the following disclaimer.\r\n *  \r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *  \r\n *  * The name Michael Bostock may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *  \r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\r\n *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\r\n *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\r\n *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n\r\n    module linkColorType {\r\n        export var byWeight: string = 'ByWeight';\r\n        export var byLinkType: string = 'ByLinkType';\r\n        export var interactive: string = 'Interactive';\r\n\r\n        export var type: IEnumType = createEnumType([\r\n            { value: byWeight, displayName: 'ByWeight' },\r\n            { value: byLinkType, displayName: 'ByLinkType' },\r\n            { value: interactive, displayName: 'Interactive' },\r\n        ]);\r\n    }\r\n\r\n    export interface ForceGraphOptions {\r\n        showDataLabels: boolean;\r\n        labelColor: string;\r\n        fontSize: number;\r\n        showArrow: boolean;\r\n        showLabel: boolean;\r\n        colorLink: string;\r\n        thickenLink: boolean;\r\n        displayImage: boolean;\r\n        defaultImage: string;\r\n        imageUrl: string;\r\n        imageExt: string;\r\n        nameMaxLength: number;\r\n        highlightReachableLinks: boolean;\r\n        charge: number;\r\n        defaultLinkColor: string;\r\n        defaultLinkHighlightColor: string;\r\n        defaultLinkThickness: string;\r\n    }\r\n\r\n    export var forceProps = {\r\n        general: {\r\n            formatString: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"general\",\r\n                propertyName: \"formatString\"\r\n            }\r\n        },\r\n        labels: {\r\n            show: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"show\"\r\n            },\r\n            color: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"color\"\r\n            },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{\r\n                objectName: \"labels\",\r\n                propertyName: \"fontSize\"\r\n            }\r\n        },\r\n        links: {\r\n            showArrow: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'showArrow' },\r\n            showLabel: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'showLabel' },\r\n            colorLink: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'colorLink' },\r\n            thickenLink: <DataViewObjectPropertyIdentifier>{ objectName: 'links', propertyName: 'thickenLink' },\r\n        },\r\n        nodes: {\r\n            displayImage: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'displayImage' },\r\n            defaultImage: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'defaultImage' },\r\n            imageUrl: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'imageUrl' },\r\n            imageExt: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'imageExt' },\r\n            nameMaxLength: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'nameMaxLength' },\r\n            highlightReachableLinks: <DataViewObjectPropertyIdentifier>{ objectName: 'nodes', propertyName: 'highlightReachableLinks' },\r\n        },\r\n        size: {\r\n            charge: <DataViewObjectPropertyIdentifier>{ objectName: 'size', propertyName: 'charge' },\r\n        }\r\n    };\r\n\r\n    export interface ForceGraphData {\r\n        nodes: {};\r\n        links: any[];\r\n        minFiles: number;\r\n        maxFiles: number;\r\n        linkedByName: {};\r\n        linkTypes: {};\r\n    }\r\n\r\n    export class ForceGraph implements IVisual {\r\n        public static VisualClassName = 'forceGraph';\r\n        private root: D3.Selection;\r\n        private paths: D3.Selection;\r\n        private nodes: D3.Selection;\r\n        private forceLayout: D3.Layout.ForceLayout;\r\n        private dataView: DataView;\r\n        private colors: IDataColorPalette;\r\n        private options: ForceGraphOptions;\r\n        private data: ForceGraphData;\r\n\r\n        private marginValue: IMargin;\r\n        private get margin(): IMargin {\r\n            return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };\r\n        }\r\n        private set margin(value: IMargin) {\r\n            this.marginValue = $.extend({}, value);\r\n            this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\r\n        }\r\n\r\n        private viewportValue: IViewport;\r\n        private get viewport(): IViewport {\r\n            return this.viewportValue || { width: 0, height: 0 };\r\n        }\r\n        private set viewport(value: IViewport) {\r\n            this.viewportValue = $.extend({}, value);\r\n            this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);\r\n        }\r\n\r\n        private viewportInValue: IViewport;\r\n        private get viewportIn(): IViewport {\r\n            return this.viewportInValue || this.viewport;\r\n        }\r\n\r\n        private static substractMargin(viewport: IViewport, margin: IMargin): IViewport {\r\n            return {\r\n                width: Math.max(viewport.width - (margin.left + margin.right), 0),\r\n                height: Math.max(viewport.height - (margin.top + margin.bottom), 0)\r\n            };\r\n        }\r\n\r\n        private scale1to10(d) {\r\n            let scale = d3.scale.linear().domain([this.data.minFiles, this.data.maxFiles]).rangeRound([1, 10]).clamp(true);\r\n            return scale(d);\r\n        }\r\n\r\n        private getLinkColor(d): string {\r\n            switch (this.options.colorLink) {\r\n                case linkColorType.byWeight:\r\n                    return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;\r\n                case linkColorType.byLinkType:\r\n                    return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;\r\n            };\r\n            return this.options.defaultLinkColor;\r\n        }\r\n\r\n        private getDefaultOptions(): ForceGraphOptions {\r\n            return {\r\n                showDataLabels: true,\r\n                labelColor: dataLabelUtils.defaultLabelColor,\r\n                fontSize: dataLabelUtils.DefaultFontSizeInPt,\r\n                showArrow: false,\r\n                showLabel: false,\r\n                colorLink: linkColorType.interactive,\r\n                thickenLink: true,\r\n                displayImage: false,\r\n                defaultImage: \"Home\",\r\n                imageUrl: \"\",\r\n                imageExt: \".png\",\r\n                nameMaxLength: 10,\r\n                highlightReachableLinks: false,\r\n                charge: -15,\r\n                defaultLinkColor: \"#bbb\",\r\n                defaultLinkHighlightColor: \"#f00\",\r\n                defaultLinkThickness: \"1.5px\",\r\n            };\r\n        }\r\n\r\n        private updateOptions(objects: DataViewObjects) {\r\n            this.options.showDataLabels = DataViewObjects.getValue(objects, forceProps.labels.show, this.options.showDataLabels);\r\n            this.options.labelColor = DataViewObjects.getFillColor(objects, forceProps.labels.color, this.options.labelColor);\r\n            this.options.fontSize = DataViewObjects.getValue(objects, forceProps.labels.fontSize, this.options.fontSize);\r\n            this.options.showArrow = DataViewObjects.getValue(objects, forceProps.links.showArrow, this.options.showArrow);\r\n            this.options.showLabel = DataViewObjects.getValue(objects, forceProps.links.showLabel, this.options.showLabel);\r\n            this.options.colorLink = DataViewObjects.getValue(objects, forceProps.links.colorLink, this.options.colorLink);\r\n            this.options.thickenLink = DataViewObjects.getValue(objects, forceProps.links.thickenLink, this.options.thickenLink);\r\n            this.options.displayImage = DataViewObjects.getValue(objects, forceProps.nodes.displayImage, this.options.displayImage);\r\n            this.options.defaultImage = DataViewObjects.getValue(objects, forceProps.nodes.defaultImage, this.options.defaultImage);\r\n            this.options.imageUrl = DataViewObjects.getValue(objects, forceProps.nodes.imageUrl, this.options.imageUrl);\r\n            this.options.imageExt = DataViewObjects.getValue(objects, forceProps.nodes.imageExt, this.options.imageExt);\r\n            this.options.nameMaxLength = DataViewObjects.getValue(objects, forceProps.nodes.nameMaxLength, this.options.nameMaxLength);\r\n            this.options.highlightReachableLinks = DataViewObjects.getValue(objects, forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks);\r\n            this.options.charge = DataViewObjects.getValue(objects, forceProps.size.charge, this.options.charge);\r\n            if (this.options.charge >= 0 || this.options.charge < -100) this.options.charge = this.getDefaultOptions().charge;\r\n        }\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Source',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Source',\r\n                },\r\n                {\r\n                    name: 'Target',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Target',\r\n                },\r\n                {\r\n                    name: 'Weight',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Weight',\r\n                },\r\n                {\r\n                    name: 'LinkType',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'LinkType',\r\n                    description: 'Links can be colored by link types',\r\n                },\r\n                {\r\n                    name: 'SourceType',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'SourceType',\r\n                    description: 'Source type represents the image name for source entities',\r\n                },\r\n                {\r\n                    name: 'TargetType',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'TargetType',\r\n                    description: 'Target type represents the image name for target entities',\r\n                },\r\n            ],\r\n            objects: {\r\n                general: {\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        }\r\n                    }\r\n                },\r\n                labels: {\r\n                    displayName: 'Data labels',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'Show',\r\n                            type: { bool: true }\r\n                        },\r\n                        color: {\r\n                            displayName: 'Fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                links: {\r\n                    displayName: 'Links',\r\n                    properties: {\r\n                        showArrow: {\r\n                            type: { bool: true },\r\n                            displayName: 'Arrow'\r\n                        },\r\n                        showLabel: {\r\n                            type: { bool: true },\r\n                            displayName: 'Label',\r\n                            description: 'Displays weight on links',\r\n                        },\r\n                        colorLink: {\r\n                            type: { enumeration: linkColorType.type },\r\n                            displayName: 'Color',\r\n                        },\r\n                        thickenLink: {\r\n                            type: { bool: true },\r\n                            displayName: 'Thickness',\r\n                            description: 'Thickenss of links represents weight',\r\n                        },\r\n                    }\r\n                },\r\n                nodes: {\r\n                    displayName: 'Nodes',\r\n                    properties: {\r\n                        displayImage: {\r\n                            type: { bool: true },\r\n                            displayName: 'Image',\r\n                            description: 'Images are loaded from image url + source or target type + image extension',\r\n                        },\r\n                        defaultImage: {\r\n                            type: { text: true },\r\n                            displayName: 'Default image'\r\n                        },\r\n                        imageUrl: {\r\n                            type: { text: true },\r\n                            displayName: 'Image url'\r\n                        },\r\n                        imageExt: {\r\n                            type: { text: true },\r\n                            displayName: 'Image extension'\r\n                        },\r\n                        nameMaxLength: {\r\n                            type: { numeric: true },\r\n                            displayName: 'Max name length',\r\n                            description: 'Max length of the name of entities displayed',\r\n                        },\r\n                        highlightReachableLinks: {\r\n                            type: { bool: true },\r\n                            displayName: 'Highlight all reachable links',\r\n                            description: \"In interactive mode, whether a node's all reachable links will be highlighted\",\r\n                        },\r\n                    }\r\n                },\r\n                size: {\r\n                    displayName: 'Size',\r\n                    properties: {\r\n                        charge: {\r\n                            type: { numeric: true },\r\n                            displayName: 'Charge',\r\n                            description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',\r\n                        },\r\n                    }\r\n                },\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Source': { max: 1 }, 'Target': { max: 1 }, 'Weight': { max: 1 }, 'LinkType': { max: 1 }, 'SourceType': { max: 1 }, 'TargetType': { max: 1 } },\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Source' },\r\n                        dataReductionAlgorithm: { top: {} }\r\n                    },\r\n                    values: {\r\n                        select: [\r\n                            { bind: { to: 'Target' } },\r\n                            { bind: { to: 'Weight' } },\r\n                            { bind: { to: 'LinkType' } },\r\n                            { bind: { to: 'SourceType' } },\r\n                            { bind: { to: 'TargetType' } },\r\n                        ],\r\n                    },\r\n                    rowCount: { preferred: { min: 1 } }\r\n                },\r\n            }],\r\n            suppressDefaultTitle: true,\r\n        };\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration = new ObjectEnumerationBuilder();\r\n\r\n            switch (options.objectName) {\r\n                case 'labels':\r\n                    this.enumerateLabels(enumeration);\r\n                    break;\r\n                case 'links':\r\n                    this.enumerateLinks(enumeration);\r\n                    break;\r\n                case 'nodes':\r\n                    this.enumerateNodes(enumeration);\r\n                    break;\r\n                case 'size':\r\n                    this.enumerateSize(enumeration);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n\r\n            return enumeration.complete();\r\n        }\r\n\r\n        private enumerateLabels(enumeration: ObjectEnumerationBuilder): void {\r\n            let labels: VisualObjectInstance,\r\n                options: ForceGraphOptions;\r\n\r\n            if (!this.options || !this.options)\r\n                return;\r\n\r\n            options = this.options;\r\n\r\n            labels = {\r\n                objectName: 'labels',\r\n                displayName: 'Labels',\r\n                selector: null,\r\n                properties: {\r\n                    show: options.showDataLabels,\r\n                    fontSize: options.fontSize,\r\n                    color: options.labelColor\r\n                }\r\n            };\r\n\r\n            enumeration.pushInstance(labels);\r\n        }\r\n\r\n        private enumerateLinks(enumeration: ObjectEnumerationBuilder): void {\r\n            let links: VisualObjectInstance,\r\n                options: ForceGraphOptions;\r\n\r\n            if (!this.options)\r\n                return;\r\n\r\n            options = this.options;\r\n\r\n            links = {\r\n                objectName: 'links',\r\n                displayName: 'Links',\r\n                selector: null,\r\n                properties: {\r\n                    showArrow: options.showArrow,\r\n                    colorLink: options.colorLink,\r\n                    showLabel: options.showLabel,\r\n                    thickenLink: options.thickenLink,\r\n                }\r\n            };\r\n\r\n            enumeration.pushInstance(links);\r\n        }\r\n\r\n        private enumerateNodes(enumeration: ObjectEnumerationBuilder): void {\r\n            let nodes: VisualObjectInstance,\r\n                options: ForceGraphOptions;\r\n\r\n            if (!this.options)\r\n                return;\r\n\r\n            options = this.options;\r\n\r\n            nodes = {\r\n                objectName: 'nodes',\r\n                displayName: 'Nodes',\r\n                selector: null,\r\n                properties: {\r\n                    displayImage: options.displayImage,\r\n                    defaultImage: options.defaultImage,\r\n                    imageUrl: options.imageUrl,\r\n                    imageExt: options.imageExt,\r\n                    nameMaxLength: options.nameMaxLength,\r\n                    highlightReachableLinks: options.highlightReachableLinks,\r\n                }\r\n            };\r\n\r\n            enumeration.pushInstance(nodes);\r\n        }\r\n\r\n        private enumerateSize(enumeration: ObjectEnumerationBuilder): void {\r\n            let size: VisualObjectInstance,\r\n                options: ForceGraphOptions;\r\n\r\n            if (!this.options)\r\n                return;\r\n\r\n            options = this.options;\r\n\r\n            size = {\r\n                objectName: 'size',\r\n                displayName: 'Size',\r\n                selector: null,\r\n                properties: {\r\n                    charge: options.charge,\r\n                }\r\n            };\r\n\r\n            enumeration.pushInstance(size);\r\n        }\r\n\r\n        public static converter(dataView: DataView, colors: IDataColorPalette): ForceGraphData {\r\n            let categorical: DataViewCategorical = dataView.categorical;\r\n            let nodes = {};\r\n            let minFiles = Number.MAX_VALUE;\r\n            let maxFiles = 0;\r\n            let linkedByName = {};\r\n            let links = [];\r\n            let linkDataPoints = {};\r\n            let linkTypeCount = 0;\r\n            let sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1;\r\n            let rows;\r\n            let tooltipInfo: TooltipDataItem[] = [];\r\n            let formatStringProp = forceProps.general.formatString;\r\n\r\n            if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) {\r\n                let metadataColumns = dataView.metadata.columns;\r\n                for (let i = 0; i < metadataColumns.length; i++) {\r\n                    let col = metadataColumns[i];\r\n                    if (col.roles) {\r\n                        if (col.roles['Source'])\r\n                            sourceCol = i;\r\n                        else if (col.roles['Target'])\r\n                            targetCol = i;\r\n                        else if (col.roles['Weight'])\r\n                            weightCol = i;\r\n                        else if (col.roles['LinkType'])\r\n                            linkTypeCol = i;\r\n                        else if (col.roles['SourceType'])\r\n                            sourceTypeCol = i;\r\n                        else if (col.roles['TargetType'])\r\n                            targetTypeCol = i;\r\n                    }\r\n                }\r\n            }\r\n            if (dataView && dataView.table) {\r\n                rows = dataView.table.rows;\r\n            }\r\n            if (sourceCol < 0 || targetCol < 0)\r\n                return <ForceGraphData>{\r\n                    nodes: {},\r\n                    links: [],\r\n                    minFiles: 0,\r\n                    maxFiles: 0,\r\n                    linkedByName: {},\r\n                    linkTypes: {},\r\n                };\r\n\r\n            let categorySourceFormatString = valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp);\r\n            let categoryTargetFormatString = valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp);\r\n            let weightFormatString = valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, true);\r\n\r\n            rows.forEach(function(item) {\r\n                linkedByName[item[sourceCol] + \",\" + item[targetCol]] = 1;\r\n                let source = nodes[item[sourceCol]] ||\r\n                    (nodes[item[sourceCol]] = { name: item[sourceCol], image: sourceTypeCol > 0 ? item[sourceTypeCol] : '', adj: {} });\r\n                let target = nodes[item[targetCol]] ||\r\n                    (nodes[item[targetCol]] = { name: item[targetCol], image: targetTypeCol > 0 ? item[targetTypeCol] : '', adj: {} });\r\n                source.adj[target.name] = 1;\r\n                target.adj[source.name] = 1;\r\n\r\n                tooltipInfo = [{\r\n                    displayName: dataView.metadata.columns[0].displayName,\r\n                    value: valueFormatter.format(source.name, categorySourceFormatString)\r\n                }, {\r\n                        displayName: dataView.metadata.columns[1].displayName,\r\n                        value: valueFormatter.format(target.name, categoryTargetFormatString)\r\n                    }];\r\n\r\n                if (weightCol > 0)\r\n                    tooltipInfo.push({\r\n                        displayName: dataView.metadata.columns[2].displayName,\r\n                        value: valueFormatter.format(item[weightCol], weightFormatString)\r\n                    });\r\n\r\n                let link = {\r\n                    source: source,\r\n                    target: target,\r\n                    filecount: weightCol > 0 ? item[weightCol] : 0,\r\n                    type: linkTypeCol > 0 ? item[linkTypeCol] : '',\r\n                    tooltipInfo: tooltipInfo,\r\n                };\r\n\r\n                if (linkTypeCol > 0) {\r\n                    if (!linkDataPoints[item[linkTypeCol]]) {\r\n                        linkDataPoints[item[linkTypeCol]] = {\r\n                            label: item[linkTypeCol],\r\n                            color: colors.getColorByIndex(linkTypeCount++).value,\r\n                        };\r\n                    };\r\n                };\r\n                if (link.filecount < minFiles) { minFiles = link.filecount; };\r\n                if (link.filecount > maxFiles) { maxFiles = link.filecount; };\r\n                links.push(link);\r\n            });\r\n\r\n            return {\r\n                nodes: nodes,\r\n                links: links,\r\n                minFiles: minFiles,\r\n                maxFiles: maxFiles,\r\n                linkedByName: linkedByName,\r\n                linkTypes: linkDataPoints,\r\n            };\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            this.root = d3.select(options.element.get(0));\r\n            this.forceLayout = d3.layout.force();\r\n            this.colors = options.style.colorPalette.dataColors;\r\n            this.options = this.getDefaultOptions();\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options.dataViews || (options.dataViews.length < 1)) return;\r\n            this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);\r\n            if (!this.data) return;\r\n            if (options.dataViews[0].metadata && options.dataViews[0].metadata.objects)\r\n                this.updateOptions(options.dataViews[0].metadata.objects);\r\n            this.viewport = options.viewport;\r\n            let k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));\r\n\r\n            this.root.selectAll(\"svg\").remove();\r\n\r\n            let svg = this.root\r\n                .append(\"svg\")\r\n                .attr(\"width\", this.viewport.width)\r\n                .attr(\"height\", this.viewport.height)\r\n                .classed(ForceGraph.VisualClassName, true);\r\n\r\n            this.forceLayout\r\n                .gravity(100 * k)\r\n                .links(this.data.links)\r\n                .size([this.viewport.width, this.viewport.height])\r\n                .linkDistance(100)\r\n                .charge(this.options.charge / k)\r\n                .on(\"tick\", this.tick());\r\n            this.updateNodes();\r\n            this.forceLayout.start();\r\n\r\n            // uncomment if we don't need the marker-end workaround\r\n            //if (this.options.showArrow) {\r\n            // build the arrow.\r\n            //function marker(d, i) {\r\n            //    let val = \"mid_\" + i;\r\n            //    svg.append(\"defs\").selectAll(\"marker\")\r\n            //        .data([val])      // Different link/path types can be defined here\r\n            //        .enter().append(\"marker\")    // This section adds in the arrows\r\n            //        .attr(\"id\", String)\r\n            //        .attr(\"viewBox\", \"0 -5 10 10\")\r\n            //        .attr(\"refX\", 10)\r\n            //        .attr(\"refY\", 0)\r\n            //        .attr(\"markerWidth\", 6)\r\n            //        .attr(\"markerHeight\", 6)\r\n            //        .attr(\"orient\", \"auto\")\r\n            //        .attr(\"markerUnits\", \"userSpaceOnUse\")\r\n            //        .append(\"path\")\r\n            //        .attr(\"d\", \"M0,-5L10,0L0,5\")\r\n            //    //below works if no marker-end workaround needed\r\n            //        .style(\"fill\", d => this.getLinkColor(d))\r\n            //    ;\r\n            //    return \"url(#\" + val + \")\";\r\n            //}\r\n            //}\r\n            this.paths = svg.selectAll(\".link\")\r\n                .data(this.forceLayout.links())\r\n                .enter().append(\"path\")\r\n                .attr(\"class\", \"link\")\r\n                .attr(\"id\", (d, i) => \"linkid_\" + i)\r\n                // uncomment if we don't need the marker-end workaround\r\n                //.attr(\"marker-end\", function (d, i) { return marker(d, i); })\r\n                .attr(\"stroke-width\", d => this.options.thickenLink ? this.scale1to10(d.filecount) : this.options.defaultLinkThickness)\r\n                .style(\"stroke\", d => this.getLinkColor(d))\r\n                // no need for \"fill\" if we don't need the marker-end workaround\r\n                .style(\"fill\", d => { if (this.options.showArrow) return this.getLinkColor(d); })\r\n                .on(\"mouseover\", this.fadePath(.3, this.options.defaultLinkHighlightColor))\r\n                .on(\"mouseout\", this.fadePath(1, this.options.defaultLinkColor));\r\n\r\n            TooltipManager.addTooltip(this.paths, (tooltipEvent: TooltipEvent) => {\r\n                return tooltipEvent.data.tooltipInfo;\r\n            });\r\n\r\n            if (this.options.showLabel) {\r\n                svg.selectAll(\".linklabelholder\")\r\n                    .data(this.forceLayout.links())\r\n                    .enter().append(\"g\")\r\n                    .attr(\"class\", \"linklabelholder\")\r\n                    .append(\"text\")\r\n                    .attr(\"class\", \"linklabel\")\r\n                    .attr(\"y\", \"-12\")\r\n                    .attr(\"text-anchor\", \"middle\")\r\n                    .style(\"fill\", \"#000\")\r\n                    .append(\"textPath\")\r\n                    .attr(\"xlink:href\", (d, i) => \"#linkid_\" + i)\r\n                    .attr(\"startOffset\", \"25%\") //use \"50%\" if we don't need the marker-end workaround\r\n                    .text(d => this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount);\r\n            }\r\n\r\n            // define the nodes\r\n            this.nodes = svg.selectAll(\".node\")\r\n                .data(this.forceLayout.nodes())\r\n                .enter().append(\"g\")\r\n                .attr(\"class\", \"node\")\r\n                .call(this.forceLayout.drag)\r\n                .on(\"mouseover\", this.fadeNode(.3, this.options.defaultLinkHighlightColor))\r\n                .on(\"mouseout\", this.fadeNode(1, this.options.defaultLinkColor))\r\n                .on(\"mousedown\", () => d3.event.stopPropagation())\r\n                .attr(\"drag-resize-disabled\", true);\r\n\r\n            // add the nodes\r\n            if (this.options.displayImage) {\r\n                this.nodes.append(\"image\")\r\n                    .attr(\"xlink:href\", d =>\r\n                        d.image && d.image !== '' ?\r\n                            this.options.imageUrl + d.image + this.options.imageExt :\r\n                            (\r\n                                this.options.defaultImage && this.options.defaultImage !== '' ?\r\n                                    this.options.imageUrl + this.options.defaultImage + this.options.imageExt :\r\n                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII='\r\n                            )\r\n                    )\r\n                    .attr(\"x\", \"-12px\")\r\n                    .attr(\"y\", \"-12px\")\r\n                    .attr(\"width\", \"24px\")\r\n                    .attr(\"height\", \"24px\");\r\n            } else {\r\n                this.nodes.append(\"circle\")\r\n                    .attr(\"r\", d => d.weight < 5 ? 5 : d.weight);\r\n            }\r\n\r\n            // add the text\r\n            if (this.options.showDataLabels) {\r\n                this.nodes.append(\"text\")\r\n                    .attr({\r\n                        x: 12,\r\n                        dy: \".35em\"\r\n                    })\r\n                    .style({\r\n                        fill: this.options.labelColor,\r\n                        'font-size': PixelConverter.fromPoint(this.options.fontSize)\r\n                    })\r\n                    .text(d => d.name ? (d.name.length > this.options.nameMaxLength ? d.name.substr(0, this.options.nameMaxLength) : d.name) : '');\r\n            }\r\n        }\r\n\r\n        private updateNodes() {\r\n            let oldNodes = this.forceLayout.nodes();\r\n            this.forceLayout.nodes(d3.values(this.data.nodes));\r\n            this.forceLayout.nodes().forEach((node, i) => {\r\n                if (!oldNodes[i]) {\r\n                    return;\r\n                }\r\n                node.x = oldNodes[i].x;\r\n                node.y = oldNodes[i].y;\r\n                node.px = oldNodes[i].px;\r\n                node.py = oldNodes[i].py;\r\n                node.weight = oldNodes[i].weight;\r\n            });\r\n        }\r\n\r\n        private tick() {\r\n            let viewport = this.viewportIn;\r\n            // limitX and limitY is necessary when you minimize the graph and then resize it to normal.\r\n            //\"width/height * 20\" seems enough to move nodes freely by force layout.\r\n            let maxWidth = viewport.width * 20;\r\n            let maxHeight = viewport.height * 20;\r\n            let limitX = x => Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));\r\n            let limitY = y => Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));\r\n            //use this if we don't need the marker-end workaround\r\n            //path.attr(\"d\", function (d) {\r\n            //    let dx = d.target.x - d.source.x,\r\n            //        dy = d.target.y - d.source.y,\r\n            //        dr = Math.sqrt(dx * dx + dy * dy);\r\n            //    // x and y distances from center to outside edge of target node\r\n            //    let offsetX = (dx * d.target.radius) / dr;\r\n            //    let offsetY = (dy * d.target.radius) / dr;\r\n            //    return \"M\" +\r\n            //        d.source.x + \",\" +\r\n            //        d.source.y + \"A\" +\r\n            //        dr + \",\" + dr + \" 0 0,1 \" +\r\n            //        (d.target.x - offsetX) + \",\" +\r\n            //        (d.target.y - offsetY);\r\n            //});\r\n\r\n            let getPath = this.options.showArrow ?\r\n                //this is for marker-end workaround, build the marker with the path\r\n                d => {\r\n                    d.source.x = limitX(d.source.x);\r\n                    d.source.y = limitY(d.source.y);\r\n                    d.target.x = limitX(d.target.x);\r\n                    d.target.y = limitY(d.target.y);\r\n                    let dx = d.target.x - d.source.x,\r\n                        dy = d.target.y - d.source.y,\r\n                        dr = Math.sqrt(dx * dx + dy * dy),\r\n                        theta = Math.atan2(dy, dx) + Math.PI / 7.85,\r\n                        d90 = Math.PI / 2,\r\n                        dtxs = d.target.x - 6 * Math.cos(theta),\r\n                        dtys = d.target.y - 6 * Math.sin(theta);\r\n                    return \"M\" +\r\n                        d.source.x + \",\" +\r\n                        d.source.y + \"A\" +\r\n                        dr + \",\" + dr + \" 0 0 1,\" +\r\n                        d.target.x + \",\" +\r\n                        d.target.y +\r\n                        \"A\" + dr + \",\" + dr + \" 0 0 0,\" + d.source.x + \",\" + d.source.y + \"M\" + dtxs + \",\" + dtys + \"l\" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"L\" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + \",\" + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + \"z\";\r\n                } :\r\n                d => {\r\n                    d.source.x = limitX(d.source.x);\r\n                    d.source.y = limitY(d.source.y);\r\n                    d.target.x = limitX(d.target.x);\r\n                    d.target.y = limitY(d.target.y);\r\n                    let dx = d.target.x - d.source.x,\r\n                        dy = d.target.y - d.source.y,\r\n                        dr = Math.sqrt(dx * dx + dy * dy);\r\n                    return \"M\" +\r\n                        d.source.x + \",\" +\r\n                        d.source.y + \"A\" +\r\n                        dr + \",\" + dr + \" 0 0,1 \" +\r\n                        d.target.x + \",\" +\r\n                        d.target.y;\r\n                };\r\n\r\n            return () => {\r\n                this.paths.each(function() { this.parentNode.insertBefore(this, this); });\r\n                this.paths.attr(\"d\", getPath);\r\n                this.nodes.attr(\"transform\", d => \"translate(\" + limitX(d.x) + \",\" + limitY(d.y) + \")\");\r\n            };\r\n        }\r\n\r\n        private fadePath(opacity: number, highlight: string) {\r\n            if (this.options.colorLink !== linkColorType.interactive) return;\r\n            return d => {\r\n                this.paths.style(\"stroke-opacity\", o => o.source === d.source && o.target === d.target ? 1 : opacity);\r\n                this.paths.style(\"stroke\", o => o.source === d.source && o.target === d.target ? highlight : this.options.defaultLinkColor);\r\n            };\r\n        }\r\n\r\n        private isReachable(a, b): boolean {\r\n            if (a.name === b.name) return true;\r\n            if (this.data.linkedByName[a.name + \",\" + b.name]) return true;\r\n            let visited = {};\r\n            for (let name in this.data.nodes) {\r\n                visited[name] = false;\r\n            };\r\n            visited[a.name] = true;\r\n\r\n            let stack = [];\r\n            stack.push(a.name);\r\n            while (stack.length > 0) {\r\n                let cur = stack.pop();\r\n                let node = this.data.nodes[cur];\r\n                for (let nb in node.adj) {\r\n                    if (nb === b.name) return true;\r\n\r\n                    if (!visited[nb]) {\r\n                        visited[nb] = true;\r\n                        stack.push(nb);\r\n                    }\r\n                }\r\n            };\r\n            return false;\r\n        }\r\n\r\n        private fadeNode(opacity: number, highlight: string) {\r\n            if (this.options.colorLink !== linkColorType.interactive) return;\r\n            let isConnected = (a, b) => this.data.linkedByName[a.name + \",\" + b.name] || this.data.linkedByName[b.name + \",\" + a.name] || a.name === b.name;\r\n\r\n            return d => {\r\n                let that = this;\r\n                this.nodes.style(\"stroke-opacity\", function(o) {\r\n                    let thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;\r\n                    this.setAttribute('fill-opacity', thisOpacity);\r\n                    return thisOpacity;\r\n                });\r\n\r\n                this.paths.style(\"stroke-opacity\", o =>\r\n                    (this.options.highlightReachableLinks ? this.isReachable(d, o.source) :\r\n                        (o.source === d || o.target === d)) ? 1 : opacity);\r\n                this.paths.style(\"stroke\", o =>\r\n                    (this.options.highlightReachableLinks ? this.isReachable(d, o.source) :\r\n                        (o.source === d || o.target === d)) ? highlight : this.options.defaultLinkColor);\r\n            };\r\n        }\r\n\r\n        public destroy(): void {\r\n            this.root = null;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/forceGraph/visual/forceGraph.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import SelectionManager = utility.SelectionManager;\r\n    import PixelConverter = jsCommon.PixelConverter;\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    const PercentFormat: string = \"0.00 %;-0.00 %;0.00 %\";\r\n    const MillisecondsInADay: number = 86400000;\r\n    const MillisecondsInWeek: number = 604800000;\r\n    const MillisecondsInAMonth: number = 2629746000;\r\n    const MillisecondsInAYear: number = 31556952000;\r\n    export const DefaultDateType: string = \"Week\";\r\n    const ChartLineHeight: number = 40;\r\n    const PaddingTasks: number = 5;\r\n\r\n    export module dateTypeSelector {\r\n        export const day: string = 'Day';\r\n        export const week: string = 'Week';\r\n        export const month: string = 'Month';\r\n        export const year: string = 'Year';\r\n\r\n        export const type: IEnumType = createEnumType([\r\n            { value: day, displayName: 'Day' },\r\n            { value: week, displayName: 'Week' },\r\n            { value: month, displayName: 'Month' },\r\n            { value: year, displayName: 'Year' }\r\n        ]);\r\n    }\r\n    export interface Task extends SelectableDataPoint {\r\n        id: number;\r\n        name: string;\r\n        start: Date;\r\n        duration: number;\r\n        completion: number;\r\n        resource: string;\r\n        end: Date;\r\n        taskType: string;\r\n        description: string;\r\n        color: string;\r\n        tooltipInfo: TooltipDataItem[];\r\n    }\r\n\r\n    export interface GanttChartFormatters {\r\n        startDateFormatter: IValueFormatter;\r\n        completionFormatter: IValueFormatter;\r\n        durationFormatter: IValueFormatter;\r\n    }\r\n\r\n    export interface GanttChartData {\r\n        legendData: LegendData;\r\n        series: GanttSeries[];\r\n        showLegend: boolean;\r\n    }\r\n\r\n    export interface GanttViewModel {\r\n        taskLabelsShow: boolean;\r\n        taskLabelsColor: string;\r\n        taskLabelsFontSize: number;\r\n        taskLabelsWidth: number;\r\n        taskProgressColor: string;\r\n        taskResourceShow: boolean;\r\n        taskResourceColor: string;\r\n        taskResourceFontSize: number;\r\n        legendData: LegendData;\r\n        taskTypes: TaskTypes;\r\n        dateType: string;\r\n    }\r\n\r\n    export interface GanttDataPoint extends SelectableDataPoint {\r\n        color: string;\r\n        value: any;\r\n    }\r\n\r\n    export interface GanttSeries extends SelectableDataPoint {\r\n        tasks: Task[];\r\n        fill: string;\r\n        name: string;\r\n    }\r\n\r\n    export interface TaskTypes { /*TODO: change to more proper name*/\r\n        types: string[];\r\n        typeName: string;\r\n    };\r\n\r\n    interface Line {\r\n        x1: number;\r\n        y1: number;\r\n        x2: number;\r\n        y2: number;\r\n        tooltipInfo: TooltipDataItem[];\r\n    }\r\n\r\n    export const GanttChartProps = {\r\n        legend: {\r\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'show' },\r\n            position: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'position' },\r\n            showTitle: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'showTitle' },\r\n            titleText: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'titleText' },\r\n            labelColor: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'labelColor' },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'legend', propertyName: 'fontSize' },\r\n        },\r\n        taskCompletion: {\r\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskCompletion', propertyName: 'fill' },\r\n        },\r\n        dataPoint: {\r\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'dataPoint', propertyName: 'fill' },\r\n        },\r\n        taskLabels: {\r\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'show' },\r\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'fill' },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'fontSize' },\r\n            width: <DataViewObjectPropertyIdentifier>{ objectName: 'taskLabels', propertyName: 'width' },\r\n        },\r\n        taskResource: {\r\n            show: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'show' },\r\n            fill: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'fill' },\r\n            fontSize: <DataViewObjectPropertyIdentifier>{ objectName: 'taskResource', propertyName: 'fontSize' },\r\n        },\r\n        ganttDateType:\r\n        {\r\n            type: <DataViewObjectPropertyIdentifier>{ objectName: 'ganttDateType', propertyName: 'type' },\r\n        }\r\n    };\r\n\r\n    module Selectors {\r\n\r\n        import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n        import CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n\r\n        export const ClassName: ClassAndSelector = CreateClassAndSelector(\"gantt\");\r\n        export const Chart: ClassAndSelector = CreateClassAndSelector(\"chart\");\r\n        export const ChartLine: ClassAndSelector = CreateClassAndSelector(\"chart-line\");\r\n        export const Body: ClassAndSelector = CreateClassAndSelector(\"gantt-body\");\r\n        export const AxisGroup: ClassAndSelector = CreateClassAndSelector(\"axis\");\r\n        export const Domain: ClassAndSelector = CreateClassAndSelector(\"domain\");\r\n        export const AxisTick: ClassAndSelector = CreateClassAndSelector(\"tick\");\r\n\r\n        export const Tasks: ClassAndSelector = CreateClassAndSelector(\"tasks\");\r\n        export const SingleTask: ClassAndSelector = CreateClassAndSelector(\"task\");\r\n        export const TaskRect: ClassAndSelector = CreateClassAndSelector(\"task-rect\");\r\n        export const TaskProgress: ClassAndSelector = CreateClassAndSelector(\"task-progress\");\r\n        export const TaskResource: ClassAndSelector = CreateClassAndSelector(\"task-resource\");\r\n        export const SingleMilestone: ClassAndSelector = CreateClassAndSelector(\"milestone\");\r\n\r\n        export const TaskLabels: ClassAndSelector = CreateClassAndSelector(\"task-labels\");\r\n        export const TaskLines: ClassAndSelector = CreateClassAndSelector(\"task-lines\");\r\n        export const SingleTaskLine: ClassAndSelector = CreateClassAndSelector(\"task-line\");\r\n        export const Label: ClassAndSelector = CreateClassAndSelector(\"label\");\r\n        export const LegendItems: ClassAndSelector = CreateClassAndSelector(\"legendItem\");\r\n        export const LegendTitle: ClassAndSelector = CreateClassAndSelector(\"legendTitle\");\r\n    }\r\n\r\n    export class Gantt implements IVisual {\r\n\r\n        private data: GanttChartData;\r\n        private dataView: DataView;\r\n        private viewport: IViewport;\r\n        private colors: IDataColorPalette;\r\n        private legend: ILegend;\r\n        private legendObjectProperties: DataViewObject;\r\n\r\n        private textProperties: TextProperties = {\r\n            fontFamily: 'wf_segoe-ui_normal',\r\n            fontSize: jsCommon.PixelConverter.toString(9),\r\n        };\r\n\r\n        private static DefaultValues = {\r\n            AxisTickSize: 6,\r\n            LabelFontSize: 9,\r\n            LegendFontSize: 8,\r\n            LegendLabelColor: \"#000000\",\r\n            MaxTaskOpacity: 1,\r\n            MinTaskOpacity: 0.4,\r\n            ProgressBarHeight: 4,\r\n            ProgressColor: \"#000000\",\r\n            ResourceFontSize: 9,\r\n            ResourceWidth: 100,\r\n            TaskColor: \"#00B099\",\r\n            TaskLabelColor: \"#000000\",\r\n            TaskLabelWidth: 110,\r\n            TaskLineWidth: 15,\r\n            TaskResourceColor: \"#000000\",\r\n            ganttFormatString: \"MMM dd\"\r\n        };\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: \"Legend\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: \"Legend\",\r\n                }, {\r\n                    name: \"Task\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: \"Task\"\r\n                }, {\r\n                    name: \"StartDate\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: \"Start Date\",\r\n                }, {\r\n                    name: \"Duration\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: \"Duration\",\r\n                    requiredTypes: [{ numeric: true }, { integer: true }]\r\n                }, {\r\n                    name: \"Completion\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: \"% Completion\",\r\n                    requiredTypes: [{ numeric: true }, { integer: true }]\r\n                }, {\r\n                    name: \"Resource\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: \"Resource\"\r\n                }\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    {\r\n                        \"Legend\": { min: 0, max: 1 },\r\n                        \"Task\": { min: 1, max: 1 },\r\n                        \"StartDate\": { min: 0, max: 0 },\r\n                        \"Duration\": { min: 0, max: 0 },\r\n                        \"Completion\": { min: 0, max: 0 },\r\n                        \"Resource\": { min: 0, max: 0 }\r\n                    }, {\r\n                        \"Legend\": { min: 0, max: 1 },\r\n                        \"Task\": { min: 1, max: 1 },\r\n                        \"StartDate\": { min: 0, max: 1 },\r\n                        \"Duration\": { min: 0, max: 0 },\r\n                        \"Completion\": { min: 0, max: 0 },\r\n                        \"Resource\": { min: 0, max: 0 }\r\n                    }, {\r\n                        \"Legend\": { min: 0, max: 1 },\r\n                        \"Task\": { min: 0, max: 1 },\r\n                        \"StartDate\": { min: 0, max: 1 },\r\n                        \"Duration\": { min: 0, max: 1 },\r\n                        \"Completion\": { min: 0, max: 1 },\r\n                        \"Resource\": { min: 0, max: 1 },\r\n                    }\r\n                ],\r\n                table: {\r\n                    rows: {\r\n                        select:\r\n                        [\r\n                            { for: { in: \"Legend\" } },\r\n                            { for: { in: \"Task\" } },\r\n                            { for: { in: \"StartDate\" } },\r\n                            { for: { in: \"Duration\" } },\r\n                            { for: { in: \"Completion\" } },\r\n                            { for: { in: \"Resource\" } },\r\n                        ]\r\n                    },\r\n                },\r\n            }],\r\n            sorting: {\r\n                default: {},\r\n            },\r\n            objects: {\r\n                legend: {\r\n                    displayName: \"Legend\",\r\n                    description: \"Display legend options\",\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: \"Position\",\r\n                            description: \"Select the location for the legend\",\r\n                            type: { enumeration: legendPosition.type }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: \"Title\",\r\n                            description: \"Display a title for legend symbols\",\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: \"Legend Name\",\r\n                            description: \"Title text\",\r\n                            type: { text: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelColor: {\r\n                            displayName: \"Color\",\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: \"Text Size\",\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                //dataPoint: {\r\n                //    displayName: \"Data colors\",\r\n                //    properties: {\r\n                //        fill: {\r\n                //            displayName: \"Fill\",\r\n                //            type: { fill: { solid: { color: true } } }\r\n                //        }\r\n                //    }\r\n                //},\r\n                taskLabels: {\r\n                    displayName: 'Category Labels',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: 'Fill',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Font Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        },\r\n                        width: {\r\n                            displayName: 'Width',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                },\r\n                taskCompletion: {\r\n                    displayName: 'Task Completion',\r\n                    properties: {\r\n                        show: {\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: 'Completion Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                taskResource: {\r\n                    displayName: 'Data Labels',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: \"Show\",\r\n                            type: { bool: true }\r\n                        },\r\n                        fill: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Font Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                },\r\n                ganttDateType: {\r\n                    displayName: 'Gantt Date Type',\r\n                    properties: {\r\n                        type: {\r\n                            displayName: \"Type\",\r\n                            type: { enumeration: dateTypeSelector.type }\r\n                        },\r\n                    }\r\n                },\r\n            }\r\n        };\r\n\r\n        private margin: IMargin = {\r\n            top: 50,\r\n            right: 40,\r\n            bottom: 40,\r\n            left: 10\r\n        };\r\n\r\n        private style: IVisualStyle;\r\n        private body: D3.Selection;\r\n        private ganttSvg: D3.Selection;\r\n        private viewModel: GanttViewModel;\r\n        private timeScale: D3.Scale.TimeScale;\r\n        private axisGroup: D3.Selection;\r\n\r\n        private chartGroup: D3.Selection;\r\n        private taskGroup: D3.Selection;\r\n        private lineGroup: D3.Selection;\r\n\r\n        private clearCatcher: D3.Selection;\r\n        private ganttDiv: D3.Selection;\r\n        private selectionManager: SelectionManager;\r\n        private behavior: GanttChartBehavior;\r\n        private interactivityService: IInteractivityService;\r\n        private hostServices: IVisualHostServices;\r\n        private isInteractiveChart: boolean;\r\n\r\n        public static getMaxTaskOpacity(): number {\r\n            return Gantt.DefaultValues.MaxTaskOpacity;\r\n        }\r\n\r\n        public static getMinTaskOpacity(): number {\r\n            return Gantt.DefaultValues.MinTaskOpacity;\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            let element: JQuery = options.element;\r\n\r\n            this.style = options.style;\r\n            this.body = d3.select(element.get(0));\r\n\r\n            this.hostServices = options.host;\r\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\r\n\r\n            this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;\r\n            this.interactivityService = createInteractivityService(this.hostServices);\r\n            this.createViewport(element);\r\n            this.updateChartSize(options.viewport);\r\n            this.behavior = new GanttChartBehavior();\r\n            this.colors = options.style.colorPalette.dataColors;\r\n\r\n            this.data = {\r\n                legendData: null,\r\n                series: null,\r\n                showLegend: null\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Create the vieport area of the gantt chart\r\n         */\r\n        private createViewport(element: JQuery): void {\r\n            //create div container to the whole viewport area\r\n            this.ganttDiv = this.body.append(\"div\")\r\n                .classed(Selectors.Body.class, true);\r\n\r\n            //create container to the svg area\r\n            this.ganttSvg = this.ganttDiv\r\n                .append(\"svg\")\r\n                .classed(Selectors.ClassName.class, true);\r\n         \r\n            //create clear catcher\r\n            this.clearCatcher = appendClearCatcher(this.ganttSvg);\r\n\r\n            //create axis container\r\n            this.axisGroup = this.ganttSvg\r\n                .append(\"g\")\r\n                .classed(Selectors.AxisGroup.class, true);\r\n            \r\n            //create task lines container\r\n            this.lineGroup = this.ganttSvg\r\n                .append(\"g\")\r\n                .classed(Selectors.TaskLines.class, true);\r\n            \r\n            //create chart container\r\n            this.chartGroup = this.ganttSvg\r\n                .append(\"g\")\r\n                .classed(Selectors.Chart.class, true);\r\n            \r\n            //create tasks container\r\n            this.taskGroup = this.chartGroup\r\n                .append(\"g\")\r\n                .classed(Selectors.Tasks.class, true);\r\n\r\n            //create legend container\r\n            this.legend = createLegend(element.children(Selectors.Body.selector),\r\n                this.isInteractiveChart,\r\n                this.interactivityService,\r\n                true,\r\n                LegendPosition.Top);\r\n        }\r\n\r\n        /**\r\n         * Clear the viewport area\r\n         */\r\n        private clearViewport(): void {\r\n            this.body.selectAll(Selectors.LegendItems.selector).remove();\r\n            this.body.selectAll(Selectors.LegendTitle.selector).remove();\r\n            this.axisGroup.selectAll(Selectors.AxisTick.selector).remove();\r\n            this.axisGroup.selectAll(Selectors.Domain.selector).remove();\r\n            this.lineGroup.selectAll(\"*\").remove();\r\n            this.chartGroup.selectAll(Selectors.ChartLine.selector).remove();\r\n            this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();\r\n        }\r\n\r\n        /**\r\n         * Update div container size to the whole viewport area\r\n         * @param viewport The vieport to change it size \r\n         */\r\n        private updateChartSize(viewport: IViewport): void {\r\n            this.ganttDiv.style({\r\n                height: PixelConverter.toString(viewport.height),\r\n                width: PixelConverter.toString(viewport.width)\r\n            });\r\n        }\r\n\r\n        /**\r\n       * Create the gantt tasks series based on all task types\r\n       * @param taskTypes All unique types from the tasks array.\r\n       */\r\n        private createSeries(objects: DataViewObjects, tasks: Task[]): GanttSeries[] {\r\n            let colorHelper = new ColorHelper(this.colors, GanttChartProps.dataPoint.fill);\r\n            let taskGroup: _.Dictionary<Task[]> = _.groupBy(tasks, t=> t.taskType);\r\n            let taskTypes = Gantt.getAllTasksTypes(this.dataView);\r\n\r\n            let series: GanttSeries[] = _.map(taskTypes.types, type => {\r\n                return {\r\n                    tasks: taskGroup[type],\r\n                    fill: colorHelper.getColorForMeasure(objects, type),\r\n                    name: type,\r\n                    identity: SelectionId.createWithMeasure(type),\r\n                    selected: false\r\n                };\r\n            });\r\n\r\n            return series;\r\n        }\r\n\r\n        /**\r\n        * Convert the dataView to view model\r\n        * @param dataView The data Model\r\n        */\r\n        public static converter(dataView: DataView, colorPalette: IDataColorPalette): GanttViewModel {\r\n            let taskLabelsShow: boolean = DataViewObjects.getValue<boolean>(dataView.metadata.objects, GanttChartProps.taskLabels.show, true);\r\n            let taskLabelsColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor);\r\n            let taskLabelsFontSize: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\r\n            let taskLabelsWidth: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0);\r\n            let taskProgressColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor);\r\n            let taskResourceColor: string = DataViewObjects.getFillColor(dataView.metadata.objects, GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor);\r\n            let taskResourceFontSize: number = DataViewObjects.getValue<number>(dataView.metadata.objects, GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize);\r\n            let taskResourceShow: boolean = DataViewObjects.getValue<boolean>(dataView.metadata.objects, GanttChartProps.taskResource.show, true);\r\n            let dateType: string = DataViewObjects.getValue<string>(dataView.metadata.objects, GanttChartProps.ganttDateType.type, DefaultDateType);\r\n\r\n            let taskTypes = Gantt.getAllTasksTypes(dataView);\r\n            let colorHelper = new ColorHelper(colorPalette, GanttChartProps.dataPoint.fill);\r\n            let legendData: LegendData = {\r\n                fontSize: Gantt.DefaultValues.LegendFontSize,\r\n                dataPoints: [],\r\n                title: taskTypes.typeName\r\n            };\r\n\r\n            legendData.dataPoints = _.map(taskTypes.types, type => {\r\n                return {\r\n                    label: type,\r\n                    color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),\r\n                    icon: LegendIcon.Circle,\r\n                    selected: false,\r\n                    identity: SelectionId.createWithMeasure(type)\r\n                };\r\n            });\r\n\r\n            let settings: GanttViewModel = {\r\n                taskLabelsShow: taskLabelsShow,\r\n                taskLabelsColor: taskLabelsColor,\r\n                taskLabelsFontSize: taskLabelsFontSize,\r\n                taskLabelsWidth: taskLabelsWidth,\r\n                taskProgressColor: taskProgressColor,\r\n                taskResourceShow: taskResourceShow,\r\n                taskResourceColor: taskResourceColor,\r\n                taskResourceFontSize: taskResourceFontSize,\r\n                legendData: legendData,\r\n                taskTypes: taskTypes,\r\n                dateType: dateType\r\n            };\r\n\r\n            return settings;\r\n        }\r\n\r\n        /**\r\n         * Returns the chart formatters\r\n         * @param dataView The data Model\r\n         */\r\n        private parseSettings(dataView: DataView): GanttChartFormatters {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns)\r\n                return null;\r\n\r\n            let dateFormat = \"d\";\r\n            let numberFormat = \"#\";\r\n\r\n            for (let dvColumn of dataView.metadata.columns) {\r\n                if (!!dataView.categorical.categories) {\r\n                    for (let dvCategory of dataView.categorical.categories) {\r\n                        if (this.hasRole(dvCategory.source, \"StartDate\"))\r\n                            dateFormat = dvColumn.format;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return <GanttChartFormatters>{\r\n                startDateFormatter: valueFormatter.create({ format: dateFormat }),\r\n                durationFormatter: valueFormatter.create({ format: numberFormat }),\r\n                completionFormatter: valueFormatter.create({ format: PercentFormat, value: 1, allowFormatBeautification: true })\r\n            };\r\n        }\r\n\r\n        private isValidDate(date: Date) {\r\n            if (Object.prototype.toString.call(date) !== \"[object Date]\")\r\n                return false;\r\n            return !isNaN(date.getTime());\r\n        }\r\n\r\n        private convertToDecimal(number) {\r\n            if (!(number >= 0 && number <= 1))\r\n                return (number / 100);\r\n            return number;\r\n        }\r\n\r\n        /**\r\n        * Create task objects dataView\r\n        * @param dataView The data Model.\r\n        * @param formatters task attributes represented format.\r\n        * @param series An array that holds the color data of different task groups.\r\n        */\r\n        private createTasks(dataView: DataView, formatters: GanttChartFormatters): Task[] {\r\n            let columnSource = dataView.table.columns;\r\n            let data = dataView.table.rows;\r\n            let categories = dataView.categorical.categories[0];\r\n            let colorHelper = new ColorHelper(this.colors, GanttChartProps.dataPoint.fill);\r\n\r\n            return data.map((child: DataViewTableRow, index: number) => {\r\n                let dateString = this.getTaskProperty<Date>(columnSource, child, \"StartDate\");\r\n                //let startDate = new Date(dateString);\r\n                dateString = this.isValidDate(dateString) ? dateString : new Date(Date.now());\r\n\r\n                let duration = this.getTaskProperty<number>(columnSource, child, \"Duration\");\r\n\r\n                let completionValue = this.getTaskProperty<number>(columnSource, child, \"Completion\");\r\n                let completion = this.convertToDecimal(completionValue);\r\n                completion = completion <= 1 ? completion : 1;\r\n\r\n                let taskType = this.getTaskProperty<string>(columnSource, child, \"Legend\");\r\n                let tasksTypeColor: string = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType);\r\n\r\n                let task: Task = {\r\n                    id: index,\r\n                    name: this.getTaskProperty<string>(columnSource, child, \"Task\"),\r\n                    start: dateString ? dateString : new Date(Date.now()),\r\n                    duration: duration > 0 ? duration : 1,\r\n                    end: null,\r\n                    completion: completion > 0 ? completion : 0,\r\n                    resource: this.getTaskProperty<string>(columnSource, child, \"Resource\"),\r\n                    taskType: taskType,\r\n                    color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor, /* get color by task type  */\r\n                    tooltipInfo: null,\r\n                    description: \"\",\r\n                    identity: SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),\r\n                    selected: false\r\n                };\r\n\r\n                task.end = d3.time.day.offset(task.start, task.duration);\r\n                task.tooltipInfo = this.getTooltipInfo(task, formatters);\r\n                return task;\r\n            });\r\n        }\r\n\r\n        /**\r\n        * Gets all unique types from the tasks array\r\n        * @param dataView The data model.\r\n        */\r\n        private static getAllTasksTypes(dataView: DataView): TaskTypes {\r\n            let types: string[] = [];\r\n            let groupName: string = \"\";\r\n            let taskTypes: TaskTypes;\r\n            let data = dataView.table.rows;\r\n            let index = _.findIndex(dataView.table.columns, col => col.roles.hasOwnProperty(\"Legend\"));\r\n\r\n            if (index !== -1) {\r\n                groupName = dataView.table.columns[index].displayName;\r\n                types = _.unique(data, (d) => d[index]).map((d) => d[index]);\r\n            }\r\n\r\n            taskTypes = {\r\n                typeName: groupName,\r\n                types: types\r\n            };\r\n\r\n            return taskTypes;\r\n        }\r\n\r\n        /**\r\n        * Get the tooltip info (data display names & formated values)\r\n        * @param task All task attributes.\r\n        * @param formatters Formatting options for gantt attributes.\r\n        */\r\n        private getTooltipInfo(task: Task, formatters: GanttChartFormatters, timeInterval: string = \"Days\") {\r\n            let tooltipDataArray: TooltipDataItem[] = [];\r\n\r\n            if (task.taskType)\r\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.taskType });\r\n\r\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: task.name });\r\n            if (!isNaN(task.start.getDate()))\r\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: formatters.startDateFormatter.format(task.start.toLocaleDateString()) });\r\n\r\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: formatters.durationFormatter.format(task.duration) + \" \" + timeInterval });\r\n            tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: formatters.completionFormatter.format(task.completion) });\r\n\r\n            if (task.resource)\r\n                tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[5].name, value: task.resource });\r\n\r\n            return tooltipDataArray;\r\n        }\r\n\r\n        /**\r\n         * Get task property from the data view\r\n         * @param columnSource\r\n         * @param child\r\n         * @param propertyName The property to get\r\n         */\r\n        private getTaskProperty<T>(columnSource: DataViewMetadataColumn[], child: DataViewTableRow, propertyName: string): T {\r\n            if (!child ||\r\n                !columnSource ||\r\n                !(columnSource.length > 0) ||\r\n                !columnSource[0].roles)\r\n                return null;\r\n\r\n            let index = columnSource.indexOf(columnSource.filter(x=> x.roles[propertyName])[0]);\r\n            return index !== -1 ? <T>child[index] : null;\r\n        }\r\n\r\n        /**\r\n         * Check if dataView has a given role\r\n         * @param column The dataView headers\r\n         * @param name The role to find\r\n         */\r\n        private hasRole(column: DataViewMetadataColumn, name: string) {\r\n            var roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        /**\r\n         * Check if task has data for task\r\n         * @param dataView\r\n         */\r\n        private isChartHasTask(dataView: DataView): boolean {\r\n            if (dataView.table &&\r\n                dataView.table.columns) {\r\n                for (let column of dataView.table.columns) {\r\n                    if (this.hasRole(column, \"Task\")) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Get legend data, calculate position and draw it\r\n         * @param ganttChartData Data for series and legend\r\n         */\r\n        private renderLegend(legendData: LegendData): void {\r\n            if (!legendData)\r\n                return;\r\n\r\n            if (this.legendObjectProperties) {\r\n                LegendData.update(legendData, this.legendObjectProperties);\r\n                var position: string;\r\n                position = <string>this.legendObjectProperties[legendProps.position];\r\n\r\n                if (position)\r\n                    this.legend.changeOrientation(LegendPosition[position]);\r\n            }\r\n\r\n            let viewport = this.viewport;\r\n            this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });\r\n            Legend.positionChartArea(this.ganttSvg, this.legend);\r\n        }\r\n\r\n        private parseLegendProperties(dataView: DataView): void {\r\n            if (!dataView || !dataView.metadata) {\r\n                this.legendObjectProperties = {};\r\n                return;\r\n            }\r\n\r\n            this.legendObjectProperties = DataViewObjects.getObject(dataView.metadata.objects, 'legend', {});\r\n        }\r\n\r\n        /**\r\n        * Called on data change or resizing\r\n        * @param options The visual option that contains the dataview and the viewport\r\n        */\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options.dataViews || !options.dataViews[0])\r\n                return;\r\n            let dataView = options.dataViews[0];\r\n\r\n            if (!this.isChartHasTask(dataView) || options.dataViews[0].table.rows.length === 0) {\r\n                this.clearViewport();\r\n                return;\r\n            }\r\n\r\n            this.dataView = dataView;\r\n            let viewport = options.viewport;\r\n            this.viewport = viewport;\r\n            this.updateChartSize(viewport);\r\n\r\n            let viewModel: GanttViewModel = Gantt.converter(dataView, this.colors),\r\n                formatters: GanttChartFormatters = this.parseSettings(dataView),\r\n                tasks: Task[] = this.createTasks(dataView, formatters);\r\n\r\n            this.parseLegendProperties(dataView);\r\n            this.renderLegend(viewModel.legendData);\r\n            this.data.series = this.createSeries(dataView.metadata.objects, tasks);\r\n            this.viewModel = viewModel;\r\n\r\n            if (this.interactivityService) {\r\n                this.interactivityService.applySelectionStateToData(tasks);\r\n                this.interactivityService.applySelectionStateToData(this.data.series);\r\n            }\r\n\r\n            if (tasks.length > 0) {\r\n                let tasksSortedByStartDate: Task[] = _.sortBy(tasks, (t) => t.start);\r\n                let tasksSortedByEndDate: Task[] = _.sortBy(tasks, (t) => t.end);\r\n                let dateTypeMilliseconds = this.getDateType();\r\n\r\n                let startDate: Date = tasksSortedByStartDate[0].start,\r\n                    endDate: Date = tasksSortedByEndDate[tasks.length - 1].end,\r\n                    ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);\r\n\r\n                ticks = ticks === 0 || ticks === 1 ? 2 : ticks;\r\n                let axisLength = ticks * 50;\r\n                this.ganttSvg\r\n                    .attr({\r\n                        height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),\r\n                        width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)\r\n                    });\r\n\r\n                let viewportIn: IViewport = {\r\n                    height: viewport.height,\r\n                    width: axisLength\r\n                };\r\n\r\n                let xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, false);\r\n                this.timeScale = <D3.Scale.TimeScale>xAxisProperties.scale;\r\n\r\n                this.renderAxis(xAxisProperties, 200);\r\n                this.renderTasks(tasks);\r\n\r\n                this.createMilestoneLine(tasks);\r\n                this.updateTaskLabels(tasks, viewModel.taskLabelsWidth);\r\n                this.updateElementsPositions(viewport, this.margin);\r\n\r\n                if (this.interactivityService) {\r\n                    let behaviorOptions: GanttBehaviorOptions = {\r\n                        clearCatcher: this.clearCatcher,\r\n                        taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),\r\n                        legendSelection: this.body.selectAll(Selectors.LegendItems.selector),\r\n                        interactivityService: this.interactivityService\r\n                    };\r\n                    this.interactivityService.bind(tasks, this.behavior, behaviorOptions);\r\n                }\r\n            }\r\n        }\r\n        \r\n        private getDateType(): number {\r\n            let milliSeconds: number = MillisecondsInWeek;\r\n\r\n            switch (this.viewModel.dateType) {\r\n                case \"Day\":\r\n                    milliSeconds = MillisecondsInADay;\r\n                    break;\r\n\r\n                case \"Week\":\r\n                    milliSeconds = MillisecondsInWeek;\r\n                    break;\r\n\r\n                case \"Month\":\r\n                    milliSeconds = MillisecondsInAMonth;\r\n                    break;\r\n\r\n                case \"Year\":\r\n                    milliSeconds = MillisecondsInAYear;\r\n                    break;\r\n            }\r\n\r\n            return milliSeconds;\r\n        }\r\n\r\n        private calculateAxes(\r\n            viewportIn: IViewport,\r\n            textProperties: TextProperties,\r\n            startDate: Date,\r\n            endDate: Date,\r\n            axisLength: number,\r\n            ticksCount: number,\r\n            scrollbarVisible: boolean): IAxisProperties {\r\n\r\n            let dataTypeDatetime = ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Date);\r\n            let category: DataViewMetadataColumn = { displayName: \"StartDate\", queryName: \"StartDate\", type: dataTypeDatetime, index: 0 };\r\n            let visualOptions: CalculateScaleAndDomainOptions = {\r\n                viewport: viewportIn,\r\n                margin: this.margin,\r\n                forcedXDomain: [startDate, endDate],\r\n                forceMerge: false,\r\n                showCategoryAxisLabel: false,\r\n                showValueAxisLabel: false,\r\n                categoryAxisScaleType: powerbi.visuals.axisScale.linear,\r\n                valueAxisScaleType: null,\r\n                valueAxisDisplayUnits: 0,\r\n                categoryAxisDisplayUnits: 0,\r\n                trimOrdinalDataOnOverflow: false,\r\n                forcedTickCount: ticksCount\r\n            };\r\n\r\n            let width = viewportIn.width;\r\n            let axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);\r\n            axes.willLabelsFit = AxisHelper.LabelLayoutStrategy.willLabelsFit(\r\n                axes,\r\n                width,\r\n                TextMeasurementService.measureSvgTextWidth,\r\n                textProperties);\r\n\r\n            // If labels do not fit and we are not scrolling, try word breaking\r\n            axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(\r\n                axes, this.margin, width, TextMeasurementService.measureSvgTextWidth,\r\n                TextMeasurementService.estimateSvgTextHeight, TextMeasurementService.getTailoredTextOrDefault,\r\n                textProperties);\r\n\r\n            return axes;\r\n        }\r\n\r\n        private calculateAxesProperties(viewportIn: IViewport, options: CalculateScaleAndDomainOptions, axisLength: number, metaDataColumn: DataViewMetadataColumn): IAxisProperties {\r\n            let xAxisProperties = AxisHelper.createAxis({\r\n                pixelSpan: viewportIn.width,\r\n                dataDomain: options.forcedXDomain,\r\n                metaDataColumn: metaDataColumn,\r\n                formatString: Gantt.DefaultValues.ganttFormatString,\r\n                outerPadding: 0,\r\n                isScalar: true,\r\n                isVertical: false,\r\n                forcedTickCount: options.forcedTickCount,\r\n                useTickIntervalForDisplayUnits: true,\r\n                isCategoryAxis: true,\r\n                getValueFn: (index, type) => {\r\n                    return valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);\r\n                },\r\n                scaleType: options.categoryAxisScaleType,\r\n                axisDisplayUnits: options.categoryAxisDisplayUnits,\r\n            });\r\n\r\n            xAxisProperties.axisLabel = metaDataColumn.displayName;\r\n            return xAxisProperties;\r\n        }\r\n\r\n        private renderAxis(xAxisProperties: IAxisProperties, duration: number): void {\r\n            let xAxis = xAxisProperties.axis;\r\n            xAxis.orient('bottom');\r\n\r\n            this.axisGroup.transition().duration(duration).call(xAxis);\r\n        }\r\n        /**\r\n        * Update task labels and add its tooltips \r\n        * @param tasks All tasks array\r\n        * @param width The task label width\r\n        */\r\n        private updateTaskLabels(tasks: Task[], width: number): void {\r\n            let axisLabel: D3.UpdateSelection;\r\n            let taskLineCoordinateX: number = 15;\r\n            let taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : true;\r\n            let taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor;\r\n            let taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;\r\n\r\n            if (taskLabelsShow) {\r\n                axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks);\r\n                axisLabel.enter().append(\"text\").classed(Selectors.Label.class, true);\r\n                axisLabel.attr({\r\n                    x: taskLineCoordinateX,\r\n                    y: (task: Task, i: number) => this.getTaskLabelCoordinateY(task.id),\r\n                    fill: taskLabelsColor,\r\n                    \"stroke-width\": 1\r\n                })\r\n                    .style(\"font-size\", PixelConverter.fromPoint(taskLabelsFontSize))\r\n                    .text((task) => { return task.name; });\r\n\r\n                axisLabel.call(AxisHelper.LabelLayoutStrategy.clip, width - 20, TextMeasurementService.svgEllipsis);\r\n                axisLabel.append(\"title\").text((task) => { return task.name; });\r\n                axisLabel.exit().remove();\r\n            }\r\n            else {\r\n                this.lineGroup.selectAll(Selectors.Label.selector).remove();\r\n            }\r\n        }\r\n\r\n        private renderTasks(tasks: Task[]) {\r\n            let taskSelection: D3.UpdateSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks);\r\n            let taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor;\r\n            let taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : true;\r\n            let padding: number = 4;\r\n            let taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor;\r\n            let taskResourceFontSize: number = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;\r\n\r\n            //render task group container \r\n            taskSelection.enter().append(\"g\").classed(Selectors.SingleTask.class, true);\r\n            //render task main rect\r\n            let taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data((d: Task) => [d]);\r\n            taskRect.enter().append(\"rect\").classed(Selectors.TaskRect.class, true);\r\n            taskRect.classed(Selectors.TaskRect.class, true).attr({\r\n                x: (task: Task) => this.timeScale(task.start),\r\n                y: (task: Task) => this.getBarYCoordinate(task.id),\r\n                width: (task: Task) => this.taskDurationToWidth(task),\r\n                height: () => this.getBarHeight()\r\n            }).style(\"fill\", (task: Task) => task.color);\r\n            taskRect.exit().remove();\r\n\r\n            //render task progress rect \r\n            let taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data((d: Task) => [d]);\r\n            taskProgress.enter().append(\"rect\").classed(Selectors.TaskProgress.class, true);\r\n            taskProgress.attr({\r\n                x: (task: Task) => this.timeScale(task.start),\r\n                y: (task: Task) => this.getBarYCoordinate(task.id) + this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2,\r\n                width: (task: Task) => this.setTaskProgress(task),\r\n                height: Gantt.DefaultValues.ProgressBarHeight\r\n            }).style(\"fill\", taskProgressColor);\r\n            taskProgress.exit().remove();\r\n\r\n            if (taskResourceShow) {\r\n                //render task resource labels\r\n                let taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data((d: Task) => [d]);\r\n                taskResource.enter().append(\"text\").classed(Selectors.TaskResource.class, true);\r\n                taskResource.attr({\r\n                    x: (task: Task) => this.timeScale(task.end) + padding,\r\n                    y: (task: Task) => (this.getBarYCoordinate(task.id) + (this.getBarHeight() / 2) + padding)\r\n                })\r\n                    .text((task: Task) => task.resource)\r\n                    .style({\r\n                        fill: taskResourceColor,\r\n                        \"font-size\": PixelConverter.fromPoint(taskResourceFontSize)\r\n                    }).call(AxisHelper.LabelLayoutStrategy.clip,\r\n                    Gantt.DefaultValues.ResourceWidth - 10,\r\n                    TextMeasurementService.svgEllipsis);\r\n\r\n                taskResource.exit().remove();\r\n            }\r\n            else {\r\n                taskSelection.selectAll(Selectors.TaskResource.selector).remove();\r\n            }\r\n\r\n            TooltipManager.addTooltip(taskSelection, (tooltipEvent: TooltipEvent) => (<Task>tooltipEvent.data).tooltipInfo);\r\n            taskSelection.exit().remove();\r\n        }\r\n\r\n        public onClearSelection() {\r\n            this.selectionManager.clear();\r\n        }\r\n\r\n        /**\r\n         * Returns the matching Y coordinate for a given task index \r\n         * @param taskIndex Task Number\r\n         */\r\n        private getTaskLabelCoordinateY(taskIndex: number): number {\r\n            let fontSize: number = +this.getTaskLabelFontSize();\r\n            return (ChartLineHeight * taskIndex) + (this.getBarHeight() + 5 - (40 - fontSize) / 4);\r\n        }\r\n\r\n        /**\r\n         * Set the task progress bar in the gantt\r\n         * @param task All task attributes\r\n         */\r\n        private setTaskProgress(task: Task): number {\r\n            let fraction = task.completion / 1.0,\r\n                y = this.timeScale,\r\n                progress = (y(task.end) - y(task.start)) * fraction;\r\n\r\n            return progress;\r\n        }\r\n\r\n        /**\r\n         * Set the task progress bar in the gantt\r\n         * @param lineNumber Line number that represents the task number\r\n         */\r\n        private getBarYCoordinate(lineNumber: number): number {\r\n            return (ChartLineHeight * lineNumber) + (PaddingTasks);\r\n        }\r\n\r\n        private getBarHeight(): number {\r\n            return ChartLineHeight / 1.5;\r\n        }\r\n\r\n        /**\r\n        * convert task duration to width in the time scale\r\n        * @param task The task to convert\r\n        */\r\n        private taskDurationToWidth(task: Task): number {\r\n            return this.timeScale(task.end) - this.timeScale(task.start);\r\n        }\r\n\r\n        private getTooltipForMilstoneLine(timestamp: number, milestoneTitle: string): TooltipDataItem[] {\r\n            let stringDate = new Date(timestamp).toDateString();\r\n            let tooltip: TooltipDataItem[] = [{ displayName: milestoneTitle, value: stringDate }];\r\n            return tooltip;\r\n        }\r\n\r\n        /**\r\n        * Create vertical dotted line that represent milestone in the time axis (by default it shows not time)\r\n        * @param tasks All tasks array\r\n        * @param timestamp the milestone to be shown in the time axis (default Date.now())\r\n        */\r\n        private createMilestoneLine(tasks: Task[], milestoneTitle: string = \"Today\", timestamp: number = Date.now()): void {\r\n            let line: Line[] = [{\r\n                x1: this.timeScale(timestamp),\r\n                y1: 0,\r\n                x2: this.timeScale(timestamp),\r\n                y2: this.getMilestoneLineLength(tasks.length),\r\n                tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)\r\n            }];\r\n\r\n            let chartLineSelection: D3.UpdateSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);\r\n            chartLineSelection.enter().append(\"line\").classed(Selectors.ChartLine.class, true);\r\n            chartLineSelection.attr({\r\n                x1: (line: Line) => line.x1,\r\n                y1: (line: Line) => line.y1,\r\n                x2: (line: Line) => line.x2,\r\n                y2: (line: Line) => line.y2,\r\n                tooltipInfo: (line: Line) => line.tooltipInfo\r\n            });\r\n\r\n            TooltipManager.addTooltip(chartLineSelection, (tooltipEvent: TooltipEvent) => (<Line>tooltipEvent.data).tooltipInfo);\r\n            chartLineSelection.exit().remove();\r\n        }\r\n\r\n        private updateElementsPositions(viewport: IViewport, margin: IMargin): void {\r\n            let viewModel = this.viewModel;\r\n            this.axisGroup.attr(\"transform\", SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15));\r\n            this.chartGroup.attr(\"transform\", SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top));\r\n            this.lineGroup.attr(\"transform\", SVGUtil.translate(0, margin.top));\r\n        }\r\n       \r\n        /**\r\n         * Returns the width of the now line based on num of tasks\r\n         * @param numOfTasks Number of tasks\r\n         */\r\n        private getMilestoneLineLength(numOfTasks: number): number {\r\n            return numOfTasks * ChartLineHeight;\r\n        }\r\n\r\n        private getTaskLabelFontSize(): number {\r\n            return DataViewObjects.getValue<number>(this.dataView.metadata.objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);\r\n        }\r\n            \r\n        /** \r\n         * handle \"Legend\" card\r\n         * @param enumeration The instance to be pushed into \"Legend\" card\r\n         * @param objects Dataview objects\r\n         */\r\n        private enumerateLegendOptions(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            enumeration.pushInstance({\r\n                displayName: GanttChartProps.legend.show.objectName,\r\n                selector: null,\r\n                properties: {\r\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.show, true),\r\n                    position: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.position, true), //TODO: change type of prop\r\n                    showTitle: DataViewObjects.getValue<boolean>(objects, GanttChartProps.legend.showTitle, true),\r\n                    titleText: DataViewObjects.getValue<string>(objects, GanttChartProps.legend.titleText, \"\"), //TODO: default text ?\r\n                    labelColor: DataViewObjects.getFillColor(objects, GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),\r\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)\r\n                },\r\n                objectName: GanttChartProps.legend.show.objectName\r\n            });\r\n        }\r\n\r\n        /** \r\n        * handle \"Data Colors\" card\r\n        * @param enumeration The instance to be pushed into \"Data Colors\" card\r\n        * @param objects Dataview objects\r\n        */\r\n        private enumerateDataPoints(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            let taskSeries: GanttSeries[] = this.data.series;\r\n\r\n            taskSeries.forEach((item: GanttSeries) => {\r\n                enumeration.pushInstance({\r\n                    objectName: 'dataPoint',\r\n                    displayName: item.name,\r\n                    selector: ColorHelper.normalizeSelector(item.identity.getSelector(), false),\r\n                    properties: {\r\n                        fill: { solid: { color: item.fill } }\r\n                    }\r\n                });\r\n            });\r\n        }\r\n            \r\n        /** \r\n        * handle \"Task Completion\" card\r\n        * @param enumeration The instance to be pushed into \"Task Completion\" card\r\n        * @param objects Dataview objects\r\n        */\r\n        private enumerateTaskCompletion(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                properties: {\r\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)\r\n                },\r\n                objectName: GanttChartProps.taskCompletion.fill.objectName\r\n            });\r\n        }\r\n        \r\n        /** \r\n        * handle \"Labels\" card\r\n        * @param enumeration The instance to be pushed into \"Data Labels\" card\r\n        * @param objects Dataview objects\r\n        */\r\n        private enumerateTaskLabels(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                properties: {\r\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.taskLabels.show, true),\r\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),\r\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),\r\n                    width: DataViewObjects.getValue<number>(objects, GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth),\r\n                },\r\n                objectName: GanttChartProps.taskLabels.show.objectName\r\n            });\r\n        }\r\n      \r\n        /** \r\n        * handle \"Data Labels\" card\r\n        * @param enumeration The instance to be pushed into \"Task Resource\" card\r\n        * @param objects Dataview objects\r\n        */\r\n        private enumerateDataLabels(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                properties: {\r\n                    show: DataViewObjects.getValue<boolean>(objects, GanttChartProps.taskResource.show, true),\r\n                    fill: DataViewObjects.getFillColor(objects, GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),\r\n                    fontSize: DataViewObjects.getValue<number>(objects, GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)\r\n                },\r\n                objectName: GanttChartProps.taskResource.show.objectName\r\n            });\r\n        }\r\n\r\n        private enumerateDateType(enumeration: ObjectEnumerationBuilder, objects: DataViewObjects) {\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                properties: {\r\n                    type: DataViewObjects.getValue<string>(objects, GanttChartProps.ganttDateType.type, DefaultDateType),\r\n                },\r\n                objectName: GanttChartProps.ganttDateType.type.objectName\r\n            });\r\n        }        \r\n        /** \r\n        * handle the property pane options\r\n        * @param objects Dataview enumerate objects\r\n        */\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let dataView = this.dataView;\r\n            if (!dataView)\r\n                return;\r\n\r\n            let enumeration = new ObjectEnumerationBuilder();\r\n\r\n            switch (options.objectName) {\r\n                case 'legend':\r\n                    this.enumerateLegendOptions(enumeration, dataView.metadata.objects);\r\n                    break;\r\n                case 'dataPoint':\r\n                    this.enumerateDataPoints(enumeration, dataView.metadata.objects);\r\n                    break;\r\n                case 'taskLabels':\r\n                    this.enumerateTaskLabels(enumeration, dataView.metadata.objects);\r\n                    break;\r\n                case 'taskCompletion':\r\n                    this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);\r\n                    break;\r\n                case 'taskResource':\r\n                    this.enumerateDataLabels(enumeration, dataView.metadata.objects);\r\n                    break;\r\n                case 'ganttDateType':\r\n                    this.enumerateDateType(enumeration, dataView.metadata.objects);\r\n                    break;\r\n            }\r\n            return enumeration.complete();\r\n        }\r\n    }\r\n\r\n    export interface GanttBehaviorOptions {\r\n        clearCatcher: D3.Selection;\r\n        taskSelection: D3.Selection;\r\n        legendSelection: D3.Selection;\r\n        interactivityService: IInteractivityService;\r\n    }\r\n\r\n    export class GanttChartBehavior implements IInteractiveBehavior {\r\n        private options: GanttBehaviorOptions;\r\n\r\n        public bindEvents(options: GanttBehaviorOptions, selectionHandler: ISelectionHandler) {\r\n            this.options = options;\r\n            let clearCatcher = options.clearCatcher;\r\n\r\n            options.taskSelection.on('click', (d: SelectableDataPoint) => {\r\n                selectionHandler.handleSelection(d, d3.event.ctrlKey);\r\n                d3.event.stopPropagation();\r\n            });\r\n\r\n            clearCatcher.on('click', () => {\r\n                selectionHandler.handleClearSelection();\r\n            });\r\n        }\r\n\r\n        public renderSelection(hasSelection: boolean) {\r\n            let options = this.options;\r\n            let ganttMaxOpacity = Gantt.getMaxTaskOpacity();\r\n            let ganttMinOpacity = Gantt.getMinTaskOpacity();\r\n\r\n            options.taskSelection.style(\"opacity\", (d: SelectableDataPoint) => {\r\n                return (hasSelection && !d.selected) ? ganttMinOpacity : ganttMaxOpacity;\r\n            });\r\n\r\n        }\r\n    }\r\n\r\n    export class GanttChartWarning implements IVisualWarning {\r\n        public get code(): string {\r\n            return \"GanttChartWarning\";\r\n        }\r\n\r\n        public getMessages(resourceProvider: IStringResourceProvider): IVisualErrorMessage {\r\n            let message: string = \"This visual requires task value\",\r\n                titleKey: string = \"\",\r\n                detailKey: string = \"\",\r\n                visualMessage: IVisualErrorMessage;\r\n\r\n            visualMessage = {\r\n                message: message,\r\n                title: resourceProvider.get(titleKey),\r\n                detail: resourceProvider.get(detailKey)\r\n            };\r\n\r\n            return visualMessage;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/gantt/visual/gantt.ts\n **/","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n*  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*\r\n*  The above copyright notice and this permission notice shall be included in \r\n*  all copies or substantial portions of the Software.\r\n*\r\n*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n\timport ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n\timport createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;\r\n\timport SelectionManager = utility.SelectionManager;\r\n\timport px = jsCommon.PixelConverter.toString;\r\n\timport pt = jsCommon.PixelConverter.fromPoint;\r\n\timport fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;\r\n\r\n\texport const Months: IEnumType = createEnumType([\r\n\t\t{ value: 1, displayName: 'January' },\r\n\t\t{ value: 2, displayName: 'February' },\r\n\t\t{ value: 3, displayName: 'March' },\r\n\t\t{ value: 4, displayName: 'April' },\r\n\t\t{ value: 5, displayName: 'May' },\r\n\t\t{ value: 6, displayName: 'June' },\r\n\t\t{ value: 7, displayName: 'July' },\r\n\t\t{ value: 8, displayName: 'August' },\r\n\t\t{ value: 9, displayName: 'September' },\r\n\t\t{ value: 10, displayName: 'October' },\r\n\t\t{ value: 11, displayName: 'November' },\r\n\t\t{ value: 12, displayName: 'December' }\r\n\t]);\r\n\r\n\texport const WeekDays: IEnumType = createEnumType([\r\n\t\t{ value: 0, displayName: 'Sunday' },\r\n\t\t{ value: 1, displayName: 'Monday' },\r\n\t\t{ value: 2, displayName: 'Tuesday' },\r\n\t\t{ value: 3, displayName: 'Wednesday' },\r\n\t\t{ value: 4, displayName: 'Thursday' },\r\n\t\t{ value: 5, displayName: 'Friday' },\r\n\t\t{ value: 6, displayName: 'Saturday' }\r\n\t]);\r\n\r\n\texport enum GranularityType {\r\n\t\tyear,\r\n\t\tquarter,\r\n\t\tmonth,\r\n\t\tweek,\r\n\t\tday\r\n\t}\r\n\r\n\texport interface GranularityName {\r\n\t\tgranularityType: GranularityType;\r\n\t\tname: string;\r\n\t}\r\n\r\n\texport interface TimelineMargins {\r\n\t\tLeftMargin: number;\r\n\t\tRightMargin: number;\r\n\t\tTopMargin: number;\r\n\t\tBottomMargin: number;\r\n\t\tCellWidth: number;\r\n\t\tCellHeight: number;\r\n\t\tStartXpoint: number;\r\n\t\tStartYpoint: number;\r\n\t\tElementWidth: number;\r\n\t\tMinCellWidth: number;\r\n\t\tMaxCellHeight: number;\r\n\t\tPeriodSlicerRectWidth: number;\r\n\t\tPeriodSlicerRectHeight: number;\r\n\t}\r\n\r\n\texport interface DefaultTimelineProperties {\r\n\t\tDefaultLabelsShow: boolean;\r\n\t\tTimelineDefaultTextSize: number;\r\n\t\tTimelineDefaultCellColor: string;\r\n\t\tTimelineDefaultCellColorOut: string;\r\n\t\tTimelineDefaultTimeRangeShow: boolean;\r\n\t\tDefaultTimeRangeColor: string;\r\n\t\tDefaultLabelColor: string;\r\n\t\tDefaultGranularity: GranularityType;\r\n\t\tDefaultFirstMonth: number;\r\n\t\tDefaultFirstDay: number;\r\n\t\tDefaultFirstWeekDay: number;\r\n\t}\r\n\r\n\texport interface TimelineSelectors {\r\n\t\tTimelineVisual: ClassAndSelector;\r\n\t\tSelectionRangeContainer: ClassAndSelector;\r\n\t\ttextLabel: ClassAndSelector;\r\n\t\tLowerTextCell: ClassAndSelector;\r\n\t\tUpperTextCell: ClassAndSelector;\r\n\t\tUpperTextArea: ClassAndSelector;\r\n\t\tLowerTextArea: ClassAndSelector;\r\n\t\tRangeTextArea: ClassAndSelector;\r\n\t\tCellsArea: ClassAndSelector;\r\n\t\tCursorsArea: ClassAndSelector;\r\n\t\tMainArea: ClassAndSelector;\r\n\t\tSelectionCursor: ClassAndSelector;\r\n\t\tCell: ClassAndSelector;\r\n\t\tCellRect: ClassAndSelector;\r\n\t\tVertLine: ClassAndSelector;\r\n\t\tTimelineSlicer: ClassAndSelector;\r\n\t\tPeriodSlicerGranularities: ClassAndSelector;\r\n\t\tPeriodSlicerSelection: ClassAndSelector;\r\n\t\tPeriodSlicerSelectionRect: ClassAndSelector;\r\n\t\tPeriodSlicerRect: ClassAndSelector;\r\n\t}\r\n\r\n\texport interface TimelineLabel {\r\n\t\ttitle: string;\r\n\t\ttext: string;\r\n\t\tid: number;\r\n\t}\r\n\r\n\texport interface ExtendedLabel {\r\n\t\tyearLabels?: TimelineLabel[];\r\n\t\tquarterLabels?: TimelineLabel[];\r\n\t\tmonthLabels?: TimelineLabel[];\r\n\t\tweekLabels?: TimelineLabel[];\r\n\t\tdayLabels?: TimelineLabel[];\r\n\t}\r\n\r\n\tconst SelectedCellColorProp: DataViewObjectPropertyIdentifier = { objectName: 'cells', propertyName: 'fillSelected' };\r\n\tconst UnselectedCellColorProp: DataViewObjectPropertyIdentifier = { objectName: 'cells', propertyName: 'fillUnselected' };\r\n\tconst TimeRangeColorProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'fontColor' };\r\n\tconst TimeRangeSizeProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'textSize' };\r\n\tconst TimeRangeShowProp: DataViewObjectPropertyIdentifier = { objectName: 'rangeHeader', propertyName: 'show' };\r\n\tconst LabelsColorProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'fontColor' };\r\n\tconst LabelsSizeProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'textSize' };\r\n\tconst LabelsShowProp: DataViewObjectPropertyIdentifier = { objectName: 'labels', propertyName: 'show' };\r\n\tconst CalendarMonthProp: DataViewObjectPropertyIdentifier = { objectName: 'calendar', propertyName: 'month' };\r\n\tconst CalendarDayProp: DataViewObjectPropertyIdentifier = { objectName: 'calendar', propertyName: 'day' };\r\n\tconst WeekDayProp: DataViewObjectPropertyIdentifier = { objectName: 'weekDay', propertyName: 'day' };\r\n\tconst GranularityNames: GranularityName[] = [\r\n\t\t{\r\n\t\t\tgranularityType: GranularityType.year,\r\n\t\t\tname: \"year\"\r\n\t\t}, {\r\n\t\t\tgranularityType: GranularityType.quarter,\r\n\t\t\tname: \"quarter\"\r\n\t\t}, {\r\n\t\t\tgranularityType: GranularityType.month,\r\n\t\t\tname: \"month\"\r\n\t\t}, {\r\n\t\t\tgranularityType: GranularityType.week,\r\n\t\t\tname: \"week\"\r\n\t\t}, {\r\n\t\t\tgranularityType: GranularityType.day,\r\n\t\t\tname: \"day\"\r\n\t\t}];\r\n\r\n\texport interface DatePeriod {\r\n\t\tidentifierArray: (string | number)[];\r\n\t\tstartDate: Date;\r\n\t\tendDate: Date;\r\n\t\tyear: number;\r\n\t\tweek: number[];\r\n\t\tfraction: number;\r\n\t\tindex: number;\r\n\t}\r\n\r\n\texport interface Granularity {\r\n\t\tgetType(): GranularityType;\r\n\t\tsplitDate(date: Date): (string | number)[];\r\n\t\tgetDatePeriods(): DatePeriod[];\r\n\t\tresetDatePeriods(): void;\r\n\t\tgetExtendedLabel(): ExtendedLabel;\r\n\t\tsetExtendedLabel(extendedLabel: ExtendedLabel): void;\r\n\t\tcreateLabels(granularity: Granularity): TimelineLabel[];\r\n\t\tsameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean;\r\n\t\tgenerateLabel(datePeriod: DatePeriod): TimelineLabel;\r\n\t\taddDate(date: Date, identifierArray: (string | number)[]);\r\n\t\tsetNewEndDate(date: Date): void;\r\n\t\tsplitPeriod(index: number, newFraction: number, newDate: Date): void;\r\n\t}\r\n\r\n\texport interface TimelineCursorOverElement {\r\n\t\tindex: number;\r\n\t\tdatapoint: TimelineDatapoint;\r\n\t}\r\n\r\n\texport class TimelineGranularity {\r\n\t\tprivate datePeriods: DatePeriod[] = [];\r\n\t\tprivate extendedLabel: ExtendedLabel;\r\n\r\n\t\t/**\r\n\t\t* Returns the short month name of the given date (e.g. Jan, Feb, Mar)\r\n\t\t*/\r\n\t\tpublic shortMonthName(date: Date): string {\r\n\t\t\treturn date.toString().split(' ')[1];\r\n\t\t}\r\n\r\n\t\tpublic resetDatePeriods(): void {\r\n\t\t\tthis.datePeriods = [];\r\n\t\t}\r\n\r\n\t\tpublic getDatePeriods() {\r\n\t\t\treturn this.datePeriods;\r\n\t\t}\r\n\r\n\t\tpublic getExtendedLabel(): ExtendedLabel {\r\n\t\t\treturn this.extendedLabel;\r\n\t\t}\r\n\r\n\t\tpublic setExtendedLabel(extendedLabel: ExtendedLabel): void {\r\n\t\t\tthis.extendedLabel = extendedLabel;\r\n\t\t}\r\n\r\n\t\tpublic createLabels(granularity: Granularity): TimelineLabel[] {\r\n\t\t\tlet labels: TimelineLabel[] = [];\r\n\t\t\tlet lastDatePeriod: DatePeriod;\r\n\t\t\t_.map(this.datePeriods, (x) => {\r\n\t\t\t\tif (_.isEmpty(labels) || !granularity.sameLabel(x, lastDatePeriod)) {\r\n\t\t\t\t\tlastDatePeriod = x;\r\n\t\t\t\t\tlabels.push(granularity.generateLabel(x));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\treturn labels;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* Adds the new date into the given datePeriods array\r\n\t\t* If the date corresponds to the last date period, given the current granularity,\r\n\t\t* it will be added to that date period. Otherwise, a new date period will be added to the array.\r\n\t\t* i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.\r\n\t\t* It is assumed that the given date does not correspond to previous date periods, other than the last date period\r\n\t\t*/\r\n\t\tpublic addDate(date: Date, identifierArray: (string | number)[]): void {\r\n\t\t\tlet datePeriods: DatePeriod[] = this.getDatePeriods();\r\n\t\t\tlet lastDatePeriod: DatePeriod = datePeriods[datePeriods.length - 1];\r\n\t\t\tif (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, identifierArray)) {\r\n\t\t\t\tif (datePeriods.length > 0)\r\n\t\t\t\t\tlastDatePeriod.endDate = date;\r\n\t\t\t\tdatePeriods.push({\r\n\t\t\t\t\tidentifierArray: identifierArray,\r\n\t\t\t\t\tstartDate: date,\r\n\t\t\t\t\tendDate: date,\r\n\t\t\t\t\tweek: this.determineWeek(date),\r\n\t\t\t\t\tyear: this.determineYear(date),\r\n\t\t\t\t\tfraction: 1,\r\n\t\t\t\t\tindex: datePeriods.length\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tlastDatePeriod.endDate = date;\r\n\t\t}\r\n\r\n\t\tpublic setNewEndDate(date: Date): void {\r\n\t\t\t_.last(this.datePeriods).endDate = date;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits a given period into two periods.\r\n\t\t * The new period is added after the index of the old one, while the old one is simply updated.\r\n\t\t * @param index The index of the date priod to be split\r\n\t\t * @param newFraction The fraction value of the new date period\r\n\t\t * @param newDate The date in which the date period is split\r\n\t\t */\r\n\t\tpublic splitPeriod(index: number, newFraction: number, newDate: Date): void {\r\n\t\t\tlet oldDatePeriod: DatePeriod = this.datePeriods[index];\r\n\t\t\toldDatePeriod.fraction -= newFraction;\r\n\t\t\tlet newDateObject: DatePeriod = {\r\n\t\t\t\tidentifierArray: oldDatePeriod.identifierArray,\r\n\t\t\t\tstartDate: newDate,\r\n\t\t\t\tendDate: oldDatePeriod.endDate,\r\n\t\t\t\tweek: this.determineWeek(newDate),\r\n\t\t\t\tyear: this.determineYear(newDate),\r\n\t\t\t\tfraction: newFraction,\r\n\t\t\t\tindex: oldDatePeriod.index + oldDatePeriod.fraction\r\n\t\t\t};\r\n\t\t\toldDatePeriod.endDate = newDate;\r\n\t\t\tthis.datePeriods.splice(index + 1, 0, newDateObject);\r\n\t\t}\r\n\r\n\t\tprivate previousMonth(month: number): number {\r\n\t\t\treturn (month > 0) ? month - 1 : 11;\r\n\t\t}\r\n\r\n\t\tprivate nextMonth(month: number): number {\r\n\t\t\treturn (month < 11) ? month + 1 : 0;\r\n\t\t}\r\n\r\n\t\tprivate countWeeks(startDate: Date, endDate: Date): number {\r\n\t\t\tlet totalDays: number;\r\n\t\t\tif (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate())\r\n\t\t\t\ttotalDays = endDate.getDate() - startDate.getDate();\r\n\t\t\telse {\r\n\t\t\t\ttotalDays = endDate.getDate() - 1;\r\n\t\t\t\tlet lastMonth = this.nextMonth(startDate.getMonth());\r\n\t\t\t\tlet month = endDate.getMonth();\r\n\t\t\t\twhile (month !== lastMonth) {\r\n\t\t\t\t\ttotalDays += new Date(endDate.getFullYear(), month, 0).getDate();\r\n\t\t\t\t\tmonth = this.previousMonth(month);\r\n\t\t\t\t}\r\n\t\t\t\ttotalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();\r\n\t\t\t}\r\n\t\t\treturn 1 + Math.floor(totalDays / 7);\r\n\t\t}\r\n\r\n\t\tpublic determineWeek(date: Date): number[] {\r\n\t\t\tvar year = date.getFullYear();\r\n\t\t\tif (this.inPreviousYear(date))\r\n\t\t\t\tyear--;\r\n\t\t\tlet dateOfFirstWeek: Date = Timeline.calendar.getDateOfFirstWeek(year);\r\n\t\t\tlet weeks: number = this.countWeeks(dateOfFirstWeek, date);\r\n\t\t\treturn [weeks, year];\r\n\t\t}\r\n\r\n\t\tprivate inPreviousYear(date: Date): boolean {\r\n\t\t\tlet dateOfFirstWeek: Date = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());\r\n\t\t\treturn date < dateOfFirstWeek;\r\n\t\t}\r\n\r\n\t\tpublic determineYear(date: Date): number {\r\n\t\t\tlet firstDay: Date = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());\r\n\t\t\treturn date.getFullYear() - ((firstDay <= date) ? 0 : 1);\r\n\t\t}\r\n\t}\r\n\r\n\texport class DayGranularity extends TimelineGranularity implements Granularity {\r\n\t\tpublic getType(): GranularityType {\r\n\t\t\treturn GranularityType.day;\r\n\t\t}\r\n\r\n\t\tpublic splitDate(date: Date): (string | number)[] {\r\n\t\t\treturn [this.shortMonthName(date), date.getDate(), date.getFullYear()];\r\n\t\t}\r\n\r\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\r\n\t\t\treturn firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();\r\n\t\t}\r\n\r\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\r\n\t\t\treturn {\r\n\t\t\t\ttitle: this.shortMonthName(datePeriod.startDate) + ' ' + datePeriod.startDate.getDate() + ' - ' + datePeriod.year,\r\n\t\t\t\ttext: datePeriod.startDate.getDate().toString(),\r\n\t\t\t\tid: datePeriod.index\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\texport class MonthGranularity extends TimelineGranularity implements Granularity {\r\n\t\tpublic getType(): GranularityType {\r\n\t\t\treturn GranularityType.month;\r\n\t\t}\r\n\r\n\t\tpublic splitDate(date: Date): (string | number)[] {\r\n\t\t\treturn [this.shortMonthName(date), date.getFullYear()];\r\n\t\t}\r\n\r\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\r\n\t\t\treturn this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);\r\n\t\t}\r\n\r\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\r\n\t\t\tlet shortMonthName = this.shortMonthName(datePeriod.startDate);\r\n\t\t\treturn {\r\n\t\t\t\ttitle: shortMonthName,\r\n\t\t\t\ttext: shortMonthName,\r\n\t\t\t\tid: datePeriod.index\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\texport class WeekGranularity extends TimelineGranularity implements Granularity {\r\n\t\tpublic getType(): GranularityType {\r\n\t\t\treturn GranularityType.week;\r\n\t\t}\r\n\r\n\t\tpublic splitDate(date: Date): (string | number)[] {\r\n\t\t\treturn this.determineWeek(date);\r\n\t\t}\r\n\r\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\r\n\t\t\treturn _.isEqual(firstDatePeriod.week, secondDatePeriod.week);\r\n\t\t}\r\n\r\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\r\n\t\t\treturn {\r\n\t\t\t\ttitle: 'Week ' + datePeriod.week[0] + ' - ' + datePeriod.week[1],\r\n\t\t\t\ttext: 'W' + datePeriod.week[0],\r\n\t\t\t\tid: datePeriod.index\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\texport class QuarterGranularity extends TimelineGranularity implements Granularity {\r\n\t\t/**\r\n\t\t * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)\r\n\t\t * @param date A date \r\n\t\t */\r\n\t\tprivate quarterText(date: Date): string {\r\n\t\t\tlet quarter = 3;\r\n\t\t\tlet year = date.getFullYear();\r\n\t\t\twhile (date < Timeline.calendar.getQuarterStartDate(year, quarter))\r\n\t\t\t\tif (quarter > 0)\r\n\t\t\t\t\tquarter--;\r\n\t\t\t\telse {\r\n\t\t\t\t\tquarter = 3;\r\n\t\t\t\t\tyear--;\r\n\t\t\t\t}\r\n\t\t\tquarter++;\r\n\t\t\treturn 'Q' + quarter;\r\n\t\t}\r\n\r\n\t\tpublic getType(): GranularityType {\r\n\t\t\treturn GranularityType.quarter;\r\n\t\t}\r\n\r\n\t\tpublic splitDate(date: Date): (string | number)[] {\r\n\t\t\treturn [this.quarterText(date), date.getFullYear()];\r\n\t\t}\r\n\r\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\r\n\t\t\treturn this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate)\r\n\t\t\t\t&& firstDatePeriod.year === secondDatePeriod.year;\r\n\t\t}\r\n\r\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\r\n\t\t\tlet quarter = this.quarterText(datePeriod.startDate);\r\n\t\t\treturn {\r\n\t\t\t\ttitle: quarter + ' ' + datePeriod.year,\r\n\t\t\t\ttext: quarter,\r\n\t\t\t\tid: datePeriod.index\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\texport class YearGranularity extends TimelineGranularity implements Granularity {\r\n\t\tpublic getType(): GranularityType {\r\n\t\t\treturn GranularityType.year;\r\n\t\t}\r\n\r\n\t\tpublic splitDate(date: Date): (string | number)[] {\r\n\t\t\treturn [date.getFullYear()];\r\n\t\t}\r\n\r\n\t\tpublic sameLabel(firstDatePeriod: DatePeriod, secondDatePeriod: DatePeriod): boolean {\r\n\t\t\treturn firstDatePeriod.year === secondDatePeriod.year;\r\n\t\t}\r\n\r\n\t\tpublic generateLabel(datePeriod: DatePeriod): TimelineLabel {\r\n\t\t\treturn {\r\n\t\t\t\ttitle: 'Year ' + datePeriod.year,\r\n\t\t\t\ttext: datePeriod.year.toString(),\r\n\t\t\t\tid: datePeriod.index\r\n\t\t\t};\r\n\t\t}\r\n\t}\r\n\r\n\texport class TimelineGranularityData {\r\n\t\tprivate dates: Date[];\r\n\t\tprivate granularities: Granularity[];\r\n\t\tprivate endingDate: Date;\r\n\r\n\t\t/**\r\n\t\t * Returns the date of the previos day \r\n\t\t * @param date The following date\r\n\t\t */\r\n\t\tpublic static previousDay(date: Date): Date {\r\n\t\t\tlet prevDay: Date = new Date(date.getTime());\r\n\t\t\tprevDay.setDate(prevDay.getDate() - 1);\r\n\t\t\treturn prevDay;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the date of the next day \r\n\t\t * @param date The previous date\r\n\t\t */\r\n\t\tpublic static nextDay(date: Date): Date {\r\n\t\t\tlet nextDay: Date = new Date(date.getTime());\r\n\t\t\tnextDay.setDate(nextDay.getDate() + 1);\r\n\t\t\treturn nextDay;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* Returns an array of dates with all the days between the start date and the end date\r\n\t\t*/\r\n\t\tprivate setDatesRange(startDate: Date, endDate: Date): void {\r\n\t\t\tthis.dates = [];\r\n\t\t\tlet date: Date = startDate;\r\n\t\t\twhile (date <= endDate) {\r\n\t\t\t\tthis.dates.push(date);\r\n\t\t\t\tdate = TimelineGranularityData.nextDay(date);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconstructor(startDate: Date, endDate: Date) {\r\n\t\t\tthis.granularities = [];\r\n\t\t\tthis.setDatesRange(startDate, endDate);\r\n\t\t\tlet lastDate: Date = this.dates[this.dates.length - 1];\r\n\t\t\tthis.endingDate = TimelineGranularityData.nextDay(lastDate);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a new granularity to the array of granularities.\r\n\t\t * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.\r\n\t\t * @param granularity The new granularity to be added\r\n\t\t */\r\n\t\tpublic addGranularity(granularity: Granularity): void {\r\n\t\t\tgranularity.resetDatePeriods();\r\n\t\t\tfor (let date of this.dates) {\r\n\t\t\t\tlet identifierArray: (string | number)[] = granularity.splitDate(date);\r\n\t\t\t\tgranularity.addDate(date, identifierArray);\r\n\t\t\t}\r\n\t\t\tgranularity.setNewEndDate(this.endingDate);\r\n\t\t\tthis.granularities.push(granularity);\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns a specific granularity from the array of granularities\r\n\t\t * @param index The index of the requested granularity\r\n\t\t */\r\n\t\tpublic getGranularity(index: number): Granularity {\r\n\t\t\treturn this.granularities[index];\r\n\t\t}\r\n\r\n\t\tpublic createGranularities(): void {\r\n\t\t\tthis.granularities = [];\r\n\t\t\tthis.addGranularity(new YearGranularity());\r\n\t\t\tthis.addGranularity(new QuarterGranularity());\r\n\t\t\tthis.addGranularity(new MonthGranularity());\r\n\t\t\tthis.addGranularity(new WeekGranularity());\r\n\t\t\tthis.addGranularity(new DayGranularity());\r\n\t\t}\r\n\r\n\t\tpublic createLabels(): void {\r\n\t\t\tthis.granularities.forEach((x) => {\r\n\t\t\t\tx.setExtendedLabel({\r\n\t\t\t\t\tdayLabels: x.getType() >= GranularityType.day ? x.createLabels(this.granularities[GranularityType.day]) : [],\r\n\t\t\t\t\tweekLabels: x.getType() >= GranularityType.week ? x.createLabels(this.granularities[GranularityType.week]) : [],\r\n\t\t\t\t\tmonthLabels: x.getType() >= GranularityType.month ? x.createLabels(this.granularities[GranularityType.month]) : [],\r\n\t\t\t\t\tquarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(this.granularities[GranularityType.quarter]) : [],\r\n\t\t\t\t\tyearLabels: x.getType() >= GranularityType.year ? x.createLabels(this.granularities[GranularityType.year]) : [],\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\texport class Utils {\r\n\t\t/**\r\n\t\t * Returns the date of the start of the selection\r\n\t\t * @param timelineData The TimelineData which contains all the date periods\r\n\t\t */\r\n\t\tpublic static getStartSelectionDate(timelineData: TimelineData): Date {\r\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the date of the end of the selection\r\n\t\t * @param timelineData The TimelineData which contains all the date periods\r\n\t\t */\r\n\t\tpublic static getEndSelectionDate(timelineData: TimelineData): Date {\r\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the date period of the end of the selection\r\n\t\t * @param timelineData The TimelineData which contains all the date periods\r\n\t\t */\r\n\t\tpublic static getEndSelectionPeriod(timelineData: TimelineData): DatePeriod {\r\n\t\t\treturn timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the color of a cell, depending on whether its date period is between the selected date periods\r\n\t\t * @param d The TimelineDataPoint of the cell\r\n\t\t * @param timelineData The TimelineData with the selected date periods\r\n\t\t * @param timelineFormat The TimelineFormat with the chosen colors\r\n\t\t */\r\n\t\tpublic static getCellColor(d: TimelineDatapoint, timelineData: TimelineData, cellFormat: CellFormat): string {\r\n\t\t\tlet inSelectedPeriods: boolean = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);\r\n\t\t\treturn inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the granularity type of the given granularity name\r\n\t\t * @param granularityName The name of the granularity\r\n\t\t */\r\n\t\tpublic static getGranularityType(granularityName: string): GranularityType {\r\n\t\t\tlet index: number = _.findIndex(GranularityNames, x => x.name === granularityName);\r\n\t\t\treturn GranularityNames[index].granularityType;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the name of the granularity type\r\n\t\t * @param granularity The type of granularity\r\n\t\t */\r\n\t\tpublic static getGranularityName(granularity: GranularityType): string {\r\n\t\t\tlet index: number = _.findIndex(GranularityNames, x => x.granularityType === granularity);\r\n\t\t\treturn GranularityNames[index].name;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.\r\n\t\t * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly\r\n\t\t * @param timelineData The TimelineData that contains the date periods\r\n\t\t * @param startDate The starting date of the selection\r\n\t\t * @param endDate The ending date of the selection\r\n\t\t */\r\n\t\tpublic static separateSelection(timelineData: TimelineData, startDate: Date, endDate: Date): void {\r\n\t\t\tlet datePeriods: DatePeriod[] = timelineData.currentGranularity.getDatePeriods();\r\n\t\t\tlet startDateIndex: number = _.findIndex(datePeriods, x => startDate < x.endDate);\r\n\t\t\tlet endDateIndex: number = _.findIndex(datePeriods, x => endDate <= x.endDate);\r\n\t\t\ttimelineData.selectionStartIndex = startDateIndex;\r\n\t\t\ttimelineData.selectionEndIndex = endDateIndex;\r\n\t\t\tlet startRatio: number = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);\r\n\t\t\tlet endRatio: number = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);\r\n\t\t\tif (endRatio > 0)\r\n\t\t\t\ttimelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate);\r\n\t\t\tif (startRatio > 0) {\r\n\t\t\t\tlet startFration: number = datePeriods[startDateIndex].fraction - startRatio;\r\n\t\t\t\ttimelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate);\r\n\t\t\t\ttimelineData.selectionStartIndex++;\r\n\t\t\t\ttimelineData.selectionEndIndex++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Returns the ratio of the given date compared to the whole date period.\r\n\t\t * The ratio is calculated either from the start or the end of the date period.\r\n\t\t * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,\r\n\t\t * is 0.2142 from the start of the month, or 0.7857 from the end of the month.\r\n\t\t * @param datePeriod The date period that contain the specified date\r\n\t\t * @param date The date\r\n\t\t * @param fromStart Whether to calculater the ratio from the start of the date period.\r\n\t\t */\r\n\t\tpublic static getDateRatio(datePeriod: DatePeriod, date: Date, fromStart: boolean): number {\r\n\t\t\tlet dateDifference: number = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();\r\n\t\t\tlet periodDifference: number = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();\r\n\t\t\treturn periodDifference === 0 ? 0 : dateDifference / periodDifference;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* Returns the time range text, depending on the given granularity (e.g. \"Feb 3 2014 - Apr 5 2015\", \"Q1 2014 - Q2 2015\")\r\n\t\t*/\r\n\t\tpublic static timeRangeText(timelineData: TimelineData): string {\r\n\t\t\tlet startSelectionDateArray: (string | number)[] = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));\r\n\t\t\tlet endSelectionDateArray: (string | number)[] = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);\r\n\t\t\treturn startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');\r\n\t\t}\r\n\r\n\t\tpublic static dateRangeText(datePeriod: DatePeriod): string {\r\n\t\t\treturn datePeriod.startDate.toDateString() + ' - ' + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Combines the first two partial date periods, into a single date period.\r\n\t\t * Returns whether a partial date period was found.\r\n\t\t * i.e. combines \"Feb 1 2016 - Feb 5 2016\" with \"Feb 5 2016 - Feb 29 2016\" into \"Feb 1 2016 - Feb 29 2016\"\r\n\t\t * @param datePeriods The list of date periods\r\n\t\t */\r\n\t\tpublic static unseparateSelection(datePeriods: DatePeriod[]): boolean {\r\n\t\t\tlet separationIndex: number = _.findIndex(datePeriods, x => x.fraction < 1);\r\n\t\t\tif (separationIndex >= 0) {\r\n\t\t\t\tdatePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;\r\n\t\t\t\tdatePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;\r\n\t\t\t\tdatePeriods.splice(separationIndex + 1, 1);\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\texport interface TimelineProperties {\r\n\t\tleftMargin: number;\r\n\t\trightMargin: number;\r\n\t\ttopMargin: number;\r\n\t\tbottomMargin: number;\r\n\t\ttextYPosition: number;\r\n\t\tstartXpoint: number;\r\n\t\tstartYpoint: number;\r\n\t\telementWidth: number;\r\n\t\telement: any;\r\n\t\tcellWidth: number;\r\n\t\tcellHeight: number;\r\n\t\tcellsYPosition: number;\r\n\t}\r\n\r\n\texport interface TimelineFormat {\r\n\t\tcellFormat?: CellFormat;\r\n\t\trangeTextFormat?: LabelFormat;\r\n\t\tlabelFormat?: LabelFormat;\r\n\t\tcalendarFormat?: CalendarFormat;\r\n\t}\r\n\r\n\texport interface LabelFormat {\r\n\t\tshowProperty: boolean;\r\n\t\tsizeProperty: number;\r\n\t\tcolorProperty: string;\r\n\t}\r\n\r\n\texport interface CalendarFormat {\r\n\t\tfirstMonthProperty: number;\r\n\t\tfirstDayProperty: number;\r\n\t\tweekDayProperty: number;\r\n\t}\r\n\r\n\texport interface CellFormat {\r\n\t\tcolorInProperty: string;\r\n\t\tcolorOutProperty: string;\r\n\t}\r\n\r\n\texport interface TimelineData {\r\n\t\tdragging?: boolean;\r\n\t\tcategorySourceName?: string;\r\n\t\tcolumnIdentity?: powerbi.data.SQColumnRefExpr;\r\n\t\ttimelineDatapoints?: TimelineDatapoint[];\r\n\t\telementsCount?: number;\r\n\t\tselectionStartIndex?: number;\r\n\t\tselectionEndIndex?: number;\r\n\t\tcursorDataPoints?: CursorDatapoint[];\r\n\t\tcurrentGranularity?: Granularity;\r\n\t}\r\n\r\n\texport interface CursorDatapoint {\r\n\t\tx: number;\r\n\t\tcursorIndex: number;\r\n\t\tselectionIndex: number;\r\n\t}\r\n\r\n\texport interface TimelineDatapoint {\r\n\t\tindex: number;\r\n\t\tdatePeriod: DatePeriod;\r\n\t}\r\n\r\n\texport interface DateDictionary {\r\n\t\t[year: number]: Date;\r\n\t}\r\n\r\n\texport class Calendar {\r\n\t\tprivate firstDayOfWeek: number;\r\n\t\tprivate firstMonthOfYear: number;\r\n\t\tprivate firstDayOfYear: number;\r\n\t\tprivate dateOfFirstWeek: DateDictionary;\r\n\t\tprivate quarterFirstMonths: number[];\r\n\r\n\t\tpublic getFirstDayOfWeek(): number {\r\n\t\t\treturn this.firstDayOfWeek;\r\n\t\t}\r\n\r\n\t\tpublic getFirstMonthOfYear(): number {\r\n\t\t\treturn this.firstMonthOfYear;\r\n\t\t}\r\n\r\n\t\tpublic getFirstDayOfYear(): number {\r\n\t\t\treturn this.firstDayOfYear;\r\n\t\t}\r\n\r\n\t\tpublic getQuarterStartDate(year: number, quarterIndex: number): Date {\r\n\t\t\treturn new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);\r\n\t\t}\r\n\r\n\t\tpublic isChanged(calendarFormat: CalendarFormat): boolean {\r\n\t\t\treturn this.firstMonthOfYear !== (calendarFormat.firstMonthProperty - 1)\r\n\t\t\t\t|| this.firstDayOfYear !== calendarFormat.firstDayProperty\r\n\t\t\t\t|| this.firstDayOfWeek !== calendarFormat.weekDayProperty;\r\n\t\t}\r\n\r\n\t\tconstructor(calendarFormat: CalendarFormat) {\r\n\t\t\tthis.firstDayOfWeek = calendarFormat.weekDayProperty;\r\n\t\t\tthis.firstMonthOfYear = calendarFormat.firstMonthProperty - 1;\r\n\t\t\tthis.firstDayOfYear = calendarFormat.firstDayProperty;\r\n\t\t\tthis.dateOfFirstWeek = {};\r\n\t\t\tthis.quarterFirstMonths = [0, 3, 6, 9].map((x) => x + this.firstMonthOfYear);\r\n\t\t}\r\n\r\n\t\tprivate calculateDateOfFirstWeek(year: number): Date {\r\n\t\t\tlet date: Date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear);\r\n\t\t\twhile (date.getDay() !== this.firstDayOfWeek)\r\n\t\t\t\tdate = TimelineGranularityData.nextDay(date);\r\n\t\t\treturn date;\r\n\t\t}\r\n\r\n\t\tpublic getDateOfFirstWeek(year: number): Date {\r\n\t\t\tif (!this.dateOfFirstWeek[year])\r\n\t\t\t\tthis.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year);\r\n\t\t\treturn this.dateOfFirstWeek[year];\r\n\t\t}\r\n\t}\r\n\r\n\texport class Timeline implements IVisual {\r\n\t\tprivate requiresNoUpdate: boolean = false;\r\n\t\tprivate foreignSelection: boolean = false;\r\n\t\tprivate timelineProperties: TimelineProperties;\r\n\t\tprivate timelineFormat: TimelineFormat;\r\n\t\tprivate timelineData: TimelineData;\r\n\t\tprivate timelineGranularityData: TimelineGranularityData;\r\n\t\tprivate hostServices: IVisualHostServices;\r\n\t\tprivate svg: D3.Selection;\r\n\t\tprivate timelineDiv: D3.Selection;\r\n\t\tprivate body: D3.Selection;\r\n\t\tprivate rangeText: D3.Selection;\r\n\t\tprivate mainGroupElement: D3.Selection;\r\n\t\tprivate yearLabelsElement: D3.Selection;\r\n\t\tprivate quarterLabelsElement: D3.Selection;\r\n\t\tprivate monthLabelsElement: D3.Selection;\r\n\t\tprivate weekLabelsElement: D3.Selection;\r\n\t\tprivate dayLabelsElement: D3.Selection;\r\n\t\tprivate cellsElement: D3.Selection;\r\n\t\tprivate cursorGroupElement: D3.Selection;\r\n\t\tprivate selectorContainer: D3.Selection;\r\n\t\tprivate options: VisualUpdateOptions;\r\n\t\tprivate periodSlicerRect: D3.Selection;\r\n\t\tprivate selectedText: D3.Selection;\r\n\t\tprivate selector = ['Y', 'Q', 'M', 'W', 'D'];\r\n\t\tprivate initialized: boolean;\r\n\t\tprivate selectionManager: SelectionManager;\r\n\t\tprivate clearCatcher: D3.Selection;\r\n\t\tprivate dataView: DataView;\r\n\t\tprivate valueType: string;\r\n\t\tprivate values: any[];\r\n\t\tprivate svgWidth: number;\r\n\t\tprivate newGranularity: GranularityType;\r\n\t\tpublic static calendar: Calendar;\r\n\t\tpublic static capabilities: VisualCapabilities = {\r\n\t\t\tdataRoles: [{\r\n                name: 'Time',\r\n                kind: powerbi.VisualDataRoleKind.Grouping,\r\n                displayName: 'Time'\r\n            }],\r\n\t\t\tdataViewMappings: [{\r\n\t\t\t\tconditions: [\r\n\t\t\t\t\t{ 'Time': { max: 1 } }\r\n\t\t\t\t],\r\n\t\t\t\tcategorical: {\r\n\t\t\t\t\tcategories: {\r\n\t\t\t\t\t\tfor: { in: 'Time' },\r\n\t\t\t\t\t\tdataReductionAlgorithm: { sample: {} }\r\n\t\t\t\t\t},\r\n\t\t\t\t\tvalues: {\r\n\t\t\t\t\t\tselect:\r\n\t\t\t\t\t\t[{\r\n\t\t\t\t\t\t\tbind: { to: 'Time' }\r\n\t\t\t\t\t\t}]\r\n\t\t\t\t\t},\r\n\t\t\t\t}\r\n\t\t\t}],\r\n\t\t\tobjects: {\r\n\t\t\t\tgeneral: {\r\n\t\t\t\t\tdisplayName: 'General',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tformatString: {\r\n\t\t\t\t\t\t\ttype: {\r\n\t\t\t\t\t\t\t\tformatting: {\r\n\t\t\t\t\t\t\t\t\tformatString: true\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tselected: {\r\n\t\t\t\t\t\t\ttype: { bool: true }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfilter: {\r\n\t\t\t\t\t\t\ttype: { filter: {} },\r\n\t\t\t\t\t\t\trule: {\r\n\t\t\t\t\t\t\t\toutput: {\r\n\t\t\t\t\t\t\t\t\tproperty: 'selected',\r\n\t\t\t\t\t\t\t\t\tselector: ['Time'],\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t},\r\n\t\t\t\tcalendar: {\r\n\t\t\t\t\tdisplayName: 'Fiscal Year Start',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tmonth: {\r\n\t\t\t\t\t\t\tdisplayName: 'Month',\r\n\t\t\t\t\t\t\ttype: { enumeration: Months }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tday: {\r\n\t\t\t\t\t\t\tdisplayName: 'Day',\r\n\t\t\t\t\t\t\ttype: { numeric: true }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tweekDay: {\r\n\t\t\t\t\tdisplayName: 'First Day of Week',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tday: {\r\n\t\t\t\t\t\t\tdisplayName: 'Day',\r\n\t\t\t\t\t\t\ttype: { enumeration: WeekDays }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\trangeHeader: {\r\n\t\t\t\t\tdisplayName: 'Range Header',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tshow: {\r\n\t\t\t\t\t\t\tdisplayName: 'Show',\r\n\t\t\t\t\t\t\ttype: { bool: true }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfontColor: {\r\n\t\t\t\t\t\t\tdisplayName: 'Font color',\r\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\ttextSize: {\r\n\t\t\t\t\t\t\tdisplayName: 'Text Size',\r\n\t\t\t\t\t\t\ttype: { numeric: true }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tcells: {\r\n\t\t\t\t\tdisplayName: 'Cells',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tfillSelected: {\r\n\t\t\t\t\t\t\tdisplayName: 'Selected cell color',\r\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfillUnselected: {\r\n\t\t\t\t\t\t\tdisplayName: 'Unselected cell color',\r\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tlabels: {\r\n\t\t\t\t\tdisplayName: 'Labels',\r\n\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\tshow: {\r\n\t\t\t\t\t\t\tdisplayName: 'Show',\r\n\t\t\t\t\t\t\ttype: { bool: true }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tfontColor: {\r\n\t\t\t\t\t\t\tdisplayName: 'Font color',\r\n\t\t\t\t\t\t\ttype: { fill: { solid: { color: true } } }\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\ttextSize: {\r\n\t\t\t\t\t\t\tdisplayName: 'Text Size',\r\n\t\t\t\t\t\t\ttype: { numeric: true }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tprivate timelineMargins: TimelineMargins =\r\n\t\t{\r\n\t\t\tLeftMargin: 15,\r\n\t\t\tRightMargin: 15,\r\n\t\t\tTopMargin: 15,\r\n\t\t\tBottomMargin: 10,\r\n\t\t\tCellWidth: 40,\r\n\t\t\tCellHeight: 25,\r\n\t\t\tStartXpoint: 10,\r\n\t\t\tStartYpoint: 20,\r\n\t\t\tElementWidth: 30,\r\n\t\t\tMinCellWidth: 30,\r\n\t\t\tMaxCellHeight: 60,\r\n\t\t\tPeriodSlicerRectWidth: 15,\r\n\t\t\tPeriodSlicerRectHeight: 23\r\n\t\t};\r\n\r\n\t\tprivate defaultTimelineProperties: DefaultTimelineProperties =\r\n\t\t{\r\n\t\t\tDefaultLabelsShow: true,\r\n\t\t\tTimelineDefaultTextSize: 9,\r\n\t\t\tTimelineDefaultCellColor: \"#ADD8E6\",\r\n\t\t\tTimelineDefaultCellColorOut: \"#FFFFFF\",\r\n\t\t\tTimelineDefaultTimeRangeShow: true,\r\n\t\t\tDefaultTimeRangeColor: \"#777777\",\r\n\t\t\tDefaultLabelColor: \"#777777\",\r\n\t\t\tDefaultGranularity: GranularityType.month,\r\n\t\t\tDefaultFirstMonth: 1,\r\n\t\t\tDefaultFirstDay: 1,\r\n\t\t\tDefaultFirstWeekDay: 0\r\n\t\t};\r\n\r\n\t\tprivate timelineSelectors: TimelineSelectors =\r\n\t\t{\r\n\t\t\tTimelineVisual: createClassAndSelector('Timeline'),\r\n\t\t\tSelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),\r\n\t\t\ttextLabel: createClassAndSelector('label'),\r\n\t\t\tLowerTextCell: createClassAndSelector('lowerTextCell'),\r\n\t\t\tUpperTextCell: createClassAndSelector('upperTextCell'),\r\n\t\t\tUpperTextArea: createClassAndSelector('upperTextArea'),\r\n\t\t\tLowerTextArea: createClassAndSelector('lowerTextArea'),\r\n\t\t\tRangeTextArea: createClassAndSelector('rangeTextArea'),\r\n\t\t\tCellsArea: createClassAndSelector('cellsArea'),\r\n\t\t\tCursorsArea: createClassAndSelector('cursorsArea'),\r\n\t\t\tMainArea: createClassAndSelector('mainArea'),\r\n\t\t\tSelectionCursor: createClassAndSelector('selectionCursor'),\r\n\t\t\tCell: createClassAndSelector('cell'),\r\n\t\t\tCellRect: createClassAndSelector('cellRect'),\r\n\t\t\tVertLine: createClassAndSelector('timelineVertLine'),\r\n\t\t\tTimelineSlicer: createClassAndSelector('timelineSlicer'),\r\n\t\t\tPeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),\r\n\t\t\tPeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),\r\n\t\t\tPeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),\r\n\t\t\tPeriodSlicerRect: createClassAndSelector('periodSlicerRect')\r\n\t\t};\r\n\r\n\t\t/**\r\n\t\t * Changes the current granularity depending on the given granularity type\r\n\t\t * Separates the new granularity's date periods which contain the start/end selection\r\n\t\t * Unseparates the date periods of the previous granularity.\r\n\t\t * @param granularity The new granularity type\r\n\t\t */\r\n\t\tpublic changeGranularity(granularity: GranularityType, startDate: Date, endDate: Date): void {\r\n\t\t\tif (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))\r\n\t\t\t\tUtils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());\r\n\t\t\tthis.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);\r\n\t\t\tUtils.separateSelection(this.timelineData, startDate, endDate);\r\n\t\t}\r\n\r\n\t\tpublic init(options: VisualInitOptions): void {\r\n\t\t\tthis.hostServices = options.host;\r\n\t\t\tthis.initialized = false;\r\n\t\t\tlet element = options.element;\r\n\t\t\tthis.selectionManager = new SelectionManager({ hostServices: options.host });\r\n\r\n\t\t\tthis.timelineProperties = {\r\n\t\t\t\telement: element,\r\n\t\t\t\ttextYPosition: 50,\r\n\t\t\t\tcellsYPosition: this.timelineMargins.TopMargin * 3 + 65,\r\n\t\t\t\ttopMargin: this.timelineMargins.TopMargin,\r\n\t\t\t\tbottomMargin: this.timelineMargins.BottomMargin,\r\n\t\t\t\tleftMargin: this.timelineMargins.LeftMargin,\r\n\t\t\t\tstartXpoint: this.timelineMargins.StartXpoint,\r\n\t\t\t\tstartYpoint: this.timelineMargins.StartYpoint,\r\n\t\t\t\tcellWidth: this.timelineMargins.CellWidth,\r\n\t\t\t\tcellHeight: this.timelineMargins.CellHeight,\r\n\t\t\t\telementWidth: this.timelineMargins.ElementWidth,\r\n\t\t\t\trightMargin: this.timelineMargins.RightMargin\r\n\t\t\t};\r\n\r\n\t\t\tthis.body = d3.select(element.get(0));\r\n\t\t\tthis.timelineDiv = this.body.append('div');\r\n\t\t\tthis.svg = this.timelineDiv.append('svg').attr('width', px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, true);\r\n\t\t\tthis.clearCatcher = appendClearCatcher(this.svg);\r\n\r\n\t\t\tthis.clearCatcher.data([this])\r\n\t\t\t\t.on(\"click\", (timeline: Timeline) => timeline.clear())\r\n\t\t\t\t.on(\"touchstart\", (timeline: Timeline) => timeline.clear());\r\n\r\n\t\t\tthis.rangeText = this.svg.append('g').classed(this.timelineSelectors.RangeTextArea.class, true).append('text');\r\n\t\t\tthis.mainGroupElement = this.svg.append('g').classed(this.timelineSelectors.MainArea.class, true);\r\n\t\t\tthis.yearLabelsElement = this.mainGroupElement.append('g');\r\n\t\t\tthis.quarterLabelsElement = this.mainGroupElement.append('g');\r\n\t\t\tthis.monthLabelsElement = this.mainGroupElement.append('g');\r\n\t\t\tthis.weekLabelsElement = this.mainGroupElement.append('g');\r\n\t\t\tthis.dayLabelsElement = this.mainGroupElement.append('g');\r\n\t\t\tthis.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelectors.CellsArea.class, true);\r\n\t\t\tthis.cursorGroupElement = this.svg.append('g').classed(this.timelineSelectors.CursorsArea.class, true);\r\n\t\t}\r\n\r\n\t\tprivate clear(): void {\r\n\t\t\tthis.selectionManager.clear();\r\n\r\n\t\t\tif (this.timelineData) {\r\n\t\t\t\tthis.timelineData.selectionStartIndex = 0;\r\n\t\t\t\tthis.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;\r\n\t\t\t\tif (_.any(this.timelineData.timelineDatapoints, (x) => x.index % 1 !== 0))\r\n\t\t\t\t\tthis.selectPeriod(this.timelineData.currentGranularity.getType());\r\n\t\t\t\telse {\r\n\t\t\t\t\tTimeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth);\r\n\t\t\t\t\tthis.fillCells(this.timelineFormat.cellFormat);\r\n\t\t\t\t\tthis.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\r\n\t\t\t\t\tthis.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\r\n\t\t\t\t}\r\n\t\t\t\tthis.setSelection(this.timelineData);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tprivate drawGranular(timelineProperties: TimelineProperties): void {\r\n\t\t\tlet dragPeriodRectState: boolean = false;\r\n\t\t\tlet startXpoint = timelineProperties.startXpoint;\r\n\t\t\tlet startYpoint = timelineProperties.startYpoint;\r\n\t\t\tlet elementWidth = timelineProperties.elementWidth;\r\n\t\t\tthis.selectorContainer = this.svg.append('g').classed(this.timelineSelectors.TimelineSlicer.class, true);\r\n\r\n\t\t\tthis.selectorContainer.on('mouseleave', d => dragPeriodRectState = false);\r\n\t\t\tlet fillRect = this.selectorContainer.append('rect');\r\n\t\t\tlet selectorPeriods = this.selector;\r\n\t\t\tfillRect.attr({\r\n\t\t\t\theight: px(1),\r\n\t\t\t\tx: px(startXpoint),\r\n\t\t\t\ty: px(startYpoint + 2),\r\n\t\t\t\twidth: px((selectorPeriods.length - 1) * elementWidth)\r\n\t\t\t});\r\n\r\n\t\t\tlet fillVertLine = this.selectorContainer.selectAll(\"vertLines\")\r\n\t\t\t\t.data(selectorPeriods).enter().append('rect');\r\n\t\t\tfillVertLine\r\n\t\t\t\t.classed(this.timelineSelectors.VertLine.class, true)\r\n\t\t\t\t.attr({\r\n\t\t\t\t\tx: (d, index) => px(startXpoint + index * elementWidth),\r\n\t\t\t\t\ty: px(startYpoint),\r\n\t\t\t\t\twidth: px(2),\r\n\t\t\t\t\theight: px(3)\r\n\t\t\t\t})\r\n\t\t\t\t.style({ 'cursor': 'pointer' });\r\n\r\n\t\t\tlet text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector)\r\n\t\t\t\t.data(selectorPeriods)\r\n\t\t\t\t.enter()\r\n\t\t\t\t.append(\"text\")\r\n\t\t\t\t.classed(this.timelineSelectors.PeriodSlicerGranularities.class, true);\r\n\r\n\t\t\tlet textLabels: any;\r\n\t\t\ttextLabels = text.text((d) => d)\r\n\t\t\t\t.attr({\r\n\t\t\t\t\tx: (d, index) => px(startXpoint - 3 + index * elementWidth),\r\n\t\t\t\t\ty: px(startYpoint - 3)\r\n\t\t\t\t});\r\n\t\t\tthis.selectedText = this.selectorContainer.append(\"text\").classed(this.timelineSelectors.PeriodSlicerSelection.class, true);\r\n\t\t\tthis.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))\r\n\t\t\t\t.attr({\r\n\t\t\t\t\tx: px(startXpoint + 2 * elementWidth),\r\n\t\t\t\t\ty: px(startYpoint + 17),\r\n\t\t\t\t});\r\n\r\n\t\t\tlet selRects = this.selectorContainer\r\n\t\t\t\t.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector)\r\n\t\t\t\t.data(selectorPeriods)\r\n\t\t\t\t.enter()\r\n\t\t\t\t.append('rect')\r\n\t\t\t\t.classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, true);\r\n\r\n\t\t\tlet clickHandler: (d: any, index: number) => void = (d: any, index: number) => {\r\n\t\t\t\tthis.selectPeriod(index);\r\n\t\t\t\tdragPeriodRectState = true;\r\n\t\t\t};\r\n\r\n\t\t\tselRects.attr({\r\n\t\t\t\t\tx: (d, index) => px(startXpoint - elementWidth / 2 + index * elementWidth),\r\n\t\t\t\t\ty: px(3),\r\n\t\t\t\t\twidth: px(elementWidth),\r\n\t\t\t\t\theight: px(23)\r\n\t\t\t\t})\r\n\t\t\t\t.style({ 'cursor': 'pointer' })\r\n\t\t\t\t.on('mousedown', clickHandler)\r\n\t\t\t\t.on('touchstart', clickHandler)\r\n\t\t\t\t.on('mouseup', () => dragPeriodRectState = false)\r\n\t\t\t\t.on('touchend', () => dragPeriodRectState = false)\r\n\t\t\t\t.on(\"mouseover\", (d, index) => {\r\n\t\t\t\t\tif (dragPeriodRectState) {\r\n\t\t\t\t\t\tthis.selectPeriod(index);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\tlet dragPeriodRect = d3.behavior.drag()\r\n\t\t\t\t.on(\"dragstart\", function (e, b) {\r\n\t\t\t\t\tdragPeriodRectState = true;\r\n\t\t\t\t})\r\n\t\t\t\t.on(\"dragend\", function (e, b) {\r\n\t\t\t\t\tdragPeriodRectState = false;\r\n\t\t\t\t});\r\n\r\n\t\t\tthis.periodSlicerRect = this.selectorContainer\r\n\t\t\t\t.append('rect').classed(this.timelineSelectors.PeriodSlicerRect.class, true)\r\n\t\t\t\t.attr({\r\n\t\t\t\t\tx: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),\r\n\t\t\t\t\ty: px(startYpoint - 16),\r\n\t\t\t\t\trx: px(4),\r\n\t\t\t\t\twidth: px(15),\r\n\t\t\t\t\theight: px(23)\r\n\t\t\t\t})\r\n\t\t\t\t.on('mouseup', d => dragPeriodRectState = false);\r\n\t\t\tthis.periodSlicerRect.call(dragPeriodRect);\r\n\t\t}\r\n\r\n\t\tpublic redrawPeriod(granularity: GranularityType): void {\r\n\t\t\tlet dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;\r\n\t\t\tthis.periodSlicerRect.transition().attr(\"x\", px(dx - 7));\r\n\t\t\tthis.selectedText.text(Utils.getGranularityName(granularity));\r\n\t\t\tlet startDate: Date = Utils.getStartSelectionDate(this.timelineData);\r\n\t\t\tlet endDate: Date = Utils.getEndSelectionDate(this.timelineData);\r\n\t\t\tthis.changeGranularity(granularity, startDate, endDate);\r\n\t\t}\r\n\r\n\t\tprivate static setMeasures(labelFormat: LabelFormat, granularityType: GranularityType, datePeriodsCount: number, viewport: IViewport, timelineProperties: TimelineProperties, timelineMargins: TimelineMargins) {\r\n\t\t\ttimelineProperties.cellsYPosition = timelineProperties.textYPosition;\r\n\t\t\tlet labelSize = fromPointToPixel(labelFormat.sizeProperty);\r\n\t\t\tif (labelFormat.showProperty)\r\n\t\t\t\ttimelineProperties.cellsYPosition += labelSize * 1.5 * (granularityType + 1);\r\n\t\t\tlet svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin);\r\n\t\t\tlet maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount;\r\n\t\t\tlet height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20));\r\n\t\t\tlet width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);\r\n\t\t\ttimelineProperties.cellHeight = height;\r\n\t\t\ttimelineProperties.cellWidth = width;\r\n\t\t}\r\n\r\n\t\tprivate visualChangeOnly(options: VisualUpdateOptions): boolean {\r\n\t\t\tif (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata &&\r\n\t\t\t\tthis.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {\r\n\t\t\t\tlet newObjects = options.dataViews[0].metadata.objects;\r\n\t\t\t\tlet oldObjects = this.options.dataViews[0].metadata.objects;\r\n\t\t\t\tlet properties = ['rangeHeader', 'cells', 'labels'];\r\n\t\t\t\tlet metadataChanged = !properties.every((x) => _.isEqual(newObjects ? newObjects[x] : undefined, oldObjects ? oldObjects[x] : undefined));\r\n\t\t\t\treturn options.suppressAnimations || metadataChanged;\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tprivate unavailableType(dataViewCategorical: DataViewCategorical): boolean {\r\n\t\t\treturn !dataViewCategorical.categories\r\n\t\t\t\t|| dataViewCategorical.categories.length !== 1\r\n\t\t\t\t|| !dataViewCategorical.categories[0].values\r\n\t\t\t\t|| dataViewCategorical.categories[0].values.length === 0\r\n\t\t\t\t|| !dataViewCategorical.categories[0].source\r\n\t\t\t\t|| !dataViewCategorical.categories[0].source.type;\r\n\t\t}\r\n\r\n\t\tprivate unavailableChildIdentityField(dataViewTree: DataViewTree): boolean {\r\n\t\t\treturn !dataViewTree.root || !dataViewTree.root.childIdentityFields || dataViewTree.root.childIdentityFields.length === 0;\r\n\t\t}\r\n\r\n\t\tprivate createTimelineOptions(dataView: DataView): boolean {\r\n\t\t\tthis.dataView = dataView;\r\n\t\t\tif (!dataView.categorical\r\n\t\t\t\t|| !dataView.metadata\r\n\t\t\t\t|| this.unavailableType(dataView.categorical)\r\n\t\t\t\t|| !dataView.tree\r\n\t\t\t\t|| this.unavailableChildIdentityField(dataView.tree))\r\n\t\t\t\treturn false;\r\n\t\t\tlet columnExp = <powerbi.data.SQColumnRefExpr>dataView.tree.root.childIdentityFields[0];\r\n\t\t\tthis.valueType = columnExp ? columnExp.ref : null;\r\n\t\t\tif (!(dataView.categorical.categories[0].source.type.dateTime ||\r\n\t\t\t\t(dataView.categorical.categories[0].source.type.numeric && (this.valueType === 'Year' || this.valueType === 'Date'))))\r\n\t\t\t\treturn false;\r\n\t\t\tthis.values = this.prepareValues(this.dataView.categorical.categories[0].values);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t//Public for testability.\r\n\t\tpublic prepareValues(values) {\r\n\t\t\t// remove null strings and rebuild string type date \r\n\t\t\t// (BUG #7266283 IN PBI-service)\r\n\t\t\tvalues = values.filter(Boolean);\r\n\t\t\tfor (var i in values) { \r\n\t\t\t\tvar item = values[i];\r\n\t\t\t\tif(typeof(item) === 'String' && (String(new Date(item)) !== 'Invalid Date')){\r\n\t\t\t\t\treturn values[i] = new Date(item);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\treturn values;\r\n\t\t}\r\n\r\n\t\tprivate createTimelineData() {\r\n\t\t\tlet startDate: Date;\r\n\t\t\tlet endDate: Date;\r\n\t\t\tif (this.valueType === 'Year') {\r\n\t\t\t\tlet years: number[] = this.values;\r\n\t\t\t\tstartDate = new Date(_.min(years), 0);\r\n\t\t\t\tendDate = new Date(_.max(years), 11);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet dates: Date[] = this.values;\r\n\t\t\t\tstartDate = _.min(dates);\r\n\t\t\t\tendDate = _.max(dates);\r\n\t\t\t}\r\n\t\t\tif (!this.initialized)\r\n\t\t\t\tthis.drawGranular(this.timelineProperties);\r\n\t\t\tif (this.initialized) {\r\n\t\t\t\tlet actualEndDate = TimelineGranularityData.nextDay(endDate);\r\n\t\t\t\tlet daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();\r\n\t\t\t\tlet prevStartDate = daysPeriods[0].startDate;\r\n\t\t\t\tlet prevEndDate = daysPeriods[daysPeriods.length - 1].endDate;\r\n\t\t\t\tlet changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();\r\n\t\t\t\tthis.newGranularity = this.timelineData.currentGranularity.getType();\r\n\t\t\t\tif (changedSelection) {\r\n\t\t\t\t\tthis.foreignSelection = true;\r\n\t\t\t\t\tthis.changeGranularity(this.newGranularity, startDate, actualEndDate);\r\n\t\t\t\t\tthis.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (actualEndDate < prevEndDate)\r\n\t\t\t\t\t\tendDate = daysPeriods[daysPeriods.length - 1].startDate;\r\n\t\t\t\t\tif (startDate > prevStartDate)\r\n\t\t\t\t\t\tstartDate = prevStartDate;\r\n\t\t\t\t\tthis.initialized = false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!this.initialized) {\r\n\t\t\t\tthis.timelineGranularityData = new TimelineGranularityData(startDate, endDate);\r\n\t\t\t\tthis.timelineData = {\r\n\t\t\t\t\telementsCount: 0,\r\n\t\t\t\t\ttimelineDatapoints: [],\r\n\t\t\t\t\tcursorDataPoints: new Array<CursorDatapoint>()\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic update(options: VisualUpdateOptions): void {\r\n\t\t\tlet visualChange: boolean = this.visualChangeOnly(options);\r\n\t\t\tthis.requiresNoUpdate = this.requiresNoUpdate && !visualChange;\r\n\t\t\tif (this.requiresNoUpdate) {\r\n\t\t\t\tif (this.foreignSelection)\r\n\t\t\t\t\tthis.foreignSelection = false;\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.requiresNoUpdate = false;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.options = options;\r\n\t\t\tif (!options.dataViews || !options.dataViews[0])\r\n\t\t\t\treturn;\r\n\t\t\tlet validOptions: boolean = this.createTimelineOptions(options.dataViews[0]);\r\n\t\t\tif (!validOptions) {\r\n\t\t\t\tthis.clearData();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tthis.newGranularity = this.defaultTimelineProperties.DefaultGranularity;\r\n\t\t\tif (!visualChange)\r\n\t\t\t\tthis.createTimelineData();\r\n\t\t\tthis.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins);\r\n\t\t\tthis.render(this.timelineData, this.timelineFormat, this.timelineProperties, options);\r\n\t\t\tthis.initialized = true;\r\n\t\t}\r\n\r\n\t\tpublic selectPeriod(periodNameIndex): void {\r\n\t\t\tthis.redrawPeriod(periodNameIndex);\r\n\t\t\tthis.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins);\r\n\t\t\tthis.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);\r\n\t\t}\r\n\r\n\t\tprivate static isDataNotMatch(dataView): boolean {\r\n\t\t\tif (dataView.categorical.categories.length <= 0 ||\r\n\t\t\t\tdataView.categorical.categories[0] === undefined ||\r\n\t\t\t\tdataView.categorical.categories[0].identityFields === undefined ||\r\n\t\t\t\tdataView.categorical.categories[0].identityFields.length <= 0)\r\n\t\t\t\treturn true;\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tpublic static converter(timelineData: TimelineData, timelineProperties: TimelineProperties, defaultTimelineProperties: DefaultTimelineProperties, timelineGranularityData: TimelineGranularityData, dataView: DataView, initialized: boolean, granularityType: GranularityType, viewport: IViewport, timelineMargins: TimelineMargins): TimelineFormat {\r\n\t\t\tlet timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);\r\n\t\t\tif (!initialized) {\r\n\t\t\t\ttimelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 0 });\r\n\t\t\t\ttimelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 1 });\r\n\t\t\t}\r\n\t\t\tif (!initialized || Timeline.calendar.isChanged(timelineFormat.calendarFormat)) {\r\n\t\t\t\tTimeline.calendar = new Calendar(timelineFormat.calendarFormat);\r\n\t\t\t\ttimelineGranularityData.createGranularities();\r\n\t\t\t\ttimelineGranularityData.createLabels();\r\n\t\t\t\ttimelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);\r\n\t\t\t\ttimelineData.selectionStartIndex = 0;\r\n\t\t\t\ttimelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;\r\n\t\t\t}\r\n\t\t\ttimelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;\r\n\t\t\ttimelineData.columnIdentity = <powerbi.data.SQColumnRefExpr>dataView.categorical.categories[0].identityFields[0];\r\n\t\t\tif (dataView.categorical.categories[0].source.type.numeric) {\r\n\t\t\t\ttimelineData.columnIdentity.ref = \"Date\";\r\n\t\t\t}\r\n\t\t\tif (this.isDataNotMatch(dataView))\r\n\t\t\t\treturn;\r\n\t\t\tlet timelineElements: DatePeriod[] = timelineData.currentGranularity.getDatePeriods();\r\n\t\t\ttimelineData.elementsCount = timelineElements.length;\r\n\t\t\ttimelineData.timelineDatapoints = [];\r\n\t\t\tfor (let currentTimePeriod of timelineElements) {\r\n\t\t\t\tlet datapoint: TimelineDatapoint = {\r\n\t\t\t\t\tindex: currentTimePeriod.index,\r\n\t\t\t\t\tdatePeriod: currentTimePeriod\r\n\t\t\t\t};\r\n\t\t\t\ttimelineData.timelineDatapoints.push(datapoint);\r\n\t\t\t}\r\n\t\t\tlet countFullCells = timelineData.currentGranularity.getDatePeriods().filter((x) => x.index % 1 === 0).length;\r\n\t\t\tTimeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins);\r\n\t\t\tTimeline.updateCursors(timelineData, timelineProperties.cellWidth);\r\n\t\t\treturn timelineFormat;\r\n\t\t}\r\n\r\n\t\tprivate render(timelineData: TimelineData, timelineFormat: TimelineFormat, timelineProperties: TimelineProperties, options: VisualUpdateOptions): void {\r\n\t\t\tlet timelineDatapointsCount = this.timelineData.timelineDatapoints.filter((x) => x.index % 1 === 0).length;\r\n\t\t\tthis.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount;\r\n\t\t\tthis.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\r\n\t\t\tthis.timelineDiv.attr({\r\n\t\t\t\theight: px(options.viewport.height),\r\n\t\t\t\twidth: px(options.viewport.width),\r\n\t\t\t\t'drag-resize-disabled': true\r\n\t\t\t}).style({\r\n\t\t\t\t'overflow-x': 'auto',\r\n\t\t\t\t'overflow-y': 'auto'\r\n\t\t\t});\r\n\t\t\tthis.svg.attr({\r\n\t\t\t\theight: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),\r\n\t\t\t\twidth: px(Math.max(0, this.svgWidth))\r\n\t\t\t});\r\n\t\t\tlet fixedTranslateString: string = SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin);\r\n\t\t\tlet translateString: string = SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);\r\n\t\t\tthis.mainGroupElement.attr('transform', translateString);\r\n\t\t\tthis.selectorContainer.attr('transform', fixedTranslateString);\r\n\t\t\tthis.cursorGroupElement.attr('transform', translateString);\r\n\r\n\t\t\tlet extendedLabels = this.timelineData.currentGranularity.getExtendedLabel();\r\n\t\t\tlet granularityType = this.timelineData.currentGranularity.getType();\r\n\t\t\tlet yPos = 0, yDiff = 1.50;\r\n\t\t\tthis.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, granularityType === 0);\r\n\t\t\tyPos += yDiff;\r\n\t\t\tthis.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, granularityType === 1);\r\n\t\t\tyPos += yDiff;\r\n\t\t\tthis.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, granularityType === 2);\r\n\t\t\tyPos += yDiff;\r\n\t\t\tthis.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, granularityType === 3);\r\n\t\t\tyPos += yDiff;\r\n\t\t\tthis.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, granularityType === 4);\r\n\t\t\tthis.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations);\r\n\t\t\tthis.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\r\n\t\t}\r\n\r\n\t\tprivate renderLabels(labels: TimelineLabel[], labelsElement: D3.Selection, index: number, isLast: boolean): void {\r\n\t\t\tlet labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);\r\n\t\t\tif (!this.timelineFormat.labelFormat.showProperty) {\r\n\t\t\t\tlabelTextSelection.remove();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tlet labelsGroupSelection = labelTextSelection.data(labels);\r\n\t\t\tlabelsGroupSelection.enter().append('text').classed(this.timelineSelectors.textLabel.class, true);\r\n\r\n\t\t\tlabelsGroupSelection.text((x: TimelineLabel, id: number) => {\r\n\t\t\t\tif (!isLast && id === 0 && labels.length > 1) {\r\n\t\t\t\t\tlet fontSize = pt(this.timelineFormat.labelFormat.sizeProperty);\r\n\t\t\t\t\tlet textProperties: powerbi.TextProperties = {\r\n\t\t\t\t\t\ttext: labels[0].text,\r\n\t\t\t\t\t\tfontFamily: 'arial',\r\n\t\t\t\t\t\tfontSize: fontSize\r\n\t\t\t\t\t};\r\n\t\t\t\t\tlet halfFirstTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\r\n\t\t\t\t\ttextProperties = {\r\n\t\t\t\t\t\ttext: labels[1].text,\r\n\t\t\t\t\t\tfontFamily: 'arial',\r\n\t\t\t\t\t\tfontSize: fontSize\r\n\t\t\t\t\t};\r\n\t\t\t\t\tlet halfSecondTextWidth = TextMeasurementService.measureSvgTextWidth(textProperties) / 2;\r\n\t\t\t\t\tlet diff = this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);\r\n\t\t\t\t\tif (diff < halfFirstTextWidth + halfSecondTextWidth)\r\n\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t\tlet labelFormattedTextOptions: LabelFormattedTextOptions = {\r\n\t\t\t\t\tlabel: x.text,\r\n\t\t\t\t\tmaxWidth: this.timelineProperties.cellWidth * (isLast ? 0.90 : 3),\r\n\t\t\t\t\tfontSize: this.timelineFormat.labelFormat.sizeProperty\r\n\t\t\t\t};\r\n\t\t\t\treturn dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\r\n\t\t\t})\r\n\t\t\t\t.style('font-size', pt(this.timelineFormat.labelFormat.sizeProperty))\r\n\t\t\t\t.attr({\r\n\t\t\t\t\tx: (x: TimelineLabel) => (x.id + 0.5) * this.timelineProperties.cellWidth,\r\n\t\t\t\t\ty: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),\r\n\t\t\t\t\tfill: this.timelineFormat.labelFormat.colorProperty\r\n\t\t\t\t}).append('title').text((x: TimelineLabel) => x.title);\r\n\t\t\tlabelsGroupSelection.exit().remove();\r\n\t\t}\r\n\r\n\t\tprivate clearData(): void {\r\n\t\t\tthis.initialized = false;\r\n\t\t\tthis.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove();\r\n\t\t\tthis.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();\r\n\t\t\tthis.rangeText.text(\"\");\r\n\t\t\tthis.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove();\r\n\t\t\tthis.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();\r\n\t\t}\r\n\r\n\t\tprivate static updateCursors(timelineData: TimelineData, cellWidth: number): void {\r\n\t\t\tlet startDate: DatePeriod = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;\r\n\t\t\ttimelineData.cursorDataPoints[0].selectionIndex = startDate.index;\r\n\t\t\tlet endDate: DatePeriod = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;\r\n\t\t\ttimelineData.cursorDataPoints[1].selectionIndex = (endDate.index + endDate.fraction);\r\n\t\t}\r\n\r\n\t\tprivate static fillTimelineFormat(objects: any, timelineProperties: DefaultTimelineProperties): TimelineFormat {\r\n\t\t\tlet timelineFormat: TimelineFormat =\r\n\t\t\t\t{\r\n\t\t\t\t\trangeTextFormat: {\r\n\t\t\t\t\t\tshowProperty: DataViewObjects.getValue<boolean>(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),\r\n\t\t\t\t\t\tcolorProperty: DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),\r\n\t\t\t\t\t\tsizeProperty: DataViewObjects.getValue<number>(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcellFormat: {\r\n\t\t\t\t\t\tcolorInProperty: DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),\r\n\t\t\t\t\t\tcolorOutProperty: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)\r\n\t\t\t\t\t},\r\n\t\t\t\t\tlabelFormat: {\r\n\t\t\t\t\t\tshowProperty: DataViewObjects.getValue<boolean>(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),\r\n\t\t\t\t\t\tcolorProperty: DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),\r\n\t\t\t\t\t\tsizeProperty: DataViewObjects.getValue<number>(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)\r\n\t\t\t\t\t},\r\n\t\t\t\t\tcalendarFormat: {\r\n\t\t\t\t\t\tfirstMonthProperty: DataViewObjects.getValue<number>(objects, CalendarMonthProp, 1),\r\n\t\t\t\t\t\tfirstDayProperty: Math.max(1, Math.min(31, DataViewObjects.getValue<number>(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),\r\n\t\t\t\t\t\tweekDayProperty: Math.max(0, Math.min(6, DataViewObjects.getValue<number>(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\treturn timelineFormat;\r\n\t\t}\r\n\r\n\t\tpublic fillCells(cellFormat: CellFormat): void {\r\n\t\t\tlet dataPoints = this.timelineData.timelineDatapoints;\r\n\t\t\tlet cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);\r\n\t\t\tcellSelection.attr('fill', d => Utils.getCellColor(d, this.timelineData, cellFormat));\r\n\t\t}\r\n\r\n\t\tpublic renderCells(timelineData: TimelineData, timelineFormat: TimelineFormat, timelineProperties: TimelineProperties, suppressAnimations: any): void {\r\n\t\t\tlet allDataPoints = timelineData.timelineDatapoints;\r\n\t\t\tlet totalX = 0;\r\n\t\t\tlet cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);\r\n\t\t\tcellsSelection.enter().append('rect').classed(this.timelineSelectors.CellRect.class, true);\r\n\t\t\tcellsSelection\r\n\t\t\t\t.attr({\r\n\t\t\t\t\theight: px(timelineProperties.cellHeight),\r\n\t\t\t\t\twidth: (d: TimelineDatapoint) => px(d.datePeriod.fraction * timelineProperties.cellWidth),\r\n\t\t\t\t\tx: (d: TimelineDatapoint) => {\r\n\t\t\t\t\t\tlet value = totalX;\r\n\t\t\t\t\t\ttotalX += d.datePeriod.fraction * timelineProperties.cellWidth;\r\n\t\t\t\t\t\treturn px(value);\r\n\t\t\t\t\t},\r\n\t\t\t\t\ty: px(timelineProperties.cellsYPosition),\r\n\t\t\t\t\tid: (d: TimelineDatapoint) => d.index\r\n\t\t\t\t});\r\n\r\n\t\t\tlet clickHandler: (d: TimelineDatapoint, index: number) => void = (d: TimelineDatapoint, index: number) => {\r\n\t\t\t\td3.event.preventDefault();\r\n\t\t\t\tlet cursorDataPoints = this.timelineData.cursorDataPoints;\r\n\t\t\t\tlet keyEvent: any = d3.event;\r\n\t\t\t\tif (keyEvent.altKey || keyEvent.shiftKey) {\r\n\t\t\t\t\tif (this.timelineData.selectionEndIndex < index) {\r\n\t\t\t\t\t\tcursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\r\n\t\t\t\t\t\ttimelineData.selectionEndIndex = index;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcursorDataPoints[0].selectionIndex = d.datePeriod.index;\r\n\t\t\t\t\t\ttimelineData.selectionStartIndex = index;\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttimelineData.selectionStartIndex = index;\r\n\t\t\t\t\ttimelineData.selectionEndIndex = index;\r\n\t\t\t\t\tcursorDataPoints[0].selectionIndex = d.datePeriod.index;\r\n\t\t\t\t\tcursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.fillCells(timelineFormat.cellFormat);\r\n\t\t\t\tthis.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);\r\n\t\t\t\tthis.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);\r\n\t\t\t\tthis.setSelection(timelineData);\r\n\t\t\t};\r\n\r\n\t\t\tcellsSelection\r\n\t\t\t\t.on('click', clickHandler)\r\n\t\t\t\t.on(\"touchstart\", clickHandler);\r\n\r\n\t\t\tthis.fillCells(timelineFormat.cellFormat);\r\n\t\t\tcellsSelection.exit().remove();\r\n\t\t}\r\n\r\n\t\tpublic dragstarted(): void {\r\n\t\t\tthis.timelineData.dragging = true;\r\n\t\t}\r\n\r\n\t\tpublic dragged(currentCursor: CursorDatapoint): void {\r\n\t\t\tif (this.timelineData.dragging === true) {\r\n\t\t\t\tlet xScale = 1;\r\n\t\t\t\tlet container = d3.select(this.timelineSelectors.TimelineVisual.selector);\r\n\r\n\t\t\t\tif (container) {\r\n\t\t\t\t\tlet transform = container.style(\"transform\");\r\n\t\t\t\t\tif (transform !== undefined && transform !== 'none') {\r\n\t\t\t\t\t\tlet str = transform.split(\"(\")[1];\r\n\t\t\t\t\t\txScale = Number(str.split(\", \")[0]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet cursorOverElement: TimelineCursorOverElement = this.findCursorOverElement(d3.event.x);\r\n\r\n\t\t\t\tif (!cursorOverElement) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet currentlyMouseOverElement: TimelineDatapoint = cursorOverElement.datapoint,\r\n\t\t\t\t\tcurrentlyMouseOverElementIndex: number = cursorOverElement.index;\r\n\r\n\t\t\t\tif (currentCursor.cursorIndex === 0 && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex) {\r\n\t\t\t\t\tthis.timelineData.selectionStartIndex = currentlyMouseOverElementIndex;\r\n\t\t\t\t\tthis.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentCursor.cursorIndex === 1 && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex) {\r\n\t\t\t\t\tthis.timelineData.selectionEndIndex = currentlyMouseOverElementIndex;\r\n\t\t\t\t\tthis.timelineData.cursorDataPoints[1].selectionIndex = (currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.fillCells(this.timelineFormat.cellFormat);\r\n\t\t\t\tthis.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);\r\n\t\t\t\tthis.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Note: Public for testability.\r\n\t\t */\r\n\t\tpublic findCursorOverElement(x: number): TimelineCursorOverElement {\r\n\t\t\tlet timelineDatapoints: TimelineDatapoint[] = this.timelineData.timelineDatapoints || [],\r\n\t\t\t\tlength: number = timelineDatapoints.length,\r\n\t\t\t\tcellWidth: number = this.timelineProperties.cellWidth;\r\n\r\n\t\t\tif (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tindex: 0,\r\n\t\t\t\t\tdatapoint: timelineDatapoints[0]\r\n\t\t\t\t};\r\n\t\t\t} else if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) {\r\n\t\t\t\treturn {\r\n\t\t\t\t\tindex: length - 1,\r\n\t\t\t\t\tdatapoint: timelineDatapoints[length - 1]\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i = 1; i < length; i++) {\r\n\t\t\t\tlet left: number = timelineDatapoints[i].index * cellWidth,\r\n\t\t\t\t\tright: number = timelineDatapoints[i + 1].index * cellWidth;\r\n\r\n\t\t\t\tif (x >= left && x <= right) {\r\n\t\t\t\t\treturn {\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tdatapoint: timelineDatapoints[i]\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\tpublic dragended(): void {\r\n\t\t\tthis.setSelection(this.timelineData);\r\n\t\t}\r\n\r\n\t\tprivate drag = d3.behavior.drag()\r\n\t\t\t.origin((d: CursorDatapoint) => {\r\n\t\t\t\td.x = d.selectionIndex * this.timelineProperties.cellWidth;\r\n\r\n\t\t\t\treturn d;\r\n\t\t\t})\r\n\t\t\t.on(\"dragstart\", () => { this.dragstarted(); })\r\n\t\t\t.on(\"drag\", (d: CursorDatapoint) => { this.dragged(d); })\r\n\t\t\t.on(\"dragend\", () => { this.dragended(); });\r\n\r\n\t\tpublic renderCursors(timelineData: TimelineData, timelineFormat: TimelineFormat, cellHeight: number, cellsYPosition: number): D3.UpdateSelection {\r\n\t\t\tlet cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);\r\n\t\t\tcursorSelection.enter().append('path').classed(this.timelineSelectors.SelectionCursor.class, true);\r\n\r\n\t\t\tcursorSelection.attr(\"transform\", (d: CursorDatapoint) => SVGUtil.translate(d.selectionIndex * this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition)).attr({\r\n\t\t\t\td: d3.svg.arc()\r\n\t\t\t\t\t.innerRadius(0)\r\n\t\t\t\t\t.outerRadius(cellHeight / 2)\r\n\t\t\t\t\t.startAngle(d => d.cursorIndex * Math.PI + Math.PI)\r\n\t\t\t\t\t.endAngle(d => d.cursorIndex * Math.PI + 2 * Math.PI)\r\n\t\t\t})\r\n\t\t\t\t.call(this.drag);\r\n\r\n\t\t\tcursorSelection.exit().remove();\r\n\t\t\treturn cursorSelection;\r\n\t\t}\r\n\r\n\t\tpublic renderTimeRangeText(timelineData: TimelineData, timeRangeFormat: LabelFormat): void {\r\n            let leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth;\r\n            let maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;\r\n\r\n\t\t\tif (timeRangeFormat.showProperty && maxWidth > 0) {\r\n\t\t\t\tlet timeRangeText = Utils.timeRangeText(timelineData);\r\n\t\t\t\tlet labelFormattedTextOptions: LabelFormattedTextOptions = {\r\n\t\t\t\t\tlabel: timeRangeText,\r\n\t\t\t\t\tmaxWidth: maxWidth,\r\n\t\t\t\t\tfontSize: timeRangeFormat.sizeProperty\r\n\t\t\t\t};\r\n\t\t\t\tlet actualText = dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);\r\n\t\t\t\tthis.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, true);\r\n\t\t\t\tthis.rangeText.attr({\r\n\t\t\t\t\tx: (GranularityNames.length) * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),\r\n\t\t\t\t\ty: 40,\r\n\t\t\t\t\tfill: timeRangeFormat.colorProperty\r\n\t\t\t\t})\r\n\t\t\t\t\t.style({\r\n\t\t\t\t\t\t'font-size': pt(timeRangeFormat.sizeProperty)\r\n\t\t\t\t\t}).text(actualText)\r\n\t\t\t\t\t.append('title').text(timeRangeText);;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tthis.rangeText.text(\"\");\r\n\t\t}\r\n\r\n\t\tpublic setSelection(timelineData: TimelineData): void {\r\n\t\t\tthis.requiresNoUpdate = true;\r\n\t\t\tlet lower: data.SQConstantExpr = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));\r\n\t\t\tlet upper: data.SQConstantExpr = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));\r\n\t\t\tlet filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);\r\n\t\t\tlet filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);\r\n\t\t\tlet objects: VisualObjectInstancesToPersist = {\r\n\t\t\t\tmerge: [\r\n\t\t\t\t\t<VisualObjectInstance>{\r\n\t\t\t\t\t\tobjectName: \"general\",\r\n\t\t\t\t\t\tselector: undefined,\r\n\t\t\t\t\t\tproperties: {\r\n\t\t\t\t\t\t\t\"filter\": filter,\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t]\r\n\t\t\t};\r\n\t\t\tthis.hostServices.persistProperties(objects);\r\n\t\t\tthis.hostServices.onSelect({ data: [] });\r\n\t\t}\r\n\r\n\t\t// This function retruns the values to be displayed in the property pane for each object.\r\n\t\t// Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do\r\n\t\t// validation and return other values/defaults \r\n\t\tpublic enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n\t\t\tlet enumeration = new ObjectEnumerationBuilder();\r\n\t\t\tswitch (options.objectName) {\r\n\t\t\t\tcase 'rangeHeader':\r\n\t\t\t\t\tthis.enumerateRangeHeader(enumeration, this.dataView);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'cells':\r\n\t\t\t\t\tthis.enumerateCells(enumeration, this.dataView);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'labels':\r\n\t\t\t\t\tthis.enumerateLabels(enumeration, this.dataView);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'calendar':\r\n\t\t\t\t\tthis.enumerateCalendar(enumeration, this.dataView);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 'weekDay':\r\n\t\t\t\t\tthis.enumerateWeekDay(enumeration, this.dataView);\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\treturn enumeration.complete();\r\n\t\t}\r\n\r\n\t\tpublic enumerateRangeHeader(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\r\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\r\n\t\t\tenumeration.pushInstance({\r\n\t\t\t\tobjectName: 'rangeHeader',\r\n\t\t\t\tdisplayName: 'Selection Color',\r\n\t\t\t\tselector: null,\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\tshow: DataViewObjects.getValue<boolean>(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),\r\n\t\t\t\t\tfontColor: DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),\r\n\t\t\t\t\ttextSize: DataViewObjects.getValue<number>(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tpublic enumerateCells(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\r\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\r\n\t\t\tenumeration.pushInstance({\r\n\t\t\t\tobjectName: 'cells',\r\n\t\t\t\tselector: null,\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\tfillSelected: DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),\r\n\t\t\t\t\tfillUnselected: DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tpublic enumerateLabels(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\r\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\r\n\t\t\tenumeration.pushInstance({\r\n\t\t\t\tobjectName: 'labels',\r\n\t\t\t\tselector: null,\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\tshow: DataViewObjects.getValue<boolean>(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),\r\n\t\t\t\t\tfontColor: DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),\r\n\t\t\t\t\ttextSize: DataViewObjects.getValue<number>(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tpublic enumerateCalendar(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\r\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\r\n\t\t\tenumeration.pushInstance({\r\n\t\t\t\tobjectName: 'calendar',\r\n\t\t\t\tselector: null,\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\tmonth: Math.max(1, Math.min(12, DataViewObjects.getValue<number>(objects, CalendarMonthProp, 1))),\r\n\t\t\t\t\tday: Math.max(1, Math.min(31, DataViewObjects.getValue<number>(objects, CalendarDayProp, 1))),\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tpublic enumerateWeekDay(enumeration: ObjectEnumerationBuilder, dataview: DataView): void {\r\n\t\t\tlet objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;\r\n\t\t\tenumeration.pushInstance({\r\n\t\t\t\tobjectName: 'weekDay',\r\n\t\t\t\tselector: null,\r\n\t\t\t\tproperties: {\r\n\t\t\t\t\tday: Math.max(0, Math.min(6, DataViewObjects.getValue<number>(objects, WeekDayProp, 0)))\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/timeline/visual/timeline.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n\r\n    import ValueFormatter = powerbi.visuals.valueFormatter;\r\n    import SelectionManager = utility.SelectionManager;\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n\r\n    export interface StreamData {\r\n        dataPoints: StreamDataPoint[][];\r\n        legendData: LegendData;\r\n        valueFormatter: IValueFormatter;\r\n        categoryFormatter: IValueFormatter;\r\n        streamGraphSettings: StreamGraphSettings;\r\n    }\r\n\r\n    export interface StreamDataPoint {\r\n        x: number;\r\n        y: number;\r\n        y0?: number;\r\n        identity: SelectionId;\r\n    }\r\n\r\n    export interface StreamGraphSettings {\r\n        legendSettings: StreamGraphLegendSettings;\r\n        categoryAxisSettings: StreamGraphAxisSettings;\r\n        valueAxisSettings: StreamGraphAxisSettings;\r\n    }\r\n\r\n    export interface StreamGraphLegendSettings {\r\n        show: boolean;\r\n        showTitle: boolean;\r\n        titleText: string;\r\n        labelColor: string;\r\n        fontSize: number;\r\n    }\r\n\r\n    export interface StreamGraphAxisSettings {\r\n        show: boolean;\r\n        axisColor: string;\r\n        showAxisTitle: boolean;\r\n    }\r\n\r\n    export interface StreamProperty {\r\n        [propertyName: string]: DataViewObjectPropertyIdentifier;\r\n    }\r\n\r\n    const StreamGraphAxisGraphicsContextClassName = 'axisGraphicsContext';\r\n    const StreamGraphXAxisClassName = 'x axis';\r\n    const StreamGraphYAxisClassName = 'y axis';\r\n    const StreamGraphDefaultAxisColor = \"#777\";\r\n    const StreamGraphDefaultFontSizeInPoints: number = 8;\r\n    const DefaultLegendFontSizeInPt = 8;\r\n    const DefaultLegendLabelFillColor: string = '#666666';\r\n    const StreamGraphDefaultFontFamily: string = 'wf_segoe-ui_normal';\r\n    const StreamGraphDefaultFontWeight: string = 'normal';\r\n    const StreamGraphDefaultSettings: StreamGraphSettings = {\r\n        legendSettings: {\r\n            show: true,\r\n            showTitle: true,\r\n            labelColor: DefaultLegendLabelFillColor,\r\n            titleText: \"\",\r\n            fontSize: DefaultLegendFontSizeInPt\r\n        },\r\n        categoryAxisSettings: {\r\n            show: true,\r\n            axisColor: StreamGraphDefaultAxisColor,\r\n            showAxisTitle: false,\r\n        },\r\n        valueAxisSettings: {\r\n            show: true,\r\n            axisColor: StreamGraphDefaultAxisColor,\r\n            showAxisTitle: false,\r\n        },\r\n    };\r\n\r\n    export class StreamGraph implements IVisual {\r\n        private static VisualClassName = 'streamGraph';\r\n\r\n        private static Properties: any = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: 'general',\r\n                    propertyName: 'formatString'\r\n                }\r\n            },\r\n            legend: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"legend\",\r\n                    propertyName: \"show\"\r\n                }\r\n            },\r\n            categoryAxis: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"categoryAxis\",\r\n                    propertyName: \"show\"\r\n                },\r\n                axisColor: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"categoryAxis\",\r\n                    propertyName: \"axisColor\"\r\n                },\r\n                showAxisTitle: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"categoryAxis\",\r\n                    propertyName: \"showAxisTitle\"\r\n                }\r\n            },\r\n            valueAxis: {\r\n                show: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"valueAxis\",\r\n                    propertyName: \"show\"\r\n                },\r\n                axisColor: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"valueAxis\",\r\n                    propertyName: \"axisColor\"\r\n                },\r\n                showAxisTitle: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"valueAxis\",\r\n                    propertyName: \"showAxisTitle\"\r\n                }\r\n            }\r\n        };\r\n\r\n        private static Layer: ClassAndSelector = {\r\n            'class': 'layer',\r\n            selector: '.layer'\r\n        };\r\n\r\n        private static XAxisLabel: ClassAndSelector = {\r\n            'class': 'xAxisLabel',\r\n            selector: '.xAxisLabel'\r\n        };\r\n\r\n        private static YAxisLabel: ClassAndSelector = {\r\n            'class': 'yAxisLabel',\r\n            selector: '.yAxisLabel'\r\n        };\r\n\r\n        private static MaxNumberOfAxisXValues: number = 5;\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: 'Category',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Category',\r\n                }, {\r\n                    name: 'Series',\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Series',\r\n                }, {\r\n                    name: 'Y',\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: data.createDisplayNameGetter('Role_DisplayName_Values'),\r\n                },\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Category': { max: 1 }, 'Series': { max: 0 } },\r\n                    { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }\r\n                ],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: 'Category' },\r\n                        dataReductionAlgorithm: { bottom: {} }\r\n                    },\r\n                    values: {\r\n                        group: {\r\n                            by: 'Series',\r\n                            select: [{ for: { in: 'Y' } }],\r\n                            dataReductionAlgorithm: { bottom: {} }\r\n                        }\r\n                    },\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: 'General',\r\n                    properties: {\r\n                        formatString: { type: { formatting: { formatString: true } } },\r\n                        wiggle: {\r\n                            type: { bool: true },\r\n                            displayName: 'Wiggle'\r\n                        }\r\n                    }\r\n                },\r\n                categoryAxis: {\r\n                    displayName: 'X-Axis',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'show',\r\n                            type: { bool: true }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: 'Title',\r\n                            type: { bool: true }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                valueAxis: {\r\n                    displayName: 'Y-Axis',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'show',\r\n                            type: { bool: true }\r\n                        },\r\n                        showAxisTitle: {\r\n                            displayName: 'Title',\r\n                            type: { bool: true }\r\n                        },\r\n                        axisColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        }\r\n                    }\r\n                },\r\n                legend: {\r\n                    displayName: 'Legend',\r\n                    properties: {\r\n                        show: {\r\n                            displayName: 'show',\r\n                            type: { bool: true }\r\n                        },\r\n                        position: {\r\n                            displayName: 'Position',\r\n                            type: { enumeration: legendPosition.type }\r\n                        },\r\n                        showTitle: {\r\n                            displayName: 'Title',\r\n                            type: { bool: true }\r\n                        },\r\n                        titleText: {\r\n                            displayName: 'Legend Name',\r\n                            type: { text: true },\r\n                            suppressFormatPainterCopy: true\r\n                        },\r\n                        labelColor: {\r\n                            displayName: 'Color',\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        fontSize: {\r\n                            displayName: 'Text Size',\r\n                            type: { formatting: { fontSize: true } }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        private margin: IMargin = { left: 45, right: 20, bottom: 20, top: 20 };\r\n\r\n        private viewport: IViewport;\r\n\r\n        private svg: D3.Selection;\r\n        private axisGraphicsContext: D3.Selection;\r\n        private xAxis: D3.Selection;\r\n        private yAxis: D3.Selection;\r\n        private colors: IDataColorPalette;\r\n        private selectionManager: utility.SelectionManager;\r\n        private dataView: DataView;\r\n        private legend: ILegend;\r\n        private legendObjectProperties: DataViewObject;\r\n        private data: StreamData;\r\n\r\n        public converter(dataView: DataView, colors: IDataColorPalette): StreamData {\r\n            if (!dataView ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.values ||\r\n                !dataView.categorical.categories ||\r\n                !colors) {\r\n                return null;\r\n            }\r\n\r\n            let catDv: DataViewCategorical = dataView.categorical,\r\n                grouped = catDv && catDv.values ? catDv.values.grouped() : undefined,\r\n                values: DataViewValueColumns = catDv.values,\r\n                dataPoints: StreamDataPoint[][] = [],\r\n                legendData: LegendData = {\r\n                    dataPoints: [],\r\n                    title: values[0].source.displayName,\r\n                    fontSize: StreamGraphDefaultFontSizeInPoints,\r\n                },\r\n                value: number = 0,\r\n                valueFormatter: IValueFormatter,\r\n                categoryFormatter: IValueFormatter;\r\n\r\n            for (let i = 0; i < values.length; i++) {\r\n                let columnGroup: DataViewValueColumnGroup = grouped\r\n                    && grouped.length > i && grouped[i].values ? grouped[i] : null;\r\n\r\n                dataPoints.push([]);\r\n\r\n                if (values[i].source.groupName) {\r\n                    legendData.dataPoints.push({\r\n                        label: values[i].source.groupName,\r\n                        color: colors.getColorByIndex(i).value,\r\n                        icon: LegendIcon.Box,\r\n                        selected: false,\r\n                        identity: SelectionId.createWithId(values[i].identity)\r\n                    });\r\n                }\r\n\r\n                for (let k = 0; k < values[i].values.length; k++) {\r\n                    let id: SelectionId = SelectionIdBuilder\r\n                        .builder()\r\n                        .withSeries(dataView.categorical.values, columnGroup)\r\n                        .createSelectionId(),\r\n                        y: number = values[i].values[k];\r\n\r\n                    if (y > value) {\r\n                        value = y;\r\n                    }\r\n\r\n                    dataPoints[i].push({\r\n                        x: k,\r\n                        y: y,\r\n                        identity: id\r\n                    });\r\n                }\r\n            }\r\n\r\n            let streamGraphSettings: StreamGraphSettings = this.parseSettings(dataView);\r\n\r\n            valueFormatter = ValueFormatter.create({\r\n                format: \"g\",\r\n                value: value\r\n            });\r\n\r\n            categoryFormatter = ValueFormatter.create({\r\n                format: ValueFormatter.getFormatString(\r\n                    catDv.categories[0].source,\r\n                    StreamGraph.Properties.general.formatString),\r\n                value: catDv.categories[0].values\r\n            });\r\n\r\n            return {\r\n                dataPoints: dataPoints,\r\n                legendData: legendData,\r\n                valueFormatter: valueFormatter,\r\n                categoryFormatter: categoryFormatter,\r\n                streamGraphSettings: streamGraphSettings\r\n            };\r\n        }\r\n\r\n        private parseSettings(dataView: DataView): StreamGraphSettings {\r\n            if (!dataView || !dataView.metadata)\r\n                return StreamGraphDefaultSettings;\r\n\r\n            let objects: DataViewObjects = dataView.metadata.objects;\r\n            let streamGraphSettings = _.clone(StreamGraphDefaultSettings);\r\n\r\n            let categoryAxisSettings = streamGraphSettings.categoryAxisSettings;\r\n            categoryAxisSettings.show = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show);\r\n            categoryAxisSettings.axisColor = <string>DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor);\r\n            categoryAxisSettings.showAxisTitle = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);\r\n\r\n            let valueAxisSettings = streamGraphSettings.valueAxisSettings;\r\n            valueAxisSettings.show = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show);\r\n            valueAxisSettings.axisColor = <string>DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor);\r\n            valueAxisSettings.showAxisTitle = DataViewObjects.getValue<boolean>(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);\r\n\r\n            return streamGraphSettings;\r\n        }\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            let element: JQuery = options.element;\r\n\r\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\r\n\r\n            this.svg = d3.select(element.get(0))\r\n                .append('svg')\r\n                .classed(StreamGraph.VisualClassName, true)\r\n                .style('position', 'absolute');\r\n\r\n            this.axisGraphicsContext = this.svg.append('g')\r\n                .classed(StreamGraphAxisGraphicsContextClassName, true);\r\n\r\n            this.xAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphXAxisClassName, true);\r\n            this.yAxis = this.axisGraphicsContext.append(\"g\").classed(StreamGraphYAxisClassName, true);\r\n\r\n            this.colors = options.style.colorPalette.dataColors;\r\n\r\n            this.legend = createLegend(element, false, null, true);\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions): void {\r\n            if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) {\r\n                this.clearData();\r\n                return;\r\n            };\r\n\r\n            this.viewport = {\r\n                width: Math.max(0, options.viewport.width),\r\n                height: Math.max(0, options.viewport.height)\r\n            };\r\n\r\n            let duration: number = options.suppressAnimations ? 0 : 250,\r\n                dataView: DataView = this.dataView = options.dataViews[0],\r\n                data: StreamData = this.data = this.converter(dataView, this.colors);\r\n\r\n            if (!data || !data.dataPoints || !data.dataPoints.length) {\r\n                this.clearData();\r\n                return;\r\n            }\r\n\r\n            let dataPoints: StreamDataPoint[][] = data.dataPoints;\r\n\r\n            this.renderLegend(data);\r\n            this.updateViewPort();\r\n            this.renderXAxisLabels();\r\n            this.renderYAxisLabels();\r\n\r\n            let height: number = Math.max(0, this.viewport.height - this.margin.top);\r\n\r\n            this.svg.attr({\r\n                'width': this.viewport.width,\r\n                'height': height\r\n            });\r\n\r\n            let stack: D3.Layout.StackLayout = d3.layout.stack();\r\n\r\n            if (this.getWiggle(dataView))\r\n                stack.offset('wiggle');\r\n\r\n            let layers: StreamDataPoint[][] = stack(dataPoints);\r\n\r\n            let xScale: D3.Scale.LinearScale = d3.scale.linear()\r\n                .domain([0, dataPoints[0].length - 1])\r\n                .range([this.margin.left, this.viewport.width - this.margin.right]);\r\n\r\n            let yScale: D3.Scale.LinearScale = d3.scale.linear()\r\n                .domain([0, d3.max(layers, (layer) => {\r\n                    return d3.max(layer, (d) => {\r\n                        return d.y0 + d.y;\r\n                    });\r\n                })])\r\n                .range([height - this.margin.bottom, this.margin.top]);\r\n\r\n            let area: D3.Svg.Area = d3.svg.area()\r\n                .interpolate('basis')\r\n                .x(d => xScale(d.x))\r\n                .y0(d => yScale(d.y0))\r\n                .y1(d => yScale(d.y0 + d.y));\r\n\r\n            let selectionManager: SelectionManager = this.selectionManager;\r\n\r\n            let selection: D3.UpdateSelection = this.svg.selectAll(StreamGraph.Layer.selector)\r\n                .data(layers);\r\n\r\n            selection.enter()\r\n                .append('path')\r\n                .classed(StreamGraph.Layer.class, true);\r\n\r\n            selection\r\n                .style(\"fill\", (d, i) => this.colors.getColorByIndex(i).value)\r\n                .on('click', function (d) {\r\n                    selectionManager.select(d[0].identity).then(ids=> {\r\n                        if (ids.length > 0) {\r\n                            selection.style('opacity', 0.5);\r\n                            d3.select(this).style('opacity', 1);\r\n                        } else\r\n                            selection.style('opacity', 1);\r\n                    });\r\n                })\r\n                .transition()\r\n                .duration(duration)\r\n                .attr(\"d\", area);\r\n\r\n            selection.exit().remove();\r\n\r\n            this.drawAxis(data, xScale, yScale);\r\n        }\r\n\r\n        private drawAxis(data: StreamData, xScale: D3.Scale.LinearScale, yScale: D3.Scale.LinearScale) {\r\n            let shiftY: number = this.viewport.height - this.margin.bottom - this.margin.top,\r\n                shiftX: number = this.viewport.width - this.margin.left - this.margin.right,\r\n                xAxis: D3.Svg.Axis = d3.svg.axis();\r\n\r\n            xAxis.scale(xScale)\r\n                .orient(\"bottom\")\r\n                .tickFormat(((item: any, index: number): any => {\r\n                    if (data.categoryFormatter)\r\n                        item = data.categoryFormatter.format(item);\r\n\r\n                    if (index != null && xAxis.tickValues() &&\r\n                        (index === 0 || index === xAxis.tickValues().length - 1)) {\r\n                        item = TextMeasurementService.getTailoredTextOrDefault(\r\n                            StreamGraph.getTextPropertiesFunction(item),\r\n                            (index ? this.margin.right : this.margin.left) * 2);\r\n                    }\r\n                    return item;\r\n                }).bind(xAxis));\r\n\r\n            let yAxis: D3.Svg.Axis = d3.svg.axis()\r\n                .scale(yScale)\r\n                .orient(\"left\")\r\n                .tickFormat((item: any): any => {\r\n                    if (data.valueFormatter) {\r\n                        return data.valueFormatter.format(item);\r\n                    }\r\n                    return item;\r\n                });\r\n\r\n            this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues);\r\n            this.setMaxTicks(yAxis, shiftY);\r\n\r\n            let valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\r\n            if (valueAxisSettings.show) {\r\n                let axisColor: Fill = valueAxisSettings.axisColor;\r\n                this.yAxis\r\n                    .attr(\"transform\", SVGUtil.translate(this.margin.left, 0))\r\n                    .call(yAxis);\r\n                this.yAxis.selectAll(\"text\").style(\"fill\", axisColor);\r\n            } else\r\n                this.yAxis.selectAll(\"*\").remove();\r\n\r\n            let categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\r\n            if (categoryAxisSettings.show) {\r\n                let axisColor: Fill = categoryAxisSettings.axisColor;\r\n                this.xAxis\r\n                    .attr(\"transform\", SVGUtil.translate(0, shiftY))\r\n                    .call(xAxis);\r\n                this.xAxis.selectAll(\"text\").style(\"fill\", axisColor);\r\n            } else\r\n                this.xAxis.selectAll(\"*\").remove();\r\n        }\r\n\r\n        private renderYAxisLabels(): void {\r\n            this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();\r\n\r\n            let valueAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\r\n            if (valueAxisSettings.show) {\r\n                this.margin.left = 45;\r\n                if (valueAxisSettings.showAxisTitle)\r\n                    if (this.dataView.categorical.values.source) {\r\n                        let marginLeft = this.margin.left = 65;\r\n                        let categoryAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\r\n                        let isXAxisOn: boolean = categoryAxisSettings.show === true;\r\n                        let isXTitleOn: boolean = categoryAxisSettings.showAxisTitle === true;\r\n                        let height: number = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height;\r\n                        let yAxisText: string = this.dataView.categorical.values.source.displayName;\r\n                        let yAxisClass: string = StreamGraph.YAxisLabel.class;\r\n                        let yAxisLabel: D3.Selection = this.yAxis.append(\"text\")\r\n                            .style(\"text-anchor\", \"middle\")\r\n                            .text(yAxisText)\r\n                            .call((text: D3.Selection) => {\r\n                                text.each(function () {\r\n                                    let text = d3.select(this);\r\n                                    text.attr({\r\n                                        class: yAxisClass,\r\n                                        transform: \"rotate(-90)\",\r\n                                        y: -marginLeft + 5,\r\n                                        x: -(height / 2),\r\n                                        dy: \"1em\"\r\n                                    });\r\n                                });\r\n                            });\r\n\r\n                        yAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                            height,\r\n                            TextMeasurementService.svgEllipsis);\r\n                    } else\r\n                        valueAxisSettings.showAxisTitle = false;\r\n            } else\r\n                this.margin.left = 20;\r\n        }\r\n\r\n        private renderXAxisLabels(): void {\r\n            this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();\r\n\r\n            let categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;\r\n            if (categoryAxisSettings.show) {\r\n                this.margin.bottom = 20;\r\n                if (categoryAxisSettings.showAxisTitle)\r\n                    if (this.dataView.categorical.categories[0].source) {\r\n                        let marginBottom = this.margin.bottom = 40;\r\n                        let valueAxisSettings: StreamGraphAxisSettings = this.data.streamGraphSettings.valueAxisSettings;\r\n                        let isYAxisOn: boolean = valueAxisSettings.show === true;\r\n                        let isYTitleOn: boolean = valueAxisSettings.showAxisTitle === true;\r\n                        let width: number = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width;\r\n                        let xAxisText: string = this.dataView.categorical.categories[0].source.displayName;\r\n                        let xAxisClass: string = StreamGraph.XAxisLabel.class;\r\n                        let xAxisLabel: D3.Selection = this.xAxis.append(\"text\")\r\n                            .style(\"text-anchor\", \"middle\")\r\n                            .text(xAxisText)\r\n                            .call((text: D3.Selection) => {\r\n                                text.each(function () {\r\n                                    let text = d3.select(this);\r\n                                    text.attr({\r\n                                        class: xAxisClass,\r\n                                        transform: SVGUtil.translate(width / 2, marginBottom - 5)\r\n                                    });\r\n                                });\r\n                            });\r\n\r\n                        xAxisLabel.call(AxisHelper.LabelLayoutStrategy.clip,\r\n                            width,\r\n                            TextMeasurementService.svgEllipsis);\r\n                    } else\r\n                        categoryAxisSettings.showAxisTitle = false;\r\n            } else\r\n                this.margin.bottom = 10;\r\n        }\r\n\r\n        private renderLegend(streamGraphData: StreamData): void {\r\n            let legendData: LegendData = streamGraphData.legendData;\r\n            if (!legendData || !this.dataView || !this.dataView.metadata)\r\n                return;\r\n\r\n            this.legendObjectProperties = DataViewObjects.getObject(this.dataView.metadata.objects, \"legend\", {});\r\n\r\n            if (this.legendObjectProperties) {\r\n                LegendData.update(legendData, this.legendObjectProperties);\r\n\r\n                let position: string = <string>this.legendObjectProperties[legendProps.position];\r\n\r\n                if (position)\r\n                    this.legend.changeOrientation(LegendPosition[position]);\r\n            }\r\n            this.legend.drawLegend(legendData, _.clone(this.viewport));\r\n            Legend.positionChartArea(this.svg, this.legend);\r\n        }\r\n\r\n        private updateViewPort(): void {\r\n            let legendMargins: IViewport = this.legend.getMargins();\r\n            let legendPosition = LegendPosition[<string>this.legendObjectProperties[legendProps.position]];\r\n\r\n            switch (legendPosition) {\r\n                case LegendPosition.Top:\r\n                case LegendPosition.TopCenter:\r\n                case LegendPosition.Bottom:\r\n                case LegendPosition.BottomCenter: {\r\n                    this.viewport.height -= legendMargins.height;\r\n                    break;\r\n                }\r\n                case LegendPosition.Left:\r\n                case LegendPosition.LeftCenter:\r\n                case LegendPosition.Right:\r\n                case LegendPosition.RightCenter: {\r\n                    this.viewport.width -= legendMargins.width;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        private setMaxTicks(axis: D3.Svg.Axis, maxSize: number, maxValue?: number): void {\r\n            let maxTicks = maxValue === undefined\r\n                ? this.getTicksByAxis(axis).length\r\n                : Math.min(maxValue, this.getTicksByAxis(axis).length);\r\n\r\n            if (axis.scale().domain.toString() === d3.scale.linear().domain.toString())\r\n                axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));\r\n            else\r\n                axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));\r\n        }\r\n\r\n        private getFittedTickLength(axis: D3.Svg.Axis, maxSize: number, maxTicks: number): number {\r\n            for (let ticks: any[] = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks);\r\n                maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks);\r\n                maxTicks-- , ticks = this.getTicksByAxis(axis)) {\r\n                axis.ticks(maxTicks);\r\n            }\r\n            return maxTicks;\r\n        }\r\n\r\n        private getFittedTickValues(axis: D3.Svg.Axis, maxSize: number, maxTicks: number): any[] {\r\n            let ticks: any[] = this.getTicksByAxis(axis),\r\n                maxWidthOf2Ticks: number,\r\n                tickPairsWidths: any[] = [],\r\n                measureTickFunction: (any) => number = this.getMeasureTickFunction(axis, ticks);\r\n\r\n            for (let currentMaxTicks: number = maxTicks, indexes: number[] = [];\r\n                maxTicks > 0 && maxSize > 0;\r\n                currentMaxTicks-- , indexes = []) {\r\n                switch (currentMaxTicks) {\r\n                    case 0:\r\n                        return [];\r\n                    case 1:\r\n                        indexes = [0];\r\n                        break;\r\n                    case 2:\r\n                        indexes = [0, ticks.length - 1];\r\n                        break;\r\n                    default:\r\n                        let takeEvery: number = ticks.length / (currentMaxTicks - 1);\r\n\r\n                        for (let i = 0; i < currentMaxTicks - 1; i++) {\r\n                            indexes.push(Math.round(takeEvery * i));\r\n                        }\r\n\r\n                        indexes.push(ticks.length - 1);\r\n                        break;\r\n                }\r\n\r\n                let ticksIndexes: any[][] = indexes.map(x => [ticks[x], x]);\r\n                maxWidthOf2Ticks = (maxSize / ticks.length) * 2;\r\n\r\n                ticksIndexes.reduce((a, b) => {\r\n                    tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);\r\n                    return b;\r\n                });\r\n\r\n                if (!tickPairsWidths.some(x => x[0] > x[1])) {\r\n                    return ticksIndexes.map(x => x[0]);\r\n                }\r\n            }\r\n            return [];\r\n        }\r\n\r\n        private measureTicks(ticks: any[], measureTickFunction: (number) => any): number {\r\n            return ticks.map((x: any) => measureTickFunction(x)).reduce((a: number, b: number) => a + b);\r\n        }\r\n\r\n        private getTicksByAxis(axis: D3.Svg.Axis): any[] {\r\n            let scale = axis.scale();\r\n            let result: any = axis.tickValues() === null\r\n                ? scale.ticks\r\n                    ? scale.ticks.apply(scale, axis.ticks())\r\n                    : scale.domain()\r\n                : axis.tickValues();\r\n\r\n            return result.length === undefined ? [result] : result;\r\n        }\r\n\r\n        private getMeasureTickFunction(axis: D3.Svg.Axis, ticks: string[]): (number) => any {\r\n            let measureFunction = axis.orient() === \"top\" || axis.orient() === \"bottom\"\r\n                ? TextMeasurementService.measureSvgTextWidth\r\n                : TextMeasurementService.measureSvgTextHeight;\r\n\r\n            let cache = {};\r\n\r\n            return function (x: any): number {\r\n                return cache[x]\r\n                    ? cache[x]\r\n                    : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();\r\n            };\r\n        }\r\n\r\n        private static getTextPropertiesFunction(text: string): TextProperties {\r\n            let fontFamily: string = StreamGraphDefaultFontFamily,\r\n                fontSize: string = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints),\r\n                fontWeight: string = StreamGraphDefaultFontWeight;\r\n\r\n            return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };\r\n        }\r\n\r\n        private getWiggle(dataView: DataView) {\r\n            if (dataView && dataView.metadata) {\r\n                let objects = dataView.metadata.objects;\r\n\r\n                if (objects) {\r\n                    let general = DataViewObjects.getObject(objects, 'general', undefined);\r\n\r\n                    if (general)\r\n                        return <boolean>general['wiggle'];\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        private enumerateValueAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n\r\n            let valueAxisSettings: StreamGraphAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;\r\n\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                objectName: 'valueAxis',\r\n                displayName: \"Y-Axis\",\r\n                properties: {\r\n                    show: valueAxisSettings.show,\r\n                    showAxisTitle: valueAxisSettings.showAxisTitle,\r\n                    axisColor: valueAxisSettings.axisColor,\r\n                }\r\n            });\r\n        }\r\n\r\n        private enumerateCategoryAxisValues(enumeration: ObjectEnumerationBuilder): void {\r\n            let categoryAxisSettings: StreamGraphAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;\r\n\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                objectName: 'categoryAxis',\r\n                displayName: \"X-Axis\",\r\n                properties: {\r\n                    show: categoryAxisSettings.show,\r\n                    showAxisTitle: categoryAxisSettings.showAxisTitle,\r\n                    axisColor: categoryAxisSettings.axisColor,\r\n                }\r\n            });\r\n        }\r\n\r\n        private enumerateLegend(enumeration: ObjectEnumerationBuilder): void {\r\n            let legendSettings: DataViewObject = this.legendObjectProperties ? this.legendObjectProperties : {};\r\n\r\n            enumeration.pushInstance({\r\n                selector: null,\r\n                objectName: 'legend',\r\n                displayName: \"Legend\",\r\n                properties: {\r\n                    show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : true,\r\n                    position: LegendPosition[this.legend.getOrientation()],\r\n                    showTitle: DataViewObject.getValue<boolean>(legendSettings, legendProps.showTitle, true),\r\n                    titleText: DataViewObject.getValue<string>(legendSettings, legendProps.titleText, \"\"),\r\n                    labelColor: DataViewObject.getValue<string>(legendSettings, legendProps.labelColor, DefaultLegendLabelFillColor),\r\n                    fontSize: DataViewObject.getValue<number>(legendSettings, legendProps.fontSize, DefaultLegendFontSizeInPt)\r\n                }\r\n            });\r\n        }\r\n\r\n        private clearData() {\r\n            this.svg.selectAll(StreamGraph.Layer.selector).remove();\r\n            this.legend.drawLegend({ dataPoints: [] }, this.viewport);\r\n            this.yAxis.selectAll(\"*\").remove();\r\n            this.xAxis.selectAll(\"*\").remove();\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstanceEnumeration {\r\n            let enumeration: ObjectEnumerationBuilder = new ObjectEnumerationBuilder(),\r\n                dataView = this.dataView;\r\n\r\n            switch (options.objectName) {\r\n                case 'legend':\r\n                    if (dataView\r\n                        && dataView.categorical\r\n                        && dataView.categorical.values\r\n                        && dataView.categorical.values.source)\r\n                            this.enumerateLegend(enumeration);\r\n                    break;\r\n                case 'categoryAxis':\r\n                    this.enumerateCategoryAxisValues(enumeration);\r\n                    break;\r\n                case 'valueAxis':\r\n                    this.enumerateValueAxisValues(enumeration);\r\n                    break;\r\n                case 'general':\r\n                    let general: VisualObjectInstance = {\r\n                        objectName: 'general',\r\n                        displayName: 'General',\r\n                        selector: null,\r\n                        properties: {\r\n                            wiggle: this.getWiggle(dataView)\r\n                        }\r\n                    };\r\n\r\n                    enumeration.pushInstance(general);\r\n                    break;\r\n            }\r\n            return enumeration.complete();\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/streamGraph/visual/streamGraph.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import ClassAndSelector = jsCommon.CssConstants.ClassAndSelector;\r\n    import SelectionManager = utility.SelectionManager;\r\n\r\n    export interface LineDotPoint {\r\n        time: number | Date;\r\n        value: number;\r\n        dot: number;\r\n        sum: number;\r\n        selector: SelectionId;\r\n    }\r\n\r\n    export interface Legend {\r\n        text: string;\r\n        transform?: string;\r\n        dx?: string;\r\n        dy?: string;\r\n    }\r\n\r\n    export interface LineDotChartViewModel {\r\n        points: LineDotPoint[];\r\n        settings: LineDotChartSettings;\r\n        xAxis: IAxisProperties;\r\n        yAxis: IAxisProperties;\r\n        yAxis2: IAxisProperties;\r\n        legends: Legend[];\r\n    };\r\n\r\n    export interface LineDotChartSettings {\r\n        lineFill: string;\r\n        lineThickness: number;\r\n        dotFill: string;\r\n        dotSizeMin: number;\r\n        dotSizeMax: number;\r\n        counterTitle: string;\r\n        // precision: number;\r\n        xAxisTitle: string;\r\n        yAxisTitle: string;\r\n        duration: number;\r\n        isanimated: boolean;\r\n        isstopped: boolean;\r\n    };\r\n\r\n    export class LineDotChart implements IVisual {\r\n        private selectionManager: SelectionManager;\r\n        private hostServices: IVisualHostServices;\r\n        private isDateTime: boolean;\r\n\r\n        private static DefaultSettings: LineDotChartSettings = {\r\n            lineFill: 'rgb(102, 212, 204)',\r\n            lineThickness: 3,\r\n            dotFill: '#005c55',\r\n            dotSizeMin: 4,\r\n            dotSizeMax: 38,\r\n            counterTitle: 'Total features',\r\n            // precision: 2,\r\n            xAxisTitle: '',\r\n            yAxisTitle: '',\r\n            duration: 20,\r\n            isanimated: true,\r\n            isstopped: true\r\n        };\r\n\r\n        /**\r\n        * Informs the System what it can do\r\n        * Fields, Formatting options, data reduction & QnA hints\r\n        */\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: \"Date\",\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Date'\r\n                }, \r\n                {\r\n                    name: \"Values\",\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName:'Values'\r\n                },\r\n                // {\r\n                //     name: \"Labels\",\r\n                //     kind: VisualDataRoleKind.Measure,\r\n                //     displayName: 'Labels'\r\n                // }\r\n            ],\r\n            dataViewMappings: [{\r\n                conditions: [{\r\n                    \"Date\": {\r\n                        min: 0,\r\n                        max: 1\r\n                    },\r\n                    \"Values\": {\r\n                        min: 0,\r\n                        max: 1\r\n                    },\r\n                    \"Labels\": {\r\n                        min: 0,\r\n                        max: 1\r\n                    }\r\n                }],\r\n                categorical: {\r\n                    categories: {\r\n                        for: { in: \"Date\" },\r\n                        dataReductionAlgorithm: { sample: {} }\r\n                    },\r\n                    values: {\r\n                        for: { in: \"Values\" }\r\n                    },\r\n                    // labels: {\r\n                    //     for: { in: \"Labels\" }\r\n                    // }\r\n                }\r\n            }],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter(\"Visual_General\"),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: {\r\n                                formatting: {\r\n                                    formatString: true\r\n                                }\r\n                            },\r\n                        }\r\n                    },\r\n                },\r\n                lineoptions: {\r\n                    displayName: 'Line',\r\n                    properties: {\r\n                        fill: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        lineThickness: {\r\n                            displayName: 'Thickness',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                },\r\n                dotoptions: {\r\n                    displayName: 'Dot',\r\n                    properties: {\r\n                        color: {\r\n                            displayName: data.createDisplayNameGetter('Visual_Fill'),\r\n                            type: { fill: { solid: { color: true } } }\r\n                        },\r\n                        dotSizeMin: {\r\n                            displayName: 'Min size',\r\n                            type: { numeric: true }\r\n                        },\r\n                        dotSizeMax: {\r\n                            displayName: 'Min size',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                },\r\n                counteroptions: {\r\n                    displayName: 'Counter',\r\n                    properties: {\r\n                        counterTitle: {\r\n                            displayName: 'Title',\r\n                            type: { text: true }\r\n                        }\r\n                    }\r\n                },\r\n                misc: {\r\n                    displayName: 'Animation',\r\n                    properties: {\r\n                        isanimated: {\r\n                            displayName: 'Animated',\r\n                            type: { bool: true }\r\n                        },\r\n                        isstopped: {\r\n                            displayName: 'Stop on load',\r\n                            type: { bool: true }\r\n                        },\r\n                        duration: {\r\n                            displayName: 'Time',\r\n                            type: { numeric: true }\r\n                        }\r\n                    }\r\n                }\r\n                // ,\r\n                // labels: {\r\n                //     displayName: data.createDisplayNameGetter('Visual_DataPointsLabels'),\r\n                //     properties: {\r\n                //         labelPrecision: {\r\n                //             displayName: data.createDisplayNameGetter('Visual_Precision'),\r\n                //             type: { numeric: true }\r\n                //         }\r\n                //     }\r\n                // }\r\n            }\r\n        };\r\n\r\n        private static Identity: ClassAndSelector = {\r\n            \"class\": \"lineDotChart\",\r\n            selector: \".lineDotChart\"\r\n        };\r\n\r\n        private static Axes: ClassAndSelector = {\r\n            \"class\": \"axes\",\r\n            selector: \".axes\"\r\n        };\r\n\r\n        private static Axis: ClassAndSelector = {\r\n            \"class\": \"axis\",\r\n            selector: \".axis\"\r\n        };\r\n\r\n        private static Legends: ClassAndSelector = {\r\n            \"class\": \"legends\",\r\n            selector: \".legends\"\r\n        };\r\n\r\n        private static Legend: ClassAndSelector = {\r\n            \"class\": \"legend\",\r\n            selector: \".legend\"\r\n        };\r\n\r\n        private static Values: ClassAndSelector = {\r\n            \"class\": \"line\",\r\n            selector: \".line\"\r\n        };\r\n\r\n        private static Properties: any = {\r\n            general: {\r\n                formatString: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"general\",\r\n                    propertyName: \"formatString\"\r\n                }\r\n            },\r\n            lineoptions: {\r\n                fill: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"lineoptions\",\r\n                    propertyName: \"fill\"\r\n                },\r\n                lineThickness: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"lineoptions\",\r\n                    propertyName: \"lineThickness\"\r\n                }\r\n            },\r\n            dotoptions: {\r\n                color: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"dotoptions\",\r\n                    propertyName: \"color\"\r\n                },\r\n                dotSizeMin: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"dotoptions\",\r\n                    propertyName: \"dotSizeMin\"\r\n                },\r\n                dotSizeMax: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"dotoptions\",\r\n                    propertyName: \"dotSizeMax\"\r\n                }\r\n            },\r\n            counteroptions: {\r\n                counterTitle: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"counteroptions\",\r\n                    propertyName: \"counterTitle\"\r\n                }\r\n            },\r\n            // labels: {\r\n            //     labelPrecision: <DataViewObjectPropertyIdentifier>{\r\n            //         objectName: \"labels\",\r\n            //         propertyName: \"labelPrecision\"\r\n            //     }\r\n            // },\r\n            misc: {\r\n                isanimated: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"misc\",\r\n                    propertyName: \"isanimated\"\r\n                },\r\n                isstopped: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"misc\",\r\n                    propertyName: \"isstopped\"\r\n                },\r\n                duration: <DataViewObjectPropertyIdentifier>{\r\n                    objectName: \"misc\",\r\n                    propertyName: \"duration\"\r\n                }\r\n            }\r\n        };\r\n\r\n        private model: LineDotChartViewModel;\r\n        private root: D3.Selection;\r\n        private main: D3.Selection;\r\n        private axes: D3.Selection;\r\n        private axisX: D3.Selection;\r\n        private axisY: D3.Selection;\r\n        private axisY2: D3.Selection;\r\n        private legends: D3.Selection;\r\n        private line: D3.Selection;\r\n        private colors: IDataColorPalette;\r\n\r\n        private margin: IMargin = {\r\n            top: 10,\r\n            right: 30,\r\n            bottom: 10,\r\n            left: 10\r\n        };\r\n\r\n        private LegendSize: number = 50;\r\n        private AxisSize: number = 30;\r\n\r\n        /* One time setup*/\r\n        public init(options: VisualInitOptions): void {\r\n            this.hostServices = options.host;\r\n            this.selectionManager = new SelectionManager({ hostServices: this.hostServices });\r\n            this.root = d3.select(options.element.get(0))\r\n                .append('svg')\r\n                .classed(LineDotChart.Identity.class, true);\r\n\r\n            this.root.on('click', (d: LineDotPoint) => { this.clearSelection(); } );\r\n\r\n            this.main = this.root.append('g');\r\n            this.axes = this.main.append('g').classed(LineDotChart.Axes.class, true);\r\n            this.axisX = this.axes.append('g').classed(LineDotChart.Axis.class, true);\r\n            this.axisY = this.axes.append('g').classed(LineDotChart.Axis.class, true);\r\n            this.axisY2 = this.axes.append('g').classed(LineDotChart.Axis.class, true);\r\n            this.legends = this.main.append('g').classed(LineDotChart.Legends.class, true);\r\n            this.line = this.main.append('g').classed(LineDotChart.Values.class, true);\r\n\r\n            this.colors = options.style && options.style.colorPalette\r\n                ? options.style.colorPalette.dataColors\r\n                : new DataColorPalette();\r\n        }\r\n\r\n        /* Called for data, size, formatting changes*/\r\n        public update(options: VisualUpdateOptions) {\r\n            if (!options.dataViews || !options.dataViews[0]) {\r\n                return;\r\n            }\r\n\r\n            var viewport: IViewport = options.viewport;\r\n            var model: LineDotChartViewModel = this.model = this.converter(options.dataViews[0], viewport);\r\n            // if (!model) {\r\n            //     return;\r\n            // }\r\n\r\n            this.clearSelection();\r\n            this.resize(viewport);\r\n            // this.draw(model, !options.suppressAnimations);\r\n            this.draw(model);\r\n        }\r\n\r\n        /*About to remove your visual, do clean up here */\r\n        public destroy() {\r\n            this.root = null;\r\n        }\r\n\r\n        public setIsStopped(isstopped: Boolean): void {\r\n            var objects: VisualObjectInstancesToPersist = {\r\n                merge: [\r\n                    <VisualObjectInstance>{\r\n                        objectName: \"misc\",\r\n                        selector: undefined,\r\n                        properties: {\r\n                            \"isstopped\": isstopped,\r\n                        }\r\n                    }\r\n                ]\r\n            };\r\n            this.hostServices.persistProperties(objects);\r\n            this.hostServices.onSelect({ data: [] });\r\n        }\r\n\r\n        public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] {\r\n            var instances: VisualObjectInstance[] = [];\r\n\r\n            if (!this.model || !this.model.settings) {\r\n                return instances;\r\n            }\r\n\r\n            var settings: LineDotChartSettings = this.model.settings;\r\n\r\n            switch (options.objectName) {\r\n                case \"lineoptions\":\r\n                    var lineoptions: VisualObjectInstance = {\r\n                        objectName: \"lineoptions\",\r\n                        displayName: \"lineoptions\",\r\n                        selector: null,\r\n                        properties: {\r\n                            fill: settings.lineFill,\r\n                            lineThickness: settings.lineThickness\r\n                        }\r\n                    };\r\n\r\n                    instances.push(lineoptions);\r\n                    break;\r\n\r\n                case \"dotoptions\":\r\n                    var dotoptions: VisualObjectInstance = {\r\n                        objectName: \"dotoptions\",\r\n                        displayName: \"dotoptions\",\r\n                        selector: null,\r\n                        properties: {\r\n                            color: settings.dotFill,\r\n                            dotSizeMin: settings.dotSizeMin,\r\n                            dotSizeMax: settings.dotSizeMax\r\n                        }\r\n                    };\r\n\r\n                    instances.push(dotoptions);\r\n                    break;\r\n\r\n                case \"counteroptions\":\r\n                    var counteroptions: VisualObjectInstance = {\r\n                        objectName: \"counteroptions\",\r\n                        displayName: \"counteroptions\",\r\n                        selector: null,\r\n                        properties: {\r\n                            counterTitle: settings.counterTitle\r\n                        }\r\n                    };\r\n\r\n                    instances.push(counteroptions);\r\n                    break;\r\n\r\n                // case \"labels\":\r\n                //     var labels: VisualObjectInstance = {\r\n                //         objectName: \"labels\",\r\n                //         displayName: \"labels\",\r\n                //         selector: null,\r\n                //         properties: {\r\n                //             labelPrecision: settings.precision\r\n                //         }\r\n                //     };\r\n\r\n                //     instances.push(labels);\r\n                //     break;\r\n\r\n                case \"misc\": \r\n                    var misc: VisualObjectInstance = {\r\n                        objectName: \"misc\",\r\n                        displayName: \"misc\",\r\n                        selector: null,\r\n                        properties: {\r\n                            isanimated: settings.isanimated,\r\n                            isstopped: settings.isstopped,\r\n                            duration: settings.duration\r\n                        }\r\n                    };\r\n\r\n                    instances.push(misc);\r\n                    break;\r\n            }\r\n\r\n            return instances;\r\n        }\r\n\r\n        private selectDot(dotelement: SVGCircleElement, selector: SelectionId) {\r\n            var dot: D3.Selection = d3.select(dotelement);\r\n            if (!dot.classed('point_selected')) {\r\n                if (selector) {\r\n                    this.selectionManager.select(selector);\r\n                }\r\n\r\n                this.root.classed(\"filtered\", true);\r\n                this.line.selectAll('circle.point')\r\n                    .classed('point_selected', false);\r\n                d3.select(dotelement)\r\n                    .classed('point_selected', true);\r\n            } else {\r\n                this.clearSelection();\r\n            }\r\n\r\n            d3.event.stopPropagation();\r\n        }\r\n\r\n        private clearSelection(): void {\r\n            this.root.classed(\"filtered\", false);\r\n            this.root.selectAll(\"circle.point\").classed(\"point_selected\", false);\r\n            this.selectionManager.clear();\r\n        }\r\n\r\n        // Convert a DataView into a view model\r\n        private converter(dataView: DataView, viewport: IViewport): LineDotChartViewModel {\r\n            if (!dataView.categorical ||\r\n                !dataView.categorical.categories ||\r\n                !dataView.categorical.categories[0] ||\r\n                !dataView.categorical.categories[0].values ||\r\n                !(dataView.categorical.categories[0].values.length > 0) ||\r\n                !dataView.categorical ||\r\n                !dataView.categorical.values ||\r\n                !dataView.categorical.values[0] ||\r\n                !dataView.categorical.values[0].values ||\r\n                !(dataView.categorical.values[0].values.length > 0)\r\n            ) {\r\n                return null;\r\n            }\r\n\r\n            var values: any[] = [];\r\n            var metadataColumn: DataViewMetadataColumn;\r\n            var extent: any[];\r\n            var min: any;\r\n            var max: any;\r\n            var that = this;\r\n\r\n            var categoryType: ValueType = AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, true);\r\n            this.isDateTime = AxisHelper.isDateTime(categoryType);\r\n            var isScalar = true;\r\n\r\n            var settings: LineDotChartSettings = this.parseSettings(dataView);\r\n            var effectiveWidth: number = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize);\r\n            var effectiveHeight: number = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize);\r\n\r\n            var format: string = \"\";\r\n            var formatter: IValueFormatter;\r\n\r\n            // X for categories\r\n            values = dataView.categorical.categories[0].values;\r\n            metadataColumn = dataView.categorical.categories[0].source;\r\n            extent = d3.extent(values);\r\n\r\n            if (this.isDateTime) {\r\n                min = extent[0].getTime();\r\n                max = extent[1].getTime();\r\n\r\n                min = new Date(min);\r\n                max = new Date(max + (max - min)*.05);\r\n\r\n                // var xDomain: number[] = isScalar ? [min, max] : [min.getTime(), max.getTime()]\r\n                // var format: string = \"MMM dd yyyy HH:mm\";\r\n                format = \"MMM dd yyyy\";\r\n                formatter = valueFormatter.create({ format: format });\r\n            } else {\r\n                min = extent[0];\r\n                max = extent[1];\r\n\r\n                max = max + (max - min)*.05;\r\n\r\n                formatter = valueFormatter.create({ value: 0 });\r\n            }\r\n\r\n            var xAxis = AxisHelper.createAxis({\r\n                pixelSpan: effectiveWidth,\r\n                dataDomain: [min, max],\r\n                metaDataColumn: metadataColumn,\r\n                formatString: null,\r\n                //formatString: LineDotChart.Properties.general.formatString,\r\n                outerPadding: 0,\r\n                isCategoryAxis: true,\r\n                isScalar: isScalar,\r\n                isVertical: false,\r\n                forcedTickCount: undefined,\r\n                useTickIntervalForDisplayUnits: true,\r\n                // axisPrecision: settings.precision,\r\n                getValueFn: (index, type) => {\r\n                    if(that.isDateTime) {\r\n                        return formatter.format(new Date(index));\r\n                    } else {\r\n                        return index;\r\n                    }\r\n                }\r\n            });\r\n            xAxis.formatter = formatter;\r\n\r\n            metadataColumn = dataView.categorical.values[0].source;\r\n\r\n            values = dataView.categorical.values[0].values;\r\n            extent = d3.extent(values);\r\n            min = extent[0];\r\n            max = extent[1];\r\n\r\n            var result: LineDotPoint[] = [];\r\n            var value_sum: number = 0;\r\n            var value: number = 0;\r\n            var time: number = 0;\r\n            var selector: SelectionId;\r\n\r\n            for (var i = 0; i < dataView.categorical.categories[0].values.length; i++) {\r\n                value = dataView.categorical.values[0].values[i];\r\n                time = dataView.categorical.categories[0].values[i];\r\n                value_sum += value;\r\n                selector = SelectionId.createWithId(dataView.categorical.categories[0].identity[i]);\r\n                result.push({\r\n                    dot: (value - min) / (max - min),\r\n                    value: value,\r\n                    sum: value_sum,\r\n                    time: time,\r\n                    selector: selector\r\n                });\r\n            }\r\n\r\n            // make some space for counter + 25%\r\n            value_sum = value_sum + (value_sum - min) * 0.10;\r\n\r\n            var yAxis = AxisHelper.createAxis({\r\n                pixelSpan: effectiveHeight,\r\n                dataDomain: [min, value_sum],\r\n                metaDataColumn: metadataColumn,\r\n                formatString: null,\r\n                outerPadding: 0,\r\n                isCategoryAxis: false,\r\n                isScalar: true,\r\n                isVertical: true,\r\n                useTickIntervalForDisplayUnits: true\r\n            });\r\n\r\n            var yAxis2 = AxisHelper.createAxis({\r\n                pixelSpan: effectiveHeight,\r\n                dataDomain: [min, value_sum],\r\n                metaDataColumn: metadataColumn,\r\n                formatString: null,\r\n                outerPadding: 0,\r\n                isCategoryAxis: false,\r\n                isScalar: true,\r\n                isVertical: true,\r\n                useTickIntervalForDisplayUnits: true\r\n            });\r\n            yAxis2.axis.orient('right');\r\n\r\n            // Show gridlines on the chart to make the values more readable.\r\n            // TODO: Make this a configuration setting that can be toggled.\r\n            // xAxis.axis = xAxis.axis.tickSize(-effectiveHeight);\r\n            // yAxis.axis = yAxis.axis.tickSize(-effectiveWidth);\r\n            return {\r\n                points: result,\r\n                settings: settings,\r\n                xAxis: xAxis,\r\n                yAxis: yAxis,\r\n                yAxis2: yAxis2,\r\n                legends: this.generateAxisLabels(viewport, settings)\r\n            };\r\n        }\r\n\r\n        private parseSettings(dataView: DataView): LineDotChartSettings {\r\n            if (!dataView ||\r\n                !dataView.metadata ||\r\n                !dataView.metadata.columns ||\r\n                !dataView.metadata.columns[0]) {\r\n                return null;\r\n            }\r\n\r\n            var objects: DataViewObjects = dataView.metadata.objects;\r\n            var lineFillColorHelper: ColorHelper = new ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill);\r\n            var dotFillColorHelper: ColorHelper = new ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill);\r\n            var xAxisTitle: string = LineDotChart.DefaultSettings.xAxisTitle;\r\n            var yAxisTitle: string = LineDotChart.DefaultSettings.yAxisTitle;\r\n\r\n            if (\r\n                dataView.categorical.categories[0] &&\r\n                dataView.categorical.categories[0].source &&\r\n                dataView.categorical.categories[0].source.displayName &&\r\n                dataView.categorical.values[0] &&\r\n                dataView.categorical.values[0].source &&\r\n                dataView.categorical.values[0].source.displayName) {\r\n                xAxisTitle = dataView.categorical.categories[0].source.displayName;\r\n                yAxisTitle = dataView.categorical.values[0].source.displayName;\r\n            }\r\n\r\n            var lineThickness: number = LineDotChart.DefaultSettings.lineThickness;\r\n            var dotSizeMin: number = LineDotChart.DefaultSettings.dotSizeMin;\r\n            var dotSizeMax: number = LineDotChart.DefaultSettings.dotSizeMax;\r\n            var counterTitle: string = LineDotChart.DefaultSettings.counterTitle;\r\n            var isanimated: boolean = LineDotChart.DefaultSettings.isanimated;\r\n            var isstopped: boolean = LineDotChart.DefaultSettings.isstopped;\r\n            var duration: number = LineDotChart.DefaultSettings.duration;\r\n            if (objects) {\r\n                lineThickness = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.lineoptions.lineThickness,\r\n                    LineDotChart.DefaultSettings.lineThickness\r\n                );\r\n                dotSizeMin = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.dotoptions.dotSizeMin,\r\n                    LineDotChart.DefaultSettings.dotSizeMin\r\n                );\r\n                dotSizeMax = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.dotoptions.dotSizeMax,\r\n                    LineDotChart.DefaultSettings.dotSizeMax\r\n                );\r\n                counterTitle = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.counteroptions.counterTitle,\r\n                    LineDotChart.DefaultSettings.counterTitle\r\n                );\r\n                isanimated = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.misc.isanimated,\r\n                    LineDotChart.DefaultSettings.isanimated\r\n                );\r\n                isstopped = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.misc.isstopped,\r\n                    LineDotChart.DefaultSettings.isstopped\r\n                );\r\n                duration = DataViewObjects.getValue(\r\n                    objects,\r\n                    LineDotChart.Properties.misc.duration,\r\n                    LineDotChart.DefaultSettings.duration\r\n                );\r\n                \r\n            }\r\n\r\n            return {\r\n                // precision: LineDotChart.getPrecision(objects),\r\n                xAxisTitle: xAxisTitle,\r\n                yAxisTitle: yAxisTitle,\r\n                lineFill: lineFillColorHelper.getColorForMeasure(objects, ''),\r\n                lineThickness: lineThickness,\r\n                dotFill: dotFillColorHelper.getColorForMeasure(objects, ''),\r\n                dotSizeMin: dotSizeMin,\r\n                dotSizeMax: dotSizeMax,\r\n                counterTitle: counterTitle,\r\n                isstopped: isstopped,\r\n                isanimated: isanimated,\r\n                duration: duration\r\n            };\r\n        }\r\n\r\n        // private static getPrecision(objects: DataViewObjects): number {\r\n        //     if (!objects) {\r\n        //         return LineDotChart.DefaultSettings.precision;\r\n        //     }\r\n\r\n        //     var precision: number = DataViewObjects.getValue(\r\n        //         objects,\r\n        //         LineDotChart.Properties.labels.labelPrecision,\r\n        //         LineDotChart.DefaultSettings.precision);\r\n\r\n        //     if (precision < LineDotChart.MinPrecision) {\r\n        //         return LineDotChart.MinPrecision;\r\n        //     }\r\n\r\n        //     return precision;\r\n        // }\r\n\r\n        private generateAxisLabels(viewport: IViewport, settings: LineDotChartSettings): Legend[] {\r\n            return [\r\n                {\r\n                    transform: SVGUtil.translate(\r\n                        (viewport.width - this.margin.left - this.margin.right) / 2,\r\n                        (viewport.height - this.margin.top - this.margin.bottom)),\r\n                    text: settings.xAxisTitle,\r\n                    dx: \"1em\",\r\n                    dy: \"-1em\"\r\n                }, {\r\n                    transform: SVGUtil.translateAndRotate(\r\n                        0,\r\n                        (viewport.height - this.margin.top - this.margin.bottom) / 2,\r\n                        0,\r\n                        0,\r\n                        270),\r\n                    text: settings.yAxisTitle,\r\n                    dx: \"3em\"\r\n                }\r\n            ];\r\n        }\r\n\r\n        private resize(viewport: IViewport): void {\r\n            this.root.attr({\r\n                'height': Math.max(0, viewport.height),\r\n                'width': Math.max(0, viewport.width)\r\n            });\r\n\r\n            this.main.attr('transform', SVGUtil.translate(this.margin.left, this.margin.top));\r\n            this.legends.attr('transform', SVGUtil.translate(this.margin.left, this.margin.top));\r\n            this.line.attr('transform', SVGUtil.translate(this.margin.left + this.LegendSize, 0));\r\n            this.axes.attr('transform', SVGUtil.translate(this.margin.left + this.LegendSize, 0));\r\n            this.axisX.attr('transform', SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize));\r\n            this.axisY2.attr('transform', SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));\r\n        }\r\n\r\n        private draw(model: LineDotChartViewModel): void {\r\n            var that = this;\r\n            // Clear canvas\r\n            this.line.selectAll('*').remove();\r\n\r\n            this.legends.selectAll('*').remove();\r\n            this.axisX.selectAll('*').remove();\r\n            this.axisY.selectAll('*').remove();\r\n            this.axisY2.selectAll('*').remove();\r\n\r\n            if (!model) {\r\n                return;\r\n            }\r\n\r\n            this.renderLegends(model);\r\n\r\n            if (model && model.points && model.points.length) {\r\n\r\n                this.axisX.call(model.xAxis.axis);\r\n                this.axisY.call(model.yAxis.axis);\r\n                this.axisY2.call(model.yAxis2.axis);\r\n\r\n                if (model.settings.isanimated) {\r\n                    var playBtn = this.line\r\n                        .append(\"g\")\r\n                        .classed(\"lineDotChart__playBtn\", true)\r\n                        .attr(\"transform\", \"translate(40, 20)\");\r\n\r\n                    playBtn\r\n                        .append(\"circle\")\r\n                        .attr(\"r\", 34 / 2);\r\n\r\n                    // play / reset buttin\r\n                    if (model.settings.isstopped) {\r\n                        playBtn\r\n                            .append(\"path\")\r\n                            .attr(\"d\", \"M0 2l10 6-10 6z\")\r\n                            .attr(\"transform\", \"translate(-4,-8)\");\r\n\r\n                        playBtn\r\n                            .on('click.lineDotChart__playBt', function() {\r\n                                that.setIsStopped(false);\r\n                            });\r\n\r\n                        return;\r\n                    } else {\r\n                        playBtn\r\n                            .append(\"path\")\r\n                            .attr(\"d\", \"M0 2l10 6-10 6z\")\r\n                            .attr(\"transform-origin\", \"center\")\r\n                            .attr(\"transform\", \"translate(6, 8) rotate(180)\");\r\n\r\n                        playBtn\r\n                            .append(\"rect\")\r\n                            .attr(\"width\", \"2\")\r\n                            .attr(\"height\", \"12\")\r\n                            .attr(\"transform\", \"translate(-7,-6)\");\r\n\r\n                        playBtn\r\n                            .on('click.lineDotChart__playBt', function() {\r\n                                that.setIsStopped(true);\r\n                            });\r\n                    }\r\n                }\r\n\r\n                var clip = this.line\r\n                    .append(\"clipPath\")\r\n                    .attr(\"id\", \"lineClip\")\r\n                    .append(\"rect\")\r\n                    .attr(\"x\", 0)\r\n                    .attr(\"y\", 0)\r\n                    .attr(\"width\", 1)\r\n                    .attr(\"height\", 10000);\r\n\r\n                // Draw the line\r\n                var line: D3.Svg.Line = d3.svg.line()\r\n                    .x((d: LineDotPoint) => model.xAxis.scale(d.time))\r\n                    .y((d: LineDotPoint) => model.yAxis.scale(d.sum));\r\n                    // .interpolate(\"basis\");\r\n\r\n                var lineSelection: D3.UpdateSelection = this.line.selectAll('path.plot')\r\n                    .data([model.points]);\r\n\r\n                lineSelection.enter().append('path');\r\n                lineSelection\r\n                    .classed('plot', true)\r\n                    .attr('stroke', (d, i) => model.settings.lineFill)\r\n                    .attr('stroke-width', model.settings.lineThickness)\r\n                    .attr('d', line);\r\n\r\n                var totalLength: number = (<SVGPathElement>lineSelection.node()).getTotalLength();\r\n                var line_left = (<SVGPathElement>lineSelection.node()).getPointAtLength(0).x;\r\n                var line_right = (<SVGPathElement>lineSelection.node()).getPointAtLength(totalLength).x;\r\n\r\n                lineSelection\r\n                    .attr(\"clip-path\", \"url(\" + location.href + \"#lineClip)\");\r\n\r\n                if(!model.settings.isanimated) {\r\n                    clip\r\n                        .interrupt()\r\n                        .attr('x', line_left)\r\n                        .attr('width', line_right - line_left);\r\n                } else {\r\n                    clip\r\n                        .attr('x', line_left)\r\n                        .interrupt()\r\n                        .transition()\r\n                        .ease(\"linear\")\r\n                        .duration(model.settings.duration * 1000)\r\n                        .attr('width', line_right - line_left);\r\n                }\r\n                lineSelection\r\n                    .exit().remove();\r\n\r\n                var point_time: number = 300;\r\n                var counter_time: number = 0; // point_time / 100;\r\n\r\n                // Draw the individual data points that will be shown on hover with a tooltip\r\n                var lineTipSelection: D3.UpdateSelection = this.line.selectAll('circle.point')\r\n                    .data(model.points);\r\n\r\n                var that = this;\r\n\r\n                lineTipSelection.enter()\r\n                    .append('circle')\r\n                    .attr('fill', model.settings.dotFill)\r\n                    .attr('opacity', .77)\r\n                    .attr('r', (d: LineDotPoint) => model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin))\r\n                    .classed('point', true)\r\n                    .on('mouseover.point', this.showDataPoint)\r\n                    .on('mouseout.point', this.hideDataPoint)\r\n                    .on(\"click.point\", function(d: LineDotPoint) {\r\n                        that.selectDot(this, d.selector);\r\n                    });\r\n\r\n                if (!model.settings.isanimated) {\r\n                    lineTipSelection\r\n                        .interrupt()\r\n                        .attr('transform', (d: LineDotPoint) => \r\n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)'\r\n                        );\r\n                } else {\r\n                    lineTipSelection\r\n                        .interrupt()\r\n                        .attr('transform', (d: LineDotPoint) => \r\n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(0.005)'\r\n                        )\r\n                        .transition()\r\n                        .duration(point_time)\r\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration))\r\n                        .ease(\"linear\")\r\n                        .attr('transform', (d: LineDotPoint) => \r\n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(3.4)'\r\n                        )\r\n                        .transition()\r\n                        .duration(point_time)\r\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration) + point_time)\r\n                        .ease(\"elastic\")\r\n                        .attr('transform', (d: LineDotPoint) =>\r\n                            'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)'\r\n                        );\r\n                }\r\n\r\n                lineTipSelection.exit().remove();\r\n\r\n                for (var i = 0; i < lineTipSelection[0].length; i++) {\r\n                    this.addTooltip(model, lineTipSelection[0][i]);\r\n                }\r\n\r\n                // Feature Counter text \r\n                var lineTextSelection: D3.UpdateSelection = this.line.selectAll('text')\r\n                    .data(model.points);\r\n\r\n                lineTextSelection.enter()\r\n                    .append(\"text\")\r\n                    .classed('text', true)\r\n                    .text((d: LineDotPoint, i: number) => {\r\n                        // if (model.points[i + 1]) {\r\n                            return model.settings.counterTitle + ' ' + (i + 1);\r\n                        // } else {\r\n                        //     // TODO: CRAZY hard code\r\n                        //     return model.settings.counterTitle + ' 265'\r\n                        // }\r\n                    })\r\n                    .attr('x', line_right - 260)\r\n                    .attr('y', 30);\r\n\r\n                if (!model.settings.isanimated) {\r\n                    // opacity 1 only for last\r\n                    lineTextSelection\r\n                        .interrupt()\r\n                        .attr('transform', 'translate(0 0)')\r\n                        .attr('opacity', (d: LineDotPoint, i: number) => Number(i === model.points.length - 1));\r\n                } else {\r\n                    lineTextSelection\r\n                        // .attr('transform', 'translate(-40 0)')\r\n                        .attr('opacity', 0)\r\n                        .interrupt()\r\n                        .transition()\r\n                        .duration(counter_time)\r\n                        .delay((d: LineDotPoint, i: number) => this.pointDelay(model.points, i, model.settings.duration))\r\n                        .attr('transform', 'translate(0 0)')\r\n                        .attr('opacity', 1)\r\n                        .transition()\r\n                        .duration(counter_time)\r\n                        .delay((d: LineDotPoint, i: number) => {\r\n                            if (model.points[i + 1]) {\r\n                                return this.pointDelay(model.points, i+1, model.settings.duration);\r\n                            } else {\r\n                                return Number.POSITIVE_INFINITY;\r\n                            }\r\n                        })\r\n                        // .attr('transform', 'translate(40 0)')\r\n                        .attr('opacity', 0)\r\n                     ;\r\n\r\n                }\r\n                lineTextSelection.exit().remove();\r\n\r\n            }\r\n        }\r\n\r\n        private pointDelay(points: LineDotPoint[], num: number, animation_duration: number): number {\r\n            if (!points.length || !points[num] || num === 0) {\r\n                return 0;\r\n            }\r\n            if (this.isDateTime) {\r\n                let time: Date = <Date>points[num].time;\r\n                var min: number = (<Date>points[0].time).getTime();\r\n                var max: number = (<Date>points[points.length - 1].time).getTime();\r\n                var val: number = time.getTime();\r\n            } else {\r\n                let time: number = <number>points[num].time;\r\n                var min: number = <number>points[0].time;\r\n                var max: number = <number>points[points.length - 1].time;\r\n                var val: number = time;\r\n            }\r\n            return animation_duration * 1000 * (val - min) / (max - min);\r\n        }\r\n\r\n        private showDataPoint(data: LineDotPoint, index: number): void {\r\n            d3.select(<any>this).classed('show', true);\r\n        }\r\n\r\n        private hideDataPoint(data: LineDotPoint, index: number): void {\r\n            d3.select(<any>this).classed('show', false);\r\n        }\r\n\r\n        private addTooltip(model: LineDotChartViewModel, element: any): void {\r\n            var selection: D3.Selection = d3.select(element);\r\n            var data: LineDotPoint = selection.datum();\r\n            TooltipManager.addTooltip(selection, (event) => {\r\n                return [\r\n                    {\r\n                        displayName: model.settings.xAxisTitle,\r\n                        value: model.xAxis.formatter.format(data.time)\r\n                    },\r\n                    {\r\n                        displayName: model.settings.yAxisTitle,\r\n                        value: data.value.toString()\r\n                    }\r\n                ];\r\n            });\r\n        }\r\n\r\n        private renderLegends(model: LineDotChartViewModel): void {\r\n            var legendSelection: D3.UpdateSelection = this.legends\r\n                .selectAll(LineDotChart.Legend.selector)\r\n                .data(model.legends);\r\n\r\n            legendSelection\r\n                .enter()\r\n                .append(\"svg:text\");\r\n\r\n            legendSelection\r\n                .attr(\"x\", 0)\r\n                .attr(\"y\", 0)\r\n                .attr(\"dx\", (item: Legend) => item.dx)\r\n                .attr(\"dy\", (item: Legend) => item.dy)\r\n                .attr(\"transform\", (item: Legend) => item.transform)\r\n                .text((item: Legend) => item.text)\r\n                .classed(LineDotChart.Legend.class, true);\r\n\r\n            legendSelection\r\n                .exit()\r\n                .remove();\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/lineDotChart/visual/lineDotChart.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"../../../_references.ts\"/>\r\n\r\nmodule powerbi.visuals.samples {\r\n    import SelectionManager = utility.SelectionManager;\r\n    export interface SunburstSlice {\r\n        children?: SunburstSlice[];\r\n        value?: any;\r\n        color?: string;\r\n        name?: string;\r\n        parent?: SunburstSlice;\r\n        selector: SelectionId;\r\n        total: number;\r\n        tooltipInfo?: TooltipDataItem[];\r\n    }\r\n\r\n    export interface SunburstViewModel {\r\n        root: SunburstSlice;\r\n    }\r\n\r\n    export var sunburstRoleNames = {\r\n        nodes: 'Nodes',\r\n        values: 'Values',\r\n    };\r\n\r\n    export class Sunburst implements IVisual {\r\n        private static minOpacity = 0.2;\r\n        private svg: D3.Selection;\r\n        private g: D3.Selection;\r\n        private arc: D3.Svg.Arc;\r\n        private total: number = 0;\r\n        private viewport: IViewport;\r\n        private colors: IDataColorPalette;\r\n        private selectionManager: SelectionManager;\r\n\r\n        private static roleNames = {\r\n            nodes: 'Nodes',\r\n            values: 'Values',\r\n        };\r\n\r\n        public static capabilities: VisualCapabilities = {\r\n            dataRoles: [\r\n                {\r\n                    name: Sunburst.roleNames.nodes,\r\n                    kind: VisualDataRoleKind.Grouping,\r\n                    displayName: 'Groups'\r\n                }, {\r\n                    name: Sunburst.roleNames.values,\r\n                    kind: VisualDataRoleKind.Measure,\r\n                    displayName: 'Values'\r\n                }\r\n            ],\r\n            objects: {\r\n                general: {\r\n                    displayName: data.createDisplayNameGetter('Visual_General'),\r\n                    properties: {\r\n                        formatString: {\r\n                            type: { formatting: { formatString: true } },\r\n                        },\r\n                    },\r\n                },\r\n            },\r\n            dataViewMappings: [{\r\n                conditions: [\r\n                    { 'Groups': { min: 0 }, 'Values': { max: 1 } },\r\n                ],\r\n                matrix: {\r\n                    rows: {\r\n                        for: { in: Sunburst.roleNames.nodes },\r\n                    },\r\n                    values: {\r\n                        for: { in: Sunburst.roleNames.values }\r\n                    },\r\n                }\r\n            }],\r\n        };\r\n\r\n        public init(options: VisualInitOptions): void {\r\n            this.arc = d3.svg.arc()\r\n                .startAngle(function(d) { return d.x; })\r\n                .endAngle(function(d) { return d.x + d.dx; })\r\n                .innerRadius(function(d) { return Math.sqrt(d.y); })\r\n                .outerRadius(function(d) { return Math.sqrt(d.y + d.dy); });\r\n\r\n            this.colors = options.style.colorPalette.dataColors;\r\n            this.selectionManager = new SelectionManager({ hostServices: options.host });\r\n            this.svg = d3.select(options.element.get(0)).append('svg');\r\n            this.svg.classed('mainDrawArea', true);\r\n            this.g = this.svg.append('g');\r\n            this.g.classed(\"container\", true);\r\n            this.svg.append(\"text\")\r\n                .classed(\"sunBurstPercentageFixed\", true);\r\n\r\n            this.svg.on('mousedown', (d) => {\r\n                this.svg.selectAll(\"path\").style(\"opacity\", 1);\r\n                this.svg.select(\".sunBurstPercentageFixed\").style(\"opacity\", 0);\r\n                this.selectionManager.clear();\r\n            });\r\n        }\r\n\r\n        private static setAllUnhide(selection): void {\r\n            selection.attr(\"setUnHide\", \"true\");\r\n        }\r\n\r\n        public update(options: VisualUpdateOptions): void {\r\n            if (options.dataViews.length > 0) {\r\n                var data = this.converter(options.dataViews[0], this.colors);\r\n                this.viewport = options.viewport;\r\n                this.updateInternal(data);\r\n            }\r\n        }\r\n\r\n        private updateInternal(dataRootNode: SunburstSlice): void {\r\n            this.svg.attr({\r\n                'height': this.viewport.height,\r\n                'width': this.viewport.width\r\n            });\r\n            this.g.attr('transform', SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));\r\n            var radius = Math.min(this.viewport.width, this.viewport.height) / 2;\r\n            var partition = d3.layout.partition()\r\n                .size([2 * Math.PI, radius * radius])\r\n                .value((d) => { return d.value; });\r\n            var path = this.g.datum(dataRootNode).selectAll(\"path\")\r\n                .data(partition.nodes);\r\n            path.enter().append(\"path\");\r\n            path.attr(\"display\", (d) => { return d.depth ? null : \"none\"; })\r\n                .attr(\"d\", this.arc)\r\n                .style(\"stroke\", \"#fff\")\r\n                .style(\"fill\", (d) => { return d.color; })\r\n                .style(\"fill-rule\", \"evenodd\")\r\n                .on(\"mousedown\", (d) => {\r\n                    if (d.selector) {\r\n                        this.selectionManager.select(d.selector);\r\n                    }\r\n                    d3.selectAll(\"path\").call(Sunburst.setAllUnhide).attr('setUnHide', null);\r\n                    this.highlightPath(d, this, true);\r\n                    var percentageFixedText = this.svg.select(\".sunBurstPercentageFixed\");\r\n                    var percentage = this.total === 0 ? 0 : (100 * d.total / this.total).toPrecision(3);\r\n                    percentageFixedText.text(d ? percentage + \"%\" : \"\");\r\n                    percentageFixedText.style(\"fill\", d.color);\r\n                    this.onResize();\r\n                    event.stopPropagation();\r\n                });\r\n            this.renderTooltip(path);\r\n            path.exit().remove();\r\n\r\n            this.onResize();\r\n        }\r\n\r\n        // Get all parents of the node\r\n        private static getTreePath(node) {\r\n            var path = [];\r\n            var current = node;\r\n            while (current.parent) {\r\n                path.unshift(current);\r\n                current = current.parent;\r\n            }\r\n            return path;\r\n        }\r\n\r\n        private onResize(): void {\r\n            var width = this.viewport.width;\r\n            var height = this.viewport.height;\r\n            var percentageFixedText = this.svg.select(\".sunBurstPercentageFixed\");\r\n            var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);\r\n\r\n            percentageFixedText.style(\"opacity\", 1);\r\n            percentageFixedText.attr(\"y\", (height / 2 + 4));\r\n            percentageFixedText.attr(\"x\", ((width / 2) - (textWidth / 2)));\r\n        }\r\n\r\n        private highlightPath(d, sunBurst, setUnhide): void {\r\n            var parentsArray = d ? Sunburst.getTreePath(d) : [];\r\n            // Set opacity for all the segments.\r\n            sunBurst.svg.selectAll(\"path\").each(function() {\r\n                if (d3.select(this).attr('setUnHide') !== 'true') {\r\n                    d3.select(this).style(\"opacity\", Sunburst.minOpacity);\r\n                }\r\n            });\r\n            // Highlight only ancestors of the current segment.\r\n            sunBurst.svg.selectAll(\"path\")\r\n                .filter(function(node) {\r\n                    return (parentsArray.indexOf(node) >= 0);\r\n                }).each(function() {\r\n                    d3.select(this).style(\"opacity\", 1);\r\n                    if (setUnhide === true) {\r\n                        d3.select(this).attr('setUnHide', 'true');\r\n                    }\r\n                });\r\n        }\r\n\r\n        private renderTooltip(selection: D3.UpdateSelection): void {\r\n            TooltipManager.addTooltip(selection, (tooltipEvent: TooltipEvent) => {\r\n                return (<SunburstSlice>tooltipEvent.data).tooltipInfo;\r\n            });\r\n        }\r\n\r\n        private static getTooltipData(displayName: string, value: number): TooltipDataItem[] {\r\n            return [{\r\n                displayName: displayName,\r\n                value: value < 0 ? \"\" : value.toString()\r\n            }];\r\n        }\r\n\r\n        private covertTreeNodeToSunBurstNode(originParentNode: DataViewTreeNode, sunburstParentNode: SunburstSlice,\r\n            colors: IColorScale, pathIdentity: DataViewScopeIdentity[], color): SunburstSlice {\r\n            var selector: powerbi.data.Selector;\r\n            if (originParentNode.identity) {\r\n                pathIdentity = pathIdentity.concat([originParentNode.identity]);\r\n                selector = { data: pathIdentity, };\r\n            }\r\n\r\n            var selectionId = pathIdentity.length === 0 ? null : new SelectionId(selector, false);\r\n            var valueToSet = originParentNode.values ? originParentNode.values[0].value : 0;\r\n\r\n            var newSunNode: SunburstSlice = {\r\n                name: originParentNode.name,\r\n                value: Math.max(valueToSet, 0),\r\n                selector: selectionId,\r\n                total: valueToSet\r\n            };\r\n            if (originParentNode.value) {\r\n                newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;\r\n            }\r\n            this.total += newSunNode.value;\r\n            if (originParentNode.children && originParentNode.children.length > 0) {\r\n\r\n                newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);\r\n\r\n                newSunNode.children = [];\r\n                for (var i = 0; i < originParentNode.children.length; i++) {\r\n                    var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);\r\n                    newSunNode.children.push(newChild);\r\n                    newSunNode.total += newChild.total;\r\n                }\r\n            } else {\r\n                newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);\r\n            }\r\n            if (sunburstParentNode) {\r\n                newSunNode.parent = sunburstParentNode;\r\n            }\r\n\r\n            return newSunNode;\r\n        }\r\n\r\n        public converter(dataView: DataView, colors: IDataColorPalette): SunburstSlice {\r\n            var colorScale = colors.getNewColorScale();\r\n            this.total = 0;\r\n            var root: SunburstSlice = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);\r\n\r\n            return root;\r\n        }\r\n    }\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/visuals/sunburst/visual/sunburst.ts\n **/","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\n/// <reference path=\"./_references.ts\"/>\r\n\r\nmodule powerbi.visuals.plugins {\r\n    export let sunburstCustom: IVisualPlugin = {\r\n        name: 'sunburstCustom',\r\n        watermarkKey: 'defaultWatermark',\r\n        capabilities: samples.Sunburst.capabilities,\r\n        create: () => new samples.Sunburst()\r\n    };\r\n\r\n    export let asterPlot: IVisualPlugin = {\r\n        name: 'asterPlot',\r\n        capabilities: samples.AsterPlot.capabilities,\r\n        create: () => new samples.AsterPlot()\r\n    };\r\n\r\n    export var tornadoChart: IVisualPlugin = {\r\n        name: \"tornadoChart\",\r\n        capabilities: samples.TornadoChart.capabilities,\r\n        create: () => new samples.TornadoChart()\r\n    };\r\n\r\n    export var sankeyDiagram: IVisualPlugin = {\r\n        name: \"sankeyDiagram\",\r\n        capabilities: samples.SankeyDiagram.capabilities,\r\n        create: () => new samples.SankeyDiagram()\r\n    };\r\n\r\n    export let mekkoChart: IVisualPlugin = {\r\n        name: 'mekkoChart',\r\n        watermarkKey: 'mekko',\r\n        capabilities: samples.MekkoChart.capabilities,\r\n        create: () => new samples.MekkoChart({ chartType: samples.MekkoChartType.HundredPercentStackedColumn }),\r\n        customizeQuery: ColumnChart.customizeQuery,\r\n        getSortableRoles: (visualSortableOptions?: VisualSortableOptions) => ColumnChart.getSortableRoles(visualSortableOptions),\r\n    };\r\n\r\n    export var bulletChart: IVisualPlugin = {\r\n        name: \"bulletChart\",\r\n        capabilities: samples.BulletChart.capabilities,\r\n        create: () => new samples.BulletChart()\r\n    };\r\n\r\n\texport var wordCloud: IVisualPlugin = {\r\n        name: \"wordCloud\",\r\n        capabilities: samples.WordCloud.capabilities,\r\n        create: () => new samples.WordCloud()\r\n    };\r\n\r\n    export var chicletSlicer: IVisualPlugin = {\r\n        name: 'chicletSlicer',\r\n        capabilities: samples.ChicletSlicer.capabilities,\r\n        create: () => new samples.ChicletSlicer()\r\n    };\r\n\r\n\texport var chordChart: IVisualPlugin = {\r\n        name: \"chordChart\",\r\n        capabilities: samples.ChordChart.capabilities,\r\n        create: () => new samples.ChordChart()\r\n    };\r\n\r\n\texport var enhancedScatterChart: IVisualPlugin = {\r\n        name: 'enhancedScatterChart',\r\n        capabilities: samples.EnhancedScatterChart.capabilities,\r\n        create: () => new samples.EnhancedScatterChart()\r\n    };\r\n\r\n\texport var radarChart: IVisualPlugin = {\r\n        name: 'radarChart',\r\n        capabilities: samples.RadarChart.capabilities,\r\n        create: () => new samples.RadarChart()\r\n    };\r\n\r\n\texport var dotPlot: IVisualPlugin = {\r\n        name: 'dotPlot',\r\n        capabilities: samples.DotPlot.capabilities,\r\n        create: () => new samples.DotPlot()\r\n    };\r\n\r\n    export var histogram: IVisualPlugin = {\r\n        name: \"histogram\",\r\n        capabilities: samples.Histogram.capabilities,\r\n        create: () => new samples.Histogram()\r\n    };\r\n\r\n\texport var timeline: IVisualPlugin = {\r\n        name: 'timeline',\r\n        capabilities: samples.Timeline.capabilities,\r\n        create: () => new samples.Timeline()\r\n    };\r\n\r\n    export var forceGraph: IVisualPlugin = {\r\n        name: \"forceGraph\",\r\n        capabilities: samples.ForceGraph.capabilities,\r\n        create: () => new samples.ForceGraph()\r\n    };\r\n\r\n    export let gantt: IVisualPlugin = {\r\n        name: \"gantt\",\r\n        capabilities: samples.Gantt.capabilities,\r\n        create: () => new samples.Gantt()\r\n    };\r\n\r\n    export let streamGraph: IVisualPlugin = {\r\n        name: \"streamGraph\",\r\n        capabilities: samples.StreamGraph.capabilities,\r\n        create: () => new samples.StreamGraph()\r\n    };\r\n    \r\n    export var lineDotChart: IVisualPlugin = {\r\n        name: \"lineDotChart\",\r\n        capabilities: samples.LineDotChart.capabilities,\r\n        create: () => new samples.LineDotChart()\r\n    };\r\n\r\n    export var dropdownSlicer: IVisualPlugin = {\r\n        name: \"dropdownSlicer\",\r\n        capabilities: samples.DropdownSlicer.capabilities,\r\n        create: () => new samples.DropdownSlicer()\r\n    };\r\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/plugins.ts\n **/","/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved. \n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in \n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n\n/// <reference path=\"../_references.ts\"/>\n\nmodule powerbi.visuals.visualPluginFactory {\n    export class CustomVisualPluginService extends VisualPluginService {\n        private customVisualPlugins: jsCommon.IStringDictionary<IVisualPlugin>;\n\n        public constructor() {\n            super({});\n\n            this.initCustomVisualPlugins();\n        }\n\n        public getVisuals(): IVisualPlugin[] {\n            let registry: jsCommon.IStringDictionary<IVisualPlugin> = this.customVisualPlugins,\n                names: string[] = Object.keys(registry);\n\n            return names.map((name: string) => registry[name]);\n        }\n\n        public getPlugin(type: string): IVisualPlugin {\n            if (!type) {\n                return null;\n            }\n\n            let plugin: IVisualPlugin = this.customVisualPlugins[type];\n\n            if (!plugin) {\n                return null;\n            }\n\n            return plugin;\n        }\n\n        public capabilities(type: string): VisualCapabilities {\n            let plugin: IVisualPlugin = this.getPlugin(type);\n\n            if (plugin) {\n                return plugin.capabilities;\n            }\n\n            return {};\n        }\n\n        private initCustomVisualPlugins(): void {\n            // Aster Plot\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, () => new samples.AsterPlot());\n\n            // Tornado Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, () => new samples.TornadoChart({\n                animator: new BaseAnimator()\n            }));\n\n            // Sankey Diagram\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, () => new samples.SankeyDiagram());\n\n            // Mekko Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, () => new samples.MekkoChart({\n                chartType: samples.MekkoChartType.HundredPercentStackedColumn,\n                isScrollable: true,\n                animator: new WebColumnChartAnimator(),\n                behavior: new CartesianChartBehavior([new ColumnChartWebBehavior()])\n            }));\n\n            // Bullet Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, () => new samples.BulletChart());\n\n            // Word Cloud\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, () => new samples.WordCloud({\n                animator: new BaseAnimator()\n            }));\n\n            // Chiclet Slicer\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, () => new samples.ChicletSlicer({\n                behavior: new samples.ChicletSlicerWebBehavior()\n            }));\n\n            // Enhanced Scatter Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, () => new samples.EnhancedScatterChart());\n\n            // Radar Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, () => new samples.RadarChart({\n                animator: new BaseAnimator()\n            }));\n            // DotPlot\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, () => new samples.DotPlot({\n                animator: new BaseAnimator()\n            }));\n\n            // Histogram\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, () => new samples.Histogram({\n                animator: new BaseAnimator()\n            }));\n\n            // Force Graph\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, () => new samples.ForceGraph());\n\n            // Gantt Chart\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, () => new samples.Gantt());\r\n\n            // Stream Graph\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, () => new samples.StreamGraph());\n\n            createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dropdownSlicer, () => new samples.DropdownSlicer({\r\n                behavior: new samples.DropdownSlicerWebBehavior()\r\n            }));\n        }\n    }\n\n    export function createCustomVisualPluginService(): IVisualPluginService {\n        return new CustomVisualPluginService();\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./src/Clients/CustomVisuals/services/customVisualPluginService.ts\n **/"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjCA;;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2CA;AAAA;AAgCA;AA1BA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAjBA;AAmBA;AAAA;AAkKA;AACA;AACA;AACA;AACA;AACA;AAiuBA;AAhtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AASA;AACA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAt4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwuBA;AAAA;AAx4BA;AAy4BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACphCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAwFA;AAAA;AAuBA;AAlBA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAoBA;AAbA;AAcA;AACA;AACA;AACA;AAZA;AAAA;AACA;AACA;;;AAAA;AAEA;AAAA;AACA;AACA;;;AAAA;AAQA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AA1JA;AA2JA;AAAA;AAEA;AAAA;AAmBA;AAlBA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAnBA;AAqBA;AACA;AACA;AAFA;AAIA;AAwVA;AA7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA0BA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAQA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAx0CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAijCA;AAAA;AA10CA;AA20CA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACtpDA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAgKA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AA3CA;AA6CA;AAAA;AA4nBA;AApmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AASA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA1nBA;AACA;AACA;AACA;AAkBA;AAsmBA;AAAA;AA5nBA;AAmoBA;;AAEA;AACA;AA+WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAvGA;AAAA;AACA;AACA;AACA;AACA;AACA;AAoGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AA/mDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAoDA;AAuwCA;AAAA;AAjnDA;AAmnDA;AAiBA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAoCA;AAgCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAgBA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA/jCA;AAEA;AACA;AA6jCA;AAAA;AAjkCA;AAmkCA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAOA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAvBA;AAwBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACp+HA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAkFA;AAyKA;AA/BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AApDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAsBA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AAcA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AAIA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAKA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxhCA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAg6BA;AAAA;AA1hCA;AA2hCA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC7oCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAoBA;AA88BA;AArvBA;AAAA;AACA;AACA;;;AAAA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAh+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkwBA;AAAA;AAl+BA;AAo+BA;AACA;AAAA;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAWA;AAAA;AAiCA;AA9BA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAjCA;AAkCA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC3wCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAJA;AAIA;AA8DA;AAQA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AALA;AAOA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AALA;AAOA;AAAA;AACA;AACA;;;AAAA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAwSA;AAlCA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAuBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAeA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AACA;AAGA;AACA;AAEA;AAKA;AAKA;AAKA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AAEA;AAOA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAMA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAh1CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAolCA;AAAA;AAl1CA;AAo1CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AATA;AAWA;AACA;AAIA;AACA;AANA;AAOA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC1gDA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AAcA;AAAA;AACA;AACA;AACA;AAFA;AAGA;AAiBA;;;AAGA;AACA;AAaA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAnNA;AACA;AAmNA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA+EA;AA0SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAt3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8oBA;AAAA;AAx3BA;AA03BA;AAAA;AACA;AAcA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAlJA;AAmJA;AAEA;AACA;AAAA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAaA;AAAA;AAoIA;AA3HA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AApIA;AAsIA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA6BA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACjtDA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkCA;AAAA;AAi/BA;AAp0BA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AASA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA/+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAi1BA;AAAA;AAj/BA;AAk/BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACjjCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAiFA;AAAA;AACA;AA2DA;AAKA;AACA;AACA;AACA;AAo3EA;AA92EA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AALA;AAQA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AALA;AAQA;AAAA;AACA;AACA;;;AAAA;AAEA;AAAA;AACA;AACA;;;AAAA;AA0UA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAcA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAcA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AAOA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAMA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAr7EA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4gEA;AAAA;AAx7EA;AAy7EA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC1iFA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAYA;AAAA;AAWA;AASA;AACA;AACA;AACA;AAmqCA;AArgCA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAzpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAugCA;AAAA;AA1rCA;AA2rCA;AAAA;AAAA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9uCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AA0CA;;AAEA;AACA;AAAA;AAoBA;AAjBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AApBA;AAsBA;AAwTA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AApIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAx7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AA6vBA;AAAA;AA17BA;AA27BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC9hCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAoFA;AAIA;AACA;AACA;AAEA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAkBA;AAAA;AAnBA;AAqBA;AA6XA;AAvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA0BA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAvBA;AAAA;AACA;AACA;AACA;;;AAAA;AAsBA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAeA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAxiDA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuvCA;AAAA;AA3iDA;AA4iDA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACxrDA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8DA;AAkOA;AAvIA;AACA;AACA;AACA;AACA;AACA;AAWA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqFA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA9FA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAvkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgfA;AAAA;AAzkBA;AAilBA;AAAA;AAuBA;AAlBA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAvBA;AAwBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACpwBA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAAA;AA8uBA;AAluBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAJA;AAOA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAJA;AAOA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAyJA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AAEA;AACA;AACA;AADA;AAEA;AACA;AAEA;AACA;AACA;AA5uBA;AA+FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAyfA;AAAA;AA9uBA;AA+uBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACr4BA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAuDA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AASA;AACA;AACA;AACA;AAuMA;AACA;AACA;AACA;AACA;AACA;AAk4BA;AA72BA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAIA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3kCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAy4BA;AAAA;AA1lCA;AAmmCA;AAAA;AA2BA;AAxBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AA3BA;AA6BA;AAAA;AAmBA;AAlBA;AAAA;AACA;AACA;;;AAAA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAnBA;AAoBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACx0CA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAgFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCA;AAAA;AACA;AAuIA;AApIA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAxIA;AA0IA;AAAA;AAAA;AAAA;AAoBA;AAnBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AApBA;AAsBA;AAAA;AAAA;AAAA;AAqBA;AApBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AArBA;AAuBA;AAAA;AAAA;AAAA;AAoBA;AAnBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AApBA;AAsBA;AAAA;AAAA;AAAA;AAwCA;AAvCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAxCA;AA0CA;AAAA;AAAA;AAAA;AAoBA;AAnBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AApBA;AAsBA;AAqCA;AACA;AACA;AACA;AACA;AACA;AArCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAvFA;AAyFA;AAAA;AA2HA;AA1HA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AA3HA;AA+LA;AA6BA;AA7BA;AA8BA;AACA;AACA;AACA;AACA;AACA;AA5BA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAjDA;AAmDA;AAAA;AAAA;AACA;AACA;AAsBA;AAkIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4nBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAyJA;AA3xBA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAYA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA18BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAq1BA;AAAA;AA7+BA;AA8+BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC/wDA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAgLA;AAwlBA;AAzkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtwBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0lBA;AAAA;AAxwBA;AAywBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACh3BA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAwBA;AAeA;AAEA;AAAA;AA4PA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA+uBA;AA7uBA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAKA;AAKA;AAKA;AAKA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA7+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAowBA;AAAA;AAn/BA;AAo/BA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AC5jCA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AAAA;AAKA;AA8NA;AA/KA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAjOA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiLA;AAAA;AAnOA;AAoOA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACvRA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;ACnJA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;;;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAvGA;AAyGA;AACA;AACA;AAFA;AAGA;AAAA;AAAA;AACA;;;;","sourceRoot":""}