!function(modules) {
    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: !1
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
        module.loaded = !0, module.exports;
    }
    var installedModules = {};
    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
    __webpack_require__.p = "", __webpack_require__(0);
}([ function(module, exports, __webpack_require__) {
    module.exports = __webpack_require__(13);
}, , , , , , , , , , , , , function(module, exports, __webpack_require__) {
    function requireAll(requireContext) {
        return requireContext.keys().map(requireContext);
    }
    window.jsCommon, window.powerbi, window.powerbitests, window.InJs, window.debug, 
    window.jasmine, window.Microsoft;
    window.jsCommon = window.jsCommon || {}, window.powerbi = window.powerbi || {}, 
    window.debug = window.debug || {}, window.InJs = window.InJs || {}, requireAll(__webpack_require__(14)), 
    __webpack_require__(36), __webpack_require__(37), __webpack_require__(38), __webpack_require__(39), 
    __webpack_require__(40), __webpack_require__(41), __webpack_require__(42), __webpack_require__(43), 
    __webpack_require__(44), __webpack_require__(45), __webpack_require__(46), __webpack_require__(47), 
    __webpack_require__(48), __webpack_require__(49), __webpack_require__(50), __webpack_require__(51), 
    __webpack_require__(52), __webpack_require__(53), __webpack_require__(54), __webpack_require__(55), 
    __webpack_require__(56);
}, function(module, exports, __webpack_require__) {
    function webpackContext(req) {
        return __webpack_require__(webpackContextResolve(req));
    }
    function webpackContextResolve(req) {
        return map[req] || function() {
            throw new Error("Cannot find module '" + req + "'.");
        }();
    }
    var map = {
        "./styles/styles.less": 15,
        "./visuals/asterPlot/visual/styles/asterPlot.less": 17,
        "./visuals/bulletChart/visual/styles/bulletChart.less": 18,
        "./visuals/chicletSlicer/visual/styles/chicletSlicer.less": 19,
        "./visuals/chordChart/visual/styles/chordChart.less": 20,
        "./visuals/dotPlot/visual/styles/dotPlot.less": 21,
        "./visuals/enhancedScatterChart/visual/styles/enhancedScatterChart.less": 22,
        "./visuals/forceGraph/visual/styles/forceGraph.less": 23,
        "./visuals/gantt/visual/styles/gantt.less": 24,
        "./visuals/globeMap/visual/styles/globeMap.less": 25,
        "./visuals/histogram/visual/styles/histogram.less": 26,
        "./visuals/lineDotChart/visual/styles/lineDotChart.less": 27,
        "./visuals/mekkoChart/visual/styles/mekkoChart.less": 28,
        "./visuals/radarChart/visual/styles/radarChart.less": 29,
        "./visuals/sankeyDiagram/visual/styles/sankeyDiagram.less": 30,
        "./visuals/streamGraph/visual/styles/streamGraph.less": 31,
        "./visuals/sunburst/visual/styles/sunburst.less": 32,
        "./visuals/timeline/visual/styles/timeline.less": 33,
        "./visuals/tornadoChart/visual/styles/tornadoChart.less": 34,
        "./visuals/wordCloud/visual/styles/wordCloud.less": 35
    };
    webpackContext.keys = function() {
        return Object.keys(map);
    }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, 
    webpackContext.id = 14;
}, function(module, exports) {}, , function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, ValueFormatter = powerbi.visuals.valueFormatter, AsterPlotVisualClassName = "asterPlot", AsterPlotLegendObjectName = "legend", AsterDefaultOuterLineThickness = 1, AsterDefaultLabelFill = {
                    solid: {
                        color: "#333"
                    }
                }, AsterDefaultLegendFontSize = 8, AsterRadiusRatio = .9, AsterConflictRatio = .9, MaxPrecision = 17, AsterPlotWebBehavior = function() {
                    function AsterPlotWebBehavior() {}
                    return AsterPlotWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.selection = options.selection, this.highlightedSelection = options.highlightedSelection, 
                        this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.selection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                        }), this.highlightedSelection && this.highlightedSelection.on("click", function(d, i) {
                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, AsterPlotWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.selection.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);
                        });
                    }, AsterPlotWebBehavior;
                }(), AsterPlotWarning = function() {
                    function AsterPlotWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(AsterPlotWarning.prototype, "code", {
                        get: function() {
                            return "AsterPlotWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), AsterPlotWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, AsterPlotWarning;
                }();
                samples.AsterPlotWarning = AsterPlotWarning;
                var AsterPlot = function() {
                    function AsterPlot() {
                        this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 15,
                            left: 10
                        };
                    }
                    return AsterPlot.prototype.getDefaultAsterData = function() {
                        return {
                            dataPoints: [],
                            highlightedDataPoints: [],
                            legendData: {
                                dataPoints: [],
                                title: null,
                                fontSize: AsterDefaultLegendFontSize,
                                labelColor: visuals.LegendData.DefaultLegendLabelFillColor
                            },
                            legendSettings: {
                                show: !1,
                                position: "Top",
                                showTitle: !0,
                                labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                                titleText: "",
                                fontSize: AsterDefaultLegendFontSize
                            },
                            valueFormatter: null,
                            labelSettings: {
                                show: !1,
                                displayUnits: 0,
                                precision: visuals.dataLabelUtils.defaultLabelPrecision,
                                labelColor: visuals.dataLabelUtils.defaultLabelColor,
                                fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt
                            },
                            showOuterLine: !1,
                            outerLineThickness: AsterDefaultOuterLineThickness
                        };
                    }, AsterPlot.prototype.converter = function(dataView, colors) {
                        var asterDataResult = this.getDefaultAsterData();
                        if (!this.dataViewContainsCategory(dataView) || 1 !== dataView.categorical.categories.length) return asterDataResult;
                        var catDv = dataView.categorical, cat = catDv.categories[0], catSource = cat.source, catValues = cat.values, values = catDv.values, catObjects = cat.objects, colorHelper = new visuals.ColorHelper(colors, AsterPlot.Properties.dataPoint.fill), hasHighlights = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);
                        if (dataView.metadata || dataView.metadata.objects) {
                            var objects = dataView.metadata.objects;
                            asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings), 
                            this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings), asterDataResult.showOuterLine = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine), 
                            asterDataResult.outerLineThickness = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);
                        }
                        var labelSettings = asterDataResult.labelSettings;
                        if (!catValues || catValues.length < 1 || !values || values.length < 1) return asterDataResult;
                        for (var formatStringProp = AsterPlot.Properties.general.formatString, maxValue = Math.max(d3.min(values[0].values)), minValue = Math.min(0, d3.min(values[0].values)), labelFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(values[0].source, formatStringProp),
                            precision: labelSettings.precision,
                            value: 0 === labelSettings.displayUnits && null != maxValue ? maxValue : labelSettings.displayUnits
                        }), categorySourceFormatString = visuals.valueFormatter.getFormatString(catSource, formatStringProp), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), i = 0; i < catValues.length; i++) {
                            var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString), currentValue = values[0].values[i], tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);
                            if (values.length > 1) {
                                var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].values[i], null, null, 1)[1];
                                toolTip && tooltipInfo.push(toolTip), currentValue += values[1].values[i];
                            }
                            var identity = cat.identity[i], color = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key), selector = visuals.SelectionId.createWithId(identity), sliceWidth = Math.max(0, values.length > 1 ? values[1].values[i] : 1);
                            if (asterDataResult.dataPoints.push({
                                sliceHeight: values[0].values[i] - minValue,
                                sliceWidth: sliceWidth,
                                label: labelFormatter.format(currentValue),
                                color: color,
                                identity: selector,
                                selected: !1,
                                tooltipInfo: tooltipInfo,
                                labelFontSize: fontSizeInPx,
                                highlight: !1
                            }), asterDataResult.legendSettings.show && asterDataResult.legendData.dataPoints.push({
                                label: catValues[i],
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: selector
                            }), hasHighlights) {
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(selector), notNull = null != values[0].highlights[i];
                                if (currentValue = notNull ? values[0].highlights[i] : 0, tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0), 
                                values.length > 1) {
                                    var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].highlights[i], null, null, 1)[1];
                                    toolTip && tooltipInfo.push(toolTip), currentValue += null !== values[1].highlights[i] ? values[1].highlights[i] : 0;
                                }
                                asterDataResult.highlightedDataPoints.push({
                                    sliceHeight: notNull ? values[0].highlights[i] - minValue : null,
                                    sliceWidth: Math.max(0, values.length > 1 && null !== values[1].highlights[i] ? values[1].highlights[i] : sliceWidth),
                                    label: labelFormatter.format(currentValue),
                                    color: color,
                                    identity: highlightIdentity,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    labelFontSize: fontSizeInPx,
                                    highlight: !0
                                });
                            }
                        }
                        return asterDataResult;
                    }, AsterPlot.prototype.dataViewContainsCategory = function(dataView) {
                        return dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories && dataView.categorical.categories[0];
                    }, AsterPlot.prototype.getLabelSettings = function(objects, labelSettings) {
                        var asterPlotLabelsProperties = AsterPlot.Properties, precision = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);
                        labelSettings.precision = void 0 === precision ? precision : Math.min(precision, MaxPrecision), 
                        labelSettings.show = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.show, labelSettings.show), 
                        labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize), 
                        labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);
                        var colorHelper = new visuals.ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);
                        return labelSettings.labelColor = colorHelper.getColorForMeasure(objects, ""), labelSettings;
                    }, AsterPlot.prototype.updateLegendSettings = function(objects, catSource, legendSettings) {
                        var legendProperties = AsterPlot.Properties.legend;
                        legendSettings.show = powerbi.DataViewObjects.getValue(objects, legendProperties.show, legendSettings.show), 
                        legendSettings.position = powerbi.DataViewObjects.getValue(objects, legendProperties.position, legendSettings.position), 
                        legendSettings.showTitle = powerbi.DataViewObjects.getValue(objects, legendProperties.showTitle, legendSettings.showTitle);
                        var titleText = powerbi.DataViewObjects.getValue(objects, legendProperties.titleText, "");
                        legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText, 
                        legendSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor), 
                        legendSettings.fontSize = powerbi.DataViewObjects.getValue(objects, legendProperties.fontSize, legendSettings.fontSize);
                    }, AsterPlot.prototype.init = function(options) {
                        this.hostService = options.host;
                        var element = options.element, svg = this.svg = d3.select(element.get(0)).append("svg").classed(AsterPlotVisualClassName, !0).style("position", "absolute");
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = svg.append("g"), 
                        this.mainLabelsElement = svg.append("g"), this.behavior = new AsterPlotWebBehavior(), 
                        this.clearCatcher = visuals.appendClearCatcher(this.mainGroupElement);
                        var interactivity = options.interactivity;
                        this.interactivityService = visuals.createInteractivityService(this.hostService), 
                        this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, AsterPlot.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                            this.currentViewport = {
                                height: Math.max(0, options.viewport.height),
                                width: Math.max(0, options.viewport.width)
                            };
                            var dataView = this.dataView = options.dataViews[0], convertedData = this.data = this.converter(dataView, this.colors);
                            if (!convertedData || !convertedData.dataPoints || 0 === convertedData.dataPoints.length) return void this.clearData();
                            this.interactivityService && (this.interactivityService.applySelectionStateToData(convertedData.dataPoints), 
                            this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints)), 
                            this.renderLegend(convertedData), this.updateViewPortAccordingToLegend(), this.svg.attr({
                                height: Math.max(0, this.currentViewport.height),
                                width: Math.max(0, this.currentViewport.width)
                            });
                            var margin = this.margin, transformX = (this.currentViewport.width - margin.left) / 2, transformY = (this.currentViewport.height - margin.top) / 2;
                            this.mainGroupElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                            this.mainLabelsElement.attr("transform", visuals.SVGUtil.translate(transformX, transformY)), 
                            this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-transformX, -transformY)), 
                            this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove(), this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove(), 
                            visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                            var dataPoints = convertedData.dataPoints;
                            if (dataPoints && 0 !== dataPoints.length) {
                                var highlightedSelection, selection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);
                                this.hasHighlights && (highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, !0));
                                var interactivityService = this.interactivityService;
                                if (interactivityService) {
                                    var behaviorOptions = {
                                        selection: selection,
                                        highlightedSelection: highlightedSelection,
                                        clearCatcher: this.clearCatcher,
                                        interactivityService: this.interactivityService
                                    };
                                    interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);
                                }
                            }
                        }
                    }, AsterPlot.prototype.renderArcsAndLabels = function(dataPoints, duration, labelSettings, isHighlight) {
                        void 0 === isHighlight && (isHighlight = !1);
                        var margin = this.margin, width = this.currentViewport.width - margin.left - margin.right, height = this.currentViewport.height - margin.top - margin.bottom, radius = Math.min(width, height) / 2, innerRadius = .3 * (labelSettings.show ? radius * AsterRadiusRatio : radius), maxScore = d3.max(dataPoints, function(d) {
                            return d.sliceHeight;
                        }), totalWeight = d3.sum(dataPoints, function(d) {
                            return d.sliceWidth;
                        }), hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = this.hasHighlights, pie = d3.layout.pie().sort(null).value(function(d) {
                            return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight;
                        }), arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(function(d) {
                            var height = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore, heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);
                            return Math.max(heightIsLabelsOn, innerRadius);
                        }), arcDescriptorDataPoints = pie(dataPoints), classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice, selection = this.mainGroupElement.selectAll(classSelector.selector).data(arcDescriptorDataPoints, function(d, idx) {
                            return d.data ? d.data.identity.getKey() : idx;
                        });
                        if (selection.enter().append("path").attr("stroke", "#333").classed(classSelector["class"], !0), 
                        selection.attr("fill", function(d) {
                            return d.data.color;
                        }).style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights);
                        }).transition().duration(duration).attrTween("d", function(data) {
                            if (!this.oldData) return this.oldData = data, function() {
                                return arc(data);
                            };
                            var interpolation = d3.interpolate(this.oldData, data);
                            return this.oldData = interpolation(0), function(x) {
                                return arc(interpolation(x));
                            };
                        }), selection.exit().remove(), visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.data.tooltipInfo;
                        }), labelSettings.show && (!hasHighlights || hasHighlights && isHighlight)) {
                            var labelRadCalc_1 = function(d) {
                                var height = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
                                return Math.max(height, innerRadius);
                            }, labelArc = d3.svg.arc().innerRadius(function(d) {
                                return labelRadCalc_1(d.data);
                            }).outerRadius(function(d) {
                                return labelRadCalc_1(d.data);
                            }), lineRadCalc_1 = function(d) {
                                var height = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
                                return height = innerRadius + height * AsterRadiusRatio, Math.max(height, innerRadius);
                            }, outlineArc = d3.svg.arc().innerRadius(function(d) {
                                return lineRadCalc_1(d.data);
                            }).outerRadius(function(d) {
                                return lineRadCalc_1(d.data);
                            }), layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);
                            this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);
                        } else visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0);
                        return isHighlight || (this.drawCenterText(innerRadius), this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints)), 
                        selection;
                    }, AsterPlot.prototype.getLabelLayout = function(labelSettings, arc, viewport) {
                        var midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, textProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            text: ""
                        }, isLabelsHasConflict = function(d) {
                            var pos = arc.centroid(d);
                            textProperties.text = d.data.label;
                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties), verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
                            return d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels, 
                            d.isLabelHasConflict;
                        };
                        return {
                            labelText: function(d) {
                                textProperties.text = d.data.label;
                                var pos = arc.centroid(d), xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0], spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
                                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                            },
                            labelLayout: {
                                x: function(d) {
                                    var pos = arc.centroid(d);
                                    textProperties.text = d.data.label;
                                    var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
                                    return xPos;
                                },
                                y: function(d) {
                                    var pos = arc.centroid(d), yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
                                    return yPos;
                                }
                            },
                            filter: function(d) {
                                return null != d && !_.isEmpty(d.data.label);
                            },
                            style: {
                                fill: labelSettings.labelColor,
                                "font-size": textProperties.fontSize,
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                }
                            }
                        };
                    }, AsterPlot.prototype.drawLabels = function(data, context, layout, viewport, outlineArc, labelArc) {
                        var _this = this, dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0);
                        if (0 === filteredData.length) return void visuals.dataLabelUtils.cleanDataLabels(context, !0);
                        context.select(AsterPlot.labelGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.labelGraphicsContextClass["class"], !0);
                        var labels = context.select(AsterPlot.labelGraphicsContextClass.selector).selectAll(".data-labels").data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        });
                        if (labels.enter().append("text").classed("data-labels", !0), labels) {
                            labels.attr({
                                x: function(d) {
                                    return d.labelX;
                                },
                                y: function(d) {
                                    return d.labelY;
                                },
                                dy: ".35em"
                            }).text(function(d) {
                                return d.labeltext;
                            }).style(layout.style), labels.exit().remove(), context.select(AsterPlot.linesGraphicsContextClass.selector).empty() && context.append("g").classed(AsterPlot.linesGraphicsContextClass["class"], !0), 
                            filteredData = _.filter(filteredData, function(d) {
                                return null !== d.data.sliceHeight && 0 !== d.data.sliceHeight;
                            });
                            var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                                return d.data.identity.getKey();
                            }), labelLinePadding = 4, chartLinePadding = 1.02, midAngle = function(d) {
                                return d.startAngle + (d.endAngle - d.startAngle) / 2;
                            };
                            lines.enter().append("polyline").classed("line-label", !0), lines.attr("points", function(d) {
                                var textPoint = [ d.labelX, d.labelY ];
                                textPoint[0] = textPoint[0] + (midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding;
                                var chartPoint = outlineArc.centroid(d);
                                return chartPoint[0] *= chartLinePadding, chartPoint[1] *= chartLinePadding, [ chartPoint, textPoint ];
                            }).style({
                                opacity: .5,
                                "fill-opacity": 0,
                                stroke: function(d) {
                                    return _this.data.labelSettings.labelColor;
                                }
                            }), lines.exit().remove();
                        }
                    }, AsterPlot.prototype.renderLegend = function(asterPlotData) {
                        if (asterPlotData && asterPlotData.legendData) {
                            var legendData = asterPlotData.legendData, objects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null, legendObjectProperties = powerbi.DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});
                            if (legendObjectProperties) {
                                var legendSettings = asterPlotData.legendSettings;
                                legendObjectProperties.titleText = legendSettings.titleText, visuals.LegendData.update(legendData, legendObjectProperties), 
                                this.legend.changeOrientation(visuals.LegendPosition[legendSettings.position]);
                            }
                            this.legend.drawLegend(legendData, _.clone(this.currentViewport)), visuals.Legend.positionChartArea(this.svg, this.legend);
                        }
                    }, AsterPlot.prototype.updateViewPortAccordingToLegend = function() {
                        var legendSettings = this.data.legendSettings;
                        if (legendSettings && legendSettings.show) {
                            var legendMargins = this.legend.getMargins(), legendPosition = visuals.LegendPosition[legendSettings.position];
                            switch (legendPosition) {
                              case visuals.LegendPosition.Top:
                              case visuals.LegendPosition.TopCenter:
                              case visuals.LegendPosition.Bottom:
                              case visuals.LegendPosition.BottomCenter:
                                this.currentViewport.height -= legendMargins.height;
                                break;

                              case visuals.LegendPosition.Left:
                              case visuals.LegendPosition.LeftCenter:
                              case visuals.LegendPosition.Right:
                              case visuals.LegendPosition.RightCenter:
                                this.currentViewport.width -= legendMargins.width;
                            }
                        }
                    }, AsterPlot.prototype.drawOuterLine = function(innerRadius, radius, data) {
                        var mainGroup = this.mainGroupElement, outlineArc = d3.svg.arc().innerRadius(innerRadius).outerRadius(radius);
                        if (this.data.showOuterLine) {
                            var OuterThickness = this.data.outerLineThickness + "px", outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                            outerLine.enter().append("path"), outerLine.attr("fill", "none").attr({
                                stroke: "#333",
                                "stroke-width": OuterThickness,
                                d: outlineArc
                            }).style("opacity", 1).classed(AsterPlot.OuterLine["class"], !0), outerLine.exit().remove();
                        } else mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
                    }, AsterPlot.prototype.getCenterText = function(dataView) {
                        if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values) for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (!column.isMeasure) return column.displayName;
                        }
                        return "";
                    }, AsterPlot.prototype.drawCenterText = function(innerRadius) {
                        var text = this.getCenterText(this.dataView);
                        if (_.isEmpty(text)) return void this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
                        var centerTextProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontWeight: "bold",
                            fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
                            text: text
                        };
                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty() && (this.centerText = this.mainGroupElement.append("text").classed(AsterPlot.CenterLabelClass["class"], !0)), 
                        this.centerText.style({
                            "line-height": 1,
                            "font-weight": centerTextProperties.fontWeight,
                            "font-size": centerTextProperties.fontSize,
                            fill: this.getLabelFill(this.dataView).solid.color
                        }).attr({
                            dy: "0.35em",
                            "text-anchor": "middle"
                        }).text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                    }, AsterPlot.prototype.getLabelFill = function(dataView) {
                        return this.dataViewContainsObjects(dataView) ? powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill) : AsterDefaultLabelFill;
                    }, AsterPlot.prototype.dataViewContainsObjects = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.objects;
                    }, AsterPlot.prototype.enumerateLegend = function(instances) {
                        var legendSettings = this.data.legendSettings, instance = {
                            selector: null,
                            objectName: AsterPlotLegendObjectName,
                            displayName: "Legend",
                            properties: {
                                show: legendSettings.show,
                                position: legendSettings.position,
                                showTitle: legendSettings.showTitle,
                                titleText: legendSettings.titleText,
                                labelColor: legendSettings.labelColor,
                                fontSize: legendSettings.fontSize
                            }
                        };
                        instances.push(instance);
                    }, AsterPlot.prototype.clearData = function() {
                        this.mainGroupElement.selectAll("path").remove(), visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, !0), 
                        this.legend.drawLegend({
                            dataPoints: []
                        }, this.currentViewport);
                    }, AsterPlot.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, AsterPlot.prototype.enumerateLabels = function(instances) {
                        var labelSettings = this.data.labelSettings, labels = {
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: labelSettings.show,
                                fontSize: labelSettings.fontSize,
                                labelPrecision: labelSettings.precision,
                                labelDisplayUnits: labelSettings.displayUnits,
                                color: labelSettings.labelColor
                            }
                        };
                        instances.push(labels);
                    }, AsterPlot.prototype.enumerateObjectInstances = function(options) {
                        var instances = [];
                        if (!this.dataViewContainsCategory(this.dataView)) return instances;
                        switch (options.objectName) {
                          case AsterPlotLegendObjectName:
                            this.data && this.enumerateLegend(instances);
                            break;

                          case "label":
                            var label = {
                                objectName: "label",
                                displayName: "Label",
                                selector: null,
                                properties: {
                                    fill: this.getLabelFill(this.dataView)
                                }
                            };
                            instances.push(label);
                            break;

                          case "labels":
                            this.enumerateLabels(instances);
                            break;

                          case "outerLine":
                            var outerLine = {
                                objectName: "outerLine",
                                displayName: "Outer Line",
                                selector: null,
                                properties: {
                                    show: this.data.showOuterLine,
                                    thickness: this.data.outerLineThickness
                                }
                            };
                            instances.push(outerLine);
                        }
                        return instances;
                    }, AsterPlot.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Y: {
                                    max: 2
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            label: {
                                displayName: "Center Label",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Detail Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            outerLine: {
                                displayName: "Outer line",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    thickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, AsterPlot.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        legend: {
                            show: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "show"
                            },
                            position: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "position"
                            },
                            showTitle: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "showTitle"
                            },
                            titleText: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "titleText"
                            },
                            labelColor: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "labelColor"
                            },
                            fontSize: {
                                objectName: AsterPlotLegendObjectName,
                                propertyName: "fontSize"
                            }
                        },
                        label: {
                            fill: {
                                objectName: "label",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            labelDisplayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            labelPrecision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        },
                        outerLine: {
                            show: {
                                objectName: "outerLine",
                                propertyName: "show"
                            },
                            thickness: {
                                objectName: "outerLine",
                                propertyName: "thickness"
                            }
                        }
                    }, AsterPlot.AsterSlice = createClassAndSelector("asterSlice"), AsterPlot.AsterHighlightedSlice = createClassAndSelector("asterHighlightedSlice"), 
                    AsterPlot.OuterLine = createClassAndSelector("outerLine"), AsterPlot.labelGraphicsContextClass = createClassAndSelector("labels"), 
                    AsterPlot.linesGraphicsContextClass = createClassAndSelector("lines"), AsterPlot.CenterLabelClass = createClassAndSelector("centerLabel"), 
                    AsterPlot.CenterTextFontHeightCoefficient = .4, AsterPlot.CenterTextFontWidthCoefficient = 1.9, 
                    AsterPlot;
                }();
                samples.AsterPlot = AsterPlot;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTornadoChartWarning() {
                    return new TornadoChartWarning();
                }
                var PixelConverter = jsCommon.PixelConverter, TornadoWebBehavior = function() {
                    function TornadoWebBehavior() {}
                    return TornadoWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), this.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, TornadoWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, TornadoWebBehavior;
                }(), TornadoChartScrolling = function() {
                    function TornadoChartScrolling(getRoot, getViewport, getMargin, isScrollable) {
                        this.scrollYBrush = d3.svg.brush(), this.getRoot = getRoot, this.getViewport = getViewport, 
                        this.isScrollable = isScrollable;
                    }
                    return Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                        get: function() {
                            return this.getRoot();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                        get: function() {
                            return this.getViewport();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartScrolling.prototype.renderY = function(data, prefferedHeight, onScroll) {
                        var _this = this;
                        if (this.isYScrollBarVisible = prefferedHeight > this.viewport.height && this.viewport.height > 0 && this.viewport.width > 0, 
                        this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, "y brush"), 
                        this.updateScrollViewport(), !this.isYScrollBarVisible) return void onScroll.call(this, jQuery.extend(!0, {}, data), 0, 1);
                        var scrollSpaceLength = this.viewport.height, extentData = this.getExtentData(prefferedHeight, scrollSpaceLength), onRender = function(wheelDelta) {
                            void 0 === wheelDelta && (wheelDelta = 0);
                            var position = _this.scrollYBrush.extent();
                            if (0 !== wheelDelta) {
                                var halfScrollsize = (position[1] - position[0]) / 2;
                                if (position[0] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, position[1] += wheelDelta > 0 ? halfScrollsize : -halfScrollsize, 
                                position[0] < 0) {
                                    var offset = 0 - position[0];
                                    position[0] += offset, position[1] += offset;
                                }
                                if (position[1] > scrollSpaceLength) {
                                    var offset = position[1] - scrollSpaceLength;
                                    position[0] -= offset, position[1] -= offset;
                                }
                                _this.scrollYBrush.extent(position), _this.brushGraphicsContextY.select(".extent").attr("y", position[0]);
                            }
                            var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
                            onScroll.call(_this, jQuery.extend(!0, {}, data), scrollPosition[0], scrollPosition[1]), 
                            _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], !0);
                        }, scrollYScale = d3.scale.ordinal().rangeBands([ 0, scrollSpaceLength ]);
                        this.scrollYBrush.y(scrollYScale).extent(extentData.value), this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender), 
                        onRender();
                    }, TornadoChartScrolling.prototype.updateScrollViewport = function() {
                        this.scrollViewport = {
                            height: this.viewport.height,
                            width: this.viewport.width
                        }, this.isYScrollBarVisible && this.isScrollable && (this.scrollViewport.width -= TornadoChart.ScrollBarWidth);
                    }, TornadoChartScrolling.prototype.createOrRemoveScrollbar = function(isVisible, brushGraphicsContext, brushClass) {
                        return isVisible && this.isScrollable ? brushGraphicsContext || this.root.append("g").classed(brushClass, !0) : brushGraphicsContext ? void brushGraphicsContext.remove() : void 0;
                    }, TornadoChartScrolling.prototype.renderScrollbar = function(brush, brushGraphicsContext, brushX, onRender) {
                        var _this = this;
                        brush.on("brush", function() {
                            return window.requestAnimationFrame(function() {
                                return onRender(0);
                            });
                        }), this.root.on("wheel", function() {
                            if (_this.isYScrollBarVisible) {
                                var wheelEvent = d3.event;
                                onRender(wheelEvent.deltaY);
                            }
                        }), brushGraphicsContext.attr({
                            transform: visuals.SVGUtil.translate(brushX, 0),
                            "drag-resize-disabled": "true"
                        }), brushGraphicsContext.call(brush), brushGraphicsContext.selectAll(".resize").remove(), 
                        brushGraphicsContext.select(".background").remove(), brushGraphicsContext.selectAll(".extent").style({
                            "fill-opacity": .125,
                            cursor: "default"
                        });
                    }, TornadoChartScrolling.prototype.setScrollBarSize = function(brushGraphicsContext, minExtent, isVertical) {
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth), 
                        brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                    }, TornadoChartScrolling.prototype.getExtentData = function(svgLength, scrollSpaceLength) {
                        var value = scrollSpaceLength * scrollSpaceLength / svgLength, scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value ? 1 : value / TornadoChartScrolling.ScrollBarMinLength;
                        value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                        var toScrollPosition = function(extent, scrollSpaceLength) {
                            var scrollSize = extent[1] - extent[0], scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                            scrollSize *= scaleMultipler;
                            var start = scrollPosition * (scrollSpaceLength - scrollSize), end = start + scrollSize;
                            return [ start / scrollSpaceLength, end / scrollSpaceLength ];
                        };
                        return {
                            value: [ 0, value ],
                            toScrollPosition: toScrollPosition
                        };
                    }, TornadoChartScrolling.prototype.clearData = function() {
                        this.brushGraphicsContextY && this.brushGraphicsContextY.selectAll("*").remove();
                    }, TornadoChartScrolling.ScrollBarMinLength = 15, TornadoChartScrolling;
                }(), TornadoChartWarning = function() {
                    function TornadoChartWarning() {}
                    return Object.defineProperty(TornadoChartWarning.prototype, "code", {
                        get: function() {
                            return "TornadoChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), TornadoChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, TornadoChartWarning;
                }();
                samples.TornadoChartWarning = TornadoChartWarning, samples.getTornadoChartWarning = getTornadoChartWarning;
                var TornadoChart = function() {
                    function TornadoChart(tornadoChartConstructorOptions) {
                        this.DefaultTornadoChartSettings = {
                            labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,
                            labelSettings: {
                                show: !0,
                                precision: null,
                                fontSize: TornadoChart.DefaultFontSize,
                                displayUnits: 0,
                                labelColor: visuals.dataLabelUtils.defaultInsideLabelColor
                            },
                            showCategories: !0,
                            showLegend: !0,
                            legendFontSize: TornadoChart.DefaultLegendFontSize,
                            legendColor: visuals.LegendData.DefaultLegendLabelFillColor,
                            categoriesFillColor: "#777"
                        }, this.DefaultFillColors = [ "purple", "teal" ], this.columnPadding = 5, this.leftLabelMargin = 4, 
                        this.InnerTextHeightDelta = 2, this.textOptions = {}, this.margin = {
                            top: 10,
                            right: 5,
                            bottom: 10,
                            left: 10
                        }, this.heightColumn = 0, this.widthLeftSection = 0, this.widthRightSection = 0, 
                        tornadoChartConstructorOptions && (this.svg = tornadoChartConstructorOptions.svg || this.svg, 
                        this.margin = tornadoChartConstructorOptions.margin || this.margin, this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding, 
                        this.animator = tornadoChartConstructorOptions.animator);
                    }
                    return TornadoChart.prototype.init = function(visualInitOptions) {
                        var fontSize, _this = this, style = visualInitOptions.style;
                        this.hostService = visualInitOptions.host;
                        var element = visualInitOptions.element;
                        this.colors = style.colorPalette.dataColors;
                        var interactivity = visualInitOptions.interactivity;
                        this.interactivityService = visuals.createInteractivityService(this.hostService);
                        var root;
                        this.svg ? this.root = root = this.svg : this.root = root = d3.select(element.get(0)).append("svg"), 
                        root.classed(TornadoChart.ClassName, !0).style("position", "absolute"), fontSize = root.style("font-size"), 
                        this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2), this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2)), 
                        this.textOptions.fontFamily = root.style("font-family"), this.scrolling = new TornadoChartScrolling(function() {
                            return root;
                        }, function() {
                            return _this.viewport;
                        }, function() {
                            return _this.margin;
                        }, !0);
                        var main = this.main = root.append("g");
                        this.clearCatcher = visuals.appendClearCatcher(main), this.columns = main.append("g").classed(TornadoChart.Columns["class"], !0), 
                        this.axes = main.append("g").classed(TornadoChart.Axes["class"], !0), this.labels = main.append("g").classed(TornadoChart.Labels["class"], !0), 
                        this.categories = main.append("g").classed(TornadoChart.Categories["class"], !0), 
                        this.behavior = new TornadoWebBehavior(), this.defaultTornadoChartDataView = {
                            categories: [],
                            series: [],
                            settings: null,
                            legend: null,
                            dataPoints: [],
                            highlightedDataPoints: []
                        }, this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, TornadoChart.prototype.update = function(visualUpdateOptions) {
                        visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && (this.viewport = {
                            height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
                            width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
                        }, this.animator ? this.durationAnimations = visuals.AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations) : this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250, 
                        this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]), this.interactivityService && (this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints), 
                        this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints)), 
                        this.render());
                    }, TornadoChart.prototype.updateElements = function() {
                        var elementsTranslate = visuals.SVGUtil.translate(this.widthLeftSection, 0);
                        this.root.attr({
                            height: this.viewport.height + this.margin.top + this.margin.bottom,
                            width: this.viewport.width + this.margin.left + this.margin.right
                        }), this.columns.attr("transform", elementsTranslate), this.labels.attr("transform", elementsTranslate), 
                        this.axes.attr("transform", elementsTranslate);
                    }, TornadoChart.prototype.converter = function(dataView) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.values && dataView.categorical.values[0])) return this.defaultTornadoChartDataView;
                        var categorical = dataView.categorical, categories = categorical.categories || [], values = categorical.values;
                        if (values.length > TornadoChart.MaxSeries) return this.hostService.setWarnings([ getTornadoChartWarning() ]), 
                        this.defaultTornadoChartDataView;
                        var category = categories[0], categoryValues = category.values, categoryValuesLength = categoryValues.length, objects = this.getObjectsFromDataView(dataView), formatStringProp = TornadoChart.Properties.general.formatString, valuesSourceFormatString = visuals.valueFormatter.getFormatString(values[0].source, formatStringProp), maxValue = d3.max(values[0].values), settings = this.parseSettings(objects, valuesSourceFormatString, maxValue);
                        this.hasDynamicSeries = !!values.source;
                        var hasHighlights = this.hasHighlights = !!(values.length > 0 && values[0].highlights);
                        this.labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize)
                        });
                        for (var series = [], dataPoints = [], highlightedDataPoints = [], categoriesLabels = [], groupedValues = values.grouped ? values.grouped() : null, maxCategoryLength = 0, showCategories = settings.showCategories, categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp), i = 0; categoryValuesLength > i; i++) {
                            var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString), textData = this.getTextData(formattedCategoryValue, !0);
                            categoriesLabels.push(textData), showCategories && textData.width > maxCategoryLength && (maxCategoryLength = textData.width);
                        }
                        var scrollBarWidth = categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height ? TornadoChart.ScrollBarWidth : 0;
                        this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;
                        var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;
                        this.updateElements();
                        var minValue = Math.min(d3.min(values[0].values), 0);
                        values.length === TornadoChart.MaxSeries && (minValue = d3.min([ minValue, d3.min(values[1].values) ]), 
                        maxValue = d3.max([ maxValue, d3.max(values[1].values) ]), maxColumnWidth /= TornadoChart.MaxSeries);
                        for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
                            var columnGroup = groupedValues && groupedValues.length > seriesIndex && groupedValues[seriesIndex].values ? groupedValues[seriesIndex] : null, parsedSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, columnGroup);
                            series.push(parsedSeries);
                            for (var currentSeries = values[seriesIndex], measureName = currentSeries.source.queryName, i = 0; categoryValuesLength > i; i++) {
                                var value = null == currentSeries.values[i] || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i], identity = visuals.SelectionIdBuilder.builder().withCategory(category, i).withSeries(values, columnGroup).withMeasure(measureName).createSelectionId(), formattedCategoryValue = categoriesLabels[i].text, tooltipInfo = void 0;
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
                                var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue, formatString = dataView.categorical.values[seriesIndex].source.format;
                                if (dataPoints.push({
                                    value: value,
                                    minValue: minValue,
                                    maxValue: currentMaxValue,
                                    formatString: formatString,
                                    color: parsedSeries.fill,
                                    selected: !1,
                                    identity: identity,
                                    tooltipData: tooltipInfo,
                                    categoryIndex: i
                                }), hasHighlights) {
                                    var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), highlight = currentSeries.highlights[i], highlightedValue = null != highlight ? highlight : 0;
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue), 
                                    highlightedDataPoints.push({
                                        value: highlightedValue,
                                        minValue: minValue,
                                        maxValue: currentMaxValue,
                                        formatString: formatString,
                                        color: parsedSeries.fill,
                                        selected: !1,
                                        identity: highlightIdentity,
                                        tooltipData: tooltipInfo,
                                        categoryIndex: i,
                                        highlight: !0
                                    });
                                }
                            }
                        }
                        return {
                            categories: categoriesLabels,
                            series: series,
                            settings: settings,
                            legend: this.getLegendData(series),
                            dataPoints: dataPoints,
                            highlightedDataPoints: highlightedDataPoints
                        };
                    }, TornadoChart.prototype.parseSettings = function(objects, formatString, value) {
                        var precision = this.getPrecision(objects), displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, this.DefaultTornadoChartSettings.labelSettings.displayUnits), labelSettings = this.DefaultTornadoChartSettings.labelSettings, labelValueFormatter = visuals.valueFormatter.create({
                            format: formatString,
                            precision: precision,
                            value: 0 === displayUnits && null != value ? value : displayUnits
                        });
                        return {
                            labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),
                            labelSettings: {
                                show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                                precision: precision,
                                fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                                displayUnits: displayUnits,
                                labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects)
                            },
                            showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),
                            showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),
                            legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),
                            legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),
                            categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),
                            labelValueFormatter: labelValueFormatter
                        };
                    }, TornadoChart.prototype.getColor = function(properties, defaultColor, objects) {
                        var colorHelper = new visuals.ColorHelper(this.colors, properties, defaultColor);
                        return colorHelper.getColorForMeasure(objects, "");
                    }, TornadoChart.prototype.getPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, this.DefaultTornadoChartSettings.labelSettings.precision);
                        return precision >= TornadoChart.MaxPrecision ? TornadoChart.MaxPrecision : precision;
                    }, TornadoChart.prototype.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {}), 
                        dataView.metadata.objects) : (this.legendObjectProperties = {}, null);
                    }, TornadoChart.prototype.parseSeries = function(dataViewValueColumns, index, isGrouped, columnGroup) {
                        var objects, categoryAxisObject, dataViewValueColumn = dataViewValueColumns ? dataViewValueColumns[index] : null, source = dataViewValueColumn ? dataViewValueColumn.source : null, identity = columnGroup ? columnGroup.identity : null, queryName = source ? source.queryName : null, selectionId = identity ? visuals.SelectionId.createWithId(identity) : visuals.SelectionIdBuilder.builder().withSeries(dataViewValueColumns, columnGroup).withMeasure(queryName).createSelectionId(), displayName = source ? source.groupName ? source.groupName : source.displayName : null;
                        isGrouped && columnGroup ? (categoryAxisObject = columnGroup.objects ? columnGroup.objects.categoryAxis : null, 
                        objects = columnGroup.objects) : source && (objects = source.objects, categoryAxisObject = objects ? objects.categoryAxis : null);
                        var color = this.getColor(TornadoChart.Properties.dataPoint.fill, this.DefaultFillColors[index], objects), categoryAxisEnd = categoryAxisObject ? categoryAxisObject.end : null;
                        return {
                            fill: color,
                            name: displayName,
                            selectionId: selectionId,
                            categoryAxisEnd: categoryAxisEnd
                        };
                    }, TornadoChart.prototype.getLegendData = function(series) {
                        var legendDataPoints = [];
                        return this.hasDynamicSeries && (legendDataPoints = series.map(function(series) {
                            return {
                                label: series.name,
                                color: series.fill,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: series.selectionId
                            };
                        })), {
                            dataPoints: legendDataPoints
                        };
                    }, TornadoChart.prototype.clearData = function() {
                        this.columns.selectAll("*").remove(), this.axes.selectAll("*").remove(), this.labels.selectAll("*").remove(), 
                        this.categories.selectAll("*").remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.scrolling.clearData();
                    }, TornadoChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, TornadoChart.prototype.render = function() {
                        var tornadoChartDataView = this.tornadoChartDataView;
                        return tornadoChartDataView && tornadoChartDataView.settings ? (this.renderLegend(), 
                        void this.scrolling.renderY(tornadoChartDataView, tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight, this.renderWithScrolling.bind(this))) : void this.clearData();
                    }, TornadoChart.prototype.renderWithScrolling = function(tornadoChartDataView, scrollStart, scrollEnd) {
                        if (this.tornadoChartDataView && this.tornadoChartDataView.settings) {
                            var categoriesLength = tornadoChartDataView.categories.length, startIndex = scrollStart * categoriesLength, endIndex = scrollEnd * categoriesLength, startIndexRound = Math.floor(startIndex), endIndexRound = Math.floor(endIndex), maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                            1 > scrollEnd - scrollStart && endIndexRound - startIndexRound > maxValues && (startIndex - startIndexRound > endIndex - endIndexRound ? startIndexRound++ : endIndex--), 
                            this.interactivityService && (this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints), 
                            this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints));
                            var scrollBarWidth = tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height ? TornadoChart.ScrollBarWidth : 0;
                            tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound), 
                            tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function(d) {
                                return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound;
                            }), this.tornadoChartDataView = tornadoChartDataView, this.computeHeightColumn(), 
                            this.renderMiddleSection(scrollBarWidth), this.renderAxes(), this.renderCategories();
                        }
                    }, TornadoChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, TornadoChart.prototype.computeHeightColumn = function() {
                        var length = this.tornadoChartDataView.categories.length;
                        this.heightColumn = (this.scrolling.scrollViewport.height - (length - 1) * this.columnPadding) / length;
                    }, TornadoChart.prototype.renderMiddleSection = function(scrollBarWidth) {
                        var tornadoChartDataView = this.tornadoChartDataView;
                        this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth), this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);
                        var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
                        this.renderColumns(dataPointsWithHighlights, 2 === tornadoChartDataView.series.length), 
                        this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
                    }, TornadoChart.prototype.calculateDataPoints = function(dataPoints, scrollBarWidth) {
                        var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth, categoriesLength = this.tornadoChartDataView.categories.length, settings = this.tornadoChartDataView.settings, hasHighlights = this.hasHighlights, heightColumn = Math.max(this.heightColumn, 0), py = heightColumn / 2, pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2, maxSeries = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;
                        maxSeries && (maxColumnWidth /= 2);
                        for (var i = 0; i < dataPoints.length; i++) {
                            var dataPoint = dataPoints[i], shiftToMiddle = categoriesLength > i && maxSeries, shiftToRight = i > categoriesLength - 1, widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth), dx = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;
                            dx = Math.max(dx, 0);
                            var highlighted = hasHighlights && dataPoint.highlight, highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0, dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset, label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
                            dataPoint.dx = dx, dataPoint.dy = dy, dataPoint.px = widthOfColumn / 2, dataPoint.py = highlighted ? pyHighlighted : py, 
                            dataPoint.angle = shiftToMiddle ? 180 : 0, dataPoint.width = widthOfColumn, dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn, 
                            dataPoint.label = label;
                        }
                    }, TornadoChart.prototype.renderColumns = function(columnsData, selectSecondSeries) {
                        void 0 === selectSecondSeries && (selectSecondSeries = !1);
                        var hasSelection = this.interactivityService && this.interactivityService.hasSelection(), hasHighlights = this.hasHighlights, columnsSelection = this.columns.selectAll(TornadoChart.Column.selector).data(columnsData);
                        columnsSelection.enter().append("svg:rect").classed(TornadoChart.Column["class"], !0), 
                        columnsSelection.style("fill", function(p) {
                            return p.color;
                        }).style("fill-opacity", function(p) {
                            return visuals.ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights);
                        }).attr("transform", function(p) {
                            return visuals.SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle);
                        }).attr("height", function(p) {
                            return p.height;
                        }).attr("width", function(p) {
                            return p.width;
                        }), columnsSelection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(columnsData);
                            var behaviorOptions = {
                                columns: columnsSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(columnsData, this.behavior, behaviorOptions);
                        }
                        this.renderTooltip(columnsSelection);
                    }, TornadoChart.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, TornadoChart.prototype.getColumnWidth = function(value, minValue, maxValue, width) {
                        if (minValue === maxValue) return width;
                        var columnWidth = width * (value - minValue) / (maxValue - minValue);
                        return Math.max(0, Math.min(width, columnWidth));
                    }, TornadoChart.prototype.getLabelData = function(value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
                        var dx, tornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor, maxOutsideLabelWidth = isColumnPositionLeft ? dxColumn - this.leftLabelMargin : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin), maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin), textProperties = {
                            fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: tornadoChartSettings.labelValueFormatter.format(value)
                        }, valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth), textDataAfterValueFormatter = this.getTextData(valueAfterValueFormatter, !0, !1, fontSize);
                        return columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding ? dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2 : (dx = isColumnPositionLeft ? dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width : dxColumn + columnWidth + this.leftLabelMargin, 
                        color = tornadoChartSettings.labelOutsideFillColor), {
                            dx: dx,
                            source: value,
                            value: valueAfterValueFormatter,
                            color: color
                        };
                    }, TornadoChart.prototype.renderAxes = function() {
                        var linesData, axesSelection, axesElements = this.main.select(TornadoChart.Axes.selector).selectAll(TornadoChart.Axis.selector);
                        return this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries ? void axesElements.remove() : (linesData = this.generateAxesData(), 
                        axesSelection = axesElements.data(linesData), axesSelection.enter().append("svg:line").classed(TornadoChart.Axis["class"], !0), 
                        axesSelection.transition().duration(this.durationAnimations).attr("x1", function(data) {
                            return data.x1;
                        }).attr("y1", function(data) {
                            return data.y1;
                        }).attr("x2", function(data) {
                            return data.x2;
                        }).attr("y2", function(data) {
                            return data.y2;
                        }), void axesSelection.exit().remove());
                    }, TornadoChart.prototype.generateAxesData = function() {
                        var x, y1, y2;
                        return x = this.widthRightSection / 2, y1 = 0, y2 = this.scrolling.scrollViewport.height, 
                        [ {
                            x1: x,
                            y1: y1,
                            x2: x,
                            y2: y2
                        } ];
                    }, TornadoChart.prototype.renderLabels = function(dataPoints, labelsSettings) {
                        var labelEnterSelection, _this = this, labelSelection = this.main.select(TornadoChart.Labels.selector).selectAll(TornadoChart.Label.selector).data(_.filter(dataPoints, function(p) {
                            return p.label.dx >= 0;
                        }));
                        if (!labelsSettings.show || this.labelHeight >= this.heightColumn) return void this.labels.selectAll("*").remove();
                        var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize), labelYOffset = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta, categoriesLength = this.tornadoChartDataView.categories.length;
                        labelEnterSelection = labelSelection.enter().append("g"), labelEnterSelection.append("svg:title").classed(TornadoChart.LabelTitle["class"], !0), 
                        labelEnterSelection.append("svg:text").attr("dy", visuals.dataLabelUtils.DefaultDy).classed(TornadoChart.LabelText["class"], !0), 
                        labelSelection.attr("pointer-events", "none").classed(TornadoChart.Label["class"], !0), 
                        labelSelection.select(TornadoChart.LabelTitle.selector).text(function(p) {
                            return p.label.source;
                        }), labelSelection.attr("transform", function(p, index) {
                            var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
                            return visuals.SVGUtil.translate(p.label.dx, dy + labelYOffset);
                        }), labelSelection.select(TornadoChart.LabelText.selector).attr("fill", function(p) {
                            return p.label.color;
                        }).attr("font-size", function(p) {
                            return fontSizeInPx;
                        }).text(function(p) {
                            return p.label.value;
                        }), labelSelection.exit().remove();
                    }, TornadoChart.prototype.renderCategories = function() {
                        var categoriesEnterSelection, categoriesSelection, _this = this, settings = this.tornadoChartDataView.settings, color = settings.categoriesFillColor, categoryElements = this.main.select(TornadoChart.Categories.selector).selectAll(TornadoChart.Category.selector), self = this;
                        return settings.showCategories ? (categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories), 
                        categoriesEnterSelection = categoriesSelection.enter().append("g"), categoriesEnterSelection.append("svg:title").classed(TornadoChart.CategoryTitle["class"], !0), 
                        categoriesEnterSelection.append("svg:text").classed(TornadoChart.CategoryText["class"], !0), 
                        categoriesSelection.attr("transform", function(text, index) {
                            var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = _this.getTextData(text, !1, !0);
                            return shift = shift + textData.height / 2 - _this.InnerTextHeightDelta, visuals.SVGUtil.translate(0, shift);
                        }).classed(TornadoChart.Category["class"], !0), categoriesSelection.select(TornadoChart.CategoryTitle.selector).text(function(text) {
                            return text.text;
                        }), categoriesSelection.select(TornadoChart.CategoryText.selector).attr("fill", color).text(function(data) {
                            var textData = self.getTextData(data.text);
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);
                        }), void categoriesSelection.exit().remove()) : void categoryElements.remove();
                    }, TornadoChart.prototype.renderLegend = function() {
                        var legend = this.tornadoChartDataView.legend;
                        if (legend) {
                            var settings = this.tornadoChartDataView.settings, legendData = {
                                title: legend.title,
                                dataPoints: legend.dataPoints,
                                fontSize: settings.legendFontSize,
                                labelColor: settings.legendColor
                            };
                            if (this.legendObjectProperties) {
                                var position = void 0;
                                visuals.LegendData.update(legendData, this.legendObjectProperties), position = this.legendObjectProperties[visuals.legendProps.position], 
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            }
                            var viewport = {
                                height: this.viewport.height + this.margin.top + this.margin.bottom,
                                width: this.viewport.width + this.margin.left + this.margin.right
                            };
                            this.legend.drawLegend(legendData, viewport), visuals.Legend.positionChartArea(this.root, this.legend), 
                            legendData.dataPoints.length > 0 && settings.showLegend && this.updateViewport();
                        }
                    }, TornadoChart.prototype.getTextData = function(text, measureWidth, measureHeight, overrideFontSize) {
                        void 0 === measureWidth && (measureWidth = !1), void 0 === measureHeight && (measureHeight = !1);
                        var fontSize, textProperties, width = 0, height = 0;
                        return text = text || "", fontSize = overrideFontSize ? PixelConverter.fromPoint(overrideFontSize) : "" + this.textOptions.fontSize + this.textOptions.sizeUnit, 
                        textProperties = {
                            text: text,
                            fontFamily: this.textOptions.fontFamily,
                            fontSize: fontSize
                        }, measureWidth && (width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties)), 
                        measureHeight && (height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)), 
                        {
                            text: text,
                            width: width,
                            height: height,
                            textProperties: textProperties
                        };
                    }, TornadoChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings) return [];
                        switch (settings = this.tornadoChartDataView.settings, options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxis(enumeration);
                            break;

                          case "labels":
                            var labelSettings = settings.labelSettings, labels = {
                                objectName: "labels",
                                displayName: "Labels",
                                selector: null,
                                properties: {
                                    show: labelSettings.show,
                                    fontSize: labelSettings.fontSize,
                                    labelPrecision: labelSettings.precision,
                                    labelDisplayUnits: labelSettings.displayUnits,
                                    insideFill: labelSettings.labelColor,
                                    outsideFill: settings.labelOutsideFillColor
                                }
                            };
                            enumeration.pushInstance(labels);
                            break;

                          case "legend":
                            if (!this.hasDynamicSeries) return;
                            var showTitle = !0, titleText = "", legend = void 0;
                            showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                            titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                            legend = {
                                objectName: "legend",
                                displayName: "Legend",
                                selector: null,
                                properties: {
                                    show: settings.showLegend,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: settings.legendFontSize,
                                    labelColor: settings.legendColor
                                }
                            }, enumeration.pushInstance(legend);
                            break;

                          case "categories":
                            var categories = {
                                objectName: "categories",
                                displayName: "Categories",
                                selector: null,
                                properties: {
                                    show: settings.showCategories,
                                    fill: settings.categoriesFillColor
                                }
                            };
                            enumeration.pushInstance(categories);
                        }
                        return enumeration.complete();
                    }, TornadoChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.tornadoChartDataView && this.tornadoChartDataView.series) for (var series = this.tornadoChartDataView.series, _i = 0, series_1 = series; _i < series_1.length; _i++) {
                            var currentSeries = series_1[_i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: currentSeries.name,
                                selector: visuals.ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: currentSeries.fill
                                        }
                                    }
                                }
                            });
                        }
                    }, TornadoChart.prototype.enumerateCategoryAxis = function(enumeration) {
                        if (this.tornadoChartDataView && this.tornadoChartDataView.series) for (var series = this.tornadoChartDataView.series, _i = 0, series_2 = series; _i < series_2.length; _i++) {
                            var currentSeries = series_2[_i];
                            enumeration.pushInstance({
                                objectName: "categoryAxis",
                                displayName: currentSeries.name,
                                selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,
                                properties: {
                                    end: currentSeries.categoryAxisEnd
                                }
                            });
                        }
                    }, TornadoChart.prototype.destroy = function() {
                        this.root = null;
                    }, TornadoChart.ClassName = "tornado-chart", TornadoChart.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            },
                            labelPrecision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            labelDisplayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            insideFill: {
                                objectName: "labels",
                                propertyName: "insideFill"
                            },
                            outsideFill: {
                                objectName: "labels",
                                propertyName: "outsideFill"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            },
                            labelColor: {
                                objectName: "legend",
                                propertyName: "labelColor"
                            },
                            fontSize: {
                                objectName: "legend",
                                propertyName: "fontSize"
                            }
                        },
                        categories: {
                            show: {
                                objectName: "categories",
                                propertyName: "show"
                            },
                            fill: {
                                objectName: "categories",
                                propertyName: "fill"
                            }
                        }
                    }, TornadoChart.Columns = {
                        "class": "columns",
                        selector: ".columns"
                    }, TornadoChart.Column = {
                        "class": "column",
                        selector: ".column"
                    }, TornadoChart.Axes = {
                        "class": "axes",
                        selector: ".axes"
                    }, TornadoChart.Axis = {
                        "class": "axis",
                        selector: ".axis"
                    }, TornadoChart.Labels = {
                        "class": "labels",
                        selector: ".labels"
                    }, TornadoChart.Label = {
                        "class": "label",
                        selector: ".label"
                    }, TornadoChart.LabelTitle = {
                        "class": "label-title",
                        selector: ".label-title"
                    }, TornadoChart.LabelText = {
                        "class": "label-text",
                        selector: ".label-text"
                    }, TornadoChart.Categories = {
                        "class": "categories",
                        selector: ".categories"
                    }, TornadoChart.Category = {
                        "class": "category",
                        selector: ".category"
                    }, TornadoChart.CategoryTitle = {
                        "class": "category-title",
                        selector: ".category-title"
                    }, TornadoChart.CategoryText = {
                        "class": "category-text",
                        selector: ".category-text"
                    }, TornadoChart.MaxSeries = 2, TornadoChart.MaxPrecision = 17, TornadoChart.LabelPadding = 2.5, 
                    TornadoChart.CategoryMinHeight = 25, TornadoChart.DefaultFontSize = 9, TornadoChart.DefaultLegendFontSize = 8, 
                    TornadoChart.HighlightedShapeFactor = .5, TornadoChart.ScrollBarWidth = 10, TornadoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    min: 2,
                                    max: 2
                                },
                                Series: {
                                    max: 0
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data Colors",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    insideFill: {
                                        displayName: "Inside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outsideFill: {
                                        displayName: "Outside fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "TextSize",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categories: {
                                displayName: "Group",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        supportsHighlight: !0
                    }, TornadoChart;
                }();
                samples.TornadoChart = TornadoChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                    var XLabelMaxAllowedOverflow = 35, xAxisProperties = axes.x, y1AxisProperties = axes.y1, y2AxisProperties = axes.y2, xLabels = xAxisProperties.values, y1Labels = y1AxisProperties.values, leftOverflow = 0, rightOverflow = 0, maxWidthY1 = 0, maxWidthY2 = 0, xMax = 0, ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0, scaleIsOrdinal = visuals.AxisHelper.isOrdinalScale(xAxisProperties.scale), xLabelOuterPadding = 0;
                    if (void 0 !== xAxisProperties.outerPadding ? xLabelOuterPadding = xAxisProperties.outerPadding : void 0 !== xAxisProperties.xLabelMaxWidth && (xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2)), 
                    0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) || 0 !== visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height)) {
                        var rotation;
                        if (rotation = scrollbarVisible ? visuals.AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar : visuals.AxisHelper.LabelLayoutStrategy.DefaultRotation, 
                        renderY1Axis) for (var i = 0, len = y1Labels.length; len > i; i++) y1AxisTextProperties.text = y1Labels[i], 
                        maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
                        if (y2AxisProperties && renderY2Axis) for (var y2Labels = y2AxisProperties.values, i = 0, len = y2Labels.length; len > i; i++) y2AxisTextProperties.text = y2Labels[i], 
                        maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
                        var textHeight = textHeightMeasurer(xAxisTextProperties), maxNumLines = Math.floor(bottomMarginLimit / textHeight), xScale = xAxisProperties.scale, xDomain = xScale.domain();
                        if (renderXAxis && xLabels.length > 0) {
                            for (var i = 0, len = xLabels.length; len > i; i++) {
                                var height;
                                xAxisTextProperties.text = xLabels[i];
                                var width = textWidthMeasurer(xAxisTextProperties);
                                if (xAxisProperties.willLabelsWordBreak) {
                                    var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                    height = wordBreaks.length * textHeight, width = xAxisProperties.xLabelMaxWidth;
                                } else !xAxisProperties.willLabelsFit && scaleIsOrdinal ? (height = width * rotation.sine, 
                                width *= rotation.cosine) : height = textHeight;
                                if (0 === i) {
                                    if (scaleIsOrdinal) leftOverflow = xAxisProperties.willLabelsFit ? width / 2 - ordinalLabelOffset - xLabelOuterPadding : width - ordinalLabelOffset - xLabelOuterPadding, 
                                    leftOverflow = Math.max(leftOverflow, 0); else if (xDomain.length > 1) {
                                        var xPos = xScale(xDomain[0]);
                                        leftOverflow = width / 2 - xPos, leftOverflow = Math.max(leftOverflow, 0);
                                    }
                                } else if (i === len - 1) if (scaleIsOrdinal) (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) && (rightOverflow = width / 2 - ordinalLabelOffset - xLabelOuterPadding, 
                                rightOverflow = Math.max(rightOverflow, 0)); else if (xDomain.length > 1) {
                                    var xPos = xScale(xDomain[1]);
                                    rightOverflow = width / 2 - (viewport.width - xPos), rightOverflow = Math.max(rightOverflow, 0);
                                }
                                xMax = Math.max(xMax, height);
                            }
                            leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0, 
                            rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
                        }
                    }
                    var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                    return showOnRight ? (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit)) : (leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit), 
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit)), {
                        xMax: Math.ceil(bottomMargin),
                        yLeft: Math.ceil(leftMargin),
                        yRight: Math.ceil(rightMargin)
                    };
                }
                function getLayerData(dataViews, currentIdx, totalLayers) {
                    return totalLayers > 1 ? dataViews && dataViews.length > currentIdx ? [ dataViews[currentIdx] ] : [] : dataViews;
                }
                function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                    return 0 === layerNumber && !!valueAxisProperties && !!valueAxisProperties.showAxisTitle || 1 === layerNumber && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties.secShowAxisTitle;
                }
                function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
                    var visualOptions = {
                        viewport: viewport,
                        margin: margin,
                        forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                        forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                        showCategoryAxisLabel: !1,
                        showValueAxisLabel: !1,
                        categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : visuals.axisScale.linear,
                        valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : visuals.axisScale.linear,
                        trimOrdinalDataOnOverflow: !1
                    }, yAxisWillMerge = !1;
                    valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain));
                    for (var result, layerNumber = 0, len = layers.length; len > layerNumber; layerNumber++) {
                        var currentlayer = layers[layerNumber];
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                        var axes = currentlayer.calculateAxesProperties(visualOptions);
                        0 === layerNumber && (result = {
                            x: axes[0],
                            y1: axes[1]
                        }), result.x.willLabelsFit = !1, result.x.willLabelsWordBreak = !1;
                    }
                    return result;
                }
                function createLayers(type, objects, interactivityService, animator, isScrollable) {
                    void 0 === isScrollable && (isScrollable = !0);
                    var layers = [], cartesianOptions = {
                        isScrollable: isScrollable,
                        animator: animator,
                        interactivityService: interactivityService
                    };
                    return layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions)), 
                    layers;
                }
                function createMekkoChartLayer(type, defaultOptions) {
                    var options = {
                        animator: defaultOptions.animator,
                        interactivityService: defaultOptions.interactivityService,
                        isScrollable: defaultOptions.isScrollable,
                        chartType: type
                    };
                    return new MekkoColumnChart(options);
                }
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils, MekkoDataWrapper = function() {
                    function MekkoDataWrapper(columnChartData, isScalar) {
                        this.data = columnChartData, this.isScalar = isScalar;
                    }
                    return MekkoDataWrapper.prototype.lookupXValue = function(index, type) {
                        var isDateTime = visuals.AxisHelper.isDateTime(type);
                        if (isDateTime && this.isScalar) return new Date(index);
                        var data = this.data;
                        if (type.text) return data.categories[index];
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                this.data.hasHighlights && (index = 2 * index);
                                var dataPoint = seriesValues[index];
                                if (dataPoint) return isDateTime ? new Date(dataPoint.categoryValue) : dataPoint.categoryValue;
                            }
                        }
                        return index;
                    }, MekkoDataWrapper;
                }();
                samples.MekkoDataWrapper = MekkoDataWrapper;
                var MekkoColumnChartStrategy = function() {
                    function MekkoColumnChartStrategy() {}
                    return MekkoColumnChartStrategy.prototype.setupVisualProps = function(columnChartProps) {
                        this.graphicsContext = columnChartProps, this.margin = columnChartProps.margin, 
                        this.width = this.graphicsContext.width, this.height = this.graphicsContext.height, 
                        this.categoryLayout = columnChartProps.layout, this.animator = columnChartProps.animator, 
                        this.interactivityService = columnChartProps.interactivityService, this.viewportHeight = columnChartProps.viewportHeight, 
                        this.viewportWidth = columnChartProps.viewportWidth;
                    }, MekkoColumnChartStrategy.prototype.setData = function(data) {
                        this.data = data;
                    }, MekkoColumnChartStrategy.createFormatter = function(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                        void 0 === useTickIntervalForDisplayUnits && (useTickIntervalForDisplayUnits = !1);
                        var formatter;
                        if (dataType.dateTime) if (isScalar) {
                            var value = new Date(scaleDomain[0]), value2 = new Date(scaleDomain[1]);
                            1 === bestTickCount && (value = value2 = new Date(dataDomain[0])), formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: value,
                                value2: value2,
                                tickCount: bestTickCount
                            });
                        } else {
                            var minDate = getValueFn(0, dataType), maxDate = getValueFn(scaleDomain.length - 1, dataType);
                            formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: minDate,
                                value2: maxDate,
                                tickCount: bestTickCount
                            });
                        } else if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var domainMin = tickValues[1] - tickValues[0], domainMax = 0;
                            formatter = visuals.valueFormatter.create({
                                format: formatString,
                                value: domainMin,
                                value2: domainMax,
                                allowFormatBeautification: !0
                            });
                        } else formatter = visuals.valueFormatter.createDefaultFormatter(formatString, !0);
                        return formatter;
                    }, MekkoColumnChartStrategy.formatAxisTickValues = function(axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                        var formattedTickValues = [];
                        return formatter ? !getValueFn || dataType.numeric && isScalar ? (axis.tickFormat(function(d) {
                            return formatter.format(d);
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(d);
                        })) : (axis.tickFormat(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        }), formattedTickValues = tickValues.map(function(d) {
                            return formatter.format(getValueFn(d, dataType));
                        })) : formattedTickValues = tickValues.map(function(d) {
                            return getValueFn(d, dataType);
                        }), formattedTickValues;
                    }, MekkoColumnChartStrategy.prototype.createAxis = function(options) {
                        var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp), dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar), isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType), scale = d3.scale.linear(), scaleDomain = [ 0, 1 ], bestTickCount = dataDomain.length || 1, borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings), chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                        chartWidth < MekkoChart.MinOrdinalRectThickness && (chartWidth = MekkoChart.MinOrdinalRectThickness), 
                        scale.domain(scaleDomain).range([ 0, chartWidth ]);
                        var tickValues = dataDomain, formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits), axis = d3.svg.axis().scale(scale).tickSize(6, 0).orient(isVertical ? "left" : "bottom").ticks(bestTickCount).tickValues(dataDomain), formattedTickValues = [];
                        metaDataColumn && (formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn));
                        var xLabelMaxWidth;
                        if (!isScalar && categoryThickness) xLabelMaxWidth = Math.max(1, categoryThickness - 2 * visuals.CartesianChart.TickLabelPadding); else {
                            var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                            xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan, xLabelMaxWidth = Math.max(1, xLabelMaxWidth - 2 * visuals.CartesianChart.TickLabelPadding);
                        }
                        return {
                            scale: scale,
                            axis: axis,
                            formatter: formatter,
                            values: formattedTickValues,
                            axisType: dataType,
                            axisLabel: null,
                            isCategoryAxis: isCategoryAxis,
                            xLabelMaxWidth: xLabelMaxWidth,
                            categoryThickness: categoryThickness,
                            outerPadding: outerPadding,
                            usingDefaultDomain: !1,
                            isLogScaleAllowed: isLogScaleAllowed
                        };
                    }, MekkoColumnChartStrategy.prototype.getCategoryAxis = function(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                        var categoryThickness = layout.categoryThickness, isScalar = layout.isScalar, outerPaddingRatio = layout.outerPaddingRatio, dw = new MekkoDataWrapper(data, isScalar), domain = [];
                        if (data.series && data.series.length > 0 && data.series[0].data && data.series[0].data.length > 0) {
                            var domainDoubles = data.series[0].data.map(function(item) {
                                return item.originalPosition + item.value / 2;
                            });
                            domain = domainDoubles.filter(function(item, pos) {
                                return domainDoubles.indexOf(item) === pos;
                            });
                        }
                        var axisProperties = this.createAxis({
                            pixelSpan: size,
                            dataDomain: domain,
                            metaDataColumn: data.categoryMetadata,
                            formatStringProp: visuals.columnChartProps.general.formatString,
                            outerPadding: categoryThickness * outerPaddingRatio,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: isVertical,
                            categoryThickness: categoryThickness,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                var domainIndex = domain.indexOf(index), value = dw.lookupXValue(domainIndex, type);
                                return value;
                            },
                            scaleType: axisScaleType,
                            borderSettings: data.borderSettings
                        });
                        return layout.categoryThickness = axisProperties.categoryThickness, axisProperties;
                    }, MekkoColumnChartStrategy.prototype.setXScale = function(is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                        var forcedXMin, forcedXMax, width = this.width;
                        forcedXDomain && 2 === forcedXDomain.length && (forcedXMin = forcedXDomain[0], forcedXMax = forcedXDomain[1]);
                        var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, !1, forcedXMin, forcedXMax, axisScaleType);
                        return props;
                    }, MekkoColumnChartStrategy.prototype.setYScale = function(is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                        var height = this.viewportHeight, valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct), valueDomainArr = [ valueDomain.min, valueDomain.max ], combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr), shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr), metadataColumn = this.data.valuesMetadata[0], formatString = is100Pct ? this.graphicsContext.hostService.getLocalizedString("Percentage") : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString), mekkoMekkoCreateAxisOptions = {
                            pixelSpan: height,
                            dataDomain: combinedDomain,
                            metaDataColumn: metadataColumn,
                            formatString: formatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: axisScaleType,
                            axisDisplayUnits: 0,
                            axisPrecision: 0,
                            is100Pct: is100Pct,
                            shouldClamp: shouldClamp,
                            formatStringProp: void 0
                        };
                        return this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions), 
                        this.yProps;
                    }, MekkoColumnChartStrategy.prototype.drawColumns = function(useAnimation) {
                        var data = this.data;
                        this.columnsCenters = null;
                        var result, shapes, axisOptions = {
                            columnWidth: 0,
                            xScale: this.xProps.scale,
                            yScale: this.yProps.scale,
                            isScalar: this.categoryLayout.isScalar,
                            margin: this.margin
                        }, stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions), labelDataPoints = this.createMekkoLabelDataPoints(), series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                        return this.animator && useAnimation && (result = this.animator.animate({
                            viewModel: data,
                            series: series,
                            layout: stackedColumnLayout,
                            itemCS: MekkoColumnChartStrategy.classes.item,
                            interactivityService: this.interactivityService,
                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                            viewPort: {
                                height: this.height,
                                width: this.width
                            }
                        }), shapes = result.shapes), this.animator && useAnimation && !result.failed || (shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection())), 
                        visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart), 
                        {
                            shapesSelection: shapes,
                            viewport: {
                                height: this.height,
                                width: this.width
                            },
                            axisOptions: axisOptions,
                            labelDataPoints: labelDataPoints
                        };
                    }, MekkoColumnChartStrategy.drawDefaultShapes = function(data, series, layout, itemCS, filterZeros, hasSelection) {
                        var rectName = "rect";
                        filterZeros = !1;
                        var dataSelector;
                        dataSelector = filterZeros ? function(d) {
                            var filteredData = _.filter(d.data, function(datapoint) {
                                return !!datapoint.value;
                            });
                            return filteredData;
                        } : function(d) {
                            return d.data;
                        };
                        var shapeSelection = series.selectAll(itemCS.selector), shapes = shapeSelection.data(dataSelector, function(d) {
                            return d.key;
                        });
                        shapes.enter().append(rectName).attr("class", function(d) {
                            return itemCS["class"].concat(d.highlight ? " highlight" : "");
                        }), shapes.style("fill", function(d) {
                            return d.color;
                        }).style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights);
                        }).attr(layout.shapeLayout), shapes.exit().remove();
                        var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector), borders = borderSelection.data(dataSelector, function(d) {
                            return d.key;
                        }), borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                        return borders.enter().append(rectName).classed(MekkoColumnChart.BorderClass["class"], !0), 
                        borders.style("fill", function(d) {
                            return borderColor;
                        }).style("fill-opacity", function(d) {
                            return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;
                        }).attr(layout.shapeBorder), borders.exit().remove(), shapes;
                    }, MekkoColumnChartStrategy.prototype.selectColumn = function(selectedColumnIndex, lastSelectedColumnIndex) {
                        visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex), 
                        this.moveHandle(selectedColumnIndex);
                    }, MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function(x, y) {
                        return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                    }, MekkoColumnChartStrategy.prototype.getColumnsCenters = function() {
                        var _this = this;
                        if (!this.columnsCenters) {
                            var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                            if (this.data.series.length > 0) {
                                var xScaleOffset = 0;
                                this.categoryLayout.isScalar || (xScaleOffset = categoryWidth / 2);
                                var firstSeries = this.data.series[0];
                                firstSeries && firstSeries.data && (this.columnsCenters = firstSeries.data.map(function(d) {
                                    return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset;
                                }));
                            }
                        }
                        return this.columnsCenters;
                    }, MekkoColumnChartStrategy.prototype.moveHandle = function(selectedColumnIndex) {
                        var columnCenters = this.getColumnsCenters(), x = columnCenters[selectedColumnIndex];
                        if (this.columnSelectionLineHandle) {
                            var handle = this.columnSelectionLineHandle;
                            handle.select("line").attr({
                                x1: x,
                                x2: x
                            }), handle.select("circle").attr({
                                cx: x
                            });
                        } else {
                            var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append("g");
                            handle.append("line").classed("interactive-hover-line", !0).attr({
                                x1: x,
                                x2: x,
                                y1: 0,
                                y2: this.height
                            }), handle.append("circle").attr({
                                cx: x,
                                cy: this.height,
                                r: "6px"
                            }).classed("drag-handle", !0);
                        }
                    }, MekkoColumnChartStrategy.getLayout = function(data, axisOptions) {
                        var xScale = axisOptions.xScale, yScale = axisOptions.yScale, scaledY0 = yScale(0), scaledX0 = xScale(0), borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings), columnWidthScale = function(d) {
                            var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);
                            return value;
                        }, columnStart = function(d) {
                            var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + borderWidth * d.categoryIndex;
                            return value;
                        }, borderStart = function(d) {
                            var value = scaledX0 + visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) + visuals.AxisHelper.diffScaled(xScale, d.value, 0) + borderWidth * d.categoryIndex;
                            return value;
                        };
                        return {
                            shapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeBorder: {
                                width: function(d) {
                                    return borderWidth;
                                },
                                x: borderStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            },
                            shapeLayoutWithoutHighlights: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute);
                                }
                            },
                            zeroShapeLayout: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                },
                                height: function(d) {
                                    return 0;
                                }
                            },
                            shapeXAxis: {
                                width: columnWidthScale,
                                x: columnStart,
                                y: function(d) {
                                    return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0);
                                },
                                height: function(d) {
                                    return visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                                }
                            }
                        };
                    }, MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function() {
                        for (var labelDataPoints = [], data = this.data, series = data.series, formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager(), shapeLayout = this.layout.shapeLayout, i = 0, ilen = series.length; ilen > i; i++) {
                            var currentSeries = series[i], labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                            if (labelSettings.show && currentSeries.data) for (var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings), j = 0; j < currentSeries.data.length; j++) {
                                var dataPoint = currentSeries.data[j];
                                if ((!data.hasHighlights || dataPoint.highlight) && null != dataPoint.value) {
                                    var parentRect = {
                                        left: shapeLayout.x(dataPoint),
                                        top: shapeLayout.y(dataPoint),
                                        width: shapeLayout.width(dataPoint),
                                        height: shapeLayout.height(dataPoint)
                                    }, formatString = null, value = dataPoint.valueOriginal;
                                    labelSettings.displayUnits || (formatString = NewDataLabelUtils.hundredPercentFormat, 
                                    value = dataPoint.valueAbsolute);
                                    var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter), text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value)), properties = {
                                        text: text,
                                        fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                                        fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
                                        fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight
                                    }, textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties), textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                                    labelDataPoints.push({
                                        isPreferred: !0,
                                        text: text,
                                        textSize: {
                                            width: textWidth,
                                            height: textHeight
                                        },
                                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
                                        insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
                                        isParentRect: !0,
                                        parentShape: {
                                            rect: parentRect,
                                            orientation: 1,
                                            validPositions: MekkoColumnChartStrategy.validLabelPositions
                                        },
                                        identity: dataPoint.identity,
                                        parentType: 1
                                    });
                                }
                            }
                        }
                        return labelDataPoints;
                    }, MekkoColumnChartStrategy.classes = {
                        item: createClassAndSelector("column"),
                        highlightItem: createClassAndSelector("highlightColumn")
                    }, MekkoColumnChartStrategy.validLabelPositions = [ 1 ], MekkoColumnChartStrategy;
                }();
                samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;
                var MekkoChart = function() {
                    function MekkoChart(options) {
                        this.isScrollable = !1, options ? (this.type = options.chartType, options.isScrollable && (this.isScrollable = options.isScrollable), 
                        this.animator = options.animator, options.cartesianSmallViewPortProperties && (this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties), 
                        options.behavior && (this.behavior = options.behavior)) : this.behavior = new MekkoChartBehavior([ new visuals.ColumnChartWebBehavior() ]);
                    }
                    return MekkoChart.getTextProperties = function(fontSize) {
                        return void 0 === fontSize && (fontSize = MekkoChart.FontSize), {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(fontSize)
                        };
                    }, MekkoChart.prototype.init = function(options) {
                        this.visualInitOptions = options, this.layers = [];
                        var element = this.element = options.element, viewport = this.currentViewport = options.viewport;
                        this.hostServices = options.host, this.brush = d3.svg.brush(), element.addClass(MekkoChart.ClassName), 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins(viewport), 
                        this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);
                        var showLinesOnX = !0, showLinesOnY = !0, svg = this.svg = d3.select(element.get(0)).append("svg");
                        svg.style("position", "absolute");
                        var axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(MekkoChart.AxisGraphicsContextClassName, !0);
                        this.labelGraphicsContextScrollable = this.svgScrollable.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                        this.behavior && (this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable));
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.y2AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), 
                        this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), 
                        this.y2AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.y2AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), 
                        this.behavior && (this.interactivityService = visuals.createInteractivityService(this.hostServices)), 
                        this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, !0);
                    }, MekkoChart.prototype.renderAxesLabels = function(options) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = options.viewport.width - (margin.left + margin.right), height = options.viewport.height, fontSize = MekkoChart.FontSize, heightOffset = fontSize, showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                        if (!options.hideXAxisTitle) {
                            var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "xAxisLabel",
                                        transform: visuals.SVGUtil.translate(width / 2, height - heightOffset)
                                    });
                                });
                            });
                            xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null), 
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null), 
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(options.axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showOnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - options.legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null), 
                            y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, MekkoChart.prototype.adjustMargins = function(viewport) {
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), xAxis = this.element.find(".x.axis");
                        0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, MekkoChart.prototype.translateAxes = function(viewport) {
                        this.adjustMargins(viewport);
                        var margin = this.margin, width = viewport.width - (margin.left + margin.right), height = viewport.height - (margin.top + margin.bottom), showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, height)), 
                        this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0)), 
                        this.y2AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0)), 
                        this.svg.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svg.style("top", this.legend.isVisible() ? this.legend.getMargins().height + "px" : 0), 
                        this.svgScrollable.attr({
                            width: viewport.width,
                            height: viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        }), this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(margin.left, margin.top)), 
                        this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: this.margin.left
                        }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                        this.labelGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, margin.top)), 
                        this.svgScrollable.attr("width", width), this.svg.attr("width", viewport.width).attr("height", viewport.height + MekkoChart.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", height + margin.top), 
                        this.svg.attr("width", viewport.width + MekkoChart.ScrollBarWidth).attr("height", viewport.height));
                    }, MekkoChart.getIsScalar = function(objects, propertyId, type) {
                        var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                        return objects && void 0 !== axisTypeValue ? axisTypeValue === visuals.axisType.scalar && !visuals.AxisHelper.isOrdinal(type) : !visuals.AxisHelper.isOrdinal(type);
                    }, MekkoChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            if (dataViewMetadata ? (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}), 
                            this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "columnBorder", {})) : (this.legendObjectProperties = {}, 
                            this.borderObjectProperties = {}), this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata), 
                            dataViewMetadata && dataViewMetadata.objects) {
                                var categoryAxis = dataViewMetadata.objects.categoryAxis, valueAxis = dataViewMetadata.objects.valueAxis;
                                categoryAxis && (this.categoryAxisProperties.showBorder = categoryAxis.showBorder, 
                                this.categoryAxisProperties.fontSize = categoryAxis.fontSize), valueAxis && (this.valueAxisProperties.fontSize = valueAxis.fontSize);
                            }
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                        }
                    }, MekkoChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.currentViewport = options.viewport, dataViews && !(this.currentViewport.width < MekkoChart.MinWidth || this.currentViewport.height < MekkoChart.MinHeight)) {
                            0 === this.layers.length && (this.layers = this.createAndInitLayers(dataViews));
                            var layers = this.layers;
                            if (dataViews && dataViews.length > 0) {
                                var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                                warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                            }
                            this.sharedColorPalette.clearPreferredScale();
                            for (var i = 0, len = layers.length; len > i; i++) layers[i].setData(getLayerData(dataViews, i, len)), 
                            len > 1 && this.sharedColorPalette.rotateScale();
                            this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend || this.renderLegend(), 
                            this.render(!this.hasSetData || options.suppressAnimations), this.hasSetData = this.hasSetData || dataViews && dataViews.length > 0;
                        }
                    }, MekkoChart.parseLabelSettings = function(objects) {
                        var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), labelsObj = objects.labels, minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
                        return visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings), 
                        labelSettings.precision < minPrecision && (labelSettings.precision = minPrecision), 
                        labelSettings.precision > maxPrecision && (labelSettings.precision = maxPrecision), 
                        labelSettings;
                    }, MekkoChart.parseBorderSettings = function(objects) {
                        var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        return width > maxWidth ? width = maxWidth : 0 > width && (width = 0), show || (width = 0), 
                        {
                            show: show,
                            color: color,
                            width: width
                        };
                    }, MekkoChart.prototype.enumerateBorder = function(enumeration) {
                        var objects = {
                            columnBorder: this.borderObjectProperties
                        }, show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show), color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color), width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width), maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                        width > maxWidth ? width = maxWidth : 0 > width && (width = 0);
                        var instance = {
                            objectName: "columnBorder",
                            selector: null,
                            properties: {
                                show: show,
                                color: color,
                                width: width
                            }
                        };
                        enumeration.pushInstance(instance);
                    }, MekkoChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder(), layersLength = this.layers ? this.layers.length : 0;
                        if ("columnBorder" === options.objectName) this.enumerateBorder(enumeration); else if ("legend" === options.objectName) {
                            if (!this.shouldShowLegendCard()) return;
                            var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : ""), fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                            enumeration.pushInstance({
                                selector: null,
                                properties: {
                                    show: show,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: fontSize
                                },
                                objectName: options.objectName
                            });
                        } else "categoryAxis" === options.objectName && this.hasCategoryAxis ? this.getCategoryAxisValues(enumeration) : "valueAxis" === options.objectName && this.getValueAxisValues(enumeration);
                        for (var i = 0, len = layersLength; len > i; i++) {
                            var layer = this.layers[i];
                            layer.enumerateObjectInstances && layer.enumerateObjectInstances(enumeration, options);
                        }
                        return enumeration.complete();
                    }, MekkoChart.prototype.shouldShowLegendCard = function() {
                        var layers = this.layers, dataViews = this.dataViews;
                        if (layers && dataViews) for (var layersLength = layers.length, layersWithValuesCtr = 0, i = 0; layersLength > i; i++) {
                            if (layers[i].hasLegend()) return !0;
                            var dataView = dataViews[i];
                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0 && (layersWithValuesCtr++, 
                            layersWithValuesCtr > 1)) return !0;
                        }
                        return !1;
                    }, MekkoChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = visuals.axisType.both, isScalar = !1, logPossible = !!this.axes.x.isLogScaleAllowed, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                        this.layers && this.layers[0].getSupportedCategoryAxisType && (supportedType = this.layers[0].getSupportedCategoryAxisType(), 
                        isScalar = supportedType === visuals.axisType.scalar ? !0 : visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties)), 
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null), 
                        instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !1, 
                        instance.properties.showBorder = this.categoryAxisProperties && null != this.categoryAxisProperties.showBorder ? this.categoryAxisProperties.showAxisTitle : !1, 
                        instance.properties.fontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null,
                                fontSize: this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, MekkoChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !!this.axes.y1.isLogScaleAllowed, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !1, 
                        instance.properties.fontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null,
                                fontSize: this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        }), 2 === this.layers.length && (instance.properties.secShow = this.valueAxisProperties && null != this.valueAxisProperties.secShow ? this.valueAxisProperties.secShow : this.y2AxisExists, 
                        instance.properties.secShow && (instance.properties.axisLabel = ""));
                    }, MekkoChart.prototype.onClearSelection = function() {
                        if (this.hasSetData) for (var i = 0, len = this.layers.length; len > i; i++) {
                            var layer = this.layers[i];
                            layer.onClearSelection(), layer.render(!0);
                        }
                    }, MekkoChart.prototype.createAndInitLayers = function(dataViews) {
                        var objects, _this = this;
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata && (objects = dataViewMetadata.objects);
                        }
                        var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable), cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                        cartesianOptions.svg = this.axisGraphicsContextScrollable, cartesianOptions.cartesianHost = {
                            updateLegend: function(data) {
                                return _this.legend.drawLegend(data, _this.currentViewport);
                            },
                            getSharedColors: function() {
                                return _this.sharedColorPalette;
                            },
                            triggerRender: void 0
                        };
                        for (var i = 0, len = layers.length; len > i; i++) layers[i].init(cartesianOptions);
                        return layers;
                    }, MekkoChart.prototype.renderLegend = function() {
                        for (var layers = this.layers, legendData = {
                            title: "",
                            dataPoints: []
                        }, i = 0, len = layers.length; len > i; i++) this.layerLegendData = layers[i].calculateLegend(), 
                        this.layerLegendData && (legendData.title = 0 === i ? this.layerLegendData.title || "" : legendData.title, 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            legendProperties.fontSize || (legendProperties.fontSize = NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            visuals.LegendData.update(legendData, legendProperties);
                            var position = legendProperties[visuals.legendProps.position];
                            position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                        } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                        (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []), 
                        this.legend.drawLegend(legendData, this.currentViewport);
                    }, MekkoChart.prototype.hideLegends = function() {
                        return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                    }, MekkoChart.prototype.addUnitTypeToAxisLabel = function(axes) {
                        var unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.x;
                        });
                        if (axes.x.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.x.axisLabel && unitType && (axes.x.isCategoryAxis ? axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType) : axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType)), 
                        unitType = MekkoChart.getUnitType(axes, function(axis) {
                            return axis.y1;
                        }), axes.y1.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        axes.y1.axisLabel && unitType && (axes.y1.isCategoryAxis ? axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType) : axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType)), 
                        axes.y2) {
                            var unitType = MekkoChart.getUnitType(axes, function(axis) {
                                return axis.y2;
                            });
                            this.secValueAxisHasUnitType = null !== unitType, axes.y2.axisLabel && unitType && this.valueAxisProperties && this.valueAxisProperties.secAxisStyle && (this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showBoth ? axes.y2.axisLabel = axes.y2.axisLabel + " (" + unitType + ")" : this.valueAxisProperties.secAxisStyle === visuals.axisStyle.showUnitOnly && (axes.y2.axisLabel = unitType));
                        }
                    }, MekkoChart.prototype.shouldRenderSecondaryAxis = function(axisProperties) {
                        return axisProperties && (!this.valueAxisProperties || null == this.valueAxisProperties.secShow || this.valueAxisProperties.secShow) ? axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, MekkoChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, MekkoChart.prototype.render = function(suppressAnimations) {
                        var legendMargins = this.legendMargins = this.legend.getMargins(), viewport = {
                            height: this.currentViewport.height - legendMargins.height,
                            width: this.currentViewport.width - legendMargins.width
                        }, maxMarginFactor = this.getMaxMarginFactor(), leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                        this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                        var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.categoryAxisProperties.fontSize) || void 0), y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.valueAxisProperties.fontSize) || void 0), margin = this.margin;
                        margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2, margin.bottom = MekkoChart.MinBottomMargin, 
                        margin.right = 0;
                        var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        this.yAxisIsCategorical = axes.y1.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                        var mainAxisScale, preferredViewport, renderXAxis = this.shouldRenderAxis(axes.x), renderY1Axis = this.shouldRenderAxis(axes.y1), renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2), width = viewport.width - (margin.left + margin.right), isScalar = !1;
                        this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        if (this.layers && (this.layers[0].getVisualCategoryAxisIsScalar && (isScalar = this.layers[0].getVisualCategoryAxisIsScalar()), 
                        !isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea)) {
                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness, categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness), 
                            this.scrollX && preferredViewport && preferredViewport.width > viewport.width && (this.isXScrollBarVisible = !0, 
                            viewport.height -= MekkoChart.ScrollBarWidth), this.scrollY && preferredViewport && preferredViewport.height > viewport.height && (this.isYScrollBarVisible = !0, 
                            viewport.width -= MekkoChart.ScrollBarWidth, width = viewport.width - (margin.left + margin.right));
                        }
                        this.isXScrollBarVisible || this.isYScrollBarVisible ? this.brushGraphicsContext || (this.brushGraphicsContext = this.svg.append("g").classed("x brush", !0)) : (this.svg.selectAll(".brush").remove(), 
                        this.brushGraphicsContext = void 0), axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                        for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0, tickLabelMargins = void 0, chartHasAxisLabels = void 0, axisLabels = void 0; !doneWithMargins && maxIterations > numIterations; ) {
                            numIterations++, tickLabelMargins = getTickLabelMargins({
                                width: width,
                                height: viewport.height
                            }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, !1, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? tickLabelMargins.xMax / 1.8 : 0;
                            maxMainYaxisSide += MekkoChart.LeftPadding, maxSecondYaxisSide += MekkoChart.RightPadding, 
                            xMax += MekkoChart.BottomPadding, this.hideAxisLabels(legendMargins) && (axes.x.axisLabel = null, 
                            axes.y1.axisLabel = null, axes.y2 && (axes.y2.axisLabel = null)), this.addUnitTypeToAxisLabel(axes), 
                            axisLabels = {
                                x: axes.x.axisLabel,
                                y: axes.y1.axisLabel,
                                y2: axes.y2 ? axes.y2.axisLabel : null
                            }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                            null != axisLabels.x && (xMax += MekkoChart.XAxisLabelPadding), null != axisLabels.y && (maxMainYaxisSide += MekkoChart.YAxisLabelPadding), 
                            null != axisLabels.y2 && (maxSecondYaxisSide += MekkoChart.YAxisLabelPadding), margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                            margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, margin.bottom = xMax, 
                            this.margin = margin, width = viewport.width - (margin.left + margin.right);
                            var previousTickCountY1 = axes.y1.values.length, previousTickCountY2 = axes.y2 && axes.y2.values.length;
                            axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes), 
                            axes.y1.values.length !== previousTickCountY1 || axes.y2 && axes.y2.values.length !== previousTickCountY2 || (doneWithMargins = !0);
                        }
                        this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                    }, MekkoChart.prototype.hideAxisLabels = function(legendMargins) {
                        return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.currentViewport.height + legendMargins.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.visualInitOptions.interactivity.isInteractiveLegend);
                    }, MekkoChart.getUnitType = function(axis, axisPropertiesLookup) {
                        return axisPropertiesLookup(axis).formatter && axisPropertiesLookup(axis).formatter.displayUnit && axisPropertiesLookup(axis).formatter.displayUnit.value > 1 ? axisPropertiesLookup(axis).formatter.displayUnit.title : null;
                    }, MekkoChart.prototype.getMaxMarginFactor = function() {
                        return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                    }, MekkoChart.getChartViewport = function(viewport, margin) {
                        return {
                            width: viewport.width - margin.left - margin.right,
                            height: viewport.height - margin.top - margin.bottom
                        };
                    }, MekkoChart.wordBreak = function(text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                        text.each(function(data, index) {
                            var width, allowedLength, node = d3.select(this);
                            columnsWidth.length >= index ? (width = columnsWidth[index], allowedLength = axisProperties.scale(width)) : allowedLength = axisProperties.xLabelMaxWidth, 
                            node.style("text-anchor", "middle").attr({
                                dx: "0em",
                                dy: "1em",
                                transform: "rotate(0)"
                            }), powerbi.TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
                        });
                    }, MekkoChart.prototype.renderChart = function(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                        var xLabelColor, yLabelColor, y2LabelColor, xFontSize, yFontSize, bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, layers = this.layers, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                        if (this.shouldRenderAxis(axes.x)) {
                            axes.x.isCategoryAxis ? (xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            xFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (xLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            xFontSize = this.valueAxisProperties && this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt), 
                            axes.x.axis.orient("bottom"), axes.x.willLabelsFit || axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(axes.x.axis) : xAxisGraphicsElement.call(axes.x.axis), 
                            xAxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, xLabelColor).call(MekkoChart.setAxisLabelFontSize, xFontSize);
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text"), columnWidth = [], borderWidth = 0;
                            this.layers && this.layers.length && (columnWidth = this.layers[0].getColumnsWidth(), 
                            borderWidth = this.layers[0].getBorderWidth()), xAxisGraphicsElement.call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8), 
                            xAxisTextNodes.call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(axes.y1)) {
                            axes.y1.isCategoryAxis ? (yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties.labelColor ? this.categoryAxisProperties.labelColor : null, 
                            yFontSize = this.categoryAxisProperties && null != this.categoryAxisProperties.fontSize ? this.categoryAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt) : (yLabelColor = this.valueAxisProperties && this.valueAxisProperties.labelColor ? this.valueAxisProperties.labelColor : null, 
                            yFontSize = this.valueAxisProperties && null != this.valueAxisProperties.fontSize ? this.valueAxisProperties.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                            var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                            axes.y1.axis.tickSize(-width).tickPadding(MekkoChart.TickPaddingY).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(axes.y1.axis) : y1AxisGraphicsElement.call(axes.y1.axis), 
                            y1AxisGraphicsElement.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, yLabelColor).call(MekkoChart.setAxisLabelFontSize, yFontSize), 
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis), 
                            !axes.y2 || this.valueAxisProperties && null != this.valueAxisProperties.secShow && !this.valueAxisProperties.secShow ? this.y2AxisGraphicsContext.selectAll("*").remove() : (y2LabelColor = this.valueAxisProperties && this.valueAxisProperties.secLabelColor ? this.valueAxisProperties.secLabelColor : null, 
                            axes.y2.axis.tickPadding(MekkoChart.TickPaddingY).orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase()), 
                            duration ? this.y2AxisGraphicsContext.transition().duration(duration).call(axes.y2.axis) : this.y2AxisGraphicsContext.call(axes.y2.axis), 
                            this.y2AxisGraphicsContext.call(MekkoChart.darkenZeroLine).call(MekkoChart.setAxisLabelColor, y2LabelColor), 
                            tickLabelMargins.yRight >= leftRightMarginLimit && this.y2AxisGraphicsContext.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis));
                        } else this.y1AxisGraphicsContext.selectAll("*").remove(), this.y2AxisGraphicsContext.selectAll("*").remove();
                        if (chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1, renderAxisOptions = {
                                axisLabels: axisLabels,
                                legendMargin: this.legendMargins.height,
                                viewport: viewport,
                                hideXAxisTitle: hideXAxisTitle,
                                hideYAxisTitle: hideYAxisTitle,
                                hideY2AxisTitle: hideY2AxisTitle,
                                xLabelColor: xLabelColor,
                                yLabelColor: yLabelColor,
                                y2LabelColor: y2LabelColor,
                                margin: void 0
                            };
                            this.renderAxesLabels(renderAxisOptions);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        this.translateAxes(viewport);
                        var dataPoints = [], layerBehaviorOptions = [], labelDataPointsGroup = [];
                        if (this.behavior) {
                            for (var i = 0, len = layers.length; len > i; i++) {
                                var result = layers[i].render(suppressAnimations);
                                if (result) if (dataPoints = dataPoints.concat(result.dataPoints), layerBehaviorOptions.push(result.behaviorOptions), 
                                result.labelDataPointGroups) for (var resultLabelDataPointsGroups = result.labelDataPointGroups, j = 0, jlen = resultLabelDataPointsGroups.length; jlen > j; j++) {
                                    var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                    labelDataPointsGroup.push({
                                        labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                        maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels
                                    });
                                } else {
                                    var resultsLabelDataPoints = result.labelDataPoints, reducedDataPoints = resultsLabelDataPoints;
                                    labelDataPointsGroup.push({
                                        labelDataPoints: reducedDataPoints,
                                        maxNumberOfLabels: reducedDataPoints.length
                                    });
                                }
                            }
                            var labelLayoutOptions = {
                                maximumOffset: NewDataLabelUtils.maxLabelOffset,
                                startingOffset: NewDataLabelUtils.startingLabelOffset
                            }, labelLayout = new powerbi.LabelLayout(labelLayoutOptions), dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                            if (layers.length > 1 && NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", .7), 
                            this.animator && !suppressAnimations ? NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration()) : NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels), 
                            this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none"), 
                            this.interactivityService) {
                                var behaviorOptions = {
                                    layerOptions: layerBehaviorOptions,
                                    clearCatcher: this.clearCatcher
                                };
                                this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                            }
                        }
                    }, MekkoChart.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, MekkoChart.setAxisLabelColor = function(g, fill) {
                        g.selectAll("g.tick text").style("fill", fill ? fill.solid.color : null);
                    }, MekkoChart.setAxisLabelFontSize = function(g, fontSize) {
                        var value = jsCommon.PixelConverter.toString(fontSize);
                        g.selectAll("g.tick text").attr("font-size", value);
                    }, MekkoChart.moveBorder = function(g, scale, borderWidth, yOffset) {
                        void 0 === yOffset && (yOffset = 0), g.selectAll("g.tick").attr("transform", function(value, index) {
                            return visuals.SVGUtil.translate(scale(value) + borderWidth * index, yOffset);
                        });
                    }, MekkoChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y Axis"
                        }, {
                            name: "Width",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Axis width"
                        } ],
                        objects: {
                            columnBorder: {
                                displayName: "Column Border",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showSeries: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                        placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    showAll: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_ShowAll"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        type: {
                                            formatting: {
                                                legendPosition: !0
                                            }
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Title text",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    axisType: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Type"),
                                        type: {
                                            formatting: {
                                                axisType: !0
                                            }
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    intersection: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Intersection"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_LabelColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 0,
                                    max: 1
                                },
                                Series: {
                                    min: 0,
                                    max: 1
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                },
                                Width: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Y"
                                            }
                                        }, {
                                            "for": {
                                                "in": "Width"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1,
                                        max: 1
                                    },
                                    supported: {
                                        min: 0
                                    }
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, MekkoChart.properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        columnBorder: {
                            show: {
                                objectName: "columnBorder",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "columnBorder",
                                propertyName: "color"
                            },
                            width: {
                                objectName: "columnBorder",
                                propertyName: "width"
                            }
                        }
                    }, MekkoChart.DefaultSettings = {
                        columnBorder: {
                            show: !0,
                            color: "#fff",
                            width: 2,
                            maxWidth: 5
                        },
                        labelSettings: {
                            maxPrecision: 4,
                            minPrecision: 0
                        }
                    }, MekkoChart.MinOrdinalRectThickness = 20, MekkoChart.MinScalarRectThickness = 2, 
                    MekkoChart.OuterPaddingRatio = .4, MekkoChart.InnerPaddingRatio = .2, MekkoChart.TickLabelPadding = 2, 
                    MekkoChart.ClassName = "cartesianChart", MekkoChart.AxisGraphicsContextClassName = "axisGraphicsContext", 
                    MekkoChart.MaxMarginFactor = .25, MekkoChart.MinBottomMargin = 50, MekkoChart.LeftPadding = 10, 
                    MekkoChart.RightPadding = 10, MekkoChart.BottomPadding = 16, MekkoChart.YAxisLabelPadding = 20, 
                    MekkoChart.XAxisLabelPadding = 20, MekkoChart.TickPaddingY = 10, MekkoChart.TickPaddingRotatedX = 5, 
                    MekkoChart.FontSize = 11, MekkoChart.MaxNumberOfLabels = 100, MekkoChart.MinWidth = 100, 
                    MekkoChart.MinHeight = 100, MekkoChart.ScrollBarWidth = 10, MekkoChart;
                }();
                samples.MekkoChart = MekkoChart, samples.createLayers = createLayers;
                var EnumExtensions = jsCommon.EnumExtensions, ArrayExtensions = jsCommon.ArrayExtensions, flagBar = 2, flagStacked = 16, RoleNames = {
                    category: "Category",
                    series: "Series",
                    y: "Y",
                    width: "Width"
                }, MekkoColumnChart = function() {
                    function MekkoColumnChart(options) {
                        var chartType = options.chartType;
                        this.chartType = chartType, this.categoryAxisType = null, this.animator = options.animator, 
                        this.isScrollable = options.isScrollable, this.interactivityService = options.interactivityService;
                    }
                    return MekkoColumnChart.prototype.init = function(options) {
                        this.svg = options.svg, this.unclippedGraphicsContext = this.svg.append("g").classed("columnChartUnclippedGraphicsContext", !0), 
                        this.mainGraphicsContext = this.unclippedGraphicsContext.append("svg").classed("columnChartMainGraphicsContext", !0), 
                        this.labelGraphicsContext = this.svg.append("g").classed(NewDataLabelUtils.labelGraphicsContextClass["class"], !0), 
                        this.style = options.style, this.currentViewport = options.viewport, this.hostService = options.host, 
                        this.interactivity = options.interactivity, this.colors = this.style.colorPalette.dataColors, 
                        this.cartesianVisualHost = options.cartesianHost, this.options = options, this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                        var element = this.element = options.element;
                        element.addClass(MekkoColumnChart.ColumnChartClassName), this.columnChart = new MekkoColumnChartStrategy();
                    }, MekkoColumnChart.prototype.getCategoryLayout = function(numCategoryValues, options) {
                        var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right), metaDataColumn = this.data ? this.data.categoryMetadata : void 0, categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isScalar = this.data ? this.data.scalarCategoryAxis : !1, domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                        return visuals.CartesianChart.getLayout(this.data, {
                            availableWidth: availableWidth,
                            categoryCount: numCategoryValues,
                            domain: domain,
                            isScalar: isScalar,
                            isScrollable: this.isScrollable,
                            trimOrdinalDataOnOverflow: !1
                        });
                    }, MekkoColumnChart.getBorderWidth = function(border) {
                        if (!border || !border.show || !border.width) return 0;
                        var width = border.width;
                        return 0 > width ? 0 : width > border.maxWidth ? border.maxWidth : width;
                    }, MekkoColumnChart.getBorderColor = function(border) {
                        return border ? border.color : MekkoChart.DefaultSettings.columnBorder.color;
                    }, MekkoColumnChart.converter = function(dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1), void 0 === dataViewMetadata && (dataViewMetadata = null);
                        var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata), valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                        isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties), dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                        var converterStrategy = new ColumnChartConverterHelper(dataView), categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString), categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : void 0, borderSettings = MekkoChart.DefaultSettings.columnBorder, labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(!0), defaultDataPointColor = void 0, showAllDataPoints = void 0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                            showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints), 
                            labelSettings = MekkoChart.parseLabelSettings(objects), borderSettings = MekkoChart.parseBorderSettings(objects);
                        }
                        for (var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor), legend = legendAndSeriesInfo.legend.dataPoints, seriesSources = legendAndSeriesInfo.seriesSources, result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata), columnSeries = result.series, valuesMetadata = [], j = 0, jlen = legend.length; jlen > j; j++) valuesMetadata.push(seriesSources[j]);
                        var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                        return {
                            categories: categories,
                            categoriesWidth: result.categoriesWidth,
                            categoryFormatter: categoryFormatter,
                            series: columnSeries,
                            valuesMetadata: valuesMetadata,
                            legendData: legendAndSeriesInfo.legend,
                            hasHighlights: result.hasHighlights,
                            categoryMetadata: categoryMetadata,
                            scalarCategoryAxis: isScalar,
                            borderSettings: borderSettings,
                            labelSettings: labelSettings,
                            axesLabels: {
                                x: labels.xAxisLabel,
                                y: labels.yAxisLabel
                            },
                            hasDynamicSeries: result.hasDynamicSeries,
                            defaultDataPointColor: defaultDataPointColor,
                            showAllDataPoints: showAllDataPoints,
                            isMultiMeasure: !1
                        };
                    }, MekkoColumnChart.getStackedMultiplier = function(rawValues, rowIdx, seriesCount, categoryCount) {
                        for (var pos = 0, neg = 0, i = 0; seriesCount > i; i++) {
                            var value = rawValues[i][rowIdx];
                            value = visuals.AxisHelper.normalizeNonFiniteNumber(value), value > 0 ? pos += value : 0 > value && (neg -= value);
                        }
                        var absTotal = pos + neg;
                        return {
                            pos: pos ? pos / absTotal / pos : 1,
                            neg: neg ? neg / absTotal / neg : 1
                        };
                    }, MekkoColumnChart.createDataPoints = function(dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                        void 0 === is100PercentStacked && (is100PercentStacked = !1), void 0 === isScalar && (isScalar = !1), 
                        void 0 === supportsOverflow && (supportsOverflow = !1);
                        var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : void 0, categoryCount = categories.length, seriesCount = legend.length, columnSeries = [];
                        if (1 > seriesCount || 1 > categoryCount || null === categories[0]) return {
                            series: columnSeries,
                            hasHighlights: !1,
                            hasDynamicSeries: !1,
                            categoriesWidth: []
                        };
                        var dvCategories = dataViewCat.categories;
                        categoryMetadata = dvCategories && dvCategories.length > 0 ? dvCategories[0].source : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata), isDateTime = visuals.AxisHelper.isDateTime(categoryType), baseValuesPos = [], baseValuesNeg = [], rawValues = [], rawHighlightValues = [], hasDynamicSeries = !(!dataViewCat.values || !dataViewCat.values.source), widthColumns = [], widthIndex = -1, seriesIndex = 0, highlightsOverflow = !1, hasHighlights = converterStrategy.hasHighlightValues(0);
                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width] && !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else {
                            for (var seriesValues = [], seriesHighlightValues = [], categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                                var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                                if (seriesValues[categoryIndex] = value, hasHighlights) {
                                    var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                    seriesHighlightValues[categoryIndex] = highlightValue, value >= 0 && highlightValue >= 0 && value >= highlightValue || 0 >= value && 0 >= highlightValue && highlightValue >= value || (highlightsOverflow = !0);
                                }
                            }
                            rawValues.push(seriesValues), hasHighlights && rawHighlightValues.push(seriesHighlightValues);
                        }
                        if (highlightsOverflow && !supportsOverflow && (highlightsOverflow = !1, hasHighlights = !1, 
                        rawValues = rawHighlightValues), widthColumns.length < 1) for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) if (dataViewCat.values[seriesIndex].source.roles && dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                            widthIndex = seriesIndex;
                            for (var widthValues = dataViewCat.values[seriesIndex].values, i = 0, valuesLen = widthValues.length; valuesLen > i; i++) widthColumns[i] = d3.sum([ 0, widthColumns[i], widthValues[i] ]);
                        } else ;
                        if (widthColumns.length < 1) for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) widthColumns.push(1);
                        var totalSum = d3.sum(widthColumns), linearScale = d3.scale.linear().domain([ 0, totalSum ]).range([ 0, 1 ]), columnStartX = [ 0 ], columnWidth = [];
                        for (seriesIndex = 0; categoryCount - 1 > seriesIndex; seriesIndex++) {
                            var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                            columnStartX.push(stepWidth);
                        }
                        for (seriesIndex = 0; categoryCount > seriesIndex; seriesIndex++) columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]), 
                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                        var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                        for (seriesIndex = 0; seriesCount > seriesIndex; seriesIndex++) {
                            var seriesLabelSettings, seriesDataPoints = [], legendItem = legend[seriesIndex];
                            if (!hasDynamicSeries) {
                                var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null, labelObjects = labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects ? labelsSeriesGroup.source.objects.labels : null;
                                labelObjects && (seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings), 
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings));
                            }
                            var series = {
                                displayName: legendItem.label,
                                key: "series" + seriesIndex,
                                index: seriesIndex,
                                data: seriesDataPoints,
                                identity: legendItem.identity,
                                color: legendItem.color,
                                labelSettings: seriesLabelSettings
                            };
                            seriesCount > 1 && (dataPointObjects = seriesObjectsList[seriesIndex]);
                            for (var metadata = dataViewCat.values[seriesIndex].source, categoryIndex = 0; categoryCount > categoryIndex; categoryIndex++) {
                                0 === seriesIndex && (baseValuesPos.push(0), baseValuesNeg.push(0));
                                var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                                if (!(null == value && seriesIndex > 0)) {
                                    var originalValue = value, categoryValue = categories[categoryIndex];
                                    if (isDateTime && categoryValue && (categoryValue = categoryValue.getTime()), !isScalar || null != categoryValue && !isNaN(categoryValue)) {
                                        var multipliers;
                                        is100PercentStacked && (multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount));
                                        var unadjustedValue = value, isNegative = 0 > value;
                                        multipliers && (value *= isNegative ? multipliers.neg : multipliers.pos);
                                        var position, valueAbsolute = Math.abs(value);
                                        isNegative ? (position = baseValuesNeg[categoryIndex], isNaN(valueAbsolute) || (baseValuesNeg[categoryIndex] -= valueAbsolute)) : (isNaN(valueAbsolute) || (baseValuesPos[categoryIndex] += valueAbsolute), 
                                        position = baseValuesPos[categoryIndex]);
                                        var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null, category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIndex).withSeries(dataViewCat.values, columnGroup).withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex)).createSelectionId(), rawCategoryValue = categories[categoryIndex], color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects), seriesData = [];
                                        if (columnGroup) {
                                            var seriesValueColumn = {
                                                values: [],
                                                source: dataViewCat.values.source
                                            };
                                            seriesData.push({
                                                value: columnGroup.name,
                                                metadata: seriesValueColumn
                                            });
                                            for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                                var columnValues = columnGroup.values[columnIndex];
                                                seriesData.push({
                                                    value: columnValues.values[categoryIndex],
                                                    metadata: columnValues
                                                });
                                            }
                                        }
                                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, rawCategoryValue, originalValue, [ category ], seriesData, null, categoryIndex), dataPointLabelSettings = series && series.labelSettings ? series.labelSettings : defaultLabelSettings, labelColor = dataPointLabelSettings.labelColor, lastValue = void 0;
                                        EnumExtensions.hasFlag(chartType, flagStacked) && (lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues), 
                                        labelColor = lastValue || seriesIndex === seriesCount - 1 && !isNegative ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor), 
                                        value = columnWidth[categoryIndex];
                                        var originalPosition = columnStartX[categoryIndex], dataPoint = {
                                            categoryValue: categoryValue,
                                            value: value,
                                            position: position,
                                            valueAbsolute: valueAbsolute,
                                            valueOriginal: unadjustedValue,
                                            seriesIndex: seriesIndex,
                                            labelSettings: dataPointLabelSettings,
                                            categoryIndex: categoryIndex,
                                            color: color,
                                            selected: !1,
                                            originalValue: value,
                                            originalPosition: originalPosition,
                                            originalValueAbsolute: valueAbsolute,
                                            identity: identity,
                                            key: identity.getKey(),
                                            tooltipInfo: tooltipInfo,
                                            labelFill: labelColor,
                                            labelFormatString: metadata.format,
                                            lastSeries: lastValue,
                                            chartType: chartType
                                        };
                                        if (seriesDataPoints.push(dataPoint), hasHighlights) {
                                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex], unadjustedValueHighlight = valueHighlight, highlightedTooltip = !0;
                                            null === valueHighlight && (valueHighlight = 0, highlightedTooltip = !1), is100PercentStacked && (valueHighlight *= multipliers.pos);
                                            var absoluteValueHighlight = Math.abs(valueHighlight), highlightPosition = position;
                                            valueHighlight > 0 ? highlightPosition -= valueAbsolute - absoluteValueHighlight : 0 === valueHighlight && value > 0 && (highlightPosition -= valueAbsolute);
                                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity), rawCategoryValue = categories[categoryIndex];
                                            highlightedTooltip && (dataPoint.tooltipInfo = tooltipInfo);
                                            var highlightDataPoint = {
                                                categoryValue: categoryValue,
                                                value: value,
                                                position: highlightPosition,
                                                valueAbsolute: absoluteValueHighlight,
                                                valueOriginal: unadjustedValueHighlight,
                                                seriesIndex: seriesIndex,
                                                labelSettings: dataPointLabelSettings,
                                                categoryIndex: categoryIndex,
                                                color: color,
                                                selected: !1,
                                                highlight: !0,
                                                originalValue: value,
                                                originalPosition: originalPosition,
                                                originalValueAbsolute: valueAbsolute,
                                                drawThinner: highlightsOverflow,
                                                identity: highlightIdentity,
                                                key: highlightIdentity.getKey(),
                                                tooltipInfo: tooltipInfo,
                                                labelFormatString: metadata.format,
                                                labelFill: labelColor,
                                                lastSeries: lastValue,
                                                chartType: chartType
                                            };
                                            seriesDataPoints.push(highlightDataPoint);
                                        }
                                    }
                                }
                            }
                            columnSeries.push(series);
                        }
                        return {
                            series: columnSeries,
                            categoriesWidth: columnWidth,
                            hasHighlights: hasHighlights,
                            hasDynamicSeries: hasDynamicSeries
                        };
                    }, MekkoColumnChart.getDataPointColor = function(legendItem, categoryIndex, dataPointObjects) {
                        if (dataPointObjects) {
                            var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                            if (colorOverride) return colorOverride;
                        }
                        return legendItem.color;
                    }, MekkoColumnChart.getStackedLabelColor = function(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                        for (var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && 1 !== seriesCount), i = seriesIndex + 1; seriesCount > i; i++) {
                            var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                            if (null !== nextValues && ((!isNegative || isNegative && 0 === seriesIndex) && nextValues > 0 || isNegative && 0 !== seriesIndex)) {
                                lastValue = !1;
                                break;
                            }
                        }
                        return lastValue;
                    }, MekkoColumnChart.sliceSeries = function(series, endIndex, startIndex) {
                        void 0 === startIndex && (startIndex = 0);
                        var newSeries = [];
                        if (series && series.length > 0) for (var i = 0, len = series.length; len > i; i++) {
                            var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                            iNewSeries.data = series[i].data.filter(function(d) {
                                return d.categoryIndex >= startIndex && d.categoryIndex < endIndex;
                            });
                        }
                        return newSeries;
                    }, MekkoColumnChart.getInteractiveColumnChartDomElement = function(element) {
                        return element.children("svg").get(0);
                    }, MekkoColumnChart.prototype.getColumnsWidth = function() {
                        var data = this.data;
                        return data && data.series && data.series[0] && data.series[0].data ? data.categoriesWidth : [];
                    }, MekkoColumnChart.prototype.getBorderWidth = function() {
                        return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                    }, MekkoColumnChart.prototype.setData = function(dataViews) {
                        var is100PctStacked = !0;
                        if (this.data = {
                            categories: [],
                            categoriesWidth: [],
                            categoryFormatter: null,
                            series: [],
                            valuesMetadata: [],
                            legendData: null,
                            hasHighlights: !1,
                            categoryMetadata: null,
                            scalarCategoryAxis: !1,
                            borderSettings: null,
                            labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                            axesLabels: {
                                x: null,
                                y: null
                            },
                            hasDynamicSeries: !1,
                            defaultDataPointColor: null,
                            isMultiMeasure: !1
                        }, dataViews.length > 0) {
                            var dataView = dataViews[0];
                            if (dataView && dataView.categorical) {
                                var dataViewCat = this.dataViewCat = dataView.categorical;
                                this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), !0, !1, this.supportsOverflow, dataView.metadata, this.chartType);
                                for (var series = this.data.series, i = 0, ilen = series.length; ilen > i; i++) {
                                    var currentSeries = series[i];
                                    this.interactivityService && this.interactivityService.applySelectionStateToData(currentSeries.data);
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateLegend = function() {
                        if (this.interactivity && this.interactivity.isInteractiveLegend) return this.createInteractiveMekkoLegendDataPoints(0);
                        var legendData = this.data ? this.data.legendData : null, MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                        return ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints) ? null : legendData;
                    }, MekkoColumnChart.prototype.hasLegend = function() {
                        return this.data && (this.data.hasDynamicSeries || this.data.series && this.data.series.length > 1);
                    }, MekkoColumnChart.prototype.enumerateObjectInstances = function(enumeration, options) {
                        switch (options.objectName) {
                          case "dataPoint":
                            visuals.GradientUtils.hasGradientRole(this.dataViewCat) || this.enumerateDataPoints(enumeration);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                    }, MekkoColumnChart.prototype.enumerateDataLabels = function(enumeration) {
                        var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                        if (visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !1)), 
                        0 !== seriesCount && !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) for (var i = 0; seriesCount > i; i++) {
                            var series = data.series[i], labelSettings = series.labelSettings ? series.labelSettings : this.data.labelSettings;
                            visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, !0, series));
                        }
                    }, MekkoColumnChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings, isSeries, series) {
                        var is100PctStacked = !0;
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !isSeries,
                            displayUnits: is100PctStacked,
                            precision: !0,
                            selector: series && series.identity ? series.identity.getSelector() : null
                        };
                    }, MekkoColumnChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data && data.series) {
                            var seriesCount = data.series.length;
                            if (0 !== seriesCount) if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) for (var i = 0; seriesCount > i; i++) {
                                var series = data.series[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.displayName,
                                    selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                var singleSeriesData = data.series[0].data, categoryFormatter = data.categoryFormatter;
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: !!data.showAllDataPoints
                                    }
                                });
                                for (var i = 0; i < singleSeriesData.length; i++) {
                                    var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                        selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: singleSeriesDataPoints.color
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, MekkoColumnChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data;
                        this.currentViewport = options.viewport;
                        var margin = this.margin = options.margin, origCatgSize = data && data.categories ? data.categories.length : 0, chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                            categoryCount: 0,
                            categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                            outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                            isScalar: !1
                        };
                        this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null, this.columnChart.setData(data);
                        var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                        preferredPlotArea.width === this.currentViewport.width && (preferredPlotArea.width -= margin.left + margin.right), 
                        preferredPlotArea.height -= margin.top + margin.bottom;
                        var is100Pct = !0, chartContext = {
                            height: preferredPlotArea.height,
                            width: preferredPlotArea.width,
                            duration: 0,
                            hostService: this.hostService,
                            unclippedGraphicsContext: this.unclippedGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            margin: this.margin,
                            layout: chartLayout,
                            animator: this.animator,
                            interactivityService: this.interactivityService,
                            viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                            viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                            is100Pct: is100Pct,
                            isComboChart: !0
                        };
                        this.ApplyInteractivity(chartContext), this.columnChart.setupVisualProps(chartContext);
                        var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                        if (isBarChart) {
                            var temp = options.forcedXDomain;
                            options.forcedXDomain = options.forcedYDomain, options.forcedYDomain = temp;
                        }
                        return this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType), 
                        this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType), 
                        options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis ? this.xAxisProperties.axisLabel = data.axesLabels.x : this.xAxisProperties.axisLabel = null, 
                        options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis ? this.yAxisProperties.axisLabel = data.axesLabels.y : this.yAxisProperties.axisLabel = null, 
                        [ this.xAxisProperties, this.yAxisProperties ];
                    }, MekkoColumnChart.prototype.getPreferredPlotArea = function(isScalar, categoryCount, categoryThickness) {
                        var viewport = {
                            height: this.currentViewport.height,
                            width: this.currentViewport.width
                        };
                        if (this.isScrollable && !isScalar) {
                            var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                            EnumExtensions.hasFlag(this.chartType, flagBar) ? viewport.height = Math.max(preferredWidth, viewport.height) : viewport.width = Math.max(preferredWidth, viewport.width);
                        }
                        return viewport;
                    }, MekkoColumnChart.prototype.ApplyInteractivity = function(chartContext) {
                        var _this = this, interactivity = this.interactivity;
                        if (interactivity && (interactivity.dragDataPoint && (chartContext.onDragStart = function(datum) {
                            datum.identity && _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        }), interactivity.isInteractiveLegend)) {
                            var dragMove = function() {
                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]), x = mousePoint[0], y = mousePoint[1], index = _this.columnChart.getClosestColumnIndex(x, y);
                                _this.selectColumn(index);
                            }, ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);
                            this.svg.on("click", dragMove), d3.select(ColumnChartSvg).on("click", dragMove);
                            var drag = d3.behavior.drag().origin(Object).on("drag", dragMove);
                            this.svg.call(drag), d3.select(ColumnChartSvg).call(drag);
                        }
                    }, MekkoColumnChart.prototype.selectColumn = function(indexOfColumnSelected, force) {
                        if (void 0 === force && (force = !1), force || this.lastInteractiveSelectedColumnIndex !== indexOfColumnSelected) {
                            var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected), MekkoLegendDataPoints = legendData.dataPoints;
                            this.cartesianVisualHost.updateLegend(legendData), MekkoLegendDataPoints.length > 0 && this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex), 
                            this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                        }
                    }, MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function(columnIndex) {
                        var data = this.data;
                        if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) return {
                            dataPoints: []
                        };
                        for (var formatStringProp = visuals.columnChartProps.general.formatString, MekkoLegendDataPoints = [], category = data.categories && data.categories[columnIndex], allSeries = data.series, dataPoints = data.legendData && data.legendData.dataPoints, converterStrategy = new ColumnChartConverterHelper(this.dataViewCat), i = 0, len = allSeries.length; len > i; i++) {
                            var dataPointColor, measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex), valueMetadata = data.valuesMetadata[i], formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                            if (1 === allSeries.length) {
                                var series = allSeries[0];
                                dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                            } else dataPointColor = dataPoints.length > i && dataPoints[i].color;
                            MekkoLegendDataPoints.push({
                                color: dataPointColor,
                                icon: visuals.LegendIcon.Box,
                                label: formattedLabel,
                                category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                                measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                                identity: visuals.SelectionId.createNull(),
                                selected: !1
                            });
                        }
                        return {
                            dataPoints: MekkoLegendDataPoints
                        };
                    }, MekkoColumnChart.prototype.overrideXScale = function(xProperties) {
                        this.xAxisProperties = xProperties;
                    }, MekkoColumnChart.prototype.render = function(suppressAnimations) {
                        var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations), data = this.data, margin = this.margin, viewport = this.currentViewport, height = viewport.height - (margin.top + margin.bottom), width = viewport.width - (margin.left + margin.right);
                        this.mainGraphicsContext.attr("height", height).attr("width", width), visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                        var allDataPoints = [], behaviorOptions = void 0;
                        if (this.interactivityService) {
                            for (var i = 0, ilen = data.series.length; ilen > i; i++) allDataPoints = allDataPoints.concat(data.series[i].data);
                            behaviorOptions = {
                                datapoints: allDataPoints,
                                bars: MekkoColumnChartDrawInfo.shapesSelection,
                                hasHighlights: data.hasHighlights,
                                eventGroup: this.mainGraphicsContext,
                                mainGraphicsContext: this.mainGraphicsContext,
                                viewport: MekkoColumnChartDrawInfo.viewport,
                                axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                                showLabel: data.labelSettings.show
                            };
                        }
                        return this.interactivity && this.interactivity.isInteractiveLegend && this.data.series.length > 0 && this.selectColumn(0, !0), 
                        visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), {
                            dataPoints: allDataPoints,
                            behaviorOptions: behaviorOptions,
                            labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                            labelsAreNumeric: !0
                        };
                    }, MekkoColumnChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function() {
                        return this.data ? this.data.scalarCategoryAxis : !1;
                    }, MekkoColumnChart.prototype.getSupportedCategoryAxisType = function() {
                        var metaDataColumn = this.data ? this.data.categoryMetadata : void 0, valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn), isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                        return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                    }, MekkoColumnChart.prototype.setFilteredData = function(startIndex, endIndex) {
                        var data = powerbi.Prototype.inherit(this.data);
                        return data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex), 
                        data.categories = data.categories.slice(startIndex, endIndex), this.columnChart.setData(data), 
                        data;
                    }, MekkoColumnChart.ColumnChartClassName = "columnChart", MekkoColumnChart.SeriesClasses = createClassAndSelector("series"), 
                    MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder"), MekkoColumnChart;
                }();
                samples.MekkoColumnChart = MekkoColumnChart;
                var ColumnChartConverterHelper = function() {
                    function ColumnChartConverterHelper(dataView) {
                        this.dataView = dataView;
                    }
                    return ColumnChartConverterHelper.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, ColumnChartConverterHelper.prototype.getLegend = function(colors, defaultColor) {
                        var legend = [], seriesSources = [], seriesObjects = [], grouped = !1, colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor), legendTitle = void 0;
                        if (this.dataView && this.dataView.values) {
                            for (var allValues = this.dataView.values, valueGroups = allValues.grouped(), hasDynamicSeries = !(!allValues || !allValues.source), formatStringProp = visuals.columnChartProps.general.formatString, valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsLen > valueGroupsIndex; valueGroupsIndex++) for (var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values, valueIndex = 0, valuesLen = values.length; valuesLen > valueIndex; valueIndex++) {
                                var series = values[valueIndex], source = series.source;
                                if (!ColumnChartConverterHelper.hasRole(source, "Width") || ColumnChartConverterHelper.hasRole(source, "Y")) {
                                    seriesSources.push(source), seriesObjects.push(series.objects);
                                    var selectionId = series.identity ? visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) : visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex)), label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp), color = hasDynamicSeries ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName) : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                    legend.push({
                                        icon: visuals.LegendIcon.Box,
                                        color: color,
                                        label: label,
                                        identity: selectionId,
                                        selected: !1
                                    }), series.identity && void 0 !== source.groupName && (grouped = !0);
                                }
                            }
                            var dvValues = this.dataView.values;
                            legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                        }
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legend,
                            grouped: grouped
                        };
                        return {
                            legend: legendData,
                            seriesSources: seriesSources,
                            seriesObjects: seriesObjects
                        };
                    }, ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].values[category];
                    }, ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function(index) {
                        return this.dataView.values[index].source.queryName;
                    }, ColumnChartConverterHelper.prototype.hasHighlightValues = function(series) {
                        var column = this.dataView && this.dataView.values ? this.dataView.values[series] : void 0;
                        return column && !!column.highlights;
                    }, ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function(series, category) {
                        return this.dataView.values[series].highlights[category];
                    }, ColumnChartConverterHelper;
                }(), MekkoChartBehavior = function() {
                    function MekkoChartBehavior(behaviors) {
                        this.behaviors = behaviors;
                    }
                    return MekkoChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        for (var behaviors = this.behaviors, i = 0, ilen = behaviors.length; ilen > i; i++) behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                        options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, MekkoChartBehavior.prototype.renderSelection = function(hasSelection) {
                        for (var i = 0; i < this.behaviors.length; i++) this.behaviors[i].renderSelection(hasSelection);
                    }, MekkoChartBehavior;
                }();
                samples.MekkoChartBehavior = MekkoChartBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, SankeyDiagram = function() {
                    function SankeyDiagram(constructorOptions) {
                        this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }, this.nodeWidth = 21.5, this.curvatureOfLinks = .5, constructorOptions && (this.svg = constructorOptions.svg, 
                        this.margin = constructorOptions.margin || this.margin, this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks);
                    }
                    return SankeyDiagram.getProperties = function(capabilities) {
                        var result = {};
                        for (var objectKey in capabilities.objects) {
                            result[objectKey] = {};
                            for (var propKey in capabilities.objects[objectKey].properties) result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                        return result;
                    }, Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
                        get: function() {
                            return {
                                fontFamily: this.root.style("font-family"),
                                fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), SankeyDiagram.prototype.init = function(visualsInitOptions) {
                        this.svg ? this.root = this.svg : this.root = d3.select(visualsInitOptions.element.get(0)).append("svg"), 
                        this.selectionManager = new SelectionManager({
                            hostServices: visualsInitOptions.host
                        });
                        var style = visualsInitOptions.style;
                        this.colours = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                        this.root.classed(SankeyDiagram.ClassName, !0), this.main = this.root.append("g"), 
                        this.links = this.main.append("g").classed(SankeyDiagram.Links["class"], !0), this.nodes = this.main.append("g").classed(SankeyDiagram.Nodes["class"], !0);
                    }, SankeyDiagram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews) {
                            var sankeyDiagramDataView, dataView = visualUpdateOptions.dataViews[0];
                            this.updateViewport(visualUpdateOptions.viewport), sankeyDiagramDataView = this.converter(dataView), 
                            this.findNodePosition(sankeyDiagramDataView), this.dataView = sankeyDiagramDataView, 
                            this.render(sankeyDiagramDataView);
                        }
                    }, SankeyDiagram.prototype.updateViewport = function(viewport) {
                        var height, width;
                        height = this.getPositiveNumber(viewport.height), width = this.getPositiveNumber(viewport.width), 
                        this.viewport = {
                            height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                            width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                        }, this.updateElements(height, width);
                    }, SankeyDiagram.prototype.getPositiveNumber = function(value) {
                        return 0 > value || isNaN(value) || value === 1 / 0 || value === -(1 / 0) ? 0 : value;
                    }, SankeyDiagram.prototype.updateElements = function(height, width) {
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    }, SankeyDiagram.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[1] && dataView.categorical.categories[0].values && dataView.categorical.categories[1].values)) return {
                            nodes: [],
                            links: [],
                            settings: {
                                scale: {
                                    x: 1,
                                    y: 1
                                },
                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                                fontSize: SankeyDiagram.DefaultSettings.fontSize
                            }
                        };
                        var allCategories, valueFormatterForCategories, valuesFormatterForWeigth, objects, labelColour, settings, shiftOfColour, nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = valuesColumn && valuesColumn.values && valuesColumn.values.map(function(x) {
                            return x || 0;
                        }) || [], formatOfWeigth = "g", linksObjects = dataView.categorical.categories[0].objects || [], identities = [];
                        return dataView.categorical.categories[0].identity && (identities = identities.concat(dataView.categorical.categories[0].identity)), 
                        dataView.categorical.categories[1].identity && (identities = identities.concat(dataView.categorical.categories[1].identity)), 
                        objects = this.getObjectsFromDataView(dataView), labelColour = this.getColour(SankeyDiagram.Properties.labels.fill, SankeyDiagram.DefaultSettings.colourOfLabels, objects), 
                        valuesColumn && valuesColumn.source && (formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties.general.formatString)), 
                        dataPoints = categories.map(function(item, index) {
                            return {
                                source: item,
                                destination: secondCategories[index],
                                weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
                            };
                        }), allCategories = categories.concat(secondCategories), valueFormatterForCategories = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties.general.formatString),
                            value: allCategories[0],
                            value2: allCategories[allCategories.length - 1]
                        }), valuesFormatterForWeigth = ValueFormatter.create({
                            format: formatOfWeigth,
                            value: Math.max(d3.max(weightValues) || 1, 1)
                        }), allCategories.forEach(function(item, index) {
                            if (!nodes.some(function(node) {
                                return item === node.label.name ? (node.selectionIds.push(visuals.SelectionId.createWithId(identities[index])), 
                                !0) : !1;
                            })) {
                                var label, selectionId, formattedValue = valueFormatterForCategories.format(item), textProperties = {
                                    text: formattedValue,
                                    fontFamily: _this.textProperties.fontFamily,
                                    fontSize: _this.textProperties.fontSize
                                };
                                label = {
                                    name: item,
                                    formattedName: valueFormatterForCategories.format(item),
                                    width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                    colour: labelColour
                                }, selectionId = visuals.SelectionId.createWithId(identities[index]), nodes.push({
                                    label: label,
                                    links: [],
                                    inputWeight: 0,
                                    outputWeight: 0,
                                    width: _this.nodeWidth,
                                    height: 0,
                                    colour: SankeyDiagram.DefaultColourOfNode,
                                    tooltipData: [],
                                    selectionIds: [ selectionId ]
                                });
                            }
                        }), shiftOfColour = this.colours.getAllColors().length / nodes.length, nodes.forEach(function(node, index) {
                            node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                        }), dataPoints.forEach(function(dataPoint, index) {
                            var sourceNode, destinationNode, link, linkColour;
                            dataPoint.source !== dataPoint.destination && (nodes.forEach(function(node) {
                                node.label.name === dataPoint.source && (sourceNode = node), node.label.name === dataPoint.destination && (destinationNode = node);
                            }), linkColour = _this.getColour(SankeyDiagram.Properties.links.fill, SankeyDiagram.DefaultColourOfLink, linksObjects[index]), 
                            link = {
                                source: sourceNode,
                                destination: destinationNode,
                                weigth: dataPoint.weigth,
                                height: dataPoint.weigth,
                                colour: linkColour,
                                tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                                selectionId: visuals.SelectionId.createWithId(identities[index])
                            }, links.push(link), sourceNode.links.push(link), destinationNode.links.push(link), 
                            _this.updateValueOfNode(sourceNode), _this.updateValueOfNode(destinationNode), sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight), 
                            destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight));
                        }), settings = this.parseSettings(objects), settings.colourOfLabels = labelColour, 
                        {
                            nodes: nodes,
                            links: links,
                            settings: settings
                        };
                    }, SankeyDiagram.prototype.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, SankeyDiagram.prototype.getColour = function(properties, defaultColor, objects) {
                        var colorHelper;
                        return colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor), 
                        colorHelper.getColorForMeasure(objects, "");
                    }, SankeyDiagram.prototype.getTooltipDataForLink = function(valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                        var formattedLinkWeight;
                        return formattedLinkWeight = valueFormatter && valueFormatter.format ? valueFormatter.format(linkWeight) : linkWeight.toString(), 
                        [ {
                            displayName: SankeyDiagram.RoleNames.rows,
                            value: sourceNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.columns,
                            value: destinationNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedLinkWeight
                        } ];
                    }, SankeyDiagram.prototype.updateValueOfNode = function(node) {
                        node.inputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
                        }, 0), node.outputWeight = node.links.reduce(function(previousValue, currentValue) {
                            return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
                        }, 0);
                    }, SankeyDiagram.prototype.getTooltipForNode = function(valueFormatter, nodeName, nodeWeight) {
                        var formattedNodeWeigth;
                        return formattedNodeWeigth = valueFormatter && valueFormatter.format ? valueFormatter.format(nodeWeight) : nodeWeight.toString(), 
                        [ {
                            displayName: "Name",
                            value: nodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedNodeWeigth
                        } ];
                    }, SankeyDiagram.prototype.parseSettings = function(objects) {
                        var isVisibleLabels = !1;
                        return isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.show, SankeyDiagram.DefaultSettings.isVisibleLabels), 
                        {
                            isVisibleLabels: isVisibleLabels,
                            scale: {
                                x: SankeyDiagram.DefaultSettings.scale.x,
                                y: SankeyDiagram.DefaultSettings.scale.y
                            },
                            colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                            fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties.labels.fontSize, SankeyDiagram.DefaultSettings.fontSize)
                        };
                    }, SankeyDiagram.prototype.findNodePosition = function(sankeyDiagramDataView) {
                        this.findNodePositionByX(sankeyDiagramDataView), this.findNodePositionByY(sankeyDiagramDataView);
                    }, SankeyDiagram.prototype.findNodePositionByX = function(sankeyDiagramDataView) {
                        for (var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = !1; nodes.length > 0; ) nextNodes = [], 
                        nodes.forEach(function(node) {
                            node.x = x, node.links.forEach(function(link) {
                                node === link.source && node !== link.destination && nextNodes.every(function(item) {
                                    return item !== link.destination;
                                }) && nextNodes.push(link.destination);
                            });
                        }), isRecursiveDependencies = nextNodes.length === previousNodes.length && previousNodes.every(function(previousNode) {
                            return nextNodes.some(function(nextNode) {
                                return nextNode === previousNode;
                            });
                        }), isRecursiveDependencies ? (previousNodes.forEach(function(element) {
                            element.x = x, x++;
                        }), nodes = []) : (nodes = nextNodes, previousNodes = nodes, x++);
                        sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1), this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);
                    }, SankeyDiagram.prototype.scaleByAxisX = function(nodes, scale) {
                        nodes.forEach(function(node) {
                            node.x *= scale;
                        });
                    }, SankeyDiagram.prototype.getScaleByAxisX = function(numberOfColumns) {
                        return void 0 === numberOfColumns && (numberOfColumns = 1), this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                    }, SankeyDiagram.prototype.findNodePositionByY = function(sankeyDiagramDataView) {
                        var nodes = sankeyDiagramDataView.nodes, links = sankeyDiagramDataView.links, currentX = 0, index = 0, maxIndex = 0, sumValueOfNodes = 0, maxValueOfNodes = 0;
                        nodes = nodes.sort(function(firstNode, secondNode) {
                            return firstNode.x - secondNode.x;
                        }), nodes.forEach(function(node) {
                            currentX !== node.x && (index = 0, currentX = node.x, sumValueOfNodes = 0), sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight), 
                            sumValueOfNodes > maxValueOfNodes && (maxValueOfNodes = sumValueOfNodes), index > maxIndex && (maxIndex = index), 
                            index++;
                        }), sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes), 
                        this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);
                    }, SankeyDiagram.prototype.getScaleByAxisY = function(numberOfRows, sumValueOfNodes) {
                        return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);
                    }, SankeyDiagram.prototype.scaleByAxisY = function(nodes, links, scale) {
                        var shiftByAxisY = 0, currentX = 0, index = 0;
                        nodes.forEach(function(node) {
                            currentX !== node.x && (currentX = node.x, shiftByAxisY = 0, index = 0), node.height = Math.max(node.inputWeight, node.outputWeight) * scale, 
                            node.y = shiftByAxisY + SankeyDiagram.NodePadding * index, shiftByAxisY += node.height, 
                            index++;
                        }), nodes.forEach(function(node) {
                            node.links = node.links.sort(function(firstLink, secondLink) {
                                var firstY, secondY;
                                return firstY = firstLink.source === node ? firstLink.destination.y : firstLink.source.y, 
                                secondY = secondLink.source === node ? secondLink.destination.y : secondLink.source.y, 
                                firstY - secondY;
                            });
                            var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                            node.links.forEach(function(link) {
                                var shiftByAxisY = 0;
                                link.height = link.weigth * scale, link.source.x < node.x || link.destination.x < node.x ? (shiftByAxisY = shiftByAxisYOfLeftLink, 
                                shiftByAxisYOfLeftLink += link.height) : (link.source.x > node.x || link.destination.x > node.x) && (shiftByAxisY = shiftByAxisYOfRightLink, 
                                shiftByAxisYOfRightLink += link.height), link.source === node ? link.dySource = shiftByAxisY : link.destination === node && (link.dyDestination = shiftByAxisY);
                            });
                        });
                    }, SankeyDiagram.prototype.render = function(sankeyDiagramDataView) {
                        var nodesSelection, linksSelection;
                        linksSelection = this.renderLinks(sankeyDiagramDataView), nodesSelection = this.renderNodes(sankeyDiagramDataView), 
                        this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.renderNodes = function(sankeyDiagramDataView) {
                        var nodesEnterSelection, nodesSelection, nodeElements, _this = this;
                        return nodeElements = this.main.select(SankeyDiagram.Nodes.selector).selectAll(SankeyDiagram.Node.selector), 
                        nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function(x) {
                            return x.height > 0;
                        })), nodesEnterSelection = nodesSelection.enter().append("g"), nodesSelection.attr("transform", function(node) {
                            return visuals.SVGUtil.translate(node.x, node.y);
                        }).classed(SankeyDiagram.Node["class"], !0), nodesEnterSelection.append("rect").classed(SankeyDiagram.NodeRect["class"], !0), 
                        nodesEnterSelection.append("text").classed(SankeyDiagram.NodeLabel["class"], !0), 
                        nodesSelection.select(SankeyDiagram.NodeRect.selector).style({
                            fill: function(node) {
                                return node.colour;
                            },
                            stroke: function(node) {
                                return d3.rgb(node.colour).darker(1.5);
                            }
                        }).attr({
                            x: 0,
                            y: 0,
                            height: function(node) {
                                return node.height;
                            },
                            width: function(node) {
                                return node.width;
                            }
                        }), nodesSelection.select(SankeyDiagram.NodeLabel.selector).attr({
                            x: function(node) {
                                return _this.getLabelPositionByAxisX(node);
                            },
                            y: function(node) {
                                return node.height / 2;
                            },
                            dy: "0.35em"
                        }).style("fill", function(node) {
                            return node.label.colour;
                        }).style("font-size", this.textProperties.fontSize).style("display", function(node) {
                            var isNotVisibleLabel = !1, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                            return isNotVisibleLabel = labelPositionByAxisX >= _this.viewport.width || 0 >= labelPositionByAxisX || node.height + SankeyDiagram.NodePadding < node.label.height, 
                            isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel ? "none" : null;
                        }).style("text-anchor", function(node) {
                            return _this.isLabelLargerWidth(node) ? "end" : null;
                        }).text(function(node) {
                            var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;
                            return _this.getCurrentPositionOfLabelByAxisX(node) > maxWidth ? powerbi.TextMeasurementService.getTailoredTextOrDefault({
                                text: node.label.formattedName,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            }, maxWidth) : node.label.formattedName;
                        }), nodesSelection.exit().remove(), this.renderTooltip(nodesSelection), nodesSelection;
                    }, SankeyDiagram.prototype.getLabelPositionByAxisX = function(node) {
                        return this.isLabelLargerWidth(node) ? -SankeyDiagram.LabelPadding : node.width + SankeyDiagram.LabelPadding;
                    }, SankeyDiagram.prototype.isLabelLargerWidth = function(node) {
                        var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelPadding;
                        return shiftByAxisX + node.label.width > this.viewport.width;
                    }, SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function(node) {
                        var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                        return labelPositionByAxisX = labelPositionByAxisX > 0 ? labelPositionByAxisX + node.x + node.label.width + node.width : node.x + labelPositionByAxisX - node.label.width - node.width;
                    }, SankeyDiagram.prototype.renderLinks = function(sankeyDiagramDataView) {
                        var linksSelection, linksElements, _this = this;
                        return linksElements = this.main.select(SankeyDiagram.Links.selector).selectAll(SankeyDiagram.Link.selector), 
                        linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function(x) {
                            return x.height > 0;
                        })), linksSelection.enter().append("path").classed(SankeyDiagram.Link["class"], !0), 
                        linksSelection.attr("d", function(link) {
                            return _this.getSvgPath(link);
                        }).style({
                            "stroke-width": function(link) {
                                return link.height;
                            },
                            stroke: function(link) {
                                return link.colour;
                            }
                        }), linksSelection.exit().remove(), this.renderTooltip(linksSelection), linksSelection;
                    }, SankeyDiagram.prototype.getSvgPath = function(link) {
                        var x0, x1, xi, x2, x3, y0, y1;
                        return link.destination.x < link.source.x ? (x0 = link.source.x, x1 = link.destination.x + link.destination.width) : (x0 = link.source.x + link.source.width, 
                        x1 = link.destination.x), xi = d3.interpolateNumber(x0, x1), x2 = xi(this.curvatureOfLinks), 
                        x3 = xi(1 - this.curvatureOfLinks), y0 = link.source.y + link.dySource + link.height / 2, 
                        y1 = link.destination.y + link.dyDestination + link.height / 2, "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                    }, SankeyDiagram.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipData;
                        });
                    }, SankeyDiagram.prototype.bindSelectionHandler = function(sankeyDiagramDataView, nodesSelection, linksSelection) {
                        var _this = this;
                        nodesSelection.on("click", function(node) {
                            var selectionIds = _.isEqual(node.selectionIds.map(function(x) {
                                return x.getKey();
                            }), _this.selectionManager.getSelectionIds().map(function(x) {
                                return x.getKey();
                            })) ? [] : node.selectionIds;
                            _this.selectMany(selectionIds, !0).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), linksSelection.on("click", function(link) {
                            _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            }), d3.event.stopPropagation();
                        }), this.root.on("click", function() {
                            _this.selectionManager.clear().then(function() {
                                return _this.setSelection(nodesSelection, linksSelection);
                            });
                        }), this.setSelection(nodesSelection, linksSelection);
                    }, SankeyDiagram.prototype.selectMany = function(selectionIds, clear) {
                        var _this = this;
                        if (void 0 === clear && (clear = !1), clear) return this.selectionManager.clear().then(function() {
                            return _this.selectMany(selectionIds, !1);
                        });
                        var selectionDeffered = selectionIds.map(function(id) {
                            return _this.selectionManager.select(id, !0);
                        });
                        return $.when.apply(null, selectionDeffered);
                    }, SankeyDiagram.prototype.setSelection = function(nodes, links) {
                        var selectionIds = this.selectionManager.getSelectionIds();
                        if (nodes.classed("selected", selectionIds.length > 0), links.classed("selected", !1), 
                        0 !== selectionIds.length) {
                            var selectedNodesSelection = nodes.filter(function(node) {
                                return selectionIds.some(function(selectedId) {
                                    return node.selectionIds.some(function(x) {
                                        return x.getKey() === selectedId.getKey();
                                    });
                                });
                            }), selectedLinksSelection = links.filter(function(link) {
                                return selectionIds.some(function(selectionId) {
                                    return selectionId.getKey() === link.selectionId.getKey();
                                });
                            });
                            selectedNodesSelection.classed("selected", !1), selectedLinksSelection.classed("selected", !0);
                        }
                    }, SankeyDiagram.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.dataView) return [];
                        switch (options.objectName) {
                          case "labels":
                            this.enumerateLabels(enumeration);
                            break;

                          case "links":
                            this.enumerateLinks(enumeration);
                        }
                        return enumeration.complete();
                    }, SankeyDiagram.prototype.enumerateLabels = function(enumeration) {
                        var labels, settings = this.dataView.settings;
                        settings && (labels = {
                            objectName: "labels",
                            displayName: "labels",
                            selector: null,
                            properties: {
                                show: settings.isVisibleLabels,
                                fill: settings.colourOfLabels,
                                fontSize: settings.fontSize
                            }
                        }, enumeration.pushInstance(labels));
                    }, SankeyDiagram.prototype.enumerateLinks = function(enumeration) {
                        var links = this.dataView.links;
                        links && links.length > 0 && links.forEach(function(link) {
                            enumeration.pushInstance({
                                objectName: "links",
                                displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                                selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: link.colour
                                        }
                                    }
                                }
                            });
                        });
                    }, SankeyDiagram.ClassName = "sankeyDiagram", SankeyDiagram.Nodes = {
                        "class": "nodes",
                        selector: ".nodes"
                    }, SankeyDiagram.Node = {
                        "class": "node",
                        selector: ".node"
                    }, SankeyDiagram.NodeRect = {
                        "class": "nodeRect",
                        selector: ".nodeRect"
                    }, SankeyDiagram.NodeLabel = {
                        "class": "nodeLabel",
                        selector: ".nodeLabel"
                    }, SankeyDiagram.Links = {
                        "class": "links",
                        selector: ".links"
                    }, SankeyDiagram.Link = {
                        "class": "link",
                        selector: ".link"
                    }, SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)", SankeyDiagram.DefaultColourOfLink = "black", 
                    SankeyDiagram.DefaultSettings = {
                        isVisibleLabels: !0,
                        scale: {
                            x: 1,
                            y: 1
                        },
                        colourOfLabels: "black",
                        fontSize: 12
                    }, SankeyDiagram.MinWidthOfLabel = 35, SankeyDiagram.NodePadding = 5, SankeyDiagram.LabelPadding = 4, 
                    SankeyDiagram.RoleNames = {
                        rows: "Source",
                        columns: "Destination",
                        values: "Weight"
                    }, SankeyDiagram.capabilities = {
                        dataRoles: [ {
                            name: SankeyDiagram.RoleNames.rows,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.rows
                        }, {
                            name: SankeyDiagram.RoleNames.columns,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.columns
                        }, {
                            name: SankeyDiagram.RoleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: SankeyDiagram.RoleNames.values
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Source: {
                                    min: 0,
                                    max: 1
                                },
                                Destination: {
                                    min: 0,
                                    max: 1
                                },
                                Weight: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": SankeyDiagram.RoleNames.rows
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: SankeyDiagram.RoleNames.columns
                                        }
                                    }, {
                                        bind: {
                                            to: SankeyDiagram.RoleNames.values
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities), 
                    SankeyDiagram;
                }();
                samples.SankeyDiagram = SankeyDiagram;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter;
                samples.bulletChartProps = {
                    values: {
                        targetValue: {
                            objectName: "values",
                            propertyName: "targetValue"
                        },
                        minimumPercent: {
                            objectName: "values",
                            propertyName: "minimumPercent"
                        },
                        needsImprovementPercent: {
                            objectName: "values",
                            propertyName: "needsImprovementPercent"
                        },
                        satisfactoryPercent: {
                            objectName: "values",
                            propertyName: "satisfactoryPercent"
                        },
                        goodPercent: {
                            objectName: "values",
                            propertyName: "goodPercent"
                        },
                        veryGoodPercent: {
                            objectName: "values",
                            propertyName: "veryGoodPercent"
                        },
                        maximumPercent: {
                            objectName: "values",
                            propertyName: "maximumPercent"
                        },
                        targetValue2: {
                            objectName: "values",
                            propertyName: "targetValue2"
                        }
                    },
                    orientation: {
                        orientation: {
                            objectName: "orientation",
                            propertyName: "orientation"
                        }
                    },
                    colors: {
                        badColor: {
                            objectName: "colors",
                            propertyName: "badColor"
                        },
                        needsImprovementColor: {
                            objectName: "colors",
                            propertyName: "needsImprovementColor"
                        },
                        satisfactoryColor: {
                            objectName: "colors",
                            propertyName: "satisfactoryColor"
                        },
                        goodColor: {
                            objectName: "colors",
                            propertyName: "goodColor"
                        },
                        veryGoodColor: {
                            objectName: "colors",
                            propertyName: "veryGoodColor"
                        },
                        bulletColor: {
                            objectName: "colors",
                            propertyName: "bulletColor"
                        }
                    },
                    axis: {
                        axis: {
                            objectName: "axis",
                            propertyName: "axis"
                        },
                        axisColor: {
                            objectName: "axis",
                            propertyName: "axisColor"
                        },
                        measureUnits: {
                            objectName: "axis",
                            propertyName: "measureUnits"
                        },
                        unitsColor: {
                            objectName: "axis",
                            propertyName: "unitsColor"
                        }
                    },
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    },
                    labels: {
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        labelColor: {
                            objectName: "labels",
                            propertyName: "labelColor"
                        }
                    }
                }, samples.bulletChartRoleNames = {
                    value: "Value",
                    targetValue: "TargetValue",
                    minValue: "Minimum",
                    needsImprovementValue: "NeedsImprovement",
                    satisfactoryValue: "Satisfactory",
                    goodValue: "Good",
                    veryGoodValue: "VeryGood",
                    maxValue: "Maximum",
                    targetValue2: "TargetValue2"
                };
                var Orientation;
                !function(Orientation) {
                    Orientation.HORIZONTALLEFT = "Horizontal Left", Orientation.HORIZONTALRIGHT = "Horizontal Right", 
                    Orientation.VERTICALTOP = "Vertical Top", Orientation.VERTICALBOTTOM = "Vertical Bottom", 
                    Orientation.type = powerbi.createEnumType([ {
                        value: Orientation.HORIZONTALLEFT,
                        displayName: Orientation.HORIZONTALLEFT
                    }, {
                        value: Orientation.HORIZONTALRIGHT,
                        displayName: Orientation.HORIZONTALRIGHT
                    }, {
                        value: Orientation.VERTICALTOP,
                        displayName: Orientation.VERTICALTOP
                    }, {
                        value: Orientation.VERTICALBOTTOM,
                        displayName: Orientation.VERTICALBOTTOM
                    } ]);
                }(Orientation || (Orientation = {}));
                var BulletChart = function() {
                    function BulletChart() {
                        this.baselineDelta = 0;
                    }
                    return Object.defineProperty(BulletChart.prototype, "reverse", {
                        get: function() {
                            return this.model.bulletChartSettings.orientation.reverse;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "vertical", {
                        get: function() {
                            return this.model.bulletChartSettings.orientation.vertical;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChart.DefaultStyleProperties = function() {
                        return {
                            values: {
                                targetValue: 0,
                                targetValue2: 0,
                                minimumPercent: 0,
                                needsImprovementPercent: 25,
                                satisfactoryPercent: 50,
                                goodPercent: 100,
                                veryGoodPercent: 125,
                                maximumPercent: 200
                            },
                            orientation: {
                                orientation: Orientation.HORIZONTALLEFT,
                                reverse: !1,
                                vertical: !1
                            },
                            colors: {
                                badColor: "Darkred",
                                needsImprovementColor: "Red",
                                satisfactoryColor: "Yellow",
                                goodColor: "Green",
                                veryGoodColor: "Darkgreen",
                                bulletColor: "Black"
                            },
                            axis: {
                                axis: !0,
                                axisColor: "Grey",
                                measureUnits: "",
                                unitsColor: "Grey"
                            },
                            labelSettings: {
                                fontSize: 11,
                                show: !0,
                                labelColor: "Black"
                            }
                        };
                    }, Object.defineProperty(BulletChart.prototype, "viewportIn", {
                        get: function() {
                            return {
                                width: this.viewport.width,
                                height: this.viewport.height
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                        get: function() {
                            var viewportIn = this.viewportIn;
                            return {
                                width: viewportIn.width - BulletChart.ScrollBarSize,
                                height: viewportIn.height - BulletChart.ScrollBarSize
                            };
                        },
                        enumerable: !0,
                        configurable: !0
                    }), BulletChart.getTextProperties = function(text, fontSize) {
                        return {
                            fontFamily: BulletChart.FontFamily,
                            fontSize: PixelConverter.fromPoint(fontSize),
                            text: text
                        };
                    }, BulletChart.converter = function(dataView, options) {
                        var defaultSettings = BulletChart.DefaultStyleProperties(), bulletModel = {
                            bulletValueFormatString: null,
                            bulletChartSettings: defaultSettings,
                            bars: [],
                            barRects: [],
                            valueRects: [],
                            targetValues: []
                        };
                        if (!(dataView && dataView.categorical && dataView.categorical.values && 0 !== dataView.categorical.values.length && dataView.metadata && dataView.metadata.columns && 0 !== dataView.metadata.columns.length)) return bulletModel;
                        var objects = dataView.metadata.objects, settings = bulletModel.bulletChartSettings;
                        objects && (settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue), 
                        settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2), 
                        settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent), 
                        settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent), 
                        settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent), 
                        settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent), 
                        settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent), 
                        settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent), 
                        settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation), 
                        settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor), 
                        settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor), 
                        settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor), 
                        settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor), 
                        settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor), 
                        settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor), 
                        settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis), 
                        settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor), 
                        settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth), 
                        settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor), 
                        settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize), 
                        settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show), 
                        settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor)), 
                        settings.orientation.orientation !== Orientation.HORIZONTALRIGHT && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.reverse = !0), 
                        settings.orientation.orientation !== Orientation.VERTICALTOP && settings.orientation.orientation !== Orientation.VERTICALBOTTOM || (settings.orientation.vertical = !0);
                        var categories, categoryValues, categoryFormatString, categoryValuesLen = 1;
                        dataView.categorical.categories && (categories = dataView.categorical.categories[0], 
                        categoryValues = categories.values, categoryValuesLen = categoryValues.length, categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString)), 
                        bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString);
                        for (var idx = 0; categoryValuesLen > idx; idx++) {
                            var toolTipItems = [], category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0, highlight = !1, categoryIdentity = void 0;
                            if (categoryValues) {
                                var categoryValue = categoryValues[idx];
                                category = visuals.valueFormatter.format(categoryValue, categoryFormatString), categoryIdentity = categories.identity ? categories.identity[idx] : null;
                                var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
                                category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);
                                var labelWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties), labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                                BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth), 
                                BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);
                            }
                            var values = dataView.categorical.values;
                            targetValue = settings.values.targetValue, targetValue2 = settings.values.targetValue2;
                            for (var i = 0; i < values.length; i++) {
                                var col = values[i].source, currentVal = values[i].values[idx] || 0;
                                col && col.roles && (col.roles[samples.bulletChartRoleNames.value] ? (values[i].highlights && (highlight = null !== values[i].highlights[idx]), 
                                toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), value = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue] ? (toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), targetValue = currentVal) : col.roles[samples.bulletChartRoleNames.targetValue2] ? (toolTipItems.push({
                                    value: currentVal,
                                    metadata: values[i]
                                }), targetValue2 = currentVal) : col.roles[samples.bulletChartRoleNames.minValue] ? minimum = currentVal : col.roles[samples.bulletChartRoleNames.needsImprovementValue] ? needsImprovement = currentVal : col.roles[samples.bulletChartRoleNames.satisfactoryValue] ? satisfactory = currentVal : col.roles[samples.bulletChartRoleNames.goodValue] ? good = currentVal : col.roles[samples.bulletChartRoleNames.veryGoodValue] ? veryGood = currentVal : col.roles[samples.bulletChartRoleNames.maxValue] && (maximum = currentVal));
                            }
                            minimum || (minimum = settings.values.minimumPercent * targetValue / 100), needsImprovement || (needsImprovement = settings.values.needsImprovementPercent * targetValue / 100), 
                            satisfactory || (satisfactory = settings.values.satisfactoryPercent * targetValue / 100), 
                            good || (good = settings.values.goodPercent * targetValue / 100), veryGood || (veryGood = settings.values.veryGoodPercent * targetValue / 100), 
                            maximum || (maximum = settings.values.maximumPercent * targetValue / 100);
                            var viewportLength = (settings.orientation.vertical ? options.viewport.height - BulletChart.MaxLabelHeight : options.viewport.width - BulletChart.MaxLabelWidth) - BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize, sortedRanges = [ minimum, needsImprovement, satisfactory, good, veryGood, maximum ].sort(d3.descending), scale = d3.scale.linear().clamp(!0).domain([ minimum, Math.max(sortedRanges[0], targetValue, value) ]).range(settings.orientation.vertical ? [ viewportLength, 0 ] : [ 0, viewportLength ]), firstScale = scale(minimum), secondScale = scale(needsImprovement), thirdScale = scale(satisfactory), fourthScale = scale(good), fifthScale = scale(veryGood), lastScale = scale(maximum), valueScale = scale(value), firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity), 
                            BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity), 
                            BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity), 
                            bulletModel.targetValues.push({
                                barIndex: idx,
                                value: scale(targetValue),
                                fill: settings.colors.bulletColor,
                                key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
                                value2: scale(targetValue2)
                            });
                            var xAxis = null;
                            if (settings.axis.axis) {
                                xAxis = d3.svg.axis(), xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
                                var minTickSize = Math.round(Math.max(3, viewportLength / 100)), axisValues = [ value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood ].filter(function(x) {
                                    return !isNaN(x);
                                });
                                xAxis.tickFormat(visuals.valueFormatter.create({
                                    format: bulletModel.bulletValueFormatString,
                                    value: axisValues.length ? Math.max.apply(null, axisValues) : 0
                                }).format), xAxis.ticks(minTickSize), xAxis.scale(scale);
                            }
                            var bar = {
                                scale: scale,
                                barIndex: idx,
                                categoryLabel: category,
                                x: settings.orientation.vertical ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,
                                y: settings.orientation.vertical ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,
                                axis: xAxis,
                                key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey()
                            };
                            bulletModel.bars.push(bar);
                        }
                        return bulletModel;
                    }, BulletChart.addItemToBarArray = function(collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity) {
                        collection.push({
                            barIndex: barIndex,
                            start: start,
                            end: end,
                            fill: fill,
                            tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),
                            selected: !1,
                            identity: visuals.SelectionId.createWithId(categoryIdentity),
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey()
                        });
                    }, BulletChart.prototype.init = function(options) {
                        var body = d3.select(options.element.get(0));
                        this.hostService = options.host, this.bulletBody = body.append("div").classed("bulletChart", !0), 
                        this.scrollContainer = this.bulletBody.append("svg").classed("bullet-scroll-region", !0), 
                        this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer), this.labelGraphicsContext = this.scrollContainer.append("g"), 
                        this.bulletGraphicsContext = this.scrollContainer.append("g"), this.behavior = new BulletWebBehavior(), 
                        this.interactivityService = visuals.createInteractivityService(options.host);
                    }, BulletChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;
                            var dataView = options.dataViews[0];
                            this.viewport = options.viewport, this.model = BulletChart.converter(dataView, options), 
                            this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize)), 
                            this.ClearViewport(), this.model && (this.interactivityService && this.interactivityService.applySelectionStateToData(this.model.barRects), 
                            this.bulletBody.style({
                                height: this.viewportIn.height + "px",
                                width: this.viewportIn.width + "px"
                            }), this.vertical ? this.scrollContainer.attr({
                                width: this.model.bars.length * BulletChart.SpaceRequiredForBarVertically + "px",
                                height: this.viewportScroll.height + "px"
                            }) : this.scrollContainer.attr({
                                height: this.model.bars.length * BulletChart.SpaceRequiredForBar + "px",
                                width: this.viewportScroll.width + "px"
                            }), this.vertical ? this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse) : this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse));
                        }
                    }, BulletChart.prototype.ClearViewport = function() {
                        this.labelGraphicsContext.selectAll("text").remove(), this.bulletGraphicsContext.selectAll("rect").remove(), 
                        this.bulletGraphicsContext.selectAll("axis").remove(), this.bulletGraphicsContext.selectAll("path").remove(), 
                        this.bulletGraphicsContext.selectAll("line").remove(), this.bulletGraphicsContext.selectAll("tick").remove(), 
                        this.bulletGraphicsContext.selectAll("g").remove();
                    }, BulletChart.prototype.calculateLabelWidth = function(barData, bar, reversed) {
                        if (reversed) return BulletChart.StartMarginHorizontal + (bar ? bar.start : 0);
                        var textSize = powerbi.TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                        return textSize > BulletChart.BiggestLabelWidth ? barData.x + BulletChart.MaxLabelWidth + (bar ? bar.start : 0) : barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + (bar ? bar.start : 0);
                    }, BulletChart.prototype.calculateLabelHeight = function(barData, bar, reversed) {
                        if (reversed) return BulletChart.StartMarginVertical + (bar ? bar.end : 0);
                        var textSize = powerbi.TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                        return textSize > BulletChart.BiggestLabelHeight ? barData.y + BulletChart.MaxLabelHeight + (bar ? bar.end : 0) : barData.y + textSize + BulletChart.BarMargin + (bar ? bar.end : 0);
                    }, BulletChart.prototype.setUpBulletsHorizontally = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                            },
                            y: function(d) {
                                return bars[d.barIndex].y - BulletChart.BulletSize / 2;
                            },
                            width: function(d) {
                                return d.end - d.start;
                            },
                            height: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                            return d.key;
                        });
                        valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed);
                            },
                            y: function(d) {
                                return bars[d.barIndex].y - BulletChart.BulletSize / 8;
                            },
                            width: function(d) {
                                return d.end - d.start;
                            },
                            height: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        }), valueSelection.exit();
                        var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                            return d.key;
                        });
                        if (markerSelection.enter().append("line").attr({
                            x1: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            x2: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            y1: function(d) {
                                return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                            },
                            y2: function(d) {
                                return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        }), markerSelection.enter().append("line").attr({
                            x1: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            x2: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            y1: function(d) {
                                return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                            },
                            y2: function(d) {
                                return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2,
                            transform: "rotate(45deg)",
                            "transform-origin": "50% 50% 0"
                        }), markerSelection.enter().append("line").attr({
                            x1: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            x2: function(d) {
                                return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            y1: function(d) {
                                return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal;
                            },
                            y2: function(d) {
                                return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2,
                            transform: "rotate(315deg)",
                            "transform-origin": "50% 50% 0"
                        }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                transform: function() {
                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed), yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return "translate(" + xLocation + "," + yLocation + ")";
                                }
                            }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                                fill: model.bulletChartSettings.axis.axisColor,
                                "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll("line").style({
                                stroke: model.bulletChartSettings.axis.axisColor
                            });
                        }
                        if (model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().width + BulletChart.StartMarginHorizontal : d.x;
                            },
                            y: function(d) {
                                return d.y + _this.baselineDelta;
                            },
                            fill: model.bulletChartSettings.labelSettings.labelColor,
                            "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        }), model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin : d.x - BulletChart.SubtitleMargin;
                            },
                            y: function(d) {
                                return d.y + BulletChart.BulletSize;
                            },
                            fill: model.bulletChartSettings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.model.bulletChartSettings,
                                hasHighlights: !1
                            }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.setUpBulletsVertically = function(bulletBody, model, reveresed) {
                        var _this = this, bars = model.bars, rects = model.barRects, valueRects = model.valueRects, targetValues = model.targetValues, barSelection = this.labelGraphicsContext.selectAll("text").data(bars, function(d) {
                            return d.key;
                        }), rectSelection = this.bulletGraphicsContext.selectAll("rect.range").data(rects, function(d) {
                            return d.key;
                        }), bullets = rectSelection.enter().append("rect").attr({
                            x: function(d) {
                                return bars[d.barIndex].x;
                            },
                            y: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                            },
                            height: function(d) {
                                return d.start - d.end;
                            },
                            width: BulletChart.BulletSize
                        }).classed("range", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        });
                        rectSelection.exit();
                        var valueSelection = this.bulletGraphicsContext.selectAll("rect").data(valueRects, function(d) {
                            return d.key;
                        });
                        valueSelection.enter().append("rect").attr({
                            x: function(d) {
                                return bars[d.barIndex].x + BulletChart.BulletSize / 3;
                            },
                            y: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed);
                            },
                            height: function(d) {
                                return d.start - d.end;
                            },
                            width: 1 * BulletChart.BulletSize / 4
                        }).classed("value", !0).style({
                            fill: function(d) {
                                return d.fill;
                            }
                        }), valueSelection.exit();
                        var markerSelection = this.bulletGraphicsContext.selectAll("values").data(targetValues, function(d) {
                            return d.key;
                        });
                        if (markerSelection.enter().append("line").attr({
                            x2: function(d) {
                                return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                            },
                            x1: function(d) {
                                return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                            },
                            y2: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                            },
                            y1: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2
                        }), markerSelection.enter().append("line").attr({
                            y1: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            y2: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            x1: function(d) {
                                return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                            },
                            x2: function(d) {
                                return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2,
                            transform: "rotate(45deg)",
                            "transform-origin": "50% 50% 0"
                        }), markerSelection.enter().append("line").attr({
                            y1: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            y2: function(d) {
                                return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2;
                            },
                            x1: function(d) {
                                return bars[d.barIndex].x + BulletChart.MarkerMarginVertical;
                            },
                            x2: function(d) {
                                return bars[d.barIndex].x + 3 * BulletChart.MarkerMarginVertical;
                            }
                        }).style({
                            stroke: function(d) {
                                return d.fill;
                            },
                            "stroke-width": 2,
                            transform: "rotate(315deg)",
                            "transform-origin": "50% 50% 0"
                        }), markerSelection.exit(), model.bulletChartSettings.axis.axis) for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                transform: function() {
                                    var xLocation = bar.x, yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                    return "translate(" + xLocation + "," + yLocation + ")";
                                }
                            }).classed("axis", !0).call(bar.axis.scale(bar.scale)).style({
                                fill: model.bulletChartSettings.axis.axisColor,
                                "font-size": PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll("line").style({
                                stroke: model.bulletChartSettings.axis.axisColor
                            });
                        }
                        if (model.bulletChartSettings.labelSettings.show && barSelection.enter().append("text").classed("title", !0).attr({
                            x: function(d) {
                                return d.x;
                            },
                            y: function(d) {
                                return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize : d.y + powerbi.TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel, model.bulletChartSettings.labelSettings.fontSize)) / 2;
                            },
                            fill: model.bulletChartSettings.labelSettings.labelColor,
                            "font-size": PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize)
                        }).text(function(d) {
                            return d.categoryLabel;
                        }), model.bulletChartSettings.axis.measureUnits && barSelection.enter().append("text").attr({
                            x: function(d) {
                                return d.x + BulletChart.BulletSize;
                            },
                            y: function(d) {
                                return reveresed ? _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin : d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                            },
                            fill: model.bulletChartSettings.axis.unitsColor,
                            "font-size": PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits), this.interactivityService) {
                            var behaviorOptions = {
                                rects: bullets,
                                valueRects: valueSelection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService,
                                bulletChartSettings: this.model.bulletChartSettings,
                                hasHighlights: !1
                            }, targetCollection = this.model.barRects.concat(this.model.valueRects);
                            this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                        }
                        barSelection.exit(), visuals.TooltipManager.addTooltip(valueSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), visuals.TooltipManager.addTooltip(rectSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0);
                    }, BulletChart.prototype.destroy = function() {}, BulletChart.prototype.enumerateObjectInstances = function(options) {
                        var data = this.model;
                        if (data) {
                            var objectName = options.objectName;
                            switch (objectName) {
                              case "labels":
                                return this.enumerateLabels(data);

                              case "values":
                                return this.enumerateValues(data);

                              case "orientation":
                                return this.enumerateOrientation(data);

                              case "axis":
                                return this.enumerateAxis(data);

                              case "colors":
                                return this.enumerateColors(data);
                            }
                        }
                    }, BulletChart.prototype.enumerateLabels = function(data) {
                        return [ {
                            selector: null,
                            objectName: "labels",
                            properties: {
                                show: this.model.bulletChartSettings.labelSettings.show,
                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize
                            }
                        } ];
                    }, BulletChart.prototype.enumerateValues = function(data) {
                        return [ {
                            selector: null,
                            objectName: "values",
                            properties: {
                                targetValue: this.model.bulletChartSettings.values.targetValue,
                                targetValue2: this.model.bulletChartSettings.values.targetValue2,
                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
                                goodPercent: this.model.bulletChartSettings.values.goodPercent,
                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent
                            }
                        } ];
                    }, BulletChart.prototype.enumerateOrientation = function(data) {
                        return [ {
                            selector: null,
                            objectName: "orientation",
                            properties: {
                                orientation: this.model.bulletChartSettings.orientation.orientation
                            }
                        } ];
                    }, BulletChart.prototype.enumerateAxis = function(data) {
                        return [ {
                            selector: null,
                            objectName: "axis",
                            properties: {
                                axis: this.model.bulletChartSettings.axis.axis,
                                axisColor: this.model.bulletChartSettings.axis.axisColor,
                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,
                                unitsColor: this.model.bulletChartSettings.axis.unitsColor
                            }
                        } ];
                    }, BulletChart.prototype.enumerateColors = function(data) {
                        return [ {
                            selector: null,
                            objectName: "colors",
                            properties: {
                                badColor: this.model.bulletChartSettings.colors.badColor,
                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
                                goodColor: this.model.bulletChartSettings.colors.goodColor,
                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
                                bulletColor: this.model.bulletChartSettings.colors.bulletColor
                            }
                        } ];
                    }, BulletChart.ScrollBarSize = 13, BulletChart.SpaceRequiredForBar = 60, BulletChart.SpaceRequiredForBarVertically = 100, 
                    BulletChart.StartMarginHorizontal = 30, BulletChart.StartMarginVertical = 50, BulletChart.BulletSize = 25, 
                    BulletChart.DefaultSubtitleFontSizeInPt = 9, BulletChart.BarMargin = 10, BulletChart.MaxLabelWidth = 80, 
                    BulletChart.MaxLabelHeight = 60, BulletChart.SubtitleMargin = 10, BulletChart.AxisFontSizeInPt = 8, 
                    BulletChart.BiggestLabelWidth = 0, BulletChart.BiggestLabelHeight = 0, BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3, 
                    BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4, BulletChart.FontFamily = "Segoe UI", 
                    BulletChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Value",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Value"
                        }, {
                            name: "TargetValue",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Target Value"
                        }, {
                            name: "Minimum",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Minimum"
                        }, {
                            name: "NeedsImprovement",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Needs Improvement"
                        }, {
                            name: "Satisfactory",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Satisfactory"
                        }, {
                            name: "Good",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Good"
                        }, {
                            name: "VeryGood",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Very Good"
                        }, {
                            name: "Maximum",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Maximum"
                        }, {
                            name: "TargetValue2",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Target Value 2"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            values: {
                                displayName: "Data values",
                                properties: {
                                    targetValue: {
                                        displayName: "Target Value",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    targetValue2: {
                                        displayName: "Target Value 2",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    minimumPercent: {
                                        displayName: "Minimum %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    needsImprovementPercent: {
                                        displayName: "Needs Improvement %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    satisfactoryPercent: {
                                        displayName: "Satisfactory %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    goodPercent: {
                                        displayName: "Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    veryGoodPercent: {
                                        displayName: "Very Good %",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maximumPercent: {
                                        displayName: "Maximum %",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Category labels",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            orientation: {
                                displayName: "Orientation",
                                properties: {
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: Orientation.type
                                        }
                                    }
                                }
                            },
                            colors: {
                                displayName: "Colors",
                                properties: {
                                    badColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Bad Color"
                                    },
                                    needsImprovementColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Needs Improvement Color"
                                    },
                                    satisfactoryColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Satisfactory Color"
                                    },
                                    goodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Good Color"
                                    },
                                    veryGoodColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Very Good Color"
                                    },
                                    bulletColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Bullet Color"
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Axis Color"
                                    },
                                    measureUnits: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Measure Units "
                                    },
                                    unitsColor: {
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        },
                                        displayName: "Units Color"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Value: {
                                    max: 1
                                },
                                TargetValue: {
                                    max: 1
                                },
                                Minimum: {
                                    max: 1
                                },
                                NeedsImprovement: {
                                    max: 1
                                },
                                Satisfactory: {
                                    max: 1
                                },
                                Good: {
                                    max: 1
                                },
                                VeryGood: {
                                    max: 1
                                },
                                Maximum: {
                                    max: 1
                                },
                                TargetValue2: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Value"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetValue2"
                                        }
                                    }, {
                                        bind: {
                                            to: "Minimum"
                                        }
                                    }, {
                                        bind: {
                                            to: "NeedsImprovement"
                                        }
                                    }, {
                                        bind: {
                                            to: "Satisfactory"
                                        }
                                    }, {
                                        bind: {
                                            to: "Good"
                                        }
                                    }, {
                                        bind: {
                                            to: "VeryGood"
                                        }
                                    }, {
                                        bind: {
                                            to: "Maximum"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        drilldown: {
                            roles: [ "Category" ]
                        }
                    }, BulletChart;
                }();
                samples.BulletChart = BulletChart;
                var TextMeasurementHelper;
                !function(TextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
                var BulletWebBehavior = function() {
                    function BulletWebBehavior() {}
                    return BulletWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.valueRects.on("click", function(d, i) {
                            d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.rects.on("click", function(d, i) {
                            d3.event.stopPropagation(), selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, BulletWebBehavior.prototype.renderSelection = function(hasSelection) {
                        var options = this.options;
                        options.valueRects.style("opacity", function(d) {
                            return hasSelection ? d.selected ? "1" : "0.4" : "1";
                        }), options.rects.style("opacity", function(d) {
                            return hasSelection ? d.selected ? "1" : "0.4" : "1";
                        });
                    }, BulletWebBehavior;
                }();
                samples.BulletWebBehavior = BulletWebBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
                !function(WordCloudScaleType) {
                    WordCloudScaleType[WordCloudScaleType.logn = 0] = "logn", WordCloudScaleType[WordCloudScaleType.sqrt = 1] = "sqrt", 
                    WordCloudScaleType[WordCloudScaleType.value = 2] = "value";
                }(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
                var WordCloudScaleType = samples.WordCloudScaleType, VisualLayout = function() {
                    function VisualLayout(defaultViewport, defaultMargin) {
                        this.defaultViewport = defaultViewport || {
                            width: 0,
                            height: 0
                        }, this.defaultMargin = defaultMargin || {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                    }
                    return Object.defineProperty(VisualLayout.prototype, "margin", {
                        get: function() {
                            return this.marginValue || (this.margin = this.defaultMargin);
                        },
                        set: function(value) {
                            this.marginValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || (this.viewportValue = this.defaultViewport);
                        },
                        set: function(value) {
                            this.viewportValue = VisualLayout.restrictToMinMax(value), this.update();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                        get: function() {
                            return 0 === this.viewportIn.width || 0 === this.viewportIn.height;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), VisualLayout.prototype.update = function() {
                        this.viewportInValue = VisualLayout.restrictToMinMax({
                            width: this.viewport.width - (this.margin.left + this.margin.right),
                            height: this.viewport.height - (this.margin.top + this.margin.bottom)
                        });
                    }, VisualLayout.restrictToMinMax = function(value) {
                        var result = $.extend({}, value);
                        return d3.keys(value).forEach(function(x) {
                            return result[x] = Math.max(0, value[x]);
                        }), result;
                    }, VisualLayout;
                }(), WordCloud = function() {
                    function WordCloud(options) {
                        this.durationAnimations = 500, this.fakeViewport = {
                            width: 1500,
                            height: 1e3
                        }, this.canvasViewport = {
                            width: 128,
                            height: 2048
                        }, options && (this.svg = options.svg || this.svg, this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin), 
                        options.animator && (this.animator = options.animator));
                    }
                    return WordCloud.prototype.init = function(options) {
                        var _this = this;
                        this.svg ? this.root = this.svg : this.root = d3.select(options.element.get(0)).append("svg"), 
                        WordCloud.colors = options.style.colorPalette.dataColors, this.hostService = options.host, 
                        this.selectionManager = new visuals.utility.SelectionManager({
                            hostServices: this.hostService
                        }), this.layout || (this.layout = new VisualLayout(null, WordCloud.DefaultMargin)), 
                        this.root.classed(WordCloud.ClassName, !0), this.root.on("click", function() {
                            _this.selectionManager.clear(), _this.setSelection(_this.wordsSelection);
                        }), this.fontFamily = this.root.style("font-family"), this.main = this.root.append("g"), 
                        this.wordsContainerSelection = this.main.append("g").classed(WordCloud.Words["class"], !0), 
                        this.canvas = document.createElement("canvas");
                    }, WordCloud.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length && dataView.categorical.categories[0].values.length > 0)) return null;
                        var frequencies, texts, categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]);
                        return settings ? (_.isEmpty(dataView.categorical.values) || _.isEmpty(dataView.categorical.values[0]) || _.isEmpty(dataView.categorical.values[0].values) || (frequencies = dataView.categorical.values[0].values), 
                        texts = categories.map(function(item, index) {
                            var color, categoryObject = dataView.categorical.categories[0];
                            return color = categoryObject.objects && categoryObject.objects[index] ? _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]) : _this.wordCloudTexts && _this.wordCloudTexts[index] ? _this.wordCloudTexts[index].color : explore.util.getRandomColor(), 
                            {
                                text: item,
                                count: frequencies && frequencies[index] && !isNaN(frequencies[index]) ? frequencies[index] : 1,
                                index: index,
                                selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),
                                color: color
                            };
                        }), {
                            settings: settings,
                            texts: texts
                        }) : null;
                    }, WordCloud.prototype.getColor = function(properties, defaultColor, objects) {
                        var colorHelper;
                        return colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor), 
                        explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, ""));
                    }, WordCloud.parseSettings = function(dataView, value) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, stopWords, stopWordsArray, maxNumberOfWords, objects = dataView.metadata.objects, isRotateText = !1, isBrokenText = !0, isRemoveStopWords = !0, isDefaultStopWords = !1;
                        return maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords), 
                        minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize), 
                        maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize), 
                        minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle), 
                        maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle), 
                        isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText), 
                        maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations), 
                        valueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),
                            value: value
                        }), isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText), 
                        isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords), 
                        stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords), 
                        stopWordsArray = "string" == typeof stopWords ? stopWords.split(WordCloud.StopWordsDelemiter) : WordCloud.DefaultSettings.stopWordsArray, 
                        isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords), 
                        {
                            minFontSize: minFontSize,
                            maxFontSize: maxFontSize,
                            minAngle: minAngle,
                            maxAngle: maxAngle,
                            maxNumberOfOrientations: maxNumberOfOrientations,
                            valueFormatter: valueFormatter,
                            isRotateText: isRotateText,
                            isBrokenText: isBrokenText,
                            isRemoveStopWords: isRemoveStopWords,
                            stopWords: stopWords,
                            stopWordsArray: stopWordsArray,
                            isDefaultStopWords: isDefaultStopWords,
                            maxNumberOfWords: maxNumberOfWords
                        };
                    }, WordCloud.getNumberFromObjects = function(objects, properties, defaultValue) {
                        return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;
                    }, WordCloud.prototype.parseNumber = function(value, defaultValue, minValue, maxValue) {
                        void 0 === defaultValue && (defaultValue = 0), void 0 === minValue && (minValue = -Number.MAX_VALUE), 
                        void 0 === maxValue && (maxValue = Number.MAX_VALUE);
                        var parsedValue = Number(value);
                        return isNaN(parsedValue) || "string" == typeof value && 0 === value.length ? defaultValue : minValue > parsedValue ? minValue : parsedValue > maxValue ? maxValue : parsedValue;
                    }, WordCloud.prototype.computePositions = function(words, onPositionsComputed) {
                        var maxNumberOfWords, _this = this, context = this.getCanvasContext(), surface = [], borders = null;
                        if (!(words && words.length > 0)) return null;
                        maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, -1 * words.length, words.length)), 
                        words.length > maxNumberOfWords && (words = words.slice(0, maxNumberOfWords));
                        for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) surface[i] = 0;
                        setTimeout(function() {
                            return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0);
                        }, 0);
                    }, WordCloud.prototype.computeCycle = function(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                        void 0 === wordsForDraw && (wordsForDraw = []), void 0 === index && (index = 0);
                        var word = words[index], ratio = 1;
                        words.length <= 10 ? ratio = 5 : words.length <= 25 ? ratio = 3 : words.length <= 75 ? ratio = 1.5 : words.length <= 100 && (ratio = 1.25), 
                        word.x = this.specialViewport.width / ratio * (Math.random() + .5) >> 1, word.y = this.specialViewport.height / ratio * (Math.random() + .5) >> 1, 
                        this.generateSprites(context, word, words, index), word.sprite && this.findPosition(surface, word, borders) && (wordsForDraw.push(word), 
                        borders = this.updateBorders(word, borders), word.x -= this.specialViewport.width >> 1, 
                        word.y -= this.specialViewport.height >> 1), ++index < words.length && this.root ? this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index) : onPositionsComputed({
                            data: wordsForDraw,
                            leftBorder: borders && borders[0],
                            rightBorder: borders && borders[1]
                        });
                    }, WordCloud.prototype.updateBorders = function(word, borders) {
                        if (borders && 2 === borders.length) {
                            var leftBorder = borders[0], rightBorder = borders[1];
                            word.x + word.x0 < leftBorder.x && (leftBorder.x = word.x + word.x0), word.y + word.y0 < leftBorder.y && (leftBorder.y = word.y + word.y0), 
                            word.x + word.x1 > rightBorder.x && (rightBorder.x = word.x + word.x1), word.y + word.y1 > rightBorder.y && (rightBorder.y = word.y + word.y1);
                        } else borders = [ {
                            x: word.x + word.x0,
                            y: word.y + word.y0
                        }, {
                            x: word.x + word.x1,
                            y: word.y + word.y1
                        } ];
                        return borders;
                    }, WordCloud.prototype.generateSprites = function(context, currentWord, words, index) {
                        if (!currentWord.sprite) {
                            context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                            for (var pixels, x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, sprite = [], i = index; quantityOfWords > i; i++) {
                                var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;
                                if (context.save(), context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily, 
                                widthOfWord = context.measureText(currentWordData.text + "m").width, heightOfWord = currentWordData.size << 1, 
                                currentWordData.rotate) {
                                    var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                                    widthOfWord = Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31 >> 5 << 5, 
                                    heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                                } else widthOfWord = widthOfWord + 31 >> 5 << 5;
                                heightOfWord > maxHeight && (maxHeight = heightOfWord), x + widthOfWord >= this.canvasViewport.width << 5 && (x = 0, 
                                y += maxHeight, maxHeight = 0), context.translate(x + (widthOfWord >> 1), y + (heightOfWord >> 1)), 
                                currentWordData.rotate && context.rotate(currentWordData.rotate * WordCloud.Radians), 
                                context.fillText(currentWordData.text, 0, 0), currentWordData.padding && (context.lineWidth = 2 * currentWordData.padding, 
                                context.strokeText(currentWordData.text, 0, 0)), context.restore(), currentWordData.width = widthOfWord, 
                                currentWordData.height = heightOfWord, currentWordData.xOff = x, currentWordData.yOff = y, 
                                currentWordData.x1 = widthOfWord >> 1, currentWordData.y1 = heightOfWord >> 1, currentWordData.x0 = -currentWordData.x1, 
                                currentWordData.y0 = -currentWordData.y1, x += widthOfWord;
                            }
                            pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data, 
                            sprite = [];
                            for (var i = quantityOfWords - 1; i >= 0; i--) {
                                var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;
                                if (currentWordData.xOff + width >= this.canvasViewport.width << 5 || currentWordData.yOff + height >= this.canvasViewport.height) currentWordData.sprite = null; else {
                                    for (var j = 0; height * width32 > j; j++) sprite[j] = 0;
                                    if (null === currentWordData.xOff) return;
                                    x_1 = currentWordData.xOff, y_1 = currentWordData.yOff, seen = 0, seenRow = -1;
                                    for (var j = 0; height > j; j++) {
                                        for (var k = 0; width > k; k++) {
                                            var l = width32 * j + (k >> 5), index_1 = (y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k) << 2, m = pixels[index_1] ? 1 << 31 - k % 32 : 0;
                                            sprite[l] |= m, seen |= m;
                                        }
                                        seen ? seenRow = j : (currentWordData.y0++, height--, j--, y_1++);
                                    }
                                    currentWordData.y1 = currentWordData.y0 + seenRow, currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                                }
                            }
                        }
                    }, WordCloud.prototype.findPosition = function(surface, word, borders) {
                        for (var point, dx, dy, startPoint = {
                            x: word.x,
                            y: word.y
                        }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), dt = Math.random() < .5 ? 1 : -1, shift = -dt; ;) {
                            if (shift += dt, point = this.archimedeanSpiral(shift), dx = Math.floor(point.x), 
                            dy = Math.floor(point.y), Math.min(Math.abs(dx), Math.abs(dy)) >= delta) break;
                            if (word.x = startPoint.x + dx, word.y = startPoint.y + dy, !(word.x + word.x0 < 0 || word.y + word.y0 < 0 || word.x + word.x1 > this.specialViewport.width || word.y + word.y1 > this.specialViewport.height) && (!borders || !this.checkIntersect(word, surface)) && (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1]))) {
                                for (var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = 127 & lx, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; height > i; i++) {
                                    for (var lastSprite = 0, j = 0; width >= j; j++) {
                                        var leftMask = lastSprite << msx, rightMask = void 0;
                                        width > j && (lastSprite = sprite[i * width + j]), rightMask = width > j ? lastSprite >>> sx : 0, 
                                        surface[x + j] |= leftMask | rightMask;
                                    }
                                    x += shiftWidth;
                                }
                                return word.sprite = null, !0;
                            }
                        }
                        return !1;
                    }, WordCloud.prototype.archimedeanSpiral = function(value) {
                        var ratio = this.specialViewport.width / this.specialViewport.height;
                        return value = .1 * value, {
                            x: ratio * value * Math.cos(value),
                            y: value * Math.sin(value)
                        };
                    }, WordCloud.prototype.checkIntersect = function(word, surface) {
                        for (var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = 127 & lx, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5), i = 0; heightOfWord > i; i++) {
                            for (var lastSprite = 0, j = 0; widthOfWord >= j; j++) {
                                var mask = 0, leftMask = void 0, intersectMask = 0;
                                if (leftMask = lastSprite << msx, widthOfWord > j && (lastSprite = sprite[i * widthOfWord + j]), 
                                mask = widthOfWord > j ? lastSprite >>> sx : 0, intersectMask = (leftMask | mask) & surface[x + j]) return !0;
                            }
                            x += shiftWidth;
                        }
                        return !1;
                    }, WordCloud.prototype.checkIntersectOfRectangles = function(word, leftBorder, rightBorder) {
                        return word.x + word.x1 > leftBorder.x && word.x + word.x0 < rightBorder.x && word.y + word.y1 > leftBorder.y && word.y + word.y0 < rightBorder.y;
                    }, WordCloud.prototype.getCanvasContext = function() {
                        if (!this.canvasViewport) return null;
                        this.canvas.width = 1, this.canvas.height = 1;
                        var context = this.canvas.getContext("2d");
                        return this.canvas.width = this.canvasViewport.width << 5, this.canvas.height = this.canvasViewport.height, 
                        context = this.canvas.getContext("2d"), context.fillStyle = context.strokeStyle = "red", 
                        context.textAlign = "center", context;
                    }, WordCloud.prototype.getReducedText = function(texts) {
                        var brokenStrings = [];
                        return brokenStrings = this.getBrokenWords(texts), brokenStrings.reduce(function(previousValue, currentValue) {
                            return previousValue.some(function(value) {
                                return value.index !== currentValue.index && value.text === currentValue.text ? (value.count += currentValue.count, 
                                !0) : !1;
                            }) || previousValue.push(currentValue), previousValue;
                        }, []);
                    }, WordCloud.prototype.getBrokenWords = function(words) {
                        var punctuatuinRegExp, _this = this, brokenStrings = [], whiteSpaceRegExp = /\s/;
                        return this.settings.isBrokenText ? (punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim"), 
                        words.forEach(function(item) {
                            if ("string" == typeof item.text) {
                                var words_1;
                                if (words_1 = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp), 
                                _this.settings.isRemoveStopWords) {
                                    var stopWords_1 = _this.settings.stopWordsArray;
                                    _this.settings.isDefaultStopWords && (stopWords_1 = stopWords_1.concat(WordCloud.StopWords)), 
                                    words_1 = words_1.filter(function(value) {
                                        return value.length > 0 && !stopWords_1.some(function(removeWord) {
                                            return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                        });
                                    });
                                }
                                words_1.forEach(function(element) {
                                    element.length > 0 && !whiteSpaceRegExp.test(element) && brokenStrings.push({
                                        text: element,
                                        count: item.count,
                                        index: item.index,
                                        selectionId: item.selectionId,
                                        color: item.color
                                    });
                                });
                            } else brokenStrings.push(item);
                        }), brokenStrings) : words;
                    }, WordCloud.prototype.getWords = function(values) {
                        var sortedValues, _this = this, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;
                        if (!(values && values.length >= 1)) return [];
                        sortedValues = values.sort(function(a, b) {
                            return b.count - a.count;
                        }), minValue = sortedValues[sortedValues.length - 1].count, maxValue = sortedValues[0].count;
                        var returnValues = values.map(function(value) {
                            return {
                                text: valueFormatter.format(value.text),
                                size: _this.getFontSize(value.count, minValue, maxValue),
                                x: 0,
                                y: 0,
                                rotate: _this.getAngle(),
                                padding: 1,
                                width: 0,
                                height: 0,
                                xOff: 0,
                                yOff: 0,
                                x0: 0,
                                y0: 0,
                                x1: 0,
                                y1: 0,
                                color: value.color,
                                selectionId: value.selectionId,
                                wordIndex: value.index
                            };
                        });
                        return this.dataBeforeRender = returnValues, returnValues;
                    }, WordCloud.prototype.getFontSize = function(value, minValue, maxValue, scaleType) {
                        void 0 === scaleType && (scaleType = WordCloudScaleType.value);
                        var weight, fontSize, maxFontSize, minFontSize;
                        if (minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize)), 
                        maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize)), 
                        minFontSize > maxFontSize) {
                            var buffer = minFontSize;
                            minFontSize = maxFontSize, maxFontSize = buffer;
                        }
                        switch (scaleType) {
                          case WordCloudScaleType.logn:
                            weight = Math.log(value);

                          case WordCloudScaleType.sqrt:
                            weight = Math.sqrt(value);

                          case WordCloudScaleType.value:
                            weight = value;
                        }
                        return fontSize = weight > minValue ? maxFontSize * (weight - minValue) / (maxValue - minValue) : 0, 
                        fontSize = 100 * fontSize / maxFontSize, fontSize = fontSize * (maxFontSize - minFontSize) / 100 + minFontSize;
                    }, WordCloud.prototype.getAngle = function() {
                        if (!this.settings || !this.settings.isRotateText) return 0;
                        var minAngle, maxAngle, maxNumberOfOrientations, angle;
                        if (maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0)), 
                        minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                        maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle), 
                        minAngle > maxAngle) {
                            var buffer = minAngle;
                            minAngle = maxAngle, maxAngle = buffer;
                        }
                        return angle = Math.abs((maxAngle - minAngle) / maxNumberOfOrientations * Math.floor(Math.random() * maxNumberOfOrientations)), 
                        0 !== maxNumberOfOrientations ? minAngle + angle : 0;
                    }, WordCloud.prototype.update = function(visualUpdateOptions) {
                        var _this = this;
                        if (visualUpdateOptions && visualUpdateOptions.viewport && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0] && visualUpdateOptions.viewport && visualUpdateOptions.viewport.height >= 0 && visualUpdateOptions.viewport.width >= 0) {
                            this.visualUpdateOptions = visualUpdateOptions, this.layout.viewport = this.visualUpdateOptions.viewport;
                            var dataView = visualUpdateOptions.dataViews[0];
                            this.layout.viewportInIsZero || (this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                            this.UpdateSize(), this.data = this.converter(dataView), this.data && (this.settings = this.data.settings, 
                            this.wordCloudTexts = this.data.texts, this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function(wordCloudDataView) {
                                return _this.render(wordCloudDataView);
                            }), visualUpdateOptions !== this.visualUpdateOptions && this.update(this.visualUpdateOptions)));
                        }
                    }, WordCloud.prototype.UpdateSize = function() {
                        var fakeWidth, fakeHeight, ratio;
                        ratio = Math.sqrt(this.fakeViewport.width * this.fakeViewport.height / (this.layout.viewportIn.width * this.layout.viewportIn.height)), 
                        isNaN(ratio) ? fakeHeight = fakeWidth = 1 : (fakeHeight = this.layout.viewportIn.height * ratio, 
                        fakeWidth = this.layout.viewportIn.width * ratio), this.specialViewport = {
                            height: fakeHeight,
                            width: fakeWidth
                        }, this.root.attr({
                            height: this.layout.viewport.height,
                            width: this.layout.viewport.width
                        });
                    }, WordCloud.prototype.render = function(wordCloudDataView) {
                        var _this = this;
                        if (wordCloudDataView && wordCloudDataView.data) {
                            this.wordCloudDataView = wordCloudDataView;
                            var animatedWordSelection, wordElements = this.main.select(WordCloud.Words.selector).selectAll(WordCloud.Word.selector);
                            this.wordsSelection = wordElements.data(wordCloudDataView.data), this.animation(this.wordsSelection, this.durationAnimations).attr("transform", function(item) {
                                return visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")";
                            }).style({
                                "font-size": function(item) {
                                    return "" + item.size + WordCloud.Size;
                                },
                                fill: function(item) {
                                    return item.color;
                                }
                            }), animatedWordSelection = this.wordsSelection.enter().append("svg:text").attr("transform", function(item) {
                                return visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")";
                            }).style("font-size", "1px"), this.wordsSelection.on("click", function(item) {
                                _this.selectionManager.select(item.selectionId, d3.event.ctrlKey).then(function() {
                                    return _this.setSelection(_this.wordsSelection);
                                }), d3.event.stopPropagation();
                            }), this.animation(animatedWordSelection, this.durationAnimations).style({
                                "font-size": function(item) {
                                    return "" + item.size + WordCloud.Size;
                                },
                                fill: function(item) {
                                    return item.color;
                                }
                            }), this.wordsSelection.text(function(item) {
                                return item.text;
                            }).classed(WordCloud.Word["class"], !0), this.wordsSelection.exit().remove(), this.setSelection(this.wordsSelection), 
                            setTimeout(function() {
                                _this.root && _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations);
                            }, this.durationAnimations + WordCloud.RenderDelay);
                        }
                    }, WordCloud.prototype.setSelection = function(selection) {
                        var selectionIds = this.selectionManager.getSelectionIds();
                        if (selectionIds.some(function(x) {
                            return !selection.data().some(function(d) {
                                return d.selectionId.getKey() === x.getKey();
                            });
                        }) && (this.selectionManager.clear(), selectionIds = []), !selectionIds.length) return void this.setOpacity(selection, WordCloud.MaxOpacity, !0);
                        var selectedColumns = selection.filter(function(x) {
                            return selectionIds.some(function(y) {
                                return y.getKey() === x.selectionId.getKey();
                            });
                        });
                        this.setOpacity(selection, WordCloud.MinOpacity), this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                    }, WordCloud.prototype.setOpacity = function(element, opacityValue, disableAnimation) {
                        void 0 === disableAnimation && (disableAnimation = !1);
                        var elementAnimation = disableAnimation ? element : this.animation(element);
                        elementAnimation.style("fill-opacity", opacityValue);
                    }, WordCloud.prototype.scaleMainView = function(wordCloudDataView, durationAnimation) {
                        if (void 0 === durationAnimation && (durationAnimation = 0), wordCloudDataView && wordCloudDataView.leftBorder && wordCloudDataView.rightBorder) {
                            var width2, height2, scaleByX, scaleByY, scale = 1, mainSVGRect = this.main.node().getBBox(), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder;
                            scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x), 
                            scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y), 
                            scale = Math.min(scaleByX, scaleByY), width2 = this.layout.margin.left + mainSVGRect.x * scale * -1 + (this.layout.viewportIn.width - mainSVGRect.width * scale) / 2, 
                            height2 = this.layout.margin.top + mainSVGRect.y * scale * -1 + (this.layout.viewportIn.height - mainSVGRect.height * scale) / 2, 
                            this.animation(this.main, durationAnimation).attr("transform", visuals.SVGUtil.translate(width2, height2) + "scale(" + scale + ")");
                        }
                    }, WordCloud.prototype.enumerateObjectInstances = function(options) {
                        var _this = this, instances = [];
                        if (!this.settings) return instances;
                        switch (options.objectName) {
                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    maxNumberOfWords: this.settings.maxNumberOfWords,
                                    minFontSize: this.settings.minFontSize,
                                    maxFontSize: this.settings.maxFontSize,
                                    isBrokenText: this.settings.isBrokenText
                                }
                            };
                            instances.push(general);
                            break;

                          case "dataPoint":
                            if (!this.wordCloudDataView || !this.wordCloudDataView.data) return;
                            var dataPoints = this.dataBeforeRender, wordCategoriesIndex_1 = [];
                            dataPoints.forEach(function(item) {
                                -1 === wordCategoriesIndex_1.indexOf(item.wordIndex) && (wordCategoriesIndex_1.push(item.wordIndex), 
                                instances.push({
                                    objectName: "dataPoint",
                                    displayName: _this.data.texts[item.wordIndex].text,
                                    selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), !1),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: item.color
                                            }
                                        }
                                    }
                                }));
                            });
                            break;

                          case "rotateText":
                            var rotateText = {
                                objectName: "rotateText",
                                displayName: "Rotate Text",
                                selector: null,
                                properties: {
                                    show: this.settings.isRotateText,
                                    minAngle: this.settings.minAngle,
                                    maxAngle: this.settings.maxAngle,
                                    maxNumberOfOrientations: this.settings.maxNumberOfOrientations
                                }
                            };
                            instances.push(rotateText);
                            break;

                          case "stopWords":
                            var stopWords = {
                                objectName: "stopWords",
                                displayName: "Stop Words",
                                selector: null,
                                properties: {
                                    show: this.settings.isRemoveStopWords,
                                    isDefaultStopWords: this.settings.isDefaultStopWords,
                                    words: this.settings.stopWords || this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)
                                }
                            };
                            instances.push(stopWords);
                        }
                        return instances;
                    }, WordCloud.prototype.animation = function(element, duration, callback) {
                        return void 0 === duration && (duration = 0), element.transition().duration(duration).each("end", callback);
                    }, WordCloud.prototype.destroy = function() {
                        this.root = null, this.canvas = null;
                    }, WordCloud.ClassName = "wordCloud", WordCloud.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            },
                            maxNumberOfWords: {
                                objectName: "general",
                                propertyName: "maxNumberOfWords"
                            },
                            minFontSize: {
                                objectName: "general",
                                propertyName: "minFontSize"
                            },
                            maxFontSize: {
                                objectName: "general",
                                propertyName: "maxFontSize"
                            },
                            isBrokenText: {
                                objectName: "general",
                                propertyName: "isBrokenText"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        stopWords: {
                            show: {
                                objectName: "stopWords",
                                propertyName: "show"
                            },
                            isDefaultStopWords: {
                                objectName: "stopWords",
                                propertyName: "isDefaultStopWords"
                            },
                            words: {
                                objectName: "stopWords",
                                propertyName: "words"
                            }
                        },
                        rotateText: {
                            show: {
                                objectName: "rotateText",
                                propertyName: "show"
                            },
                            minAngle: {
                                objectName: "rotateText",
                                propertyName: "minAngle"
                            },
                            maxAngle: {
                                objectName: "rotateText",
                                propertyName: "maxAngle"
                            },
                            maxNumberOfOrientations: {
                                objectName: "rotateText",
                                propertyName: "maxNumberOfOrientations"
                            }
                        }
                    }, WordCloud.Words = {
                        "class": "words",
                        selector: ".words"
                    }, WordCloud.Word = {
                        "class": "word",
                        selector: ".word"
                    }, WordCloud.Size = "px", WordCloud.StopWordsDelemiter = " ", WordCloud.Radians = Math.PI / 180, 
                    WordCloud.MinAngle = -180, WordCloud.MaxAngle = 180, WordCloud.MaxNumberOfWords = 2500, 
                    WordCloud.MinOpacity = .2, WordCloud.MaxOpacity = 1, WordCloud.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: WordCloud.MaxNumberOfWords
                                        }
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Values"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 2
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    maxNumberOfWords: {
                                        displayName: "Max number of words",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    minFontSize: {
                                        displayName: "Min Font",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxFontSize: {
                                        displayName: "Max Font",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    isBrokenText: {
                                        displayName: "Word-breaking",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isRemoveStopWords: {
                                        displayName: "Stop Words",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            stopWords: {
                                displayName: "Stop Words",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isDefaultStopWords: {
                                        displayName: "Default Stop Words",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    words: {
                                        displayName: "Words",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            rotateText: {
                                displayName: "Rotate Text",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    minAngle: {
                                        displayName: "Min Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxAngle: {
                                        displayName: "Max Angle",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    maxNumberOfOrientations: {
                                        displayName: "Max number of orientations",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, WordCloud.Punctuation = [ "!", ".", ":", "'", ";", ",", "!", "@", "#", "$", "%", "^", "&", "*", "(", ")", "[", "]", '"', "\\", "/", "-", "_", "+", "=" ], 
                    WordCloud.StopWords = [ "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an", "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot", "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get", "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i", "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may", "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often", "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should", "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these", "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what", "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet", "you", "your" ], 
                    WordCloud.DefaultSettings = {
                        minFontSize: 20,
                        maxFontSize: 100,
                        minAngle: -60,
                        maxAngle: 90,
                        maxNumberOfOrientations: 2,
                        isRotateText: !1,
                        isBrokenText: !0,
                        isRemoveStopWords: !1,
                        stopWordsArray: [],
                        stopWords: void 0,
                        isDefaultStopWords: !1,
                        maxNumberOfWords: 200
                    }, WordCloud.RenderDelay = 50, WordCloud.DefaultMargin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    }, WordCloud;
                }();
                samples.WordCloud = WordCloud;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRgb(hex) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                        }
                        function getRandomColor() {
                            var red = Math.floor(255 * Math.random()), green = Math.floor(255 * Math.random()), blue = Math.floor(255 * Math.random());
                            return "rgb(" + red + "," + green + "," + blue + ")";
                        }
                        util.hexToRgb = hexToRgb, util.getRandomColor = getRandomColor;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var TableViewFactory, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter;
                !function(TableViewFactory) {
                    function createTableView(options) {
                        return new TableView(options);
                    }
                    TableViewFactory.createTableView = createTableView;
                }(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
                var TableView = function() {
                    function TableView(options) {
                        this.options = $.extend(!0, {}, options), this.options.baseContainer.style("overflow-y", "auto").attr("drag-resize-disabled", !0), 
                        this.scrollContainer = options.baseContainer.append("div").attr("class", "scrollRegion"), 
                        this.visibleGroupContainer = this.scrollContainer.append("div").attr("class", "visibleGroup"), 
                        TableView.SetDefaultOptions(options);
                    }
                    return TableView.SetDefaultOptions = function(options) {
                        options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                    }, TableView.prototype.rowHeight = function(rowHeight) {
                        return this.options.rowHeight = Math.ceil(rowHeight), this;
                    }, TableView.prototype.columnWidth = function(columnWidth) {
                        return this.options.columnWidth = Math.ceil(columnWidth), this;
                    }, TableView.prototype.orientation = function(orientation) {
                        return this.options.orientation = orientation, this;
                    }, TableView.prototype.rows = function(rows) {
                        return this.options.rows = Math.ceil(rows), this;
                    }, TableView.prototype.columns = function(columns) {
                        return this.options.columns = Math.ceil(columns), this;
                    }, TableView.prototype.data = function(data, getDatumIndex, dataReset) {
                        return void 0 === dataReset && (dataReset = !1), this._data = data, this.getDatumIndex = getDatumIndex, 
                        this.setTotalRows(), dataReset && $(this.options.baseContainer.node()).scrollTop(0), 
                        this;
                    }, TableView.prototype.viewport = function(viewport) {
                        return this.options.viewport = viewport, this;
                    }, TableView.prototype.empty = function() {
                        this._data = [], this.render();
                    }, TableView.prototype.setTotalRows = function() {
                        var count = this._data.length, rows = Math.min(this.options.rows, count), columns = Math.min(this.options.columns, count);
                        columns > 0 && rows > 0 ? (this._totalColumns = columns, this._totalRows = rows) : rows > 0 ? (this._totalRows = rows, 
                        this._totalColumns = Math.ceil(count / rows)) : columns > 0 ? (this._totalColumns = columns, 
                        this._totalRows = Math.ceil(count / columns)) : (this._totalColumns = TableView.defaultColumns, 
                        this._totalRows = Math.ceil(count / TableView.defaultColumns));
                    }, TableView.prototype.render = function() {
                        var options = this.options, visibleGroupContainer = this.visibleGroupContainer, rowHeight = options.rowHeight || TableView.defaultRowHeight, groupedData = [], totalRows = options.rows, totalColumns = options.columns, totalItems = this._data.length, totalRows = options.rows > totalItems ? totalItems : options.rows, totalColumns = options.columns > totalItems ? totalItems : options.columns;
                        if (0 === totalColumns && 0 === totalRows ? options.orientation === Orientation.HORIZONTAL ? (totalColumns = totalItems, 
                        totalRows = 1) : (totalColumns = 1, totalRows = totalItems) : 0 === totalColumns && totalRows > 0 ? totalColumns = Math.ceil(totalItems / totalRows) : totalColumns > 0 && 0 === totalRows && (totalRows = Math.ceil(totalItems / totalColumns)), 
                        this.options.orientation === Orientation.VERTICAL) {
                            var n = totalRows;
                            totalRows = totalColumns, totalColumns = n;
                        } else this.options.orientation === Orientation.HORIZONTAL && (0 === totalRows && (totalRows = this._totalRows), 
                        0 === totalColumns && (totalColumns = this._totalColumns));
                        for (var m = 0, k = 0, i = 0; totalRows > i; i++) if (this.options.orientation === Orientation.VERTICAL && 0 === options.rows && totalItems % options.columns > 0 && options.columns <= totalItems) totalItems % options.columns > i ? (m = i * Math.ceil(totalItems / options.columns), 
                        k = m + Math.ceil(totalItems / options.columns), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns))), 
                        k += Math.floor(totalItems / options.columns)); else if (this.options.orientation === Orientation.HORIZONTAL && 0 === options.columns && totalItems % options.rows > 0 && options.rows <= totalItems) totalItems % options.rows > i ? (m = i * Math.ceil(totalItems / options.rows), 
                        k = m + Math.ceil(totalItems / options.rows), groupedData.push(this._data.slice(m, k))) : (groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows))), 
                        k += Math.floor(totalItems / options.rows)); else {
                            var k = i * totalColumns;
                            groupedData.push(this._data.slice(k, k + totalColumns));
                        }
                        visibleGroupContainer.selectAll(".row").remove();
                        var cellSelection = visibleGroupContainer.selectAll(".row").data(groupedData).enter().append("div").classed("row", !0).selectAll(".cell").data(function(d) {
                            return d;
                        });
                        cellSelection.enter().append("div").classed("cell", !0).call(function(d) {
                            return options.enter(d);
                        }), cellSelection.order();
                        var cellUpdateSelection = visibleGroupContainer.selectAll(".cell:not(.transitioning)");
                        if (cellUpdateSelection.call(function(d) {
                            return options.update(d);
                        }), cellUpdateSelection.style({
                            height: rowHeight > 0 ? rowHeight + "px" : "auto"
                        }), this.options.orientation === Orientation.VERTICAL) {
                            for (var realColumnNumber = 0, i = 0; i < groupedData.length; i++) 0 !== groupedData[i].length && (realColumnNumber = i + 1);
                            cellUpdateSelection.style({
                                width: "100%"
                            });
                            var rowUpdateSelection = visibleGroupContainer.selectAll("div.row");
                            rowUpdateSelection.style({
                                width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / realColumnNumber + "%"
                            });
                        } else cellUpdateSelection.style({
                            width: options.columnWidth > 0 ? options.columnWidth + "px" : 100 / totalColumns + "%"
                        });
                        cellSelection.exit().call(function(d) {
                            return options.exit(d);
                        }).remove();
                    }, TableView.defaultRowHeight = 0, TableView.defaultColumns = 1, TableView;
                }();
                samples.chicletSlicerProps = {
                    general: {
                        orientation: {
                            objectName: "general",
                            propertyName: "orientation"
                        },
                        columns: {
                            objectName: "general",
                            propertyName: "columns"
                        },
                        rows: {
                            objectName: "general",
                            propertyName: "rows"
                        },
                        showDisabled: {
                            objectName: "general",
                            propertyName: "showDisabled"
                        },
                        multiselect: {
                            objectName: "general",
                            propertyName: "multiselect"
                        },
                        selection: {
                            objectName: "general",
                            propertyName: "selection"
                        }
                    },
                    header: {
                        show: {
                            objectName: "header",
                            propertyName: "show"
                        },
                        title: {
                            objectName: "header",
                            propertyName: "title"
                        },
                        fontColor: {
                            objectName: "header",
                            propertyName: "fontColor"
                        },
                        background: {
                            objectName: "header",
                            propertyName: "background"
                        },
                        outline: {
                            objectName: "header",
                            propertyName: "outline"
                        },
                        textSize: {
                            objectName: "header",
                            propertyName: "textSize"
                        },
                        outlineColor: {
                            objectName: "header",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "header",
                            propertyName: "outlineWeight"
                        }
                    },
                    rows: {
                        fontColor: {
                            objectName: "rows",
                            propertyName: "fontColor"
                        },
                        textSize: {
                            objectName: "rows",
                            propertyName: "textSize"
                        },
                        height: {
                            objectName: "rows",
                            propertyName: "height"
                        },
                        width: {
                            objectName: "rows",
                            propertyName: "width"
                        },
                        background: {
                            objectName: "rows",
                            propertyName: "background"
                        },
                        transparency: {
                            objectName: "rows",
                            propertyName: "transparency"
                        },
                        selectedColor: {
                            objectName: "rows",
                            propertyName: "selectedColor"
                        },
                        hoverColor: {
                            objectName: "rows",
                            propertyName: "hoverColor"
                        },
                        unselectedColor: {
                            objectName: "rows",
                            propertyName: "unselectedColor"
                        },
                        disabledColor: {
                            objectName: "rows",
                            propertyName: "disabledColor"
                        },
                        outline: {
                            objectName: "rows",
                            propertyName: "outline"
                        },
                        outlineColor: {
                            objectName: "rows",
                            propertyName: "outlineColor"
                        },
                        outlineWeight: {
                            objectName: "rows",
                            propertyName: "outlineWeight"
                        },
                        borderStyle: {
                            objectName: "rows",
                            propertyName: "borderStyle"
                        }
                    },
                    images: {
                        imageSplit: {
                            objectName: "images",
                            propertyName: "imageSplit"
                        },
                        stretchImage: {
                            objectName: "images",
                            propertyName: "stretchImage"
                        },
                        bottomImage: {
                            objectName: "images",
                            propertyName: "bottomImage"
                        }
                    },
                    selectedPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "selected"
                    },
                    filterPropertyIdentifier: {
                        objectName: "general",
                        propertyName: "filter"
                    },
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    },
                    hasSavedSelection: !0
                };
                var ChicletBorderStyle;
                !function(ChicletBorderStyle) {
                    ChicletBorderStyle.ROUNDED = "Rounded", ChicletBorderStyle.CUT = "Cut", ChicletBorderStyle.SQUARE = "Square", 
                    ChicletBorderStyle.type = powerbi.createEnumType([ {
                        value: ChicletBorderStyle.ROUNDED,
                        displayName: ChicletBorderStyle.ROUNDED
                    }, {
                        value: ChicletBorderStyle.CUT,
                        displayName: ChicletBorderStyle.CUT
                    }, {
                        value: ChicletBorderStyle.SQUARE,
                        displayName: ChicletBorderStyle.SQUARE
                    } ]);
                }(ChicletBorderStyle || (ChicletBorderStyle = {}));
                var ChicletSlicerShowDisabled;
                !function(ChicletSlicerShowDisabled) {
                    ChicletSlicerShowDisabled.INPLACE = "Inplace", ChicletSlicerShowDisabled.BOTTOM = "Bottom", 
                    ChicletSlicerShowDisabled.HIDE = "Hide", ChicletSlicerShowDisabled.type = powerbi.createEnumType([ {
                        value: ChicletSlicerShowDisabled.INPLACE,
                        displayName: ChicletSlicerShowDisabled.INPLACE
                    }, {
                        value: ChicletSlicerShowDisabled.BOTTOM,
                        displayName: ChicletSlicerShowDisabled.BOTTOM
                    }, {
                        value: ChicletSlicerShowDisabled.HIDE,
                        displayName: ChicletSlicerShowDisabled.HIDE
                    } ]);
                }(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
                var Orientation;
                !function(Orientation) {
                    Orientation.HORIZONTAL = "Horizontal", Orientation.VERTICAL = "Vertical", Orientation.type = powerbi.createEnumType([ {
                        value: Orientation.HORIZONTAL,
                        displayName: Orientation.HORIZONTAL
                    }, {
                        value: Orientation.VERTICAL,
                        displayName: Orientation.VERTICAL
                    } ]);
                }(Orientation || (Orientation = {}));
                var ChicletSlicer = function() {
                    function ChicletSlicer(options) {
                        options && options.behavior && (this.behavior = options.behavior), this.behavior || (this.behavior = new ChicletSlicerWebBehavior());
                    }
                    return ChicletSlicer.DefaultStyleProperties = function() {
                        return {
                            general: {
                                orientation: Orientation.VERTICAL,
                                columns: 3,
                                rows: 0,
                                multiselect: !0,
                                showDisabled: ChicletSlicerShowDisabled.INPLACE,
                                selection: null
                            },
                            margin: {
                                top: 50,
                                bottom: 50,
                                right: 50,
                                left: 50
                            },
                            header: {
                                borderBottomWidth: 1,
                                show: !0,
                                outline: "BottomOnly",
                                fontColor: "#a6a6a6",
                                background: null,
                                textSize: 10,
                                outlineColor: "#a6a6a6",
                                outlineWeight: 1,
                                title: ""
                            },
                            headerText: {
                                marginLeft: 8,
                                marginTop: 0
                            },
                            slicerText: {
                                textSize: 10,
                                height: 0,
                                width: 0,
                                fontColor: "#666666",
                                hoverColor: "#212121",
                                selectedColor: "#BDD7EE",
                                unselectedColor: "#ffffff",
                                disabledColor: "grey",
                                marginLeft: 8,
                                outline: "Frame",
                                background: null,
                                transparency: 0,
                                outlineColor: "#000000",
                                outlineWeight: 1,
                                borderStyle: "Cut"
                            },
                            slicerItemContainer: {
                                marginTop: 5,
                                marginLeft: 0
                            },
                            images: {
                                imageSplit: 50,
                                stretchImage: !1,
                                bottomImage: !1
                            }
                        };
                    }, ChicletSlicer.converter = function(dataView, localizedSelectAllText, interactivityService) {
                        if (dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0) {
                            var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                            converter.convert();
                            var slicerData, defaultSettings = this.DefaultStyleProperties(), objects = dataView.metadata.objects;
                            objects && (defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation), 
                            defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns), 
                            defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows), 
                            defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect), 
                            defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled), 
                            defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection), 
                            defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show), 
                            defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title), 
                            defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor), 
                            defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background), 
                            defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize), 
                            defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline), 
                            defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor), 
                            defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight), 
                            defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize), 
                            defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height), 
                            defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width), 
                            defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor), 
                            defaultSettings.slicerText.hoverColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.hoverColor, defaultSettings.slicerText.hoverColor), 
                            defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor), 
                            defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor), 
                            defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background), 
                            defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency), 
                            defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor), 
                            defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline), 
                            defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor), 
                            defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight), 
                            defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle), 
                            defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit), 
                            defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage), 
                            defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage));
                            var categories = dataView.categorical.categories[0];
                            return slicerData = {
                                categorySourceName: categories.source.displayName,
                                formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                                slicerSettings: defaultSettings,
                                slicerDataPoints: converter.dataPoints
                            }, slicerData.hasSelectionOverride = converter.hasSelectionOverride, slicerData;
                        }
                    }, ChicletSlicer.prototype.init = function(options) {
                        this.element = options.element, this.currentViewport = options.viewport, this.behavior && (this.interactivityService = visuals.createInteractivityService(options.host)), 
                        this.hostServices = options.host, this.hostServices.canSelect = ChicletSlicer.canSelect, 
                        this.settings = ChicletSlicer.DefaultStyleProperties(), this.initContainer();
                    }, ChicletSlicer.canSelect = function(args) {
                        var selectors = args.data;
                        return !(selectors.length > 1 && selectors.some(function(value) {
                            return value && value.data && value.data.length > 1;
                        }));
                    }, ChicletSlicer.prototype.update = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.viewport) {
                            var existingDataView = this.dataView;
                            this.dataView = options.dataViews[0];
                            var resetScrollbarPosition = !0;
                            existingDataView && (resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView)), 
                            options.viewport.height === this.currentViewport.height && options.viewport.width === this.currentViewport.width ? this.waitingForData = !1 : this.currentViewport = options.viewport, 
                            this.updateInternal(resetScrollbarPosition);
                        }
                    }, ChicletSlicer.prototype.onResizing = function(finalViewport) {
                        this.currentViewport = finalViewport, this.updateInternal(!1);
                    }, ChicletSlicer.prototype.enumerateObjectInstances = function(options) {
                        var data = this.slicerData;
                        if (data) {
                            var objectName = options.objectName;
                            switch (objectName) {
                              case "rows":
                                return this.enumerateRows(data);

                              case "header":
                                return this.enumerateHeader(data);

                              case "general":
                                return this.enumerateGeneral(data);

                              case "images":
                                return this.enumerateImages(data);
                            }
                        }
                    }, ChicletSlicer.prototype.enumerateHeader = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "header",
                            properties: {
                                show: slicerSettings.header.show,
                                title: slicerSettings.header.title,
                                fontColor: slicerSettings.header.fontColor,
                                background: slicerSettings.header.background,
                                textSize: slicerSettings.header.textSize,
                                outline: slicerSettings.header.outline,
                                outlineColor: slicerSettings.header.outlineColor,
                                outlineWeight: slicerSettings.header.outlineWeight
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateRows = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "rows",
                            properties: {
                                textSize: slicerSettings.slicerText.textSize,
                                height: slicerSettings.slicerText.height,
                                width: slicerSettings.slicerText.width,
                                background: slicerSettings.slicerText.background,
                                transparency: slicerSettings.slicerText.transparency,
                                selectedColor: slicerSettings.slicerText.selectedColor,
                                hoverColor: slicerSettings.slicerText.hoverColor,
                                unselectedColor: slicerSettings.slicerText.unselectedColor,
                                disabledColor: slicerSettings.slicerText.disabledColor,
                                outline: slicerSettings.slicerText.outline,
                                outlineColor: slicerSettings.slicerText.outlineColor,
                                outlineWeight: slicerSettings.slicerText.outlineWeight,
                                fontColor: slicerSettings.slicerText.fontColor,
                                borderStyle: slicerSettings.slicerText.borderStyle
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateGeneral = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "general",
                            properties: {
                                orientation: slicerSettings.general.orientation,
                                columns: slicerSettings.general.columns,
                                rows: slicerSettings.general.rows,
                                showDisabled: slicerSettings.general.showDisabled,
                                multiselect: slicerSettings.general.multiselect
                            }
                        } ];
                    }, ChicletSlicer.prototype.enumerateImages = function(data) {
                        var slicerSettings = this.settings;
                        return [ {
                            selector: null,
                            objectName: "images",
                            properties: {
                                imageSplit: slicerSettings.images.imageSplit,
                                stretchImage: slicerSettings.images.stretchImage,
                                bottomImage: slicerSettings.images.bottomImage
                            }
                        } ];
                    }, ChicletSlicer.prototype.updateInternal = function(resetScrollbarPosition) {
                        var _this = this;
                        this.updateSlicerBodyDimensions();
                        var localizedSelectAllText = "Select All", data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);
                        if (!data) return void this.tableView.empty();
                        this.interactivityService && this.interactivityService.applySelectionStateToData(data.slicerDataPoints), 
                        data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight, 
                        data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight, 
                        data.slicerSettings.general.getSavedSelection = function() {
                            try {
                                return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
                            } catch (ex) {
                                return [];
                            }
                        }, data.slicerSettings.general.setSavedSelection = function(selectionIds) {
                            _this.isSelectionSaved = !0, _this.hostServices.persistProperties({
                                merge: [ {
                                    objectName: "general",
                                    selector: null,
                                    properties: {
                                        selection: selectionIds && JSON.stringify(selectionIds) || ""
                                    }
                                } ]
                            });
                        }, this.slicerData ? this.isSelectionSaved ? this.isSelectionLoaded = !0 : this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection : this.isSelectionLoaded = !1, 
                        this.slicerData = data, this.settings = this.slicerData.slicerSettings, this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM ? data.slicerDataPoints.sort(function(a, b) {
                            return a.selectable === b.selectable ? 0 : a.selectable && !b.selectable ? -1 : 1;
                        }) : this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE && (data.slicerDataPoints = data.slicerDataPoints.filter(function(x) {
                            return x.selectable;
                        }));
                        var height = this.settings.slicerText.height;
                        if (0 === height) {
                            var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders, textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                            height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
                            var hasImage = _.any(data.slicerDataPoints, function(x) {
                                return "" !== x.imageURL && "undefined" != typeof x.imageURL;
                            });
                            hasImage && (height += 100);
                        }
                        this.tableView.rowHeight(height).columnWidth(this.settings.slicerText.width).orientation(this.settings.general.orientation).rows(this.settings.general.rows).columns(this.settings.general.columns).data(data.slicerDataPoints, function(d) {
                            return $.inArray(d, data.slicerDataPoints);
                        }, resetScrollbarPosition).viewport(this.getSlicerBodyViewport(this.currentViewport)).render();
                    }, ChicletSlicer.prototype.initContainer = function() {
                        var _this = this, settings = this.settings, slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport), slicerContainer = d3.select(this.element.get(0)).append("div").classed(ChicletSlicer.Container["class"], !0);
                        this.slicerHeader = slicerContainer.append("div").classed(ChicletSlicer.Header["class"], !0), 
                        this.slicerHeader.append("span").classed(ChicletSlicer.Clear["class"], !0).attr("title", "Clear"), 
                        this.slicerHeader.append("div").classed(ChicletSlicer.HeaderText["class"], !0).style({
                            "margin-left": PixelConverter.toString(settings.headerText.marginLeft),
                            "margin-top": PixelConverter.toString(settings.headerText.marginTop),
                            "border-style": this.getBorderStyle(settings.header.outline),
                            "border-color": settings.header.outlineColor,
                            "border-width": this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                            "font-size": PixelConverter.fromPoint(settings.header.textSize)
                        }), this.slicerBody = slicerContainer.append("div").classed(ChicletSlicer.Body["class"], !0).classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL).style({
                            height: PixelConverter.toString(slicerBodyViewport.height),
                            width: "100%"
                        });
                        var rowEnter = function(rowSelection) {
                            var settings = _this.settings, listItemElement = rowSelection.append("li").classed(ChicletSlicer.ItemContainer["class"], !0).style({
                                "margin-left": PixelConverter.toString(settings.slicerItemContainer.marginLeft)
                            });
                            listItemElement.append("div").classed("slicer-img-wrapper", !0), listItemElement.append("div").classed("slicer-text-wrapper", !0).append("span").classed(ChicletSlicer.LabelText["class"], !0).style({
                                "font-size": PixelConverter.fromPoint(settings.slicerText.textSize)
                            });
                        }, rowUpdate = function(rowSelection) {
                            var settings = _this.settings, data = _this.slicerData;
                            if (data && settings) {
                                _this.slicerHeader.classed("hidden", !settings.header.show), _this.slicerHeader.select(ChicletSlicer.HeaderText.selector).text("" !== settings.header.title.trim() ? settings.header.title.trim() : _this.slicerData.categorySourceName).style({
                                    "border-style": _this.getBorderStyle(settings.header.outline),
                                    "border-color": settings.header.outlineColor,
                                    "border-width": _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                    color: settings.header.fontColor,
                                    "background-color": settings.header.background,
                                    "font-size": PixelConverter.fromPoint(settings.header.textSize)
                                }), _this.slicerBody.classed("slicerBody-horizontal", settings.general.orientation === Orientation.HORIZONTAL).classed("slicerBody-vertical", settings.general.orientation === Orientation.VERTICAL);
                                var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector), textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize), formatString = data.formatString;
                                slicerText.text(function(d) {
                                    var text = visuals.valueFormatter.format(d.category, formatString);
                                    return textProperties.text = text, 0 === _this.settings.slicerText.width ? powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.currentViewport.width / _this.settings.general.columns - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight) : powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
                                });
                                var slicerImg = rowSelection.selectAll(".slicer-img-wrapper");
                                if (slicerImg.style("height", settings.images.imageSplit + "%").classed("hidden", function(d) {
                                    return d.imageURL ? settings.images.imageSplit < 10 ? !0 : void 0 : !0;
                                }).style("display", function(d) {
                                    return d.imageURL ? "flex" : "none";
                                }).classed("stretchImage", settings.images.stretchImage).classed("bottomImage", settings.images.bottomImage).style("background-image", function(d) {
                                    return d.imageURL ? "url(" + d.imageURL + ")" : "";
                                }), rowSelection.selectAll(".slicer-text-wrapper").style("height", function(d) {
                                    return d.imageURL ? 100 - settings.images.imageSplit + "%" : "100%";
                                }).classed("hidden", function(d) {
                                    return settings.images.imageSplit > 90 ? !0 : void 0;
                                }), rowSelection.selectAll(".slicerItemContainer").style({
                                    color: settings.slicerText.fontColor,
                                    "border-style": _this.getBorderStyle(settings.slicerText.outline),
                                    "border-color": settings.slicerText.outlineColor,
                                    "border-width": _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                    "font-size": PixelConverter.fromPoint(settings.slicerText.textSize),
                                    "border-radius": _this.getBorderRadius(settings.slicerText.borderStyle)
                                }), settings.slicerText.background ? _this.slicerBody.style("background-color", explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100)) : _this.slicerBody.style("background-color", null), 
                                _this.interactivityService && _this.slicerBody) {
                                    var slicerBody = _this.slicerBody.attr("width", _this.currentViewport.width), slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector), slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector), slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector), slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector), behaviorOptions = {
                                        dataPoints: data.slicerDataPoints,
                                        slicerItemContainers: slicerItemContainers,
                                        slicerItemLabels: slicerItemLabels,
                                        slicerItemInputs: slicerItemInputs,
                                        slicerClear: slicerClear,
                                        interactivityService: _this.interactivityService,
                                        slicerSettings: data.slicerSettings,
                                        isSelectionLoaded: _this.isSelectionLoaded
                                    };
                                    _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
                                        overrideSelectionFromData: !0,
                                        hasSelectionOverride: data.hasSelectionOverride
                                    }), _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
                                } else _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), !1);
                            }
                        }, rowExit = function(rowSelection) {
                            rowSelection.remove();
                        }, tableViewOptions = {
                            rowHeight: this.getRowHeight(),
                            columnWidth: this.settings.slicerText.width,
                            orientation: this.settings.general.orientation,
                            rows: this.settings.general.rows,
                            columns: this.settings.general.columns,
                            enter: rowEnter,
                            exit: rowExit,
                            update: rowUpdate,
                            loadMoreData: function() {
                                return _this.onLoadMoreData();
                            },
                            scrollEnabled: !0,
                            viewport: this.getSlicerBodyViewport(this.currentViewport),
                            baseContainer: this.slicerBody
                        };
                        this.tableView = TableViewFactory.createTableView(tableViewOptions);
                    }, ChicletSlicer.prototype.onLoadMoreData = function() {
                        !this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment && (this.hostServices.loadMoreData(), 
                        this.waitingForData = !0);
                    }, ChicletSlicer.prototype.getSlicerBodyViewport = function(currentViewport) {
                        var settings = this.settings, headerHeight = settings.header.show ? this.getHeaderHeight() : 0, slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                        return {
                            height: slicerBodyHeight,
                            width: currentViewport.width
                        };
                    }, ChicletSlicer.prototype.updateSlicerBodyDimensions = function() {
                        var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                        this.slicerBody.style({
                            height: PixelConverter.toString(slicerViewport.height),
                            width: "100%"
                        });
                    }, ChicletSlicer.getChicletTextProperties = function(textSize) {
                        return {
                            fontFamily: ChicletSlicer.DefaultFontFamily,
                            fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt)
                        };
                    }, ChicletSlicer.prototype.getHeaderHeight = function() {
                        return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                    }, ChicletSlicer.prototype.getRowHeight = function() {
                        var textSettings = this.settings.slicerText;
                        return 0 !== textSettings.height ? textSettings.height : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                    }, ChicletSlicer.prototype.getBorderStyle = function(outlineElement) {
                        return "0px" === outlineElement ? "none" : "solid";
                    }, ChicletSlicer.prototype.getBorderWidth = function(outlineElement, outlineWeight) {
                        switch (outlineElement) {
                          case "None":
                            return "0px";

                          case "BottomOnly":
                            return "0px 0px " + outlineWeight + "px 0px";

                          case "TopOnly":
                            return outlineWeight + "px 0px 0px 0px";

                          case "TopBottom":
                            return outlineWeight + "px 0px " + outlineWeight + "px 0px";

                          case "LeftRight":
                            return "0px " + outlineWeight + "px 0px " + outlineWeight + "px";

                          case "Frame":
                            return outlineWeight + "px";

                          default:
                            return outlineElement.replace("1", outlineWeight.toString());
                        }
                    }, ChicletSlicer.prototype.getBorderRadius = function(borderType) {
                        switch (borderType) {
                          case ChicletBorderStyle.ROUNDED:
                            return "10px";

                          case ChicletBorderStyle.SQUARE:
                            return "0px";

                          default:
                            return "5px";
                        }
                    }, ChicletSlicer.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        }, {
                            name: "Image",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Image"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    selection: {
                                        displayName: "Selection",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    orientation: {
                                        displayName: "Orientation",
                                        type: {
                                            enumeration: Orientation.type
                                        }
                                    },
                                    columns: {
                                        displayName: "Columns",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    rows: {
                                        displayName: "Rows",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showDisabled: {
                                        displayName: "Show Disabled",
                                        type: {
                                            enumeration: ChicletSlicerShowDisabled.type
                                        }
                                    },
                                    multiselect: {
                                        displayName: "Multiple selection",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        }
                                    },
                                    selfFilter: {
                                        type: {
                                            filter: {
                                                selfFilter: !0
                                            }
                                        }
                                    },
                                    selfFilterEnabled: {
                                        type: {
                                            operations: {
                                                searchEnabled: !0
                                            }
                                        }
                                    },
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            header: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Header"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_FontColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outline: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            rows: {
                                displayName: "Chiclets",
                                properties: {
                                    fontColor: {
                                        displayName: "Text color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    height: {
                                        displayName: "Height",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    selectedColor: {
                                        displayName: "Selected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    hoverColor: {
                                        displayName: "Hover Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    unselectedColor: {
                                        displayName: "Unselected Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    disabledColor: {
                                        displayName: "Disabled Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    background: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Background"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    transparency: {
                                        displayName: "Transparency",
                                        description: "Set transparency for background color",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    outline: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            formatting: {
                                                outline: !0
                                            }
                                        }
                                    },
                                    outlineColor: {
                                        displayName: "Outline Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    outlineWeight: {
                                        displayName: "Outline Weight",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    borderStyle: {
                                        displayName: "Outline Style",
                                        type: {
                                            enumeration: ChicletBorderStyle.type
                                        }
                                    }
                                }
                            },
                            images: {
                                displayName: "Images",
                                properties: {
                                    imageSplit: {
                                        displayName: "Image Split",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    stretchImage: {
                                        displayName: "Stretch image",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    bottomImage: {
                                        displayName: "Bottom image",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Image: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {
                                            count: 1e4
                                        }
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Image",
                                        select: [ {
                                            bind: {
                                                to: "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {
                                                count: 1e4
                                            }
                                        }
                                    }
                                },
                                includeEmptyGroups: !0
                            }
                        } ],
                        supportsHighlight: !0,
                        sorting: {
                            "default": {}
                        },
                        suppressDefaultTitle: !0
                    }, ChicletSlicer.DefaultFontFamily = "Segoe UI, Tahoma, Verdana, Geneva, sans-serif", 
                    ChicletSlicer.DefaultFontSizeInPt = 11, ChicletSlicer.cellTotalInnerPaddings = 8, 
                    ChicletSlicer.cellTotalInnerBorders = 2, ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14, 
                    ChicletSlicer.ItemContainer = createClassAndSelector("slicerItemContainer"), ChicletSlicer.HeaderText = createClassAndSelector("headerText"), 
                    ChicletSlicer.Container = createClassAndSelector("chicletSlicer"), ChicletSlicer.LabelText = createClassAndSelector("slicerText"), 
                    ChicletSlicer.Header = createClassAndSelector("slicerHeader"), ChicletSlicer.Input = createClassAndSelector("slicerCheckbox"), 
                    ChicletSlicer.Clear = createClassAndSelector("clear"), ChicletSlicer.Body = createClassAndSelector("slicerBody"), 
                    ChicletSlicer;
                }();
                samples.ChicletSlicer = ChicletSlicer;
                var ChicletSlicerChartConversion;
                !function(ChicletSlicerChartConversion) {
                    var ChicletSlicerConverter = function() {
                        function ChicletSlicerConverter(dataView, interactivityService) {
                            var dataViewCategorical = dataView.categorical;
                            this.dataViewCategorical = dataViewCategorical, this.dataViewMetadata = dataView.metadata, 
                            dataViewCategorical.categories && dataViewCategorical.categories.length > 0 && (this.category = dataViewCategorical.categories[0], 
                            this.categoryIdentities = this.category.identity, this.categoryValues = this.category.values, 
                            this.categoryColumnRef = this.category.identityFields, this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString)), 
                            this.dataPoints = [], this.interactivityService = interactivityService, this.hasSelectionOverride = !1;
                        }
                        return ChicletSlicerConverter.prototype.convert = function() {
                            if (this.dataPoints = [], this.numberOfCategoriesSelectedInData = 0, this.categoryValues) {
                                var numberOfScopeIds, objects = this.dataViewMetadata ? this.dataViewMetadata.objects : void 0, isInvertedSelectionMode = void 0;
                                if (objects && objects.general && objects.general.filter) {
                                    if (!this.categoryColumnRef) return;
                                    var filter = objects.general.filter, scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                    scopeIds ? (isInvertedSelectionMode = scopeIds.isNot, numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0) : isInvertedSelectionMode = !1;
                                }
                                this.interactivityService && (void 0 === isInvertedSelectionMode ? isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted() : this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode));
                                for (var hasSelection = void 0, idx = 0; idx < this.categoryValues.length; idx++) {
                                    var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                    if (null != selected) {
                                        hasSelection = selected;
                                        break;
                                    }
                                }
                                for (var dataViewCategorical = this.dataViewCategorical, formatStringProp = samples.chicletSlicerProps.formatString, value = -(1 / 0), imageURL = "", categoryIndex = 0, categoryCount = this.categoryValues.length; categoryCount > categoryIndex; categoryIndex++) {
                                    var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null, categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex), selectable = !0;
                                    null != hasSelection && (isInvertedSelectionMode ? (null == this.category.objects && (categoryIsSelected = void 0), 
                                    null != categoryIsSelected ? categoryIsSelected = hasSelection : null == categoryIsSelected && (categoryIsSelected = !hasSelection)) : null == categoryIsSelected && (categoryIsSelected = !hasSelection)), 
                                    categoryIsSelected && this.numberOfCategoriesSelectedInData++;
                                    var categoryValue = this.categoryValues[categoryIndex], categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                                    if (this.dataViewCategorical.values) for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                        var seriesData = dataViewCategorical.values[seriesIndex];
                                        null != seriesData.values[categoryIndex] && (value = seriesData.values[categoryIndex], 
                                        seriesData.highlights && (selectable = !(null === seriesData.highlights[categoryIndex])), 
                                        seriesData.source.groupName && "" !== seriesData.source.groupName && (imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp), 
                                        /^(ftp|http|https):\/\/[^ "]+$/.test(imageURL) || (imageURL = void 0)));
                                    }
                                    this.dataPoints.push({
                                        identity: visuals.SelectionId.createWithId(categoryIdentity),
                                        category: categoryLabel,
                                        imageURL: imageURL,
                                        value: value,
                                        selected: categoryIsSelected,
                                        selectable: selectable
                                    });
                                }
                                null != numberOfScopeIds && numberOfScopeIds > this.numberOfCategoriesSelectedInData && (this.hasSelectionOverride = !0);
                            }
                        }, ChicletSlicerConverter;
                    }();
                    ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
                }(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
                var ChicletSlicerTextMeasurementHelper;
                !function(ChicletSlicerTextMeasurementHelper) {
                    function estimateSvgTextBaselineDelta(textProperties) {
                        var rect = estimateSvgTextRect(textProperties);
                        return rect.y + rect.height;
                    }
                    function ensureDOM() {
                        spanElement || (spanElement = $("<span/>"), $("body").append(spanElement), svgTextElement = d3.select($("body").get(0)).append("svg").style({
                            height: "0px",
                            width: "0px",
                            position: "absolute"
                        }).append("text"), canvasCtx = $("<canvas/>").get(0).getContext("2d"));
                    }
                    function measureSvgTextRect(textProperties) {
                        return ensureDOM(), svgTextElement.style(null), svgTextElement.text(textProperties.text).attr({
                            visibility: "hidden",
                            "font-family": textProperties.fontFamily,
                            "font-size": textProperties.fontSize,
                            "font-weight": textProperties.fontWeight,
                            "font-style": textProperties.fontStyle,
                            "white-space": textProperties.whiteSpace || "nowrap"
                        }), svgTextElement.node().getBBox();
                    }
                    function estimateSvgTextRect(textProperties) {
                        var estimatedTextProperties = {
                            fontFamily: textProperties.fontFamily,
                            fontSize: textProperties.fontSize,
                            text: "M"
                        }, rect = measureSvgTextRect(estimatedTextProperties);
                        return rect;
                    }
                    var spanElement, svgTextElement, canvasCtx;
                    ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                }(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
                var ChicletSlicerWebBehavior = function() {
                    function ChicletSlicerWebBehavior() {}
                    return ChicletSlicerWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var _this = this, filterPropertyId = samples.chicletSlicerProps.filterPropertyIdentifier, slicers = this.slicers = options.slicerItemContainers;
                        this.slicerItemLabels = options.slicerItemLabels, this.slicerItemInputs = options.slicerItemInputs;
                        var slicerClear = options.slicerClear;
                        this.dataPoints = options.dataPoints, this.interactivityService = options.interactivityService, 
                        this.slicerSettings = options.slicerSettings, this.options = options, this.options.isSelectionLoaded || this.loadSelection(selectionHandler), 
                        slicers.on("mouseover", function(d) {
                            d.selectable && (d.mouseOver = !0, d.mouseOut = !1, _this.renderMouseover());
                        }), slicers.on("mouseout", function(d) {
                            d.selectable && (d.mouseOver = !1, d.mouseOut = !0, _this.renderMouseover());
                        }), slicers.on("click", function(d, index) {
                            if (d.selectable) {
                                var settings = _this.slicerSettings;
                                if (d3.event.preventDefault(), d3.event.altKey && settings.general.multiselect) {
                                    var selectedIndexes = jQuery.map(_this.dataPoints, function(d, index) {
                                        return d.selected ? index : void 0;
                                    }), selIndex = selectedIndexes.length > 0 ? selectedIndexes[selectedIndexes.length - 1] : 0;
                                    if (selIndex > index) {
                                        var temp = index;
                                        index = selIndex, selIndex = temp;
                                    }
                                    selectionHandler.handleClearSelection();
                                    for (var i = selIndex; index >= i; i++) selectionHandler.handleSelection(_this.dataPoints[i], !0);
                                } else d3.event.ctrlKey && settings.general.multiselect ? selectionHandler.handleSelection(d, !0) : selectionHandler.handleSelection(d, !1);
                                selectionHandler.persistSelectionFilter(filterPropertyId), _this.saveSelection(selectionHandler);
                            }
                        }), slicerClear.on("click", function(d) {
                            selectionHandler.handleClearSelection(), selectionHandler.persistSelectionFilter(filterPropertyId), 
                            _this.saveSelection(selectionHandler);
                        });
                    }, ChicletSlicerWebBehavior.prototype.loadSelection = function(selectionHandler) {
                        selectionHandler.handleClearSelection();
                        var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
                        if (savedSelectionIds.length) {
                            var selectedDataPoints = this.dataPoints.filter(function(d) {
                                return savedSelectionIds.some(function(x) {
                                    return d.identity.getKey() === x;
                                });
                            });
                            selectedDataPoints.forEach(function(x) {
                                return selectionHandler.handleSelection(x, !0);
                            }), selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
                        }
                    }, ChicletSlicerWebBehavior.prototype.saveSelection = function(selectionHandler) {
                        var selectionIdKeys = selectionHandler.selectedIds.map(function(x) {
                            return x.getKey();
                        });
                        this.slicerSettings.general.setSavedSelection(selectionIdKeys);
                    }, ChicletSlicerWebBehavior.prototype.renderSelection = function(hasSelection) {
                        hasSelection || this.interactivityService.isSelectionModeInverted() ? this.styleSlicerInputs(this.slicers, hasSelection) : this.slicers.style("background", this.slicerSettings.slicerText.unselectedColor);
                    }, ChicletSlicerWebBehavior.prototype.renderMouseover = function() {
                        var _this = this;
                        this.slicerItemLabels.style({
                            color: function(d) {
                                return d.mouseOver ? _this.slicerSettings.slicerText.hoverColor : d.mouseOut ? d.selected ? _this.slicerSettings.slicerText.fontColor : _this.slicerSettings.slicerText.fontColor : void 0;
                            }
                        });
                    }, ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function(slicers, hasSelection) {
                        var settings = this.slicerSettings, selectedItems = [];
                        slicers.each(function(d) {
                            d.selectable && d.selected && selectedItems.push(d), d3.select(this).style({
                                background: d.selectable ? d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor : settings.slicerText.disabledColor
                            }), d3.select(this).classed("slicerItem-disabled", !d.selectable);
                        });
                    }, ChicletSlicerWebBehavior;
                }();
                samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
                var explore;
                !function(explore) {
                    var util;
                    !function(util) {
                        function hexToRGBString(hex, transparency) {
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function(m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex), rgb = result ? {
                                r: parseInt(result[1], 16),
                                g: parseInt(result[2], 16),
                                b: parseInt(result[3], 16)
                            } : null;
                            return null === rgb ? "" : transparency || 0 === transparency ? "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")" : "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        }
                        util.hexToRGBString = hexToRGBString;
                    }(util = explore.util || (explore.util = {}));
                }(explore || (explore = {}));
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ChordChart = function() {
                    function ChordChart() {}
                    return ChordChart.converter = function(dataView, colors, prevAxisVisible) {
                        var catDv = dataView.categorical, defaultDataPointColor = ChordChart.getDefaultDataPointColor(dataView).solid.color, labelColor = ChordChart.getLabelsColor(dataView), labelFontSize = ChordChart.getLabelsFontSize(dataView);
                        if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {
                            for (var cat = catDv.categories[0], catValues = cat.values, values = catDv.values, dataMatrix = [], legendData = {
                                dataPoints: [],
                                title: values[0] && values[0].source ? values[0].source.displayName : ""
                            }, toolTipData = [], sliceTooltipData = [], max = 1e3, seriesName = [], seriesIndex = [], catIndex = [], isDiffFromTo = !1, labelData = [], colorHelper = new visuals.ColorHelper(colors, ChordChart.chordChartProps.dataPoint.fill, defaultDataPointColor), i = 0, iLen = catValues.length; iLen > i; i++) catIndex[catValues[i]] = i;
                            for (var i = 0, iLen = values.length; iLen > i; i++) {
                                var seriesNameStr = visuals.converterHelper.getSeriesName(values[i].source);
                                seriesName.push(seriesNameStr), seriesIndex[seriesNameStr] = i;
                            }
                            var totalFields = this.union_arrays(catValues, seriesName);
                            ChordChart.getValidArrayLength(totalFields) === ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName) && (isDiffFromTo = !0);
                            for (var formatStringProp = ChordChart.chordChartProps.general.formatString, categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, formatStringProp), i = 0, iLen = totalFields.length; iLen > i; i++) {
                                var id = null, color = "", isCategory = !1;
                                if (void 0 !== catIndex[totalFields[i]]) {
                                    var index = catIndex[totalFields[i]];
                                    id = visuals.SelectionIdBuilder.builder().withCategory(cat, catIndex[totalFields[i]]).createSelectionId(), 
                                    isCategory = !0;
                                    var thisCategoryObjects = cat.objects ? cat.objects[index] : void 0;
                                    color = colorHelper.getColorForSeriesValue(thisCategoryObjects, void 0, catValues[index]);
                                } else if (void 0 !== seriesIndex[totalFields[i]]) {
                                    var index = seriesIndex[totalFields[i]], seriesData = values[index], seriesObjects = seriesData && seriesData.objects && seriesData.objects[0], seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);
                                    id = visuals.SelectionId.createWithId(seriesData.identity), isCategory = !1, color = colorHelper.getColorForSeriesValue(seriesObjects, void 0, seriesNameStr);
                                }
                                labelData.push({
                                    label: totalFields[i],
                                    labelColor: labelColor,
                                    barColor: color,
                                    isCategory: isCategory,
                                    identity: id,
                                    selected: !1
                                }), dataMatrix.push([]), toolTipData.push([]);
                                for (var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString), j = 0, jLen = totalFields.length; jLen > j; j++) {
                                    var elementValue = 0, tooltipInfo = [];
                                    if (void 0 !== catIndex[totalFields[i]] && void 0 !== seriesIndex[totalFields[j]]) {
                                        var row = catIndex[totalFields[i]], col = seriesIndex[totalFields[j]];
                                        null !== values[col].values[row] && (elementValue = values[col].values[row], elementValue > max && (max = elementValue), 
                                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, elementValue, null, null, col, row));
                                    } else if (isDiffFromTo && void 0 !== catIndex[totalFields[j]] && void 0 !== seriesIndex[totalFields[i]]) {
                                        var row = catIndex[totalFields[j]], col = seriesIndex[totalFields[i]];
                                        null !== values[col].values[row] && (elementValue = values[col].values[row]);
                                    }
                                    dataMatrix[i].push(elementValue), toolTipData[i].push({
                                        tooltipInfo: tooltipInfo
                                    });
                                }
                                var totalSum = d3.sum(dataMatrix[i]);
                                sliceTooltipData.push({
                                    tooltipInfo: [ {
                                        displayName: totalFields[i],
                                        value: ChordChart.isInt(totalSum) ? totalSum.toFixed(0) : totalSum.toFixed(2)
                                    } ]
                                });
                            }
                            var chordLayout = d3.layout.chord().padding(.1).matrix(dataMatrix), unitLength = Math.round(max / 5).toString().length - 1;
                            return {
                                dataMatrix: dataMatrix,
                                labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),
                                legendData: legendData,
                                tooltipData: toolTipData,
                                sliceTooltipData: sliceTooltipData,
                                tickUnit: Math.pow(10, unitLength),
                                differentFromTo: isDiffFromTo,
                                defaultDataPointColor: defaultDataPointColor,
                                prevAxisVisible: prevAxisVisible,
                                showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                                showLabels: ChordChart.getLabelsShow(dataView),
                                showAxis: ChordChart.getAxisShow(dataView),
                                labelFontSize: labelFontSize
                            };
                        }
                        return {
                            dataMatrix: [],
                            labelDataPoints: [],
                            legendData: null,
                            tooltipData: [],
                            sliceTooltipData: [],
                            tickUnit: 1e3,
                            differentFromTo: !1,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize
                        };
                    }, ChordChart.getValidArrayLength = function(array) {
                        for (var len = 0, i = 0, iLen = array.length; iLen > i; i++) void 0 !== array[i] && len++;
                        return len;
                    }, ChordChart.convertToChordArcDescriptor = function(groups, datum) {
                        for (var labelDataPoints = [], i = 0, iLen = groups.length; iLen > i; i++) {
                            var labelDataPoint = groups[i];
                            labelDataPoint.data = datum[i], labelDataPoints.push(labelDataPoint);
                        }
                        return labelDataPoints;
                    }, ChordChart.prototype.calculateRadius = function(viewport) {
                        if (this.data && this.data.showLabels) {
                            var hw = viewport.height / viewport.width, denom = 2 + 1 / (1 + Math.exp(-5 * (hw - 1)));
                            return Math.min(viewport.height, viewport.width) / denom;
                        }
                        return Math.min(viewport.height, viewport.width) / 2;
                    }, ChordChart.drawDefaultCategoryLabels = function(graphicsContext, chordData, radius, viewport) {
                        var arc = d3.svg.arc().innerRadius(0).outerRadius(radius * ChordChart.InnerArcRadiusRatio), outerArc = d3.svg.arc().innerRadius(radius * ChordChart.OuterArcRadiusRatio).outerRadius(radius * ChordChart.OuterArcRadiusRatio);
                        if (chordData.showLabels) {
                            var labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);
                            ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints, graphicsContext, labelLayout, viewport, radius, arc, outerArc);
                        } else visuals.dataLabelUtils.cleanDataLabels(graphicsContext, !0);
                    }, ChordChart.prototype.init = function(options) {
                        var element = this.element = options.element;
                        this.selectionManager = new visuals.utility.SelectionManager({
                            hostServices: options.host
                        }), this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(ChordChart.VisualClassName, !0), 
                        this.mainGraphicsContext = this.svg.append("g"), this.mainGraphicsContext.append("g").classed("slices", !0), 
                        this.mainGraphicsContext.append("g").classed("ticks", !0), this.mainGraphicsContext.append("g").classed("chords", !0), 
                        this.colors = options.style.colorPalette.dataColors;
                    }, ChordChart.prototype.update = function(options) {
                        var _this = this;
                        if (options.dataViews && options.dataViews[0]) {
                            var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration, dataView = this.dataView = options.dataViews[0], prevAxisShow = this.data ? this.data.showAxis : !ChordChart.getAxisShow(dataView), data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow), viewport = options.viewport, chordLayout = this.chordLayout = d3.layout.chord().padding(.1).matrix(data.dataMatrix), width = viewport.width, height = viewport.height, radius = this.calculateRadius(viewport), sm = this.selectionManager, innerRadius = radius, outerRadius = radius * ChordChart.InnerArcRadiusRatio, arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                            this.svg.attr({
                                width: width,
                                height: height
                            });
                            var mainGraphicsContext = this.mainGraphicsContext.attr("transform", visuals.SVGUtil.translate(width / 2, height / 2)), sliceShapes = this.svg.select(".slices").selectAll("path" + ChordChart.sliceClass.selector).data(chordLayout.groups);
                            sliceShapes.enter().insert("path").classed(ChordChart.sliceClass["class"], !0), 
                            sliceShapes.style("fill", function(d, i) {
                                return data.labelDataPoints[i].data.barColor;
                            }).style("stroke", function(d, i) {
                                return data.labelDataPoints[i].data.barColor;
                            }).on("click", function(d, i) {
                                var _this = this;
                                sm.select(data.labelDataPoints[i].data.identity).then(function(ids) {
                                    ids.length > 0 ? (mainGraphicsContext.selectAll(".chords path.chord").style("opacity", 1), 
                                    mainGraphicsContext.selectAll(".slices path.slice").style("opacity", .3), mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                        return d.source.index !== i && d.target.index !== i;
                                    }).style("opacity", .3), d3.select(_this).style("opacity", 1)) : (sliceShapes.style("opacity", 1), 
                                    mainGraphicsContext.selectAll(".chords path.chord").filter(function(d) {
                                        return d.source.index !== i && d.target.index !== i;
                                    }).style("opacity", 1));
                                }), d3.event.stopPropagation();
                            }).transition().duration(duration).attr("d", arc), sliceShapes.exit().remove(), 
                            visuals.TooltipManager.addTooltip(sliceShapes, function(tooltipEvent) {
                                return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                            });
                            var chordShapes = this.svg.select(".chords").selectAll("path" + ChordChart.chordClass.selector).data(chordLayout.chords);
                            chordShapes.enter().insert("path").classed(ChordChart.chordClass["class"], !0), 
                            chordShapes.style("fill", function(d, i) {
                                return data.labelDataPoints[d.target.index].data.barColor;
                            }).style("opacity", 1).transition().duration(duration).attr("d", d3.svg.chord().radius(innerRadius)), 
                            chordShapes.exit().remove(), this.svg.on("click", function() {
                                return _this.selectionManager.clear().then(function() {
                                    sliceShapes.style("opacity", 1), chordShapes.style("opacity", 1);
                                });
                            }), ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport), 
                            ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport), 
                            visuals.TooltipManager.addTooltip(chordShapes, function(tooltipEvent) {
                                var tooltipInfo = [];
                                return data.differentFromTo ? tooltipInfo = data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].tooltipInfo : (tooltipInfo.push({
                                    displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label + "->" + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                    value: data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                                }), tooltipInfo.push({
                                    displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label + "->" + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                    value: data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                                })), tooltipInfo;
                            });
                        }
                    }, ChordChart.prototype.destroy = function() {}, ChordChart.cleanTicks = function(context) {
                        var empty = [], tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);
                        tickLines.exit().remove();
                        var tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);
                        tickTexts.exit().remove(), context.selectAll(ChordChart.tickPairClass.selector).remove(), 
                        context.selectAll(ChordChart.sliceTicksClass.selector).remove();
                    }, ChordChart.drawTicks = function(graphicsContext, chordData, chordLayout, outerRadius, duration, viewport) {
                        if (chordData.showAxis) {
                            var tickShapes = graphicsContext.select(".ticks").selectAll("g" + ChordChart.sliceTicksClass.selector).data(chordLayout.groups), animDuration = chordData.prevAxisVisible === chordData.showAxis ? duration : 0;
                            tickShapes.enter().insert("g").classed(ChordChart.sliceTicksClass["class"], !0);
                            var tickPairs = tickShapes.selectAll("g" + ChordChart.tickPairClass.selector).data(function(d) {
                                var k = (d.endAngle - d.startAngle) / d.value, range = d3.range(0, d.value, d.value - 1 < .15 ? .15 : d.value - 1), retval = range.map(function(v, i) {
                                    var divider = 1e3, unitStr = "k";
                                    chordData.tickUnit >= 1e6 ? (divider = 1e6, unitStr = "m") : chordData.tickUnit >= 1e3 ? (divider = 1e3, 
                                    unitStr = "k") : (divider = 1, unitStr = "");
                                    var retv = {
                                        angle: v * k + d.startAngle,
                                        label: Math.floor(v / divider) + unitStr
                                    };
                                    return retv;
                                });
                                return retval;
                            });
                            tickPairs.enter().insert("g").classed(ChordChart.tickPairClass["class"], !0), tickPairs.transition().duration(animDuration).attr("transform", function(d) {
                                return "rotate(" + (180 * d.angle / Math.PI - 90) + ")translate(" + outerRadius + ",0)";
                            }), tickPairs.selectAll("line" + ChordChart.tickLineClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("line").classed(ChordChart.tickLineClass["class"], !0).style("stroke", "#000").attr("x1", 1).attr("y1", 0).attr("x2", 5).attr("y2", 0), 
                            tickPairs.selectAll("text" + ChordChart.tickTextClass.selector).data(function(d) {
                                return [ d ];
                            }).enter().insert("text").classed(ChordChart.tickTextClass["class"], !0).style("text-anchor", function(d) {
                                return d.angle > Math.PI ? "end" : null;
                            }).text(function(d) {
                                return d.label;
                            }).attr("transform", function(d) {
                                return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
                            }).attr("x", 8).attr("dy", ".35em"), tickPairs.exit().remove(), tickShapes.exit().remove();
                        } else ChordChart.cleanTicks(graphicsContext);
                    }, ChordChart.getAxisShow = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var axis = objects.axis;
                                if (axis && axis.hasOwnProperty("show")) return axis.show;
                            }
                        }
                        return !0;
                    }, ChordChart.getLabelsShow = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var labels = objects.labels;
                                if (labels && labels.hasOwnProperty("show")) return labels.show;
                            }
                        }
                        return !0;
                    }, ChordChart.getLabelsColor = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var labels = objects.labels;
                                if (labels && labels.hasOwnProperty("color")) return labels.color.solid.color;
                            }
                        }
                        return ChordChart.DefaultLabelColor;
                    }, ChordChart.getLabelsFontSize = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var labels = objects.labels;
                                if (labels && labels.hasOwnProperty("fontSize")) return labels.fontSize;
                            }
                        }
                        return ChordChart.DefaultLabelsFontSize;
                    }, ChordChart.selectLabels = function(filteredData, context, isDonut, forAnimation) {
                        if (void 0 === isDonut && (isDonut = !1), void 0 === forAnimation && (forAnimation = !1), 
                        0 === filteredData.length) return visuals.dataLabelUtils.cleanDataLabels(context, !0), 
                        null;
                        context.select(ChordChart.labelGraphicsContextClass.selector).empty() && context.append("g").classed(ChordChart.labelGraphicsContextClass["class"], !0);
                        var hasKey = null !== filteredData[0].key, hasDataPointIdentity = null !== filteredData[0].identity, getIdentifier = hasKey ? function(d) {
                            return d.key;
                        } : hasDataPointIdentity ? function(d) {
                            return d.identity.getKey();
                        } : void 0, labels = isDonut ? context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, function(d) {
                            return d.data.identity.getKey();
                        }) : null !== getIdentifier ? context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier) : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData), newLabels = labels.enter().append("text").classed(ChordChart.labelsClass["class"], !0);
                        return forAnimation && newLabels.style("opacity", 0), labels;
                    }, ChordChart.drawDefaultLabelsForChordChart = function(data, context, layout, viewport, radius, arc, outerArc) {
                        var dataLabelManager = new powerbi.DataLabelManager(), filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, !0), labels = ChordChart.selectLabels(filteredData, context, !0);
                        if (labels) {
                            labels.attr({
                                x: function(d) {
                                    return d.labelX;
                                },
                                y: function(d) {
                                    return d.labelY;
                                },
                                dy: ".35em"
                            }).text(function(d) {
                                return d.labeltext;
                            }).style(layout.style), labels.exit().remove(), context.select(ChordChart.linesGraphicsContextClass.selector).empty() && context.append("g").classed(ChordChart.linesGraphicsContextClass["class"], !0);
                            var lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll("polyline").data(filteredData, function(d) {
                                return d.data.identity.getKey();
                            }), innerLinePointMultiplier = 2.05, midAngle = function(d) {
                                return d.startAngle + (d.endAngle - d.startAngle) / 2;
                            };
                            lines.enter().append("polyline").classed(ChordChart.lineClass["class"], !0), lines.attr("points", function(d) {
                                var textPoint = outerArc.centroid(d);
                                textPoint[0] = .95 * radius * (midAngle(d) < Math.PI ? 1 : -1);
                                var midPoint = outerArc.centroid(d), chartPoint = arc.centroid(d);
                                return chartPoint[0] *= innerLinePointMultiplier, chartPoint[1] *= innerLinePointMultiplier, 
                                [ chartPoint, midPoint, textPoint ];
                            }).style({
                                opacity: function(d) {
                                    return ChordChart.PolylineOpacity;
                                },
                                stroke: function(d) {
                                    return d.data.labelColor;
                                }
                            }), lines.exit().remove();
                        }
                    }, ChordChart.getChordChartLabelLayout = function(radius, outerArc, viewport, labelFontSize) {
                        var midAngle = function(d) {
                            return d.startAngle + (d.endAngle - d.startAngle) / 2;
                        }, spaceAvaliableForLabels = viewport.width / 2 - radius, minAvailableSpace = Math.min(spaceAvaliableForLabels, visuals.dataLabelUtils.maxLabelWidth), PixelConverter = jsCommon.PixelConverter;
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: d.data.label,
                                    maxWidth: minAvailableSpace,
                                    fontSize: labelFontSize
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return radius * (midAngle(d) < Math.PI ? 1 : -1);
                                },
                                y: function(d) {
                                    var pos = outerArc.centroid(d);
                                    return pos[1];
                                }
                            },
                            filter: function(d) {
                                return null !== d && null !== d.data && null !== d.data.label;
                            },
                            style: {
                                fill: function(d) {
                                    return d.data.labelColor;
                                },
                                "text-anchor": function(d) {
                                    return midAngle(d) < Math.PI ? "start" : "end";
                                },
                                "font-size": function(d) {
                                    return PixelConverter.fromPointToPixel(labelFontSize);
                                }
                            }
                        };
                    }, ChordChart.getDefaultDataPointColor = function(dataView, defaultValue) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var dataPoint = objects.dataPoint;
                                if (dataPoint && dataPoint.hasOwnProperty("defaultColor")) {
                                    var defaultColor = dataPoint.defaultColor;
                                    if (defaultColor) return defaultColor;
                                }
                            }
                        }
                        return {
                            solid: {
                                color: defaultValue
                            }
                        };
                    }, ChordChart.getShowAllDataPoints = function(dataView) {
                        if (!dataView || !dataView.metadata || !dataView.metadata.objects) return !1;
                        var objects = dataView.metadata.objects, dataPoint = objects.dataPoint;
                        return dataPoint && dataPoint.hasOwnProperty("showAllDataPoints") ? dataPoint.showAllDataPoints : !1;
                    }, ChordChart.prototype.enumerateObjectInstances = function(options) {
                        var axis, instances = [];
                        switch (options.objectName) {
                          case "axis":
                            axis = {
                                objectName: "axis",
                                displayName: "Axis",
                                selector: null,
                                properties: {
                                    show: ChordChart.getAxisShow(this.dataView)
                                }
                            }, instances.push(axis);
                            break;

                          case "labels":
                            axis = {
                                objectName: "labels",
                                displayName: "Labels",
                                selector: null,
                                properties: {
                                    show: ChordChart.getLabelsShow(this.dataView),
                                    color: ChordChart.getLabelsColor(this.dataView),
                                    fontSize: ChordChart.getLabelsFontSize(this.dataView)
                                }
                            }, instances.push(axis);
                            break;

                          case "dataPoint":
                            var defaultColor = {
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: {
                                            color: this.data && this.data.defaultDataPointColor ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value
                                        }
                                    }
                                }
                            };
                            instances.push(defaultColor);
                            var showAllDataPoints = {
                                objectName: "dataPoint",
                                selector: null,
                                properties: {
                                    showAllDataPoints: this.data ? !!this.data.showAllDataPoints : !1
                                }
                            };
                            if (instances.push(showAllDataPoints), this.data && this.data.labelDataPoints) for (var i = 0, iLen = this.data.labelDataPoints.length; iLen > i; i++) {
                                var labelDataPoint = this.data.labelDataPoints[i].data;
                                if (labelDataPoint.isCategory) {
                                    var colorInstance = {
                                        objectName: "dataPoint",
                                        displayName: labelDataPoint.label,
                                        selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: labelDataPoint.barColor
                                                }
                                            }
                                        }
                                    };
                                    instances.push(colorInstance);
                                }
                            }
                        }
                        return instances;
                    }, ChordChart.isInt = function(n) {
                        return n % 1 === 0;
                    }, ChordChart.union_arrays = function(x, y) {
                        for (var obj = {}, i = 0; i < x.length; i++) obj[x[i]] = x[i];
                        for (var i = 0; i < y.length; i++) obj[y[i]] = y[i];
                        var res = [];
                        for (var k in obj) obj.hasOwnProperty(k) && res.push(obj[k]);
                        return res;
                    }, ChordChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "From"
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "To"
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                Y: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    },
                                    supported: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            axis: {
                                displayName: "Axis",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color_Description"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, ChordChart.chordChartProps = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            defaultColor: {
                                objectName: "dataPoint",
                                propertyName: "defaultColor"
                            },
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            },
                            showAllDataPoints: {
                                objectName: "dataPoint",
                                propertyName: "showAllDataPoints"
                            }
                        },
                        axis: {
                            show: {
                                objectName: "axis",
                                propertyName: "show"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, ChordChart.PolylineOpacity = .5, ChordChart.OuterArcRadiusRatio = .9, ChordChart.InnerArcRadiusRatio = .8, 
                    ChordChart.DefaultLabelColor = "#777777", ChordChart.DefaultLabelsFontSize = 12, 
                    ChordChart.VisualClassName = "chordChart", ChordChart.sliceClass = {
                        "class": "slice",
                        selector: ".slice"
                    }, ChordChart.chordClass = {
                        "class": "chord",
                        selector: ".chord"
                    }, ChordChart.sliceTicksClass = {
                        "class": "slice-ticks",
                        selector: ".slice-ticks"
                    }, ChordChart.tickPairClass = {
                        "class": "tick-pair",
                        selector: ".tick-pair"
                    }, ChordChart.tickLineClass = {
                        "class": "tick-line",
                        selector: ".tick-line"
                    }, ChordChart.tickTextClass = {
                        "class": "tick-text",
                        selector: ".tick-text"
                    }, ChordChart.labelGraphicsContextClass = {
                        "class": "labels",
                        selector: ".labels"
                    }, ChordChart.labelsClass = {
                        "class": "data-labels",
                        selector: ".data-labels"
                    }, ChordChart.linesGraphicsContextClass = {
                        "class": "lines",
                        selector: ".lines"
                    }, ChordChart.lineClass = {
                        "class": "line-label",
                        selector: ".line-label"
                    }, ChordChart;
                }();
                samples.ChordChart = ChordChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var PixelConverter = jsCommon.PixelConverter, DataRoleHelper = powerbi.data.DataRoleHelper, EnhancedScatterChart = function() {
                    function EnhancedScatterChart() {
                        this.AxisGraphicsContextClassName = "axisGraphicsContext", this.ScrollBarWidth = 10, 
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: PixelConverter.toString(EnhancedScatterChart.AxisFontSize)
                        };
                    }
                    return Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                        get: function() {
                            return this._margin || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this._margin = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                        get: function() {
                            return this._viewport || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this._viewport = $.extend({}, value), this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                        get: function() {
                            return this._viewportIn || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                        get: function() {
                            return this.legend.getMargins();
                        },
                        enumerable: !0,
                        configurable: !0
                    }), EnhancedScatterChart.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, EnhancedScatterChart.getCustomSymbolType = function(shape) {
                        var customSymbolTypes = d3.map({
                            circle: function(size) {
                                var r = Math.sqrt(size / Math.PI);
                                return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                            },
                            cross: function(size) {
                                var r = Math.sqrt(size / 5) / 2;
                                return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                            },
                            diamond: function(size) {
                                var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                                return "M0," + -ry + "L" + rx + ",0 0," + ry + " " + -rx + ",0Z";
                            },
                            square: function(size) {
                                var r = Math.sqrt(size) / 2;
                                return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
                            },
                            "triangle-up": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                            },
                            "triangle-down": function(size) {
                                var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                                return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                            },
                            star: function(size) {
                                for (var outerRadius = Math.sqrt(size / 2), innerRadius = Math.sqrt(size / 10), results = "", angle = Math.PI / 5, i = 0; 10 > i; i++) {
                                    var r = 0 === (1 & i) ? outerRadius : innerRadius, currX = Math.cos(i * angle) * r, currY = Math.sin(i * angle) * r;
                                    0 === i ? results = "M" + currX + "," + currY + "L" : results += " " + currX + "," + currY;
                                }
                                return results + "Z";
                            },
                            hexagon: function(size) {
                                var r = Math.sqrt(size / (6 * Math.sqrt(3))), r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                                return "M0," + 2 * r + "L" + -r2 + "," + r + " " + -r2 + "," + -r + " 0," + -2 * r + " " + r2 + "," + -r + " " + r2 + "," + r + "Z";
                            },
                            x: function(size) {
                                var r = Math.sqrt(size / 10);
                                return "M0," + r + "L" + -r + "," + 2 * r + " " + -2 * r + "," + r + " " + -r + ",0 " + -2 * r + "," + -r + " " + -r + "," + -2 * r + " 0," + -r + " " + r + "," + -2 * r + " " + 2 * r + "," + -r + " " + r + ",0 " + 2 * r + "," + r + " " + r + "," + 2 * r + "Z";
                            },
                            uparrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M" + r + "," + 3 * r + "L" + -r + "," + 3 * r + " " + -r + "," + -r + " " + -2 * r + "," + -r + " 0," + -3 * r + " " + 2 * r + "," + -r + " " + r + "," + -r + "Z";
                            },
                            downarrow: function(size) {
                                var r = Math.sqrt(size / 12);
                                return "M0," + 3 * r + "L" + -2 * r + "," + r + " " + -r + "," + r + " " + -r + "," + -3 * r + " " + r + "," + -3 * r + " " + r + "," + r + " " + 2 * r + "," + r + "Z";
                            }
                        }), defaultValue = customSymbolTypes.entries()[0].value;
                        if (shape) {
                            if (isNaN(shape)) return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                            var result = customSymbolTypes.entries()[Math.floor(shape)];
                            return result ? result.value : defaultValue;
                        }
                        return defaultValue;
                    }, EnhancedScatterChart.prototype.init = function(options) {
                        this.options = options, this.animator = new visuals.BaseAnimator(), this.behavior = new visuals.CartesianChartBehavior([ new visuals.ScatterChartWebBehavior() ]);
                        var element = this.element = options.element;
                        this.viewport = _.clone(options.viewport), this.style = options.style, this.hostServices = options.host, 
                        this.colors = this.style.colorPalette.dataColors, this.interactivity = options.interactivity, 
                        this.margin = {
                            top: 1,
                            right: 1,
                            bottom: 1,
                            left: 1
                        }, this.yAxisOrientation = visuals.yAxisPosition.left, this.adjustMargins();
                        var showLinesOnX = this.scrollY = !0, showLinesOnY = this.scrollX = !0, svg = this.svg = d3.select(element.get(0)).append("svg").style("position", "absolute").classed(EnhancedScatterChart.ClassName, !0), axisGraphicsContext = this.axisGraphicsContext = svg.append("g").classed(this.AxisGraphicsContextClassName, !0);
                        this.svgScrollable = svg.append("svg").classed("svgScrollable", !0).style("overflow", "hidden");
                        var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append("g").classed(this.AxisGraphicsContextClassName, !0);
                        this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                        var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                        this.backgroundGraphicsContext = axisGraphicsContext.append("svg:image"), this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append("g").attr("class", "x axis") : axisGraphicsContextScrollable.append("g").attr("class", "x axis"), 
                        this.y1AxisGraphicsContext = axisGroup.append("g").attr("class", "y axis"), this.xAxisGraphicsContext.classed("showLinesOnAxis", showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("showLinesOnAxis", showLinesOnY), this.xAxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnX), 
                        this.y1AxisGraphicsContext.classed("hideLinesOnAxis", !showLinesOnY), this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                        this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, !0), 
                        this.mainGraphicsG = this.axisGraphicsContextScrollable.append("g").classed(EnhancedScatterChart.MainGraphicsContextClassName, !0), 
                        this.mainGraphicsContext = this.mainGraphicsG.append("svg"), this.svgDefaultImage = "http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg", 
                        this.keyArray = [];
                    }, EnhancedScatterChart.prototype.adjustMargins = function() {
                        var xAxis = this.element.find(".x.axis");
                        0 === visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) && 0 === visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) ? (this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        }, xAxis.hide()) : xAxis.show();
                    }, EnhancedScatterChart.prototype.getValueAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var valueAxisObject = objects.valueAxis;
                            valueAxisObject && (toReturn = {
                                show: valueAxisObject.show,
                                position: valueAxisObject.position,
                                axisScale: valueAxisObject.axisScale,
                                start: valueAxisObject.start,
                                end: valueAxisObject.end,
                                showAxisTitle: null == valueAxisObject.showAxisTitle ? axisTitleOnByDefault : valueAxisObject.showAxisTitle,
                                axisStyle: valueAxisObject.axisStyle,
                                axisColor: valueAxisObject.axisColor,
                                secShow: valueAxisObject.secShow,
                                secPosition: valueAxisObject.secPosition,
                                secAxisScale: valueAxisObject.secAxisScale,
                                secStart: valueAxisObject.secStart,
                                secEnd: valueAxisObject.secEnd,
                                secShowAxisTitle: valueAxisObject.secShowAxisTitle,
                                secAxisStyle: valueAxisObject.secAxisStyle,
                                labelDisplayUnits: valueAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.prototype.getCategoryAxisProperties = function(dataViewMetadata, axisTitleOnByDefault) {
                        var toReturn = {};
                        if (!dataViewMetadata) return toReturn;
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var categoryAxisObject = objects.categoryAxis;
                            categoryAxisObject && (toReturn = {
                                show: categoryAxisObject.show,
                                axisType: categoryAxisObject.axisType,
                                axisScale: categoryAxisObject.axisScale,
                                axisColor: categoryAxisObject.axisColor,
                                start: categoryAxisObject.start,
                                end: categoryAxisObject.end,
                                showAxisTitle: null == categoryAxisObject.showAxisTitle ? axisTitleOnByDefault : categoryAxisObject.showAxisTitle,
                                axisStyle: categoryAxisObject.axisStyle,
                                labelDisplayUnits: categoryAxisObject.labelDisplayUnits
                            });
                        }
                        return toReturn;
                    }, EnhancedScatterChart.converter = function(dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                        var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName, dataViewCategorical = dataView.categorical, dataViewMetadata = dataView.metadata;
                        dataViewCategorical.categories && dataViewCategorical.categories.length > 0 ? (categoryValues = dataViewCategorical.categories[0].values, 
                        categoryFormatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString),
                            value: categoryValues[0],
                            value2: categoryValues[categoryValues.length - 1]
                        }), categoryIdentities = dataViewCategorical.categories[0].identity, categoryObjects = dataViewCategorical.categories[0].objects, 
                        categoryQueryName = dataViewCategorical.categories[0].source.queryName) : (categoryValues = [ null ], 
                        categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null));
                        var categories = dataViewCategorical.categories, dataValues = dataViewCategorical.values, hasDynamicSeries = !!dataValues.source, grouped = dataValues.grouped(), useShape = !(DataRoleHelper.getMeasureIndexOfRole(grouped, "Image") >= 0), useCustomColor = DataRoleHelper.getMeasureIndexOfRole(grouped, "ColorFill") >= 0, dvSource = dataValues.source, scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource), dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), fillPoint = !1, backdrop = {
                            show: !1,
                            url: ""
                        }, crosshair = !1, outline = !1, defaultDataPointColor = "", showAllDataPoints = !0;
                        if (dataViewMetadata && dataViewMetadata.objects) {
                            var objects = dataViewMetadata.objects;
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor), 
                            showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                            var labelsObj = objects.categoryLabels;
                            labelsObj && (dataLabelsSettings.show = void 0 !== labelsObj.show ? labelsObj.show : dataLabelsSettings.show, 
                            dataLabelsSettings.fontSize = void 0 !== labelsObj.fontSize ? labelsObj.fontSize : dataLabelsSettings.fontSize, 
                            void 0 !== labelsObj.color && (dataLabelsSettings.labelColor = labelsObj.color.solid.color)), 
                            fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);
                            var backdropObject = objects.backdrop;
                            void 0 !== backdropObject && (backdrop.show = backdropObject.show, backdrop.show && (backdrop.url = backdropObject.url));
                            var crosshairObject = objects.crosshair;
                            void 0 !== crosshairObject && (crosshair = crosshairObject.show);
                            var outlineObject = objects.outline;
                            void 0 !== outlineObject && (outline = outlineObject.show);
                        }
                        var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                        interactivityService && interactivityService.applySelectionStateToData(dataPoints);
                        var legendItems = hasDynamicSeries ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor) : [], legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                        legendTitle || (legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "");
                        var legendData = {
                            title: legendTitle,
                            dataPoints: legendItems
                        }, sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                        if (categoryAxisProperties && null !== categoryAxisProperties.showAxisTitle && categoryAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.x = null), 
                        valueAxisProperties && null !== valueAxisProperties.showAxisTitle && valueAxisProperties.showAxisTitle === !1 && (scatterMetadata.axesLabels.y = null), 
                        dataPoints && dataPoints[0]) {
                            var point = dataPoints[0];
                            null != point.backdrop && (backdrop.show = !0, backdrop.url = point.backdrop), null != point.xStart && (categoryAxisProperties.start = point.xStart), 
                            null != point.xEnd && (categoryAxisProperties.end = point.xEnd), null != point.yStart && (valueAxisProperties.start = point.yStart), 
                            null != point.yEnd && (valueAxisProperties.end = point.yEnd);
                        }
                        return {
                            xCol: scatterMetadata.cols.x,
                            yCol: scatterMetadata.cols.y,
                            dataPoints: dataPoints,
                            legendData: legendData,
                            axesLabels: scatterMetadata.axesLabels,
                            selectedIds: [],
                            size: scatterMetadata.cols.size,
                            sizeRange: sizeRange,
                            dataLabelsSettings: dataLabelsSettings,
                            defaultDataPointColor: defaultDataPointColor,
                            hasDynamicSeries: hasDynamicSeries,
                            showAllDataPoints: showAllDataPoints,
                            fillPoint: fillPoint,
                            useShape: useShape,
                            useCustomColor: useCustomColor,
                            backdrop: backdrop,
                            crosshair: crosshair,
                            outline: outline
                        };
                    }, EnhancedScatterChart.createSeriesLegend = function(dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                        for (var grouped = dataValues.grouped(), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), legendItems = [], i = 0, len = grouped.length; len > i; i++) {
                            var grouping = grouped[i], color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                            legendItems.push({
                                color: color,
                                icon: visuals.LegendIcon.Circle,
                                label: visuals.valueFormatter.format(grouping.name, formatString),
                                identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                                selected: !1
                            });
                        }
                        return legendItems;
                    }, EnhancedScatterChart.getSizeRangeForGroups = function(dataViewValueGroups, sizeColumnIndex) {
                        var result = {};
                        return dataViewValueGroups && dataViewValueGroups.forEach(function(group) {
                            var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values), currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                            (null == result.min || result.min > currentRange.min) && (result.min = currentRange.min), 
                            (null == result.max || result.max < currentRange.max) && (result.max = currentRange.max);
                        }), result;
                    }, EnhancedScatterChart.getMetadata = function(grouped, source) {
                        var xCol, yCol, sizeCol, colorFillCol, shapeCol, imageCol, rotationCol, backdropCol, xStartCol, xEndCol, yStartCol, yEndCol, xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y"), sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size"), gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Gradient"), colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "ColorFill"), shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Shape"), imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Image"), rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Rotation"), backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Backdrop"), xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X Start"), xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X End"), yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y Start"), yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y End"), xAxisLabel = "", yAxisLabel = "";
                        if (grouped && grouped.length) {
                            var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                            xIndex >= 0 || (xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            yIndex >= 0 || (yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            sizeIndex >= 0 || (sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            colorFillIndex >= 0 || (colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            shapeIndex >= 0 || (shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            imageIndex >= 0 || (imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            rotationIndex >= 0 || (rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            backdropIndex >= 0 || (backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            xStartIndex >= 0 || (xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex ])), 
                            xEndIndex >= 0 || (xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex ])), 
                            yStartIndex >= 0 || (yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex ])), 
                            yEndIndex >= 0 || (yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [ xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex ])), 
                            xIndex >= 0 && (xCol = firstGroup.values[xIndex].source, xAxisLabel = firstGroup.values[xIndex].source.displayName), 
                            yIndex >= 0 && (yCol = firstGroup.values[yIndex].source, yAxisLabel = firstGroup.values[yIndex].source.displayName), 
                            sizeIndex >= 0 && (sizeCol = firstGroup.values[sizeIndex].source), colorFillIndex >= 0 && (colorFillCol = firstGroup.values[colorFillIndex].source), 
                            shapeIndex >= 0 && (shapeCol = firstGroup.values[shapeIndex].source), imageIndex >= 0 && (imageCol = firstGroup.values[imageIndex].source), 
                            rotationIndex >= 0 && (rotationCol = firstGroup.values[rotationIndex].source), backdropIndex >= 0 && (backdropCol = firstGroup.values[backdropIndex].source), 
                            xStartIndex >= 0 && (xStartCol = firstGroup.values[xStartIndex].source), xEndIndex >= 0 && (xEndCol = firstGroup.values[xEndIndex].source), 
                            yStartIndex >= 0 && (yStartCol = firstGroup.values[yStartIndex].source), yEndIndex >= 0 && (yEndCol = firstGroup.values[yEndIndex].source);
                        }
                        return {
                            idx: {
                                x: xIndex,
                                y: yIndex,
                                size: sizeIndex,
                                colorFill: colorFillIndex,
                                shape: shapeIndex,
                                image: imageIndex,
                                rotation: rotationIndex,
                                backdrop: backdropIndex,
                                xStart: xStartIndex,
                                xEnd: xEndIndex,
                                yStart: yStartIndex,
                                yEnd: yEndIndex
                            },
                            cols: {
                                x: xCol,
                                y: yCol,
                                size: sizeCol,
                                colorFill: colorFillCol,
                                shape: shapeCol,
                                image: imageCol,
                                rotation: rotationCol,
                                backdrop: backdropCol,
                                xStart: xStartCol,
                                xEnd: xEndCol,
                                yStart: yStartCol,
                                yEnd: yEndCol
                            },
                            axesLabels: {
                                x: xAxisLabel,
                                y: yAxisLabel
                            }
                        };
                    }, EnhancedScatterChart.getDefaultMeasureIndex = function(count, usedIndexes) {
                        for (var i = 0; count > i; i++) {
                            for (var found = !0, j = 0; j < usedIndexes.length; j++) if (i === usedIndexes[j]) {
                                found = !1;
                                break;
                            }
                            if (found === !0) return i;
                        }
                        return -1;
                    }, EnhancedScatterChart.createLazyFormattedCategory = function(formatter, value) {
                        return new jsCommon.Lazy(function() {
                            return formatter.format(value);
                        });
                    }, EnhancedScatterChart.createDataPoints = function(dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                        for (var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped(), fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor), categoryIdx = 0, ilen = categoryValues.length; ilen > categoryIdx; categoryIdx++) for (var categoryValue = categoryValues[categoryIdx], seriesIdx = 0, len = grouped.length; len > seriesIdx; seriesIdx++) {
                            var grouping = grouped[seriesIdx], seriesValues = grouping.values, measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues), measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues), measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues), measureColorFill = visuals.ScatterChart.getMeasureValue(indicies.colorFill, seriesValues), measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues), measureImage = visuals.ScatterChart.getMeasureValue(indicies.image, seriesValues), measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues), measureBackdrop = visuals.ScatterChart.getMeasureValue(indicies.backdrop, seriesValues), measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues), measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues), measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues), measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues), xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null, yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0, size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null, colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null, shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]), image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null, rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0, backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null, xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null, xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null, yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null, yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null, hasNullValue = null == xVal || null == yVal;
                            if (!hasNullValue) {
                                var color = void 0;
                                if (hasDynamicSeries) color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name); else {
                                    var measureSource = null != measureSize ? measureSize.source.queryName : "";
                                    color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                                }
                                var category = categories && categories.length > 0 ? categories[0] : null, identity = visuals.SelectionIdBuilder.builder().withCategory(category, categoryIdx).withSeries(dataValues, grouping).createSelectionId(), seriesData = [];
                                dataValueSource && seriesData.push({
                                    value: grouping.name,
                                    metadata: {
                                        source: dataValueSource,
                                        values: []
                                    }
                                }), measureX && seriesData.push({
                                    value: xVal,
                                    metadata: measureX
                                }), measureY && seriesData.push({
                                    value: yVal,
                                    metadata: measureY
                                }), measureSize && measureSize.values && measureSize.values.length > 0 && seriesData.push({
                                    value: measureSize.values[categoryIdx],
                                    metadata: measureSize
                                }), measureColorFill && measureColorFill.values && measureColorFill.values.length > 0 && seriesData.push({
                                    value: measureColorFill.values[categoryIdx],
                                    metadata: measureColorFill
                                }), measureShape && measureShape.values && measureShape.values.length > 0 && seriesData.push({
                                    value: measureShape.values[categoryIdx],
                                    metadata: measureShape
                                }), measureImage && measureImage.values && measureImage.values.length > 0 && seriesData.push({
                                    value: measureImage.values[categoryIdx],
                                    metadata: measureImage
                                }), measureRotation && measureRotation.values && measureRotation.values.length > 0 && seriesData.push({
                                    value: measureRotation.values[categoryIdx],
                                    metadata: measureRotation
                                }), measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0 && seriesData.push({
                                    value: measureBackdrop.values[categoryIdx],
                                    metadata: measureBackdrop
                                }), measureXStart && measureXStart.values && measureXStart.values.length > 0 && seriesData.push({
                                    value: measureXStart.values[categoryIdx],
                                    metadata: measureXStart
                                }), measureXEnd && measureXEnd.values && measureXEnd.values.length > 0 && seriesData.push({
                                    value: measureXEnd.values[categoryIdx],
                                    metadata: measureXEnd
                                }), measureYStart && measureYStart.values && measureYStart.values.length > 0 && seriesData.push({
                                    value: measureYStart.values[categoryIdx],
                                    metadata: measureYStart
                                }), measureYEnd && measureYEnd.values && measureYEnd.values.length > 0 && seriesData.push({
                                    value: measureYEnd.values[categoryIdx],
                                    metadata: measureYEnd
                                });
                                var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData), dataPoint = {
                                    x: xVal,
                                    y: yVal,
                                    size: size,
                                    radius: {
                                        sizeMeasure: measureSize,
                                        index: categoryIdx
                                    },
                                    fill: color,
                                    formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
                                    selected: !1,
                                    identity: identity,
                                    tooltipInfo: tooltipInfo,
                                    labelFill: labelSettings.labelColor,
                                    labelFontSize: fontSizeInPx,
                                    contentPosition: 8,
                                    colorFill: colorFill,
                                    shapeSymbolType: shapeSymbolType,
                                    svgurl: image,
                                    rotation: rotation,
                                    backdrop: backdrop,
                                    xStart: xStart,
                                    xEnd: xEnd,
                                    yStart: yStart,
                                    yEnd: yEnd
                                };
                                dataPoints.push(dataPoint);
                            }
                        }
                        return dataPoints;
                    }, EnhancedScatterChart.prototype.setData = function(dataViews) {
                        if (this.data = {
                            xCol: void 0,
                            yCol: void 0,
                            dataPoints: [],
                            legendData: {
                                dataPoints: []
                            },
                            axesLabels: {
                                x: "",
                                y: ""
                            },
                            selectedIds: [],
                            sizeRange: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                            defaultDataPointColor: null,
                            hasDynamicSeries: !1,
                            useShape: !0,
                            useCustomColor: !1
                        }, dataViews.length > 0) {
                            var dataView = dataViews[0];
                            dataView && (this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, !0), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, !0), this.dataView = dataView, 
                            dataView.categorical && dataView.categorical.values && (this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties)));
                        }
                    }, EnhancedScatterChart.prototype.update = function(options) {
                        var dataViews = this.dataViews = options.dataViews;
                        if (this.viewport = _.clone(options.viewport), dataViews) {
                            if (dataViews && dataViews.length > 0) {
                                var warnings = visuals.getInvalidValueWarnings(dataViews, !1, !1, !1);
                                warnings && warnings.length > 0 && this.hostServices.setWarnings(warnings), this.populateObjectProperties(dataViews);
                            }
                            this.setData(dataViews), this.options.interactivity && this.options.interactivity.isInteractiveLegend || this.renderLegend(), 
                            this.render(options.suppressAnimations);
                        }
                    }, EnhancedScatterChart.prototype.populateObjectProperties = function(dataViews) {
                        if (dataViews && dataViews.length > 0) {
                            var dataViewMetadata = dataViews[0].metadata;
                            dataViewMetadata ? this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, "legend", {}) : this.legendObjectProperties = {}, 
                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata), 
                            this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                            var axisPosition = this.valueAxisProperties.position;
                            this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                        }
                    }, EnhancedScatterChart.prototype.renderLegend = function() {
                        var legendData = {
                            title: "",
                            dataPoints: []
                        }, legend = this.legend;
                        this.layerLegendData = this.data.legendData, this.layerLegendData && (legendData.title = this.layerLegendData.title || "", 
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []), 
                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault, 
                        this.layerLegendData.grouped && (legendData.grouped = !0));
                        var legendProperties = this.legendObjectProperties;
                        if (legendProperties) {
                            visuals.LegendData.update(legendData, legendProperties);
                            var position = legendProperties[visuals.legendProps.position];
                            position && legend.changeOrientation(visuals.LegendPosition[position]);
                        } else legend.changeOrientation(visuals.LegendPosition.Top);
                        (1 === legendData.dataPoints.length && !legendData.grouped || this.hideLegends()) && (legendData.dataPoints = []);
                        var viewport = this.viewport;
                        legend.drawLegend(legendData, {
                            height: viewport.height,
                            width: viewport.width
                        }), visuals.Legend.positionChartArea(this.svg, legend);
                    }, EnhancedScatterChart.prototype.hideLegends = function() {
                        return !!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible);
                    }, EnhancedScatterChart.prototype.shouldRenderAxis = function(axisProperties, propertyName) {
                        return void 0 === propertyName && (propertyName = "show"), axisProperties ? (!axisProperties.isCategoryAxis || this.categoryAxisProperties && null != this.categoryAxisProperties[propertyName] && !this.categoryAxisProperties[propertyName]) && (axisProperties.isCategoryAxis || this.valueAxisProperties && null != this.valueAxisProperties[propertyName] && !this.valueAxisProperties[propertyName]) ? !1 : axisProperties.values && axisProperties.values.length > 0 : !1;
                    }, EnhancedScatterChart.prototype.getMaxMarginFactor = function() {
                        return this.options.style.maxMarginFactor || .25;
                    }, EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function() {
                        var img = new Image(), that = this;
                        if (img.src = this.data.backdrop.url, img.onload = function() {
                            that.oldBackdrop !== this.src && (that.render(!0), that.oldBackdrop = this.src);
                        }, img.width > 0 && img.height > 0) if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                            this.viewport = {
                                width: this.viewport.width - deltaWidth,
                                height: this.viewport.height
                            };
                        } else {
                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                            this.viewport = {
                                width: this.viewport.width,
                                height: this.viewport.height - deltaHeight
                            };
                        }
                    }, EnhancedScatterChart.prototype.render = function(suppressAnimations) {
                        if (this.viewport.height -= this.legendViewport.height, this.viewport.width -= this.legendViewport.width, 
                        0 !== this.viewportIn.width && 0 !== this.viewportIn.height) {
                            var maxMarginFactor = this.getMaxMarginFactor();
                            this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                            var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                            this.margin.top = 8, this.margin.bottom = bottomMarginLimit, this.margin.right = 0, 
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                            this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis, this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                            var mainAxisScale, renderXAxis = this.shouldRenderAxis(this.xAxisProperties), renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                            this.isXScrollBarVisible = !1, this.isYScrollBarVisible = !1;
                            var tickLabelMargins, axisLabels, chartHasAxisLabels, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0);
                            for (var doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                                numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, maxSecondYaxisSide += 10, xMax += 12, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 20), 
                                !showY1OnRight && renderY1Axis && (maxMainYaxisSide += 20), this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, 
                                this.yAxisProperties.axisLabel = null), this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), 
                                axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url) for (this.adjustViewportbyBackdrop(), 
                            doneWithMargins = !1, maxIterations = 2, numIterations = 0; !doneWithMargins && maxIterations > numIterations; ) {
                                numIterations++, tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({
                                    width: this.viewportIn.width,
                                    height: this.viewport.height
                                }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, {
                                    x: this.xAxisProperties,
                                    y1: this.yAxisProperties
                                }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, !1);
                                var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                                maxMainYaxisSide += 10, showY1OnRight && renderY1Axis && (maxSecondYaxisSide += 15), 
                                xMax += 12, this.hideAxisLabels() && (this.xAxisProperties.axisLabel = null, this.yAxisProperties.axisLabel = null), 
                                this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties), axisLabels = {
                                    x: this.xAxisProperties.axisLabel,
                                    y: this.yAxisProperties.axisLabel,
                                    y2: null
                                }, chartHasAxisLabels = null != axisLabels.x || null != axisLabels.y || null != axisLabels.y2, 
                                null != axisLabels.x && (xMax += 18), null != axisLabels.y && (maxMainYaxisSide += 20), 
                                null != axisLabels.y2 && (maxSecondYaxisSide += 20), this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide, 
                                this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide, this.margin.bottom = xMax;
                                var previousTickCountY1 = this.yAxisProperties.values.length;
                                this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, !0), 
                                this.yAxisProperties.values.length === previousTickCountY1 && (doneWithMargins = !0);
                            }
                            if (this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations), 
                            this.updateAxis(), this.data) {
                                var data = this.data, dataPoints = this.data.dataPoints, hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                                this.mainGraphicsContext.attr("width", this.viewportIn.width).attr("height", this.viewportIn.height);
                                var sortedData = dataPoints.sort(function(a, b) {
                                    return b.radius.sizeMeasure ? b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index] : 0;
                                }), duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations), scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration), dataLabelsSettings = this.data.dataLabelsSettings;
                                if (dataLabelsSettings.show) {
                                    var layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange), clonedDataPoints = this.cloneDataPoints(dataPoints), labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);
                                    labels && labels.attr("transform", function(d) {
                                        return visuals.SVGUtil.translate(d.size.width / 2, 0);
                                    });
                                } else visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                                var behaviorOptions = void 0;
                                if (this.interactivityService && (behaviorOptions = {
                                    dataPointsSelection: scatterMarkers,
                                    data: this.data,
                                    plotContext: this.mainGraphicsContext
                                }), visuals.TooltipManager.addTooltip(scatterMarkers, function(tooltipEvent) {
                                    return tooltipEvent.data.tooltipInfo;
                                }), visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options), this.behavior) {
                                    var layerBehaviorOptions = [];
                                    if (layerBehaviorOptions.push(behaviorOptions), this.interactivityService) {
                                        var cbehaviorOptions = {
                                            layerOptions: layerBehaviorOptions,
                                            clearCatcher: this.clearCatcher
                                        };
                                        this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.cloneDataPoints = function(dataPoints) {
                        for (var clonedDataPoints = new Array(), _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                            var dataPoint = dataPoints_1[_i], clonedDataPoint = _.clone(dataPoint);
                            clonedDataPoints.push(clonedDataPoint);
                        }
                        return clonedDataPoints;
                    }, EnhancedScatterChart.prototype.darkenZeroLine = function(g) {
                        var zeroTick = g.selectAll("g.tick").filter(function(data) {
                            return 0 === data;
                        }).node();
                        zeroTick && d3.select(zeroTick).select("line").classed("zero-line", !0);
                    }, EnhancedScatterChart.prototype.getCategoryAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.categoryAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function(labelSettings, viewport, sizeRange) {
                        var xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize), fontFamily = visuals.dataLabelUtils.LabelTextProperties.fontFamily;
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: d.formattedCategory.getValue(),
                                    fontSize: labelSettings.fontSize,
                                    maxWidth: viewport.width
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return xScale(d.x);
                                },
                                y: function(d) {
                                    var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;
                                    return 0 === labelSettings.position ? yScale(d.y) - margin : yScale(d.y) + margin;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.formattedCategory.getValue();
                            },
                            style: {
                                fill: function(d) {
                                    return d.labelFill;
                                },
                                "font-size": fontSizeInPx,
                                "font-family": fontFamily
                            }
                        };
                    }, EnhancedScatterChart.prototype.getValueAxisFill = function() {
                        if (this.dataView && this.dataView.metadata.objects) {
                            var label = this.dataView.metadata.objects.valueAxis;
                            if (label) return label.axisColor;
                        }
                        return {
                            solid: {
                                color: "#333"
                            }
                        };
                    }, EnhancedScatterChart.prototype.renderCrossHair = function() {
                        var _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, mainGraphicsContext = this.mainGraphicsContext;
                        if (mainGraphicsContext.selectAll(".crosshairCanvas").remove(), this.data.crosshair) {
                            var canvas = mainGraphicsContext.append("g").attr("class", "crosshairCanvas").attr("id", "crosshairCanvas"), crossHair = canvas.append("g").attr("class", "crosshair"), hLine_1 = crossHair.append("line").attr("id", "h_crosshair").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).style("stroke", "gray").style("stroke-width", "1px").style("stroke-dasharray", "5,5").style("display", "none"), vLine_1 = crossHair.append("line").attr("id", "v_crosshair").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", 0).style("stroke", "gray").style("stroke-width", "1px").style("stroke-dasharray", "5,5").style("display", "none"), text_1 = crossHair.append("text").attr("id", "crosshair_text").style("font-size", "10px").style("stroke", "gray").style("stroke-width", "0.5px"), addCrossHair_1 = function(xCoord, yCoord) {
                                hLine_1.attr("x1", 0).attr("y1", yCoord).attr("x2", _this.viewportIn.width).attr("y2", yCoord).style("display", "block"), 
                                vLine_1.attr("x1", xCoord).attr("y1", 0).attr("x2", xCoord).attr("y2", _this.viewportIn.height).style("display", "block"), 
                                text_1.attr("transform", "translate(" + (xCoord + 5) + "," + (yCoord - 5) + ")").text("(" + Math.round(100 * xScale.invert(xCoord)) / 100 + " , " + Math.round(100 * yScale.invert(yCoord)) / 100 + ")");
                            };
                            this.axisGraphicsContextScrollable.on("mousemove", function() {
                                var coordinates = d3.mouse(this), svgNode = this.viewportElement, scaledRect = svgNode.getBoundingClientRect(), domRect = svgNode.getBBox(), ratioX = scaledRect.width / domRect.width, ratioY = scaledRect.height / domRect.height;
                                domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1, 1e-5) && (coordinates[0] = coordinates[0] / ratioX), 
                                domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1, 1e-5) && (coordinates[1] = coordinates[1] / ratioY), 
                                addCrossHair_1(coordinates[0], coordinates[1]);
                            }).on("mouseover", function() {
                                d3.selectAll(".crosshair").style("display", "block");
                            }).on("mouseout", function() {
                                d3.selectAll(".crosshair").style("display", "none");
                            });
                        }
                    }, EnhancedScatterChart.prototype.renderBackground = function() {
                        this.data.backdrop && this.data.backdrop.show && void 0 !== this.data.backdrop.url ? this.backgroundGraphicsContext.attr("xlink:href", this.data.backdrop.url).attr("x", 0).attr("y", 0).attr("width", this.viewportIn.width).attr("height", this.viewportIn.height) : this.backgroundGraphicsContext.attr("width", 0).attr("height", 0);
                    }, EnhancedScatterChart.prototype.renderChart = function(mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                        var bottomMarginLimit = this.bottomMarginLimit, leftRightMarginLimit = this.leftRightMarginLimit, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                        if (this.renderBackground(), this.shouldRenderAxis(xAxis)) {
                            xAxis.axis.orient("bottom"), xAxis.willLabelsFit || xAxis.axis.tickPadding(5);
                            var xAxisGraphicsElement = this.xAxisGraphicsContext;
                            duration ? xAxisGraphicsElement.transition().duration(duration).call(xAxis.axis).call(this.darkenZeroLine) : xAxisGraphicsElement.call(xAxis.axis).call(this.darkenZeroLine);
                            var xZeroTick = xAxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (xZeroTick) {
                                var xZeroColor = this.getValueAxisFill();
                                xZeroColor && xZeroTick.selectAll("line").style({
                                    stroke: xZeroColor.solid.color
                                });
                            }
                            var xAxisTextNodes = xAxisGraphicsElement.selectAll("text");
                            xAxis.willLabelsWordBreak ? xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit) : xAxisTextNodes.call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, visuals.CartesianChart.AxisTextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                        } else this.xAxisGraphicsContext.selectAll("*").remove();
                        if (this.shouldRenderAxis(yAxis)) {
                            var yAxisOrientation = this.yAxisOrientation;
                            yAxis.axis.tickSize(-this.viewportIn.width).tickPadding(10).orient(yAxisOrientation.toLowerCase());
                            var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                            duration ? y1AxisGraphicsElement.transition().duration(duration).call(yAxis.axis).call(this.darkenZeroLine) : y1AxisGraphicsElement.call(yAxis.axis).call(this.darkenZeroLine);
                            var yZeroTick = y1AxisGraphicsElement.selectAll("g.tick").filter(function(data) {
                                return 0 === data;
                            });
                            if (yZeroTick) {
                                var yZeroColor = this.getCategoryAxisFill();
                                yZeroColor && yZeroTick.selectAll("line").style({
                                    stroke: yZeroColor.solid.color
                                });
                            }
                            tickLabelMargins.yLeft >= leftRightMarginLimit && y1AxisGraphicsElement.selectAll("text").call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);
                        } else this.y1AxisGraphicsContext.selectAll("*").remove();
                        if (chartHasAxisLabels) {
                            var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle"), hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle"), hideY2AxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.secShowAxisTitle && this.valueAxisProperties.secShowAxisTitle === !1;
                            this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                        } else this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        this.renderCrossHair();
                    }, EnhancedScatterChart.prototype.renderAxesLabels = function(axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                        this.axisGraphicsContext.selectAll(".xAxisLabel").remove(), this.axisGraphicsContext.selectAll(".yAxisLabel").remove();
                        var margin = this.margin, width = this.viewportIn.width, height = this.viewport.height, fontSize = EnhancedScatterChart.AxisFontSize, yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        if (!hideXAxisTitle) {
                            var xAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.x).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "xAxisLabel",
                                        transform: visuals.SVGUtil.translate(width / 2, height - fontSize - 2)
                                    });
                                });
                            });
                            xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!hideYAxisTitle) {
                            var yAxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!hideY2AxisTitle && axisLabels.y2) {
                            var y2AxisLabel = this.axisGraphicsContext.append("text").style("text-anchor", "middle").text(axisLabels.y2).call(function(text) {
                                text.each(function() {
                                    var text = d3.select(this);
                                    text.attr({
                                        "class": "yAxisLabel",
                                        transform: "rotate(-90)",
                                        y: showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                        x: -((height - margin.top - legendMargin) / 2),
                                        dy: "1em"
                                    });
                                });
                            });
                            y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }, EnhancedScatterChart.prototype.updateAxis = function() {
                        this.adjustMargins();
                        var yAxisOrientation = this.yAxisOrientation, showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        this.xAxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(0, this.viewportIn.height)), 
                        this.y1AxisGraphicsContext.attr("transform", visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0)), 
                        this.svg.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            width: this.viewport.width,
                            height: this.viewport.height
                        }), this.svgScrollable.attr({
                            x: 0
                        });
                        var left = this.margin.left, top = this.margin.top;
                        this.axisGraphicsContext.attr("transform", visuals.SVGUtil.translate(left, top)), 
                        this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(left, top)), 
                        this.clearCatcher.attr("transform", visuals.SVGUtil.translate(-left, -top)), this.isXScrollBarVisible ? (this.svgScrollable.attr({
                            x: left
                        }), this.axisGraphicsContextScrollable.attr("transform", visuals.SVGUtil.translate(0, top)), 
                        this.svgScrollable.attr("width", this.viewportIn.width), this.svg.attr("width", this.viewport.width).attr("height", this.viewport.height + this.ScrollBarWidth)) : this.isYScrollBarVisible && (this.svgScrollable.attr("height", this.viewportIn.height + top), 
                        this.svg.attr("width", this.viewport.width + this.ScrollBarWidth).attr("height", this.viewport.height));
                    }, EnhancedScatterChart.prototype.getUnitType = function(xAxis) {
                        return xAxis.formatter && xAxis.formatter.displayUnit && xAxis.formatter.displayUnit.value > 1 ? xAxis.formatter.displayUnit.title : null;
                    }, EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function(xAxis, yAxis) {
                        var unitType = this.getUnitType(xAxis);
                        xAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        xAxis.axisLabel && unitType && (xAxis.isCategoryAxis ? xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType) : xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType)), 
                        unitType = this.getUnitType(yAxis), yAxis.isCategoryAxis ? this.categoryAxisHasUnitType = null !== unitType : this.valueAxisHasUnitType = null !== unitType, 
                        yAxis.axisLabel && unitType && (yAxis.isCategoryAxis ? yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType) : yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType));
                    }, EnhancedScatterChart.prototype.hideAxisLabels = function() {
                        return !(!(this.cartesianSmallViewPortProperties && this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && this.viewport.height + this.legendViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) || this.options.interactivity.isInteractiveLegend);
                    }, EnhancedScatterChart.prototype.drawScatterMarkers = function(scatterData, hasSelection, sizeRange, duration) {
                        var markers, _this = this, xScale = this.xAxisProperties.scale, yScale = this.yAxisProperties.scale, shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint, useCustomColor = this.data.useCustomColor;
                        this.data.useShape ? (this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("path").classed(EnhancedScatterChart.DotClasses["class"], !0).attr("id", "markershape"), 
                        markers.style({
                            "stroke-opacity": function(d) {
                                return visuals.ScatterChart.getBubbleOpacity(d, hasSelection);
                            },
                            "stroke-width": "1px",
                            stroke: function(d) {
                                var color = useCustomColor ? d.colorFill : d.fill;
                                return _this.data.outline ? d3.rgb(color).darker() : d3.rgb(color);
                            },
                            fill: function(d) {
                                return d3.rgb(useCustomColor ? d.colorFill : d.fill);
                            },
                            "fill-opacity": function(d) {
                                return null != d.size || shouldEnableFill ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0;
                            }
                        }).attr("d", function(d) {
                            var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport), area = 4 * r * r;
                            return d.shapeSymbolType(area);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")";
                        })) : (this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove(), 
                        markers = this.mainGraphicsContext.classed("ScatterMarkers", !0).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function(d) {
                            return d.identity.getKey();
                        }), markers.enter().append("svg:image").classed(EnhancedScatterChart.ImageClasses["class"], !0).attr("id", "markerimage"), 
                        markers.attr("xlink:href", function(d) {
                            return void 0 !== d.svgurl && null != d.svgurl && "" !== d.svgurl ? d.svgurl : _this.svgDefaultImage;
                        }).attr("width", function(d) {
                            return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).attr("height", function(d) {
                            return 2 * visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                        }).transition().duration(function(d) {
                            return _this.keyArray.indexOf(d.identity.getKey()) >= 0 ? duration : 0;
                        }).attr("transform", function(d) {
                            var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                        })), markers.exit().remove(), this.keyArray = [];
                        for (var i = 0; i < scatterData.length; i++) this.keyArray.push(scatterData[i].identity.getKey());
                        return markers;
                    }, EnhancedScatterChart.prototype.calculateAxes = function(categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forcedXDomain: [ categoryAxisProperties ? categoryAxisProperties.start : null, categoryAxisProperties ? categoryAxisProperties.end : null ],
                            forceMerge: valueAxisProperties && valueAxisProperties.secShow === !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: categoryAxisProperties && null != categoryAxisProperties.axisScale ? categoryAxisProperties.axisScale : null,
                            valueAxisScaleType: valueAxisProperties && null != valueAxisProperties.axisScale ? valueAxisProperties.axisScale : null,
                            valueAxisDisplayUnits: valueAxisProperties && null != valueAxisProperties.labelDisplayUnits ? valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            categoryAxisDisplayUnits: categoryAxisProperties && null != categoryAxisProperties.labelDisplayUnits ? categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault,
                            trimOrdinalDataOnOverflow: !1
                        };
                        valueAxisProperties && (visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ valueAxisProperties.start, valueAxisProperties.end ], visualOptions.forcedYDomain)), 
                        visualOptions.showCategoryAxisLabel = !!categoryAxisProperties && !!categoryAxisProperties.showAxisTitle, 
                        visualOptions.showValueAxisLabel = !0;
                        var width = this.viewport.width - (this.margin.left + this.margin.right), axes = this.calculateAxesProperties(visualOptions);
                        return axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes[0].willLabelsWordBreak = !axes[0].willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, EnhancedScatterChart.prototype.calculateAxesProperties = function(options) {
                        var data = this.data, dataPoints = data.dataPoints;
                        this.margin = options.margin, this.viewport = options.viewport;
                        var minY = 0, maxY = 10, minX = 0, maxX = 10;
                        dataPoints.length > 0 && (minY = d3.min(dataPoints, function(d) {
                            return d.y;
                        }), maxY = d3.max(dataPoints, function(d) {
                            return d.y;
                        }), minX = d3.min(dataPoints, function(d) {
                            return d.x;
                        }), maxX = d3.max(dataPoints, function(d) {
                            return d.x;
                        }));
                        var xDomain = [ minX, maxX ], combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                        this.xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.width,
                            dataDomain: combinedXDomain,
                            metaDataColumn: data.xCol,
                            formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        }), this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0), this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                        var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [ minY, maxY ]);
                        return this.yAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewportIn.height,
                            dataDomain: combinedDomain,
                            metaDataColumn: data.yCol,
                            formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !0,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            scaleType: options.valueAxisScaleType,
                            axisDisplayUnits: options.valueAxisDisplayUnits
                        }), this.yAxisProperties.axisLabel = this.data.axesLabels.y, [ this.xAxisProperties, this.yAxisProperties ];
                    }, EnhancedScatterChart.prototype.enumerateDataPoints = function(enumeration) {
                        var data = this.data;
                        if (data) {
                            var seriesCount = data.dataPoints.length;
                            if (data.hasDynamicSeries) for (var legendDataPointLength = data.legendData.dataPoints.length, i = 0; legendDataPointLength > i; i++) {
                                var series = data.legendData.dataPoints[i];
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    displayName: series.label,
                                    selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                    properties: {
                                        fill: {
                                            solid: {
                                                color: series.color
                                            }
                                        }
                                    }
                                });
                            } else {
                                enumeration.pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        defaultColor: {
                                            solid: {
                                                color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value
                                            }
                                        }
                                    }
                                }).pushInstance({
                                    objectName: "dataPoint",
                                    selector: null,
                                    properties: {
                                        showAllDataPoints: !!data.showAllDataPoints
                                    }
                                });
                                for (var i = 0; seriesCount > i; i++) {
                                    var seriesDataPoints = data.dataPoints[i];
                                    enumeration.pushInstance({
                                        objectName: "dataPoint",
                                        displayName: seriesDataPoints.formattedCategory.getValue(),
                                        selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), !0),
                                        properties: {
                                            fill: {
                                                solid: {
                                                    color: seriesDataPoints.fill
                                                }
                                            }
                                        }
                                    });
                                }
                            }
                        }
                    }, EnhancedScatterChart.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            visuals.GradientUtils.hasGradientRole(categoricalDataView) || this.enumerateDataPoints(enumeration);
                            break;

                          case "categoryAxis":
                            this.getCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.getValueAxisValues(enumeration);
                            break;

                          case "categoryLabels":
                            this.data ? visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, !0) : visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, !0);
                            break;

                          case "fillPoint":
                            var sizeRange = this.data.sizeRange;
                            if (sizeRange && sizeRange.min) break;
                            enumeration.pushInstance({
                                objectName: "fillPoint",
                                selector: null,
                                properties: {
                                    show: this.data.fillPoint
                                }
                            });
                            break;

                          case "backdrop":
                            enumeration.pushInstance({
                                objectName: "backdrop",
                                displayName: "Backdrop",
                                selector: null,
                                properties: {
                                    show: this.data.backdrop ? this.data.backdrop.show : !1,
                                    url: this.data.backdrop ? this.data.backdrop.url : null
                                }
                            });
                            break;

                          case "crosshair":
                            enumeration.pushInstance({
                                objectName: "crosshair",
                                selector: null,
                                properties: {
                                    show: this.data.crosshair
                                }
                            });
                            break;

                          case "outline":
                            enumeration.pushInstance({
                                objectName: "outline",
                                selector: null,
                                properties: {
                                    show: this.data.outline
                                }
                            });
                            break;

                          case "legend":
                            this.getLegendValue(enumeration);
                        }
                        return enumeration.complete();
                    }, EnhancedScatterChart.prototype.hasLegend = function() {
                        return this.data && this.data.hasDynamicSeries;
                    }, EnhancedScatterChart.prototype.getLegendValue = function(enumeration) {
                        if (this.hasLegend()) {
                            var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible()), showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, !0), titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : ""), legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                            this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault), 
                            enumeration.pushInstance({
                                selector: null,
                                properties: {
                                    show: show,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    labelColor: legendLabelColor,
                                    fontSize: this.legendLabelFontSize
                                },
                                objectName: "legend"
                            });
                        }
                    }, EnhancedScatterChart.prototype.getCategoryAxisValues = function(enumeration) {
                        var supportedType = visuals.axisType.both, isScalar = !0, logPossible = !1, scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ];
                        isScalar || this.categoryAxisProperties && (this.categoryAxisProperties.start = null, 
                        this.categoryAxisProperties.end = null);
                        var instance = {
                            selector: null,
                            properties: {},
                            objectName: "categoryAxis",
                            validValues: {
                                axisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.categoryAxisProperties && null != this.categoryAxisProperties.show ? this.categoryAxisProperties.show : !0, 
                        this.yAxisIsCategorical && (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        supportedType === visuals.axisType.both && (instance.properties.axisType = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical), 
                        isScalar && (instance.properties.axisScale = this.categoryAxisProperties && null != this.categoryAxisProperties.axisScale && logPossible ? this.categoryAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.categoryAxisProperties ? this.categoryAxisProperties.start : null, 
                        instance.properties.end = this.categoryAxisProperties ? this.categoryAxisProperties.end : null, 
                        instance.properties.labelDisplayUnits = this.categoryAxisProperties && null != this.categoryAxisProperties.labelDisplayUnits ? this.categoryAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault), 
                        instance.properties.showAxisTitle = this.categoryAxisProperties && null != this.categoryAxisProperties.showAxisTitle ? this.categoryAxisProperties.showAxisTitle : !0, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.categoryAxisProperties && this.categoryAxisProperties.axisStyle ? this.categoryAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.categoryAxisProperties ? this.categoryAxisProperties.labelColor : null
                            },
                            objectName: "categoryAxis",
                            validValues: {
                                axisStyle: this.categoryAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.getValueAxisValues = function(enumeration) {
                        var scaleOptions = [ visuals.axisScale.log, visuals.axisScale.linear ], logPossible = !1, instance = {
                            selector: null,
                            properties: {},
                            objectName: "valueAxis",
                            validValues: {
                                axisScale: scaleOptions,
                                secAxisScale: scaleOptions
                            }
                        };
                        instance.properties.show = this.valueAxisProperties && null != this.valueAxisProperties.show ? this.valueAxisProperties.show : !0, 
                        this.yAxisIsCategorical || (instance.properties.position = this.valueAxisProperties && null != this.valueAxisProperties.position ? this.valueAxisProperties.position : visuals.yAxisPosition.left), 
                        instance.properties.axisScale = this.valueAxisProperties && null != this.valueAxisProperties.axisScale && logPossible ? this.valueAxisProperties.axisScale : visuals.axisScale.linear, 
                        instance.properties.start = this.valueAxisProperties ? this.valueAxisProperties.start : null, 
                        instance.properties.end = this.valueAxisProperties ? this.valueAxisProperties.end : null, 
                        instance.properties.showAxisTitle = this.valueAxisProperties && null != this.valueAxisProperties.showAxisTitle ? this.valueAxisProperties.showAxisTitle : !0, 
                        instance.properties.labelDisplayUnits = this.valueAxisProperties && null != this.valueAxisProperties.labelDisplayUnits ? this.valueAxisProperties.labelDisplayUnits : EnhancedScatterChart.LabelDisplayUnitsDefault, 
                        enumeration.pushInstance(instance).pushInstance({
                            selector: null,
                            properties: {
                                axisStyle: this.valueAxisProperties && null != this.valueAxisProperties.axisStyle ? this.valueAxisProperties.axisStyle : visuals.axisStyle.showTitleOnly,
                                labelColor: this.valueAxisProperties ? this.valueAxisProperties.labelColor : null
                            },
                            objectName: "valueAxis",
                            validValues: {
                                axisStyle: this.valueAxisHasUnitType ? [ visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth ] : [ visuals.axisStyle.showTitleOnly ]
                            }
                        });
                    }, EnhancedScatterChart.prototype.onClearSelection = function() {
                        this.interactivityService && this.interactivityService.clearSelection();
                    }, EnhancedScatterChart.DefaultBubbleOpacity = .85, EnhancedScatterChart.DimmedBubbleOpacity = .4, 
                    EnhancedScatterChart.ClassName = "enhancedScatterChart", EnhancedScatterChart.MainGraphicsContextClassName = "mainGraphicsContext", 
                    EnhancedScatterChart.LegendLabelFontSizeDefault = 9, EnhancedScatterChart.LabelDisplayUnitsDefault = 0, 
                    EnhancedScatterChart.AxisFontSize = 11, EnhancedScatterChart.DotClasses = {
                        "class": "dot",
                        selector: ".dot"
                    }, EnhancedScatterChart.ImageClasses = {
                        "class": "img",
                        selector: ".img"
                    }, EnhancedScatterChart.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Details")
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Legend")
                        }, {
                            name: "X",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_X")
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Y")
                        }, {
                            name: "Size",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Size")
                        }, {
                            name: "Gradient",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Gradient")
                        }, {
                            name: "ColorFill",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Customized Color"
                        }, {
                            name: "Shape",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Shape"
                        }, {
                            name: "Image",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Image"
                        }, {
                            name: "Rotation",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Rotation"
                        }, {
                            name: "Backdrop",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Backdrop"
                        }, {
                            name: "X Start",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "X Start"
                        }, {
                            name: "X End",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "X End"
                        }, {
                            name: "Y Start",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y Start"
                        }, {
                            name: "Y End",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Y End"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 1
                                },
                                ColorFill: {
                                    max: 1
                                },
                                Shape: {
                                    max: 1
                                },
                                Image: {
                                    max: 0
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 0
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                },
                                X: {
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                },
                                Size: {
                                    max: 1
                                },
                                Gradient: {
                                    max: 1
                                },
                                ColorFill: {
                                    max: 0
                                },
                                Shape: {
                                    max: 0
                                },
                                Image: {
                                    max: 1
                                },
                                Rotation: {
                                    max: 1
                                },
                                Backdrop: {
                                    max: 1
                                },
                                "X Start": {
                                    max: 1
                                },
                                "X End": {
                                    max: 1
                                },
                                "Y Start": {
                                    max: 1
                                },
                                "Y End": {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "X"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y"
                                            }
                                        }, {
                                            bind: {
                                                to: "Size"
                                            }
                                        }, {
                                            bind: {
                                                to: "Gradient"
                                            }
                                        }, {
                                            bind: {
                                                to: "ColorFill"
                                            }
                                        }, {
                                            bind: {
                                                to: "Shape"
                                            }
                                        }, {
                                            bind: {
                                                to: "Image"
                                            }
                                        }, {
                                            bind: {
                                                to: "Rotation"
                                            }
                                        }, {
                                            bind: {
                                                to: "Backdrop"
                                            }
                                        }, {
                                            bind: {
                                                to: "X Start"
                                            }
                                        }, {
                                            bind: {
                                                to: "X End"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y Start"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y End"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        objects: {
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    useShape: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_UseImage"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            },
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_XAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_YAxis_Position"),
                                        type: {
                                            formatting: {
                                                yAxisPosition: !0
                                            }
                                        }
                                    },
                                    axisScale: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Scale"),
                                        type: {
                                            formatting: {
                                                axisScale: !0
                                            }
                                        }
                                    },
                                    start: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Start"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    end: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_End"),
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Title"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisStyle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Axis_Style"),
                                        type: {
                                            formatting: {
                                                axisStyle: !0
                                            }
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        }
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            categoryLabels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            fillPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_FillPoint"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            backdrop: {
                                displayName: "Backdrop",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    url: {
                                        displayName: "Image URL",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            crosshair: {
                                displayName: "Crosshair",
                                properties: {
                                    show: {
                                        displayName: "Crosshair",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            outline: {
                                displayName: "Outline",
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Outline"),
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, EnhancedScatterChart;
                }();
                samples.EnhancedScatterChart = EnhancedScatterChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    function loadGlobeMapLibs() {}
    var THREE, WebGLHeatmap, GlobeMapCanvasLayers, powerbi, powerbi = (window.jsCommon, 
    window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var DataRoleHelper = powerbi.data.DataRoleHelper, GlobeMap = function() {
                    function GlobeMap() {
                        this.renderData = [], this.locationsToLoad = 0, this.locationsLoaded = 0, this.renderLoopEnabled = !0, 
                        this.needsRender = !1;
                    }
                    return GlobeMap.converter = function(dataView) {
                        return {};
                    }, GlobeMap.prototype.init = function(options) {
                        this.container = options.element, this.viewport = options.viewport, this.readyToRender = !1, 
                        this.globeMapLocationCache || (this.globeMapLocationCache = {}), THREE || loadGlobeMapLibs(), 
                        THREE && this.setup();
                    }, GlobeMap.prototype.setup = function() {
                        this.initSettings(), this.initTextures(), this.initMercartorSphere(), this.initZoomControl(), 
                        this.initScene(), this.initHeatmap(), this.readyToRender = !0, this.composeRenderData(), 
                        this.initRayCaster();
                    }, GlobeMap.prototype.initSettings = function() {
                        var settings = this.settings = {};
                        settings.autoRotate = !1, settings.earthRadius = 30, settings.cameraRadius = 100, 
                        settings.earthSegments = 100, settings.heatmapSize = 1e3, settings.heatPointSize = 7, 
                        settings.heatIntensity = 10, settings.heatmapScaleOnZoom = .95, settings.barWidth = .3, 
                        settings.barHeight = 5, settings.rotateSpeed = .5, settings.zoomSpeed = .8, settings.cameraAnimDuration = 1e3, 
                        settings.clickInterval = 200;
                    }, GlobeMap.prototype.initScene = function() {
                        var viewport = this.viewport, settings = this.settings, clock = new THREE.Clock(), renderer = this.renderer = new THREE.WebGLRenderer({
                            antialias: !0,
                            preserveDrawingBuffer: !0
                        });
                        this.container.append(renderer.domElement), this.domElement = renderer.domElement;
                        var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, .1, 1e4), orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement), scene = this.scene = new THREE.Scene();
                        renderer.setSize(viewport.width, viewport.height), renderer.setClearColor(12240082, 1), 
                        camera.position.z = settings.cameraRadius, orbitControls.maxDistance = settings.cameraRadius, 
                        orbitControls.minDistance = settings.earthRadius + 1, orbitControls.rotateSpeed = settings.rotateSpeed, 
                        orbitControls.zoomSpeed = settings.zoomSpeed, orbitControls.autoRotate = settings.autoRotate;
                        var ambientLight = new THREE.AmbientLight(0), light1 = new THREE.DirectionalLight(16777215, .4), light2 = new THREE.DirectionalLight(16777215, .4), earth = this.earth = this.createEarth();
                        scene.add(ambientLight), scene.add(light1), scene.add(light2), scene.add(earth), 
                        light1.position.set(20, 20, 20), light2.position.set(0, 0, -20);
                        var _zis = this;
                        requestAnimationFrame(function render() {
                            try {
                                if (_zis.renderLoopEnabled && requestAnimationFrame(render), !_zis.shouldRender()) return;
                                orbitControls.update(clock.getDelta()), _zis.setEarthTexture(), _zis.intersectBars(), 
                                _zis.heatmap.display(), renderer.render(scene, camera), _zis.needsRender = !1;
                            } catch (e) {}
                        });
                    }, GlobeMap.prototype.shouldRender = function() {
                        return this.readyToRender && this.needsRender;
                    }, GlobeMap.prototype.createEarth = function() {
                        var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments), material = new THREE.MeshPhongMaterial({
                            map: this.mapTextures[0],
                            side: THREE.DoubleSide,
                            shininess: 1,
                            emissive: 11184810
                        });
                        return new THREE.Mesh(geometry, material);
                    }, GlobeMap.prototype.zoomClicked = function(zoomDirection) {
                        this.orbitControls.enabled !== !1 && this.orbitControls.enableZoom !== !1 && (-1 === zoomDirection ? this.orbitControls.constraint.dollyOut(Math.pow(.95, this.settings.zoomSpeed)) : 1 === zoomDirection && this.orbitControls.constraint.dollyIn(Math.pow(.95, this.settings.zoomSpeed)), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.rotateCam = function(deltaX, deltaY) {
                        this.orbitControls.enabled !== !1 && this.orbitControls.enableRotate !== !1 && (this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                        this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed), 
                        this.orbitControls.update(), this.animateCamera(this.camera.position));
                    }, GlobeMap.prototype.initZoomControl = function() {
                        var _this = this, radius = 17, zoomControlWidth = 8.5 * radius, zoomControlHeight = 8.5 * radius, startX = 3 * radius, startY = radius + 3, gap = 2 * radius, zoomCss = {
                            position: "absolute",
                            left: "calc(100% - " + zoomControlWidth + "px)",
                            top: "calc(100% - " + zoomControlHeight + "px)",
                            zIndex: "1000"
                        }, zoomContainer = d3.select(this.container[0]).append("div").style(zoomCss);
                        this.zoomControl = zoomContainer.append("svg").attr({
                            width: zoomControlWidth,
                            height: zoomControlHeight
                        });
                        var bottom = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(0, -5);
                        });
                        bottom.append("circle").attr({
                            cx: startX + gap,
                            cy: startY + 2 * gap,
                            r: radius,
                            fill: "white",
                            opacity: .5,
                            stroke: "gray"
                        }), bottom.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY + 4.7 * radius) + " l12 -20 a40,70 0 0,1 -24,0z",
                            fill: "gray"
                        });
                        var left = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(5, 0);
                        });
                        left.append("circle").attr({
                            cx: startX,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), left.append("path").attr({
                            d: "M" + (startX - radius / 1.5) + " " + (startY + 2 * radius) + " l20 -12 a70,40 0 0,0 0,24z",
                            fill: "gray"
                        });
                        var top = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(0, 5);
                        });
                        top.append("circle").attr({
                            cx: startX + gap,
                            cy: startY,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), top.append("path").attr({
                            d: "M" + (startX + 2 * radius) + " " + (startY - radius / 1.5) + " l12 20 a40,70 0 0,0 -24,0z",
                            fill: "gray"
                        });
                        var right = this.zoomControl.append("g").on("click", function() {
                            return _this.rotateCam(-5, 0);
                        });
                        right.append("circle").attr({
                            cx: startX + 2 * gap,
                            cy: startY + gap,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), right.append("path").attr({
                            d: "M" + (startX + 4.7 * radius) + " " + (startY + 2 * radius) + " l-20 -12 a70,40 0 0,1 0,24z",
                            fill: "gray"
                        });
                        var zoomIn = this.zoomControl.append("g").on("click", function() {
                            return _this.zoomClicked(-1);
                        });
                        zoomIn.append("circle").attr({
                            cx: startX + 4 * radius,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: .5
                        }), zoomIn.append("rect").attr({
                            x: startX + 3.5 * radius,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        }), zoomIn.append("rect").attr({
                            x: startX + 4 * radius - radius / 6,
                            y: startY + 5.55 * radius,
                            width: radius / 3,
                            height: radius,
                            fill: "gray"
                        });
                        var zoomOut = this.zoomControl.append("g").on("click", function() {
                            return _this.zoomClicked(1);
                        });
                        zoomOut.append("circle").attr({
                            cx: startX,
                            cy: startY + 6 * radius,
                            r: radius,
                            fill: "white",
                            stroke: "gray",
                            opacity: "0.50"
                        }), zoomOut.append("rect").attr({
                            x: startX - radius / 2,
                            y: startY + 5.9 * radius,
                            width: radius,
                            height: radius / 3,
                            fill: "gray"
                        });
                    }, GlobeMap.prototype.initTextures = function() {
                        var _this = this;
                        if (!GlobeMapCanvasLayers) {
                            GlobeMapCanvasLayers = [];
                            for (var level = 2; 5 >= level; ++level) {
                                var canvas = this.getBingMapCanvas(level);
                                GlobeMapCanvasLayers.push(canvas);
                            }
                        }
                        var createTexture = function(canvas) {
                            var texture = new THREE.Texture(canvas.get(0));
                            return texture.needsUpdate = !0, canvas.on("ready", function(e, resolution) {
                                texture.needsUpdate = !0, _this.needsRender = !0;
                            }), texture;
                        };
                        this.mapTextures = [];
                        for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                    }, GlobeMap.prototype.initHeatmap = function() {
                        var settings = this.settings;
                        try {
                            var heatmap = this.heatmap = new WebGLHeatmap({
                                width: settings.heatmapSize,
                                height: settings.heatmapSize,
                                intensityToAlpha: !0
                            });
                        } catch (e) {}
                        var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                        texture.needsUpdate = !0;
                        var material = new THREE.MeshBasicMaterial({
                            map: texture,
                            transparent: !0
                        }), geometry = new THREE.SphereGeometry(settings.earthRadius + .01, settings.earthSegments, settings.earthSegments), mesh = new THREE.Mesh(geometry, material);
                        window.heatmap = heatmap, window.heatmapTexture = texture, this.scene.add(mesh);
                    }, GlobeMap.prototype.setEarthTexture = function() {
                        if (this.camera) {
                            var texture, maxDistance = this.settings.cameraRadius - this.settings.earthRadius, distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;
                            texture = .2 >= distance ? this.mapTextures[3] : .4 >= distance ? this.mapTextures[2] : .6 >= distance ? this.mapTextures[1] : this.mapTextures[0], 
                            this.earth.material.map !== texture && (this.earth.material.map = texture), this.selectedBar ? this.orbitControls.rotateSpeed = this.settings.rotateSpeed : this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;
                        }
                    }, GlobeMap.prototype.update = function(options) {
                        if (this.needsRender = !0, this.cleanHeatAndBar(), options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {
                            var viewport = this.viewport = options.viewport;
                            return void (this.camera && this.renderer && (this.camera.aspect = viewport.width / viewport.height, 
                            this.camera.updateProjectionMatrix(), this.renderer.setSize(viewport.width, viewport.height)));
                        }
                        options.dataViews[0] && options.dataViews[0].categorical && this.composeRenderData(options.dataViews[0].categorical);
                    }, GlobeMap.prototype.cleanHeatAndBar = function() {
                        this.heatmap.clear(), this.heatTexture.needsUpdate = !0, this.barsGroup && this.scene.remove(this.barsGroup);
                    }, GlobeMap.prototype.renderMagic = function() {
                        if (!this.readyToRender) return void this.defferedRender();
                        var renderData = this.renderData, heatmap = this.heatmap, settings = this.settings;
                        heatmap.clear(), this.barsGroup && this.scene.remove(this.barsGroup), this.barsGroup = new THREE.Object3D(), 
                        this.scene.add(this.barsGroup);
                        var barMaterials = [ new THREE.MeshPhongMaterial({
                            color: 16711935,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 16776986,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 16711680,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 65535,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 10046720,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 11783372,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 11331072,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }), new THREE.MeshPhongMaterial({
                            color: 5395066,
                            side: THREE.DoubleSide,
                            shading: THREE.FlatShading,
                            transparent: !0
                        }) ];
                        this.averageBarVector = new THREE.Vector3();
                        for (var i = 0, len = renderData.length; len > i; ++i) {
                            var renderDatum = renderData[i];
                            if (renderDatum.lat && renderDatum.lng) {
                                if (renderDatum.heat > .001) {
                                    renderDatum.heat < .1 && (renderDatum.heat = .1);
                                    var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize, y = (1 - (90 + renderDatum.lat) / 180) * settings.heatmapSize;
                                    heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);
                                }
                                if (renderDatum.height >= 0) {
                                    renderDatum.height < .01 && (renderDatum.height = .01);
                                    var latRadians = renderDatum.lat / 180 * Math.PI, lngRadians = renderDatum.lng / 180 * Math.PI, x = Math.cos(lngRadians) * Math.cos(latRadians), z = -Math.sin(lngRadians) * Math.cos(latRadians), y = Math.sin(latRadians), v = new THREE.Vector3(x, y, z);
                                    this.averageBarVector.add(v);
                                    var barHeight = settings.barHeight * renderDatum.height, measuresBySeries = [], dataPointToolTip = [];
                                    if (renderDatum.heightBySeries) for (var c = 0; c < renderDatum.heightBySeries.length; c++) renderDatum.heightBySeries[c] && measuresBySeries.push(renderDatum.heightBySeries[c]), 
                                    dataPointToolTip.push(renderDatum.seriesToolTipData[c]); else measuresBySeries.push(1);
                                    for (var previousMeasureValue = 0, j = 0; j < measuresBySeries.length; j++) {
                                        previousMeasureValue += measuresBySeries[j];
                                        var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]), bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);
                                        bar.position = v.clone().multiplyScalar(settings.earthRadius + barHeight / 2 * previousMeasureValue), 
                                        bar.lookAt(v), bar.toolTipData = 0 === dataPointToolTip.length ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]), 
                                        this.barsGroup.add(bar), previousMeasureValue += measuresBySeries[j];
                                    }
                                }
                            }
                        }
                        this.barsGroup.children.length > 0 && this.camera && (this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length), 
                        this.locationsLoaded === this.locationsToLoad && this.animateCamera(this.averageBarVector)), 
                        heatmap.update(), heatmap.blur(), this.heatTexture.needsUpdate = !0, this.needsRender = !0;
                    }, GlobeMap.prototype.getToolTipDataForSeries = function(toolTipData, dataPointToolTip) {
                        var result = jQuery.extend(!0, {
                            series: {
                                displayName: dataPointToolTip.displayName,
                                value: dataPointToolTip.value
                            }
                        }, toolTipData);
                        return result.height.value = dataPointToolTip.dataPointValue, result;
                    }, GlobeMap.prototype.composeRenderData = function(categoricalView) {
                        categoricalView ? this.categoricalView = categoricalView : categoricalView = this.categoricalView, 
                        this.renderData = [];
                        var locations = [], globeMapLocationCache = this.globeMapLocationCache;
                        if (categoricalView) {
                            var categories = categoricalView.categories, grouped = categoricalView.values.grouped(), heightIndex = 0, intensityIndex = 0;
                            try {
                                heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Height"), intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Heat");
                                var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X"), latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                            } catch (e) {}
                            var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;
                            if (void 0 !== heightIndex && categoricalView.values[heightIndex] && void 0 !== categoricalView.values) {
                                var locationCategory = categories[0];
                                locations = locationCategory.values, locationDispName = locationCategory.source.displayName, 
                                locationType = locationCategory.source.type.category ? locationCategory.source.type.category.toLowerCase() : "";
                            } else locations = [];
                            if (void 0 !== heightIndex && categoricalView.values[heightIndex]) if (heightDispName = categoricalView.values[heightIndex].source.displayName, 
                            heightFormat = categoricalView.values[heightIndex].source.format, grouped.length > 1) {
                                heights = new Array(locations.length), heightsBySeries = new Array(locations.length), 
                                toolTipDataBySeries = new Array(locations.length);
                                for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[heightIndex].values, j = 0; j < values.length; j++) heights[j] || (heights[j] = 0), 
                                heights[j] += values[j] ? values[j] : 0, heightsBySeries[j] || (heightsBySeries[j] = []), 
                                heightsBySeries[j][i] = values[j], toolTipDataBySeries[j] || (toolTipDataBySeries[j] = []), 
                                toolTipDataBySeries[j][i] = {
                                    displayName: categoricalView.values.source.displayName,
                                    value: grouped[i].name,
                                    dataPointValue: values[j]
                                };
                                for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[heightIndex].values, j = 0; j < values.length; j++) heightsBySeries[j][i] = values[j] / heights[j];
                            } else heights = categoricalView.values[heightIndex].values, heightsBySeries = new Array(grouped.length); else heightsBySeries = new Array(locations.length), 
                            heights = new Array(locations.length);
                            if (void 0 !== intensityIndex && categoricalView.values[intensityIndex]) {
                                if (grouped.length > 1) {
                                    heats = new Array(locations.length);
                                    for (var i = 0; i < grouped.length; i++) for (var values = grouped[i].values[intensityIndex].values, j = 0; j < values.length; j++) heats[j] || (heats[j] = 0), 
                                    heats[j] += values[j] ? values[j] : 0;
                                } else heats = categoricalView.values[intensityIndex].values;
                                heatDispName = categoricalView.values[intensityIndex].source.displayName, heatFormat = categoricalView.values[intensityIndex].source.format;
                            } else heats = new Array(locations.length);
                            void 0 !== longitudeIndex && categoricalView.values[longitudeIndex] && void 0 !== latitudeIndex && categoricalView.values[latitudeIndex] ? (longitudes = categoricalView.values[longitudeIndex].values, 
                            latitudes = categoricalView.values[latitudeIndex].values) : (longitudes = null, 
                            latitudes = null);
                            for (var maxHeight = Math.max.apply(null, heights) || 1, maxHeat = Math.max.apply(null, heats) || 1, heatFormatter = visuals.valueFormatter.create({
                                format: heatFormat,
                                value: heats[0],
                                value2: heats[1]
                            }), heightFormatter = visuals.valueFormatter.create({
                                format: heightFormat,
                                value: heights[0],
                                value2: heights[1]
                            }), i = 0, len = locations.length; len > i; ++i) {
                                var lat, lng, latlng, height, heat, place = locations[i];
                                if (place && "string" == typeof place) {
                                    place = place.toLowerCase();
                                    var placeKey = place + "/" + locationType;
                                    !longitudes && globeMapLocationCache[placeKey] ? (latlng = globeMapLocationCache[placeKey], 
                                    lat = latlng.latitude, lng = latlng.longitude) : longitudes && (lat = latitudes[i], 
                                    lng = longitudes[i]), height = heights[i] / maxHeight, heat = heats[i] / maxHeat;
                                    var renderDatum = {
                                        lat: lat,
                                        lng: lng,
                                        height: height ? height || .01 : void 0,
                                        heightBySeries: heightsBySeries[i],
                                        seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : void 0,
                                        heat: heat || 0,
                                        toolTipData: {
                                            location: {
                                                displayName: locationDispName,
                                                value: locations[i]
                                            },
                                            height: {
                                                displayName: heightDispName,
                                                value: heightFormatter.format(heights[i])
                                            },
                                            heat: {
                                                displayName: heatDispName,
                                                value: heatFormatter.format(heats[i])
                                            }
                                        }
                                    };
                                    this.renderData.push(renderDatum), longitudes || latlng || this.geocodeRenderDatum(renderDatum, place, locationType);
                                }
                            }
                            try {
                                this.renderMagic();
                            } catch (e) {}
                        }
                    }, GlobeMap.prototype.geocodeRenderDatum = function(renderDatum, place, locationType) {
                        var _this = this, placeKey = place + "/" + locationType;
                        this.globeMapLocationCache[placeKey] = {}, this.locationsToLoad++;
                        try {
                            var geocoder = powerbi.visuals.BI.Services.GeocodingManager.geocode;
                        } catch (e) {
                            geocoder = visuals.services.geocode;
                        }
                        geocoder && geocoder(place, locationType).always(function(latlng) {
                            _this.globeMapLocationCache[placeKey] = latlng, _this.locationsLoaded++, latlng.latitude && latlng.longitude && (renderDatum.lat = latlng.latitude, 
                            renderDatum.lng = latlng.longitude, _this.defferedRender());
                        });
                    }, GlobeMap.prototype.defferedRender = function() {
                        var _this = this;
                        this.deferredRenderTimerId || (this.deferredRenderTimerId = setTimeout(function() {
                            _this.deferredRenderTimerId = null, _this.composeRenderData();
                        }, 500));
                    }, GlobeMap.prototype.initRayCaster = function() {
                        var _this = this;
                        this.rayCaster = new THREE.Raycaster();
                        var mouseDownTime, settings = this.settings, mousePosNormalized = this.mousePosNormalized = new THREE.Vector2(), mousePos = this.mousePos = new THREE.Vector2(), element = this.container.get(0);
                        $(this.domElement).on("mousemove", function(event) {
                            var rect = element.getBoundingClientRect();
                            mousePos.x = event.clientX, mousePos.y = event.clientY, mousePosNormalized.x = (event.clientX - rect.left) / rect.width * 2 - 1, 
                            mousePosNormalized.y = 2 * -((event.clientY - rect.top) / rect.height) + 1, _this.needsRender = !0;
                        }).on("mousedown", function(event) {
                            mouseDownTime = Date.now();
                        }).on("mouseup", function(event) {
                            Date.now() - mouseDownTime > settings.clickInterval || (_this.hoveredBar && event.shiftKey ? (_this.selectedBar = _this.hoveredBar, 
                            _this.animateCamera(_this.selectedBar.position, function() {
                                _this.selectedBar && (_this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius)), 
                                _this.orbitControls.minDistance = 1);
                            })) : _this.selectedBar && (_this.animateCamera(_this.selectedBar.position, function() {
                                _this.orbitControls.center.set(0, 0, 0), _this.orbitControls.minDistance = settings.earthRadius + 1;
                            }), _this.selectedBar = null));
                        }).on("mousewheel DOMMouseScroll", function(e) {
                            if (_this.needsRender = !0, _this.orbitControls.enabled && _this.orbitControls.enableZoom) {
                                _this.heatTexture.needsUpdate = !0, e = e.originalEvent;
                                var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1, scale = delta > 0 ? _this.settings.heatmapScaleOnZoom : 1 / _this.settings.heatmapScaleOnZoom;
                                _this.heatmap.multiply(scale), _this.heatmap.update();
                            }
                        });
                    }, GlobeMap.prototype.intersectBars = function() {
                        if (this.rayCaster && this.barsGroup) {
                            var rayCaster = this.rayCaster;
                            rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                            var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                            if (intersects && intersects.length > 0) {
                                var object = intersects[0].object;
                                if (!object || !object.toolTipData) return;
                                var toolTipData = object.toolTipData, toolTipItems = [];
                                toolTipData.location.displayName && toolTipItems.push(toolTipData.location), toolTipData.series && toolTipItems.push(toolTipData.series), 
                                toolTipData.height.displayName && toolTipItems.push(toolTipData.height), toolTipData.heat.displayName && toolTipItems.push(toolTipData.heat), 
                                this.hoveredBar = object, visuals.TooltipManager.ToolTipInstance.show(toolTipItems, {
                                    x: this.mousePos.x,
                                    y: this.mousePos.y,
                                    width: 0,
                                    height: 0
                                });
                            } else this.hoveredBar = null, visuals.TooltipManager.ToolTipInstance.hide();
                        }
                    }, GlobeMap.prototype.animateCamera = function(to, done) {
                        var _this = this;
                        if (this.camera) {
                            var startTime = Date.now(), duration = this.settings.cameraAnimDuration, endTime = startTime + duration, startPos = this.camera.position.clone().normalize(), endPos = to.clone().normalize(), length = this.camera.position.length(), easeInOut = function(t) {
                                return t *= 2, 1 > t ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);
                            }, onUpdate = function() {
                                var now = Date.now(), t = (now - startTime) / duration;
                                t > 1 && (t = 1), t = easeInOut(t);
                                var pos = new THREE.Vector3().add(startPos.clone().multiplyScalar(1 - t)).add(endPos.clone().multiplyScalar(t)).normalize().multiplyScalar(length);
                                _this.camera.position = pos, endTime > now ? requestAnimationFrame(onUpdate) : done && done(), 
                                _this.needsRender = !0;
                            };
                            requestAnimationFrame(onUpdate);
                        }
                    }, GlobeMap.prototype.destroy = function() {
                        if (clearTimeout(this.deferredRenderTimerId), this.renderLoopEnabled = !1, this.scene = null, 
                        this.heatmap = null, this.heatTexture = null, this.camera = null, this.renderer) {
                            if (this.renderer.context) {
                                var extension = this.renderer.context.getExtension("WEBGL_lose_context");
                                extension && extension.loseContext(), this.renderer.context = null;
                            }
                            this.renderer.domElement = null;
                        }
                        this.renderer = null, this.renderData = null, this.barsGroup = null, this.orbitControls && this.orbitControls.dispose(), 
                        this.orbitControls = null, this.domElement && $(this.domElement).off("mousemove mouseup mousedown mousewheel DOMMouseScroll"), 
                        this.domElement = null, this.container && this.container.empty();
                    }, GlobeMap.prototype.initMercartorSphere = function() {
                        if (!GlobeMap.MercartorSphere) {
                            var MercartorSphere = function(radius, widthSegments, heightSegments) {
                                function interplolate(a, b, t) {
                                    return (1 - t) * a + t * b;
                                }
                                function interpolateVertex(u, v, t) {
                                    var maxLng = 2 * Math.PI, maxLat = Math.PI, radius = this.radius, sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat), sphereY = -radius * Math.cos(v * maxLat), sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat), planeX = u * radius * 2 - radius, planeY = v * radius * 2 - radius, planeZ = 0, x = interplolate(sphereX, planeX, t), y = interplolate(sphereY, planeY, t), z = interplolate(sphereZ, planeZ, t);
                                    return new THREE.Vector3(x, y, z);
                                }
                                function interpolateUV(u, v, t) {
                                    var lat = 90 * (v - .5) * 2 / 180 * Math.PI, sin = Math.sin(lat), normalizedV = .5 + .25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                                    return new THREE.Vector2(u, normalizedV);
                                }
                                THREE.Geometry.call(this), this.radius = radius, this.widthSegments = widthSegments, 
                                this.heightSegments = heightSegments, this.t = 0;
                                var x, y, vertices = [], uvs = [];
                                for (y = 0; heightSegments >= y; y++) {
                                    var verticesRow = [], uvsRow = [];
                                    for (x = 0; widthSegments >= x; x++) {
                                        var u = x / widthSegments, v = y / heightSegments;
                                        this.vertices.push(interpolateVertex.call(this, u, v, this.t)), uvsRow.push(interpolateUV.call(this, u, v, this.t)), 
                                        verticesRow.push(this.vertices.length - 1);
                                    }
                                    vertices.push(verticesRow), uvs.push(uvsRow);
                                }
                                for (y = 0; y < this.heightSegments; y++) for (x = 0; x < this.widthSegments; x++) {
                                    var v1 = vertices[y][x + 1], v2 = vertices[y][x], v3 = vertices[y + 1][x], v4 = vertices[y + 1][x + 1], n1 = this.vertices[v1].clone().normalize(), n2 = this.vertices[v2].clone().normalize(), n3 = this.vertices[v3].clone().normalize(), n4 = this.vertices[v4].clone().normalize(), uv1 = uvs[y][x + 1].clone(), uv2 = uvs[y][x].clone(), uv3 = uvs[y + 1][x].clone(), uv4 = uvs[y + 1][x + 1].clone(), normals = [ n1, n2, n3, n4 ];
                                    this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals)), this.faceVertexUvs[0].push([ uv1, uv2, uv3, uv4 ]);
                                }
                                this.computeCentroids(), this.computeFaceNormals(), this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
                            };
                            MercartorSphere.prototype = Object.create(THREE.Geometry.prototype), GlobeMap.MercartorSphere = MercartorSphere;
                        }
                    }, GlobeMap.prototype.getBingMapCanvas = function(resolution) {
                        function generateQuads(res, quad) {
                            resolution >= res && (res === resolution && loadTile(quad), generateQuads(res + 1, quad + "0"), 
                            generateQuads(res + 1, quad + "1"), generateQuads(res + 1, quad + "2"), generateQuads(res + 1, quad + "3"));
                        }
                        function loadTile(quad) {
                            var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}", numServers = 7, server = Math.round(Math.random() * numServers), language = navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language, url = template.replace("{server}", server).replace("{quad}", quad).replace("{language}", language), coords = getCoords(quad), tile = new Image();
                            tile.onload = function() {
                                tilesLoaded++, canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize), 
                                tilesLoaded === numTiles && canvas.trigger("ready", resolution);
                            }, tile.crossOrigin = "", tile.src = url;
                        }
                        function getCoords(quad) {
                            for (var x = 0, y = 0, last = quad.length - 1, i = last; i >= 0; i--) {
                                var chr = quad.charAt(i), pow = Math.pow(2, last - i);
                                "1" === chr ? x += pow : "2" === chr ? y += pow : "3" === chr && (x += pow, y += pow);
                            }
                            return {
                                x: x,
                                y: y
                            };
                        }
                        var tileSize = 256, numSegments = Math.pow(2, resolution), numTiles = numSegments * numSegments, tilesLoaded = 0, canvasSize = tileSize * numSegments, canvas = $("<canvas/>").attr({
                            width: canvasSize,
                            height: canvasSize
                        }), canvasElem = canvas.get(0), canvasContext = canvasElem.getContext("2d");
                        return generateQuads(0, ""), canvas;
                    }, GlobeMap.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Location"),
                            preferredTypes: [ {
                                geography: {
                                    address: !0
                                }
                            }, {
                                geography: {
                                    city: !0
                                }
                            }, {
                                geography: {
                                    continent: !0
                                }
                            }, {
                                geography: {
                                    country: !0
                                }
                            }, {
                                geography: {
                                    county: !0
                                }
                            }, {
                                geography: {
                                    place: !0
                                }
                            }, {
                                geography: {
                                    postalCode: !0
                                }
                            }, {
                                geography: {
                                    region: !0
                                }
                            }, {
                                geography: {
                                    stateOrProvince: !0
                                }
                            } ]
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "X",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Longitude",
                            description: "Use to override the longitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    longitude: !0
                                }
                            } ]
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Latitude",
                            description: "Use to override the latitude of locations",
                            preferredTypes: [ {
                                geography: {
                                    latitude: !0
                                }
                            } ]
                        }, {
                            name: "Height",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Bar Height"
                        }, {
                            name: "Heat",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Heat Intensity"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        type: {
                                            formatting: {
                                                legendPosition: !0
                                            }
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleText"),
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    defaultColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DefaultColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    showAllDataPoints: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint_Show_All"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillRule: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Gradient"),
                                        type: {
                                            fillRule: {}
                                        },
                                        rule: {
                                            inputRole: "Gradient",
                                            output: {
                                                property: "fill",
                                                selector: [ "Category" ]
                                            }
                                        }
                                    }
                                }
                            },
                            categoryLabels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_CategoryLabels"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 1
                                },
                                Height: {
                                    max: 1
                                },
                                Heat: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            bind: {
                                                to: "Height"
                                            }
                                        }, {
                                            bind: {
                                                to: "Heat"
                                            }
                                        }, {
                                            bind: {
                                                to: "X"
                                            }
                                        }, {
                                            bind: {
                                                to: "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                },
                                rowCount: {
                                    preferred: {
                                        min: 2
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            custom: {}
                        }
                    }, GlobeMap;
                }();
                samples.GlobeMap = GlobeMap;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, RadarChartWebBehavior = function() {
                    function RadarChartWebBehavior() {}
                    return RadarChartWebBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        var selection = this.selection = options.selection, clearCatcher = options.clearCatcher;
                        selection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, RadarChartWebBehavior.prototype.renderSelection = function(hasSelection) {
                        this.selection.style("opacity", function(d) {
                            return hasSelection && !d.selected ? RadarChart.DimmedAreaFillOpacity : RadarChart.NodeFillOpacity;
                        });
                    }, RadarChartWebBehavior;
                }();
                samples.RadarChartWebBehavior = RadarChartWebBehavior;
                var RadarChart = function() {
                    function RadarChart(options) {
                        options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        options.margin && (this.margin = options.margin));
                    }
                    return RadarChart.converter = function(dataView, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories.length > 0 && dataView.categorical.categories[0] && dataView.categorical.values && dataView.categorical.values.length > 0 && colors)) return {
                            legendData: {
                                dataPoints: []
                            },
                            settings: {
                                showLegend: !0
                            },
                            series: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings()
                        };
                        for (var catDv = dataView.categorical, values = catDv.values, grouped = catDv && catDv.values ? catDv.values.grouped() : null, series = [], colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill), legendData = {
                            fontSize: 8.25,
                            dataPoints: [],
                            title: ""
                        }, legendSettings = RadarChart.parseSettings(dataView), dataLabelsSettings = RadarChart.parseLabelSettings(dataView), i = 0, iLen = values.length; iLen > i; i++) {
                            var color = colors.getColorByIndex(i).value, serieIdentity = void 0, queryName = void 0, displayName = void 0, dataPoints = [], columnGroup = grouped && grouped.length > i && grouped[i].values ? grouped[i] : null;
                            if (values[i].source) {
                                var source = values[i].source;
                                if (source.queryName && (queryName = source.queryName, serieIdentity = visuals.SelectionId.createWithMeasure(queryName)), 
                                source.displayName && (displayName = source.displayName), source.objects) {
                                    var objects = source.objects;
                                    color = colorHelper.getColorForMeasure(objects, queryName);
                                }
                            }
                            legendData.dataPoints.push({
                                label: displayName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: serieIdentity
                            });
                            for (var k = 0, kLen = values[i].values.length; kLen > k; k++) {
                                var dataPointIdentity = visuals.SelectionIdBuilder.builder().withMeasure(queryName).withCategory(catDv.categories[0], k).withSeries(dataView.categorical.values, columnGroup).createSelectionId(), tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i), labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp), fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                                dataPoints.push({
                                    x: k,
                                    y: values[i].values[k],
                                    color: color,
                                    identity: dataPointIdentity,
                                    selected: !1,
                                    tooltipInfo: tooltipInfo,
                                    value: values[i].values[k],
                                    labelFormatString: labelFormatString,
                                    labelFontSize: fontSizeInPx
                                });
                            }
                            dataPoints.length > 0 && series.push({
                                fill: color,
                                name: displayName,
                                data: dataPoints,
                                identity: serieIdentity
                            });
                        }
                        return {
                            legendData: legendData,
                            settings: legendSettings,
                            series: series,
                            dataLabelsSettings: dataLabelsSettings
                        };
                    }, RadarChart.prototype.init = function(options) {
                        var element = options.element;
                        this.svg || (this.svg = d3.select(element.get(0)).append("svg"), this.svg.style("position", "absolute")), 
                        this.margin || (this.margin = RadarChart.DefaultMargin), this.svg.classed(RadarChart.VisualClassName, !0), 
                        this.interactivityService = visuals.createInteractivityService(options.host), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top), 
                        this.colors = options.style.colorPalette.dataColors, this.mainGroupElement = this.svg.append("g"), 
                        this.segments = this.mainGroupElement.append("g").classed(RadarChart.Segments["class"], !0), 
                        this.zeroSegment = this.mainGroupElement.append("g").classed(RadarChart.ZeroSegment["class"], !0), 
                        this.axis = this.mainGroupElement.append("g").classed(RadarChart.Axis["class"], !0), 
                        this.chart = this.mainGroupElement.append("g").classed(RadarChart.Chart["class"], !0);
                    }, RadarChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            this.radarChartData = RadarChart.converter(dataView, this.colors);
                            var dataViewMetadataColumn, categories = [], series = this.radarChartData.series, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                            dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && (categories = dataView.categorical.categories[0].values), 
                            dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0 && (dataViewMetadataColumn = dataView.metadata.columns[0]), 
                            this.viewport = {
                                height: options.viewport.height > 0 ? options.viewport.height : 0,
                                width: options.viewport.width > 0 ? options.viewport.width : 0
                            }, this.parseLegendProperties(dataView), this.renderLegend(this.radarChartData), 
                            this.updateViewport(), this.svg.attr({
                                height: this.viewport.height,
                                width: this.viewport.width
                            });
                            var mainGroup = this.mainGroupElement;
                            mainGroup.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                            var width = this.viewport.width - this.margin.left - this.margin.right, height = this.viewport.height - this.margin.top - this.margin.bottom;
                            this.angle = RadarChart.Radians / categories.length, this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2, 
                            this.drawCircularSegments(categories), this.drawAxes(categories), this.drawAxesLabels(categories, dataViewMetadataColumn), 
                            this.drawChart(series, duration), this.drawDataLabels(series), this.drawZeroCircularSegment(categories), 
                            0 !== this.zeroPointRadius ? this.drawZeroLabel() : this.mainGroupElement.selectAll(RadarChart.ZeroLabel.selector).remove();
                        }
                    }, RadarChart.prototype.getRadarChartLabelLayout = function(labelSettings, allDataPoints) {
                        var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager(), angle = this.angle, viewport = this.viewport, halfHeight = this.viewport.height / 2, halfWidth = this.viewport.width / 2, y = this.calculateChartDomain(this.radarChartData.series);
                        return {
                            labelText: function(d) {
                                var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
                                if (0 === labelSettings.displayUnits) {
                                    var maxDataPoint = _.max(allDataPoints, function(d) {
                                        return d.value;
                                    }), maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
                                    formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
                                }
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: formmater.format(d.value),
                                    maxWidth: viewport.width,
                                    fontSize: labelSettings.fontSize
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth;
                                },
                                y: function(d) {
                                    return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 7;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.value;
                            },
                            style: {
                                fill: labelSettings.labelColor,
                                "font-size": function(d) {
                                    return PixelConverter.fromPoint(labelSettings.fontSize);
                                }
                            }
                        };
                    }, RadarChart.prototype.drawCircularSegments = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius, level = 0; levels - 1 > level; level++) for (var levelFactor = radius * ((level + 1) / levels), transform = -1 * levelFactor, i = 0; i < values.length; i++) data.push({
                            x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                            y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                            x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.Segments.selector).selectAll(RadarChart.SegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.SegmentNode["class"], !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawDataLabels = function(series) {
                        var allDataPoints = this.getAllDataPointsList(series);
                        if (this.radarChartData.dataLabelsSettings.show) {
                            var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints), viewport = this.viewport, labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
                            labels.attr("transform", visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
                        } else visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
                    }, RadarChart.prototype.drawAxes = function(values) {
                        var angle = this.angle, radius = -1 * this.radius, selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisNode.selector), axis = selection.data(values);
                        axis.enter().append("svg:line"), axis.attr({
                            x1: 0,
                            y1: 0,
                            x2: function(name, i) {
                                return radius * Math.sin(i * angle);
                            },
                            y2: function(name, i) {
                                return radius * Math.cos(i * angle);
                            }
                        }).classed(RadarChart.AxisNode["class"], !0), axis.exit().remove();
                    }, RadarChart.prototype.drawAxesLabels = function(values, dataViewMetadataColumn) {
                        var _this = this, angle = this.angle, radius = -1 * this.radius, length = values.length, formatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, !0),
                            value: values[0],
                            value2: values[length - 1]
                        }), selection = this.mainGroupElement.select(RadarChart.Axis.selector).selectAll(RadarChart.AxisLabel.selector), labels = selection.data(values);
                        labels.enter().append("svg:text"), labels.attr({
                            "text-anchor": "middle",
                            dy: "1.5em",
                            transform: visuals.SVGUtil.translate(0, -10),
                            x: function(name, i) {
                                return (radius - 30) * Math.sin(i * angle);
                            },
                            y: function(name, i) {
                                return (radius - 20) * Math.cos(i * angle);
                            }
                        }).text(function(item) {
                            var properties = {
                                fontFamily: RadarChart.AxesLabelsFontFamily,
                                fontSize: RadarChart.AxesLabelsfontSize,
                                text: formatter.format(item)
                            };
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, Math.min(RadarChart.AxesLabelsMaxWidth, _this.viewport.width));
                        }).classed(RadarChart.AxisLabel["class"], !0), labels.exit().remove();
                    }, RadarChart.prototype.drawChart = function(series, duration) {
                        var angle = this.angle, dotRadius = 5, dataPoints = this.getDataPoints(series), stack = d3.layout.stack(), layers = stack(dataPoints), y = this.calculateChartDomain(series), calculatePoints = function(points) {
                            return points.map(function(value) {
                                var x1 = -1 * y(value.y) * Math.sin(value.x * angle), y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                                return x1 + "," + y1;
                            }).join(" ");
                        }, areas = this.chart.selectAll(RadarChart.ChartArea.selector).data(layers);
                        areas.enter().append("g").classed(RadarChart.ChartArea["class"], !0);
                        var polygon = areas.selectAll(RadarChart.ChartPolygon.selector).data(function(d) {
                            return d && d.length > 0 ? [ d ] : [];
                        });
                        polygon.enter().append("polygon").classed(RadarChart.ChartPolygon["class"], !0), 
                        polygon.style("fill", function(d) {
                            return d[0].color;
                        }).style("opacity", RadarChart.DimmedAreaFillOpacity).on("mouseover", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.AreaFillOpacity);
                        }).on("mouseout", function(d) {
                            d3.select(this).transition().duration(duration).style("opacity", RadarChart.DimmedAreaFillOpacity);
                        }).attr("points", calculatePoints), polygon.exit().remove(), areas.exit().remove();
                        var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                        selection.enter().append("g").classed(RadarChart.ChartNode["class"], !0);
                        var dots = selection.selectAll(RadarChart.ChartDot.selector).data(function(d) {
                            return d.filter(function(d) {
                                return null != d.y;
                            });
                        });
                        dots.enter().append("svg:circle").classed(RadarChart.ChartDot["class"], !0), dots.attr("r", dotRadius).attr({
                            cx: function(value) {
                                return -1 * y(value.y) * Math.sin(value.x * angle);
                            },
                            cy: function(value) {
                                return -1 * y(value.y) * Math.cos(value.x * angle);
                            }
                        }).style("fill", function(d) {
                            return d.color;
                        }), dots.exit().remove(), visuals.TooltipManager.addTooltip(dots, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }, !0), selection.exit().remove();
                        var behaviorOptions = void 0;
                        if (this.interactivityService) {
                            var dataPointsToBind = this.getAllDataPointsList(series);
                            behaviorOptions = {
                                selection: dots,
                                clearCatcher: this.svg
                            }, this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
                        }
                    }, RadarChart.prototype.calculateChartDomain = function(series) {
                        var radius = this.radius, dataPointsList = this.getAllDataPointsList(series), minValue = d3.min(dataPointsList, function(d) {
                            return d.y;
                        }), maxValue = d3.max(dataPointsList, function(d) {
                            return d.y;
                        });
                        this.isPercentChart(dataPointsList) && (minValue = minValue >= 0 ? 0 : -1, maxValue = 0 >= maxValue ? 0 : 1);
                        var y = d3.scale.linear().domain([ minValue, maxValue ]).range([ 0, radius ]);
                        return this.zeroPointRadius = 0 > minValue && maxValue > 0 ? y(0) : 0, y;
                    }, RadarChart.prototype.renderLegend = function(radarChartData) {
                        if (radarChartData.legendData) {
                            var legendData = radarChartData.legendData;
                            if (this.legendObjectProperties) {
                                visuals.LegendData.update(legendData, this.legendObjectProperties);
                                var position = this.legendObjectProperties[visuals.legendProps.position];
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            } else this.legend.changeOrientation(visuals.LegendPosition.Top);
                            var viewport = this.viewport;
                            this.legend.drawLegend(legendData, {
                                height: viewport.height,
                                width: viewport.width
                            }), visuals.Legend.positionChartArea(this.svg, this.legend);
                        }
                    }, RadarChart.prototype.drawZeroCircularSegment = function(values) {
                        for (var data = [], angle = this.angle, factor = RadarChart.SegmentFactor, radius = this.zeroPointRadius, transform = -1 * radius, i = 0; i < values.length; i++) data.push({
                            x1: radius * (1 - factor * Math.sin(i * angle)),
                            y1: radius * (1 - factor * Math.cos(i * angle)),
                            x2: radius * (1 - factor * Math.sin((i + 1) * angle)),
                            y2: radius * (1 - factor * Math.cos((i + 1) * angle)),
                            translate: visuals.SVGUtil.translate(transform, transform)
                        });
                        var selection = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroSegmentNode.selector).data(data);
                        selection.enter().append("svg:line").classed(RadarChart.ZeroSegmentNode["class"], !0), 
                        selection.attr({
                            x1: function(item) {
                                return item.x1;
                            },
                            y1: function(item) {
                                return item.y1;
                            },
                            x2: function(item) {
                                return item.x2;
                            },
                            y2: function(item) {
                                return item.y2;
                            },
                            transform: function(item) {
                                return item.translate;
                            }
                        }), selection.exit().remove();
                    }, RadarChart.prototype.drawZeroLabel = function() {
                        var data = [];
                        data.push({
                            x: this.zeroPointRadius * (1 - RadarChart.SegmentFactor) + 5,
                            y: -1 * this.zeroPointRadius
                        });
                        var zeroLabel = this.mainGroupElement.select(RadarChart.ZeroSegment.selector).selectAll(RadarChart.ZeroLabel.selector).data(data);
                        zeroLabel.enter().append("text").classed(RadarChart.ZeroLabel["class"], !0).text("0"), 
                        zeroLabel.attr({
                            x: function(item) {
                                return item.x;
                            },
                            y: function(item) {
                                return item.y;
                            }
                        });
                    }, RadarChart.prototype.getDataPoints = function(series) {
                        for (var dataPoints = [], _i = 0, series_1 = series; _i < series_1.length; _i++) {
                            var serie = series_1[_i];
                            dataPoints.push(serie.data);
                        }
                        return dataPoints;
                    }, RadarChart.prototype.getAllDataPointsList = function(series) {
                        for (var dataPoints = [], _i = 0, series_2 = series; _i < series_2.length; _i++) {
                            var serie = series_2[_i];
                            dataPoints = dataPoints.concat(serie.data);
                        }
                        return dataPoints;
                    }, RadarChart.prototype.isPercentChart = function(dataPointsList) {
                        for (var _i = 0, dataPointsList_1 = dataPointsList; _i < dataPointsList_1.length; _i++) {
                            var dataPoint = dataPointsList_1[_i];
                            if (-1 === dataPoint.labelFormatString.indexOf("%")) return !1;
                        }
                        return !0;
                    }, RadarChart.prototype.parseLegendProperties = function(dataView) {
                        return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                    }, RadarChart.parseSettings = function(dataView) {
                        var objects;
                        return objects = dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null, 
                        {
                            showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, !0)
                        };
                    }, RadarChart.parseLabelSettings = function(dataView) {
                        var objects;
                        objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
                        var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings(), labelsObj = {
                            show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
                            displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
                            precision: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),
                            fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
                            position: dataLabelsSettings.position
                        };
                        return labelsObj;
                    }, RadarChart.prototype.enumerateObjectInstances = function(options) {
                        var settings, enumeration = new visuals.ObjectEnumerationBuilder();
                        if (!this.radarChartData || !this.radarChartData.settings) return [];
                        switch (settings = this.radarChartData.settings, options.objectName) {
                          case "legend":
                            enumeration.pushInstance(this.enumerateLegend(settings));
                            break;

                          case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration);
                        }
                        return enumeration.complete();
                    }, RadarChart.prototype.getLabelSettingsOptions = function(enumeration, labelSettings) {
                        return {
                            enumeration: enumeration,
                            dataLabelsSettings: labelSettings,
                            show: !0,
                            displayUnits: !0,
                            precision: !0,
                            fontSize: !0
                        };
                    }, RadarChart.prototype.enumerateDataLabels = function(enumeration) {
                        var labelSettings = this.radarChartData.dataLabelsSettings;
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
                    }, RadarChart.prototype.enumerateLegend = function(settings) {
                        var legend, labelColor, showTitle = !0, titleText = "", fontSize = 8;
                        return showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle), 
                        titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText), 
                        labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor), 
                        fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize), 
                        legend = {
                            objectName: "legend",
                            displayName: "legend",
                            selector: null,
                            properties: {
                                show: settings.showLegend,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                labelColor: labelColor,
                                fontSize: fontSize
                            }
                        };
                    }, RadarChart.prototype.enumerateDataPoint = function(enumeration) {
                        if (this.radarChartData && this.radarChartData.series) for (var series = this.radarChartData.series, _i = 0, series_3 = series; _i < series_3.length; _i++) {
                            var serie = series_3[_i];
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: serie.name,
                                selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: serie.fill
                                        }
                                    }
                                }
                            });
                        }
                    }, RadarChart.prototype.updateViewport = function() {
                        var legendPosition, legendMargins = this.legend.getMargins();
                        switch (legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]]) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, RadarChart.capabilities = {
                        dataRoles: [ {
                            displayName: "Category",
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping
                        }, {
                            displayName: "Y Axis",
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    min: 1,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Y"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_Legend"),
                                description: powerbi.data.createDisplayNameGetter("Visual_LegendDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendPosition"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendPositionDescription"),
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitle"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendShowTitleDescription"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendName"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LegendNameDescription"),
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LegendTitleColor"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointDescription"),
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabels"),
                                description: powerbi.data.createDisplayNameGetter("Visual_DataPointsLabelsDescription"),
                                properties: {
                                    show: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_LabelsFill"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_LabelsFillDescription"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_DisplayUnits"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_DisplayUnitsDescription"),
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Precision"),
                                        description: powerbi.data.createDisplayNameGetter("Visual_PrecisionDescription"),
                                        placeHolderText: powerbi.data.createDisplayNameGetter("Visual_Precision_Auto"),
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_TextSize"),
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, RadarChart.formatStringProp = {
                        objectName: "general",
                        propertyName: "formatString"
                    }, RadarChart.Properties = {
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            displayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            precision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        }
                    }, RadarChart.VisualClassName = "radarChart", RadarChart.Segments = CreateClassAndSelector("segments"), 
                    RadarChart.SegmentNode = CreateClassAndSelector("segmentNode"), RadarChart.ZeroSegment = CreateClassAndSelector("zeroSegment"), 
                    RadarChart.ZeroSegmentNode = CreateClassAndSelector("zeroSegmentNode"), RadarChart.ZeroLabel = CreateClassAndSelector("zeroLabel"), 
                    RadarChart.Axis = CreateClassAndSelector("axis"), RadarChart.AxisNode = CreateClassAndSelector("axisNode"), 
                    RadarChart.AxisLabel = CreateClassAndSelector("axisLabel"), RadarChart.Chart = CreateClassAndSelector("chart"), 
                    RadarChart.ChartNode = CreateClassAndSelector("chartNode"), RadarChart.ChartArea = CreateClassAndSelector("chartArea"), 
                    RadarChart.ChartPolygon = CreateClassAndSelector("chartPolygon"), RadarChart.ChartDot = CreateClassAndSelector("chartDot"), 
                    RadarChart.DefaultMargin = {
                        top: 50,
                        bottom: 50,
                        right: 100,
                        left: 100
                    }, RadarChart.SegmentLevels = 6, RadarChart.SegmentFactor = 1, RadarChart.Radians = 2 * Math.PI, 
                    RadarChart.Scale = 1, RadarChart.NodeFillOpacity = 1, RadarChart.AreaFillOpacity = .6, 
                    RadarChart.DimmedAreaFillOpacity = .4, RadarChart.AxesLabelsFontFamily = "sans-serif", 
                    RadarChart.AxesLabelsfontSize = "11px", RadarChart.AxesLabelsMaxWidth = 200, RadarChart;
                }();
                samples.RadarChart = RadarChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, ValueFormatter = powerbi.visuals.valueFormatter, getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, PixelConverter = jsCommon.PixelConverter, HistogramChartWarning = function() {
                    function HistogramChartWarning(message) {
                        this.message = message;
                    }
                    return Object.defineProperty(HistogramChartWarning.prototype, "code", {
                        get: function() {
                            return "BulletChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), HistogramChartWarning.prototype.getMessages = function(resourceProvider) {
                        return {
                            message: this.message,
                            title: resourceProvider.get(""),
                            detail: resourceProvider.get("")
                        };
                    }, HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big", 
                    HistogramChartWarning;
                }();
                samples.HistogramChartWarning = HistogramChartWarning;
                var Histogram = function() {
                    function Histogram(histogramConstructorOptions) {
                        this.ColumnPadding = 1, this.MinColumnHeight = 1, this.MinOpacity = .3, this.MaxOpacity = 1, 
                        this.MinNumberOfBins = 0, this.MaxNumberOfBins = 100, this.MinPrecision = 0, this.MaxPrecision = 17, 
                        this.TooltipDisplayName = "Range", this.SeparatorNumbers = ", ", this.LegendSize = 50, 
                        this.YLegendSize = 50, this.XLegendSize = 50, this.AxisSize = 30, this.DataLabelMargin = 0, 
                        this.widthOfColumn = 0, this.yTitleMargin = 0, this.outerPadding = 5, this.ExcludeBrackets = {
                            left: "(",
                            right: ")"
                        }, this.IncludeBrackets = {
                            left: "[",
                            right: "]"
                        }, this.margin = {
                            top: 10,
                            right: 10,
                            bottom: 10,
                            left: 10
                        }, this.durationAnimations = 200, this.oldInnerPaddingRatio = visuals.CartesianChart.InnerPaddingRatio, 
                        this.oldMinOrdinalRectThickness = visuals.CartesianChart.MinOrdinalRectThickness, 
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(9)
                        }, histogramConstructorOptions && (histogramConstructorOptions.svg && (this.svg = histogramConstructorOptions.svg), 
                        histogramConstructorOptions.animator && (this.animator = histogramConstructorOptions.animator), 
                        this.margin = histogramConstructorOptions.margin || this.margin);
                    }
                    return Object.defineProperty(Histogram.prototype, "columnsSelection", {
                        get: function() {
                            return this.main.select(Histogram.Columns.selector).selectAll(Histogram.Column.selector);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Histogram.prototype.init = function(visualsOptions) {
                        this.hostService = visualsOptions.host, this.svg ? this.root = this.svg : this.root = d3.select(visualsOptions.element.get(0)).append("svg");
                        var style = visualsOptions.style;
                        this.colors = style && style.colorPalette ? style.colorPalette.dataColors : new visuals.DataColorPalette(), 
                        this.root.classed(Histogram.ClassName, !0), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(Histogram.Axes["class"], !0), 
                        this.axisX = this.axes.append("g").classed(Histogram.Axis["class"], !0), this.axisY = this.axes.append("g").classed(Histogram.Axis["class"], !0), 
                        this.legend = this.main.append("g").classed(Histogram.Legends["class"], !0), this.columns = this.main.append("g").classed(Histogram.Columns["class"], !0), 
                        this.labels = this.main.append("g").classed(Histogram.Labels["class"], !0), this.selectionManager = new SelectionManager({
                            hostServices: visualsOptions.host
                        });
                    }, Histogram.prototype.converter = function(dataView) {
                        var _this = this;
                        if (!(dataView && dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0)) return null;
                        var settings, histogramLayout, values, data, xScale, yScale, valueFormatter, xLabelFormatter, yLabelFormatter, numericalValues = [], frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;
                        if (dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && (frequencies = dataView.categorical.values[0].values), 
                        dataView.categorical.categories[0].identity && dataView.categorical.categories[0].identity.length > 0 && (identities = dataView.categorical.categories[0].identity), 
                        settings = this.parseSettings(dataView), !settings) return null;
                        values = this.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities), 
                        values.forEach(function(value) {
                            numericalValues.push(value.value), sumFrequency += value.frequency;
                        }), histogramLayout = d3.layout.histogram(), settings.bins && settings.bins > this.MinNumberOfBins && (histogramLayout = histogramLayout.bins(settings.bins)), 
                        data = histogramLayout.frequency(settings.frequency)(numericalValues), data.forEach(function(bin, index) {
                            var filteredValues, frequency;
                            filteredValues = values.filter(function(value) {
                                return _this.isValueContainedInRange(value, bin, index);
                            }), frequency = filteredValues.reduce(function(previousValue, currentValue) {
                                return previousValue + currentValue.frequency;
                            }, 0), bin.y = settings.frequency ? frequency : frequency / sumFrequency, shiftByValues += bin.length;
                        });
                        var maxYvalue = null !== settings.yEnd && settings.yEnd > settings.yStart ? settings.yEnd : d3.max(data, function(item) {
                            return item.y;
                        }), minYValue = settings.yStart < maxYvalue ? settings.yStart : 0;
                        return settings.yEnd = maxYvalue, settings.yStart = minYValue, settings.maxX = d3.max(data, function(item) {
                            return d3.max(item);
                        }), xScale = d3.scale.linear().domain([ d3.min(data, function(item) {
                            return d3.min(item);
                        }), d3.max(data, function(item) {
                            return d3.max(item);
                        }) ]).range([ 0, this.viewport.width - this.YLegendSize - this.AxisSize ]), yScale = d3.scale.linear().domain([ minYValue, maxYvalue ]).range([ this.viewport.height - this.LegendSize, this.outerPadding ]), 
                        valueFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties.general.formatString),
                            value: values[0].value,
                            value2: values[values.length - 1].value,
                            precision: settings.precision
                        }), xLabelFormatter = ValueFormatter.create({
                            value: 0 === settings.xDisplayUnits ? values[values.length - 1].value : settings.xDisplayUnits,
                            precision: settings.xPrecision
                        }), yLabelFormatter = ValueFormatter.create({
                            value: settings.yDisplayUnits,
                            precision: settings.yPrecision
                        }), {
                            xScale: xScale,
                            yScale: yScale,
                            settings: settings,
                            data: this.getData(values, numericalValues, data, settings, yLabelFormatter, xLabelFormatter),
                            formatter: valueFormatter,
                            xLabelFormatter: xLabelFormatter,
                            yLabelFormatter: yLabelFormatter
                        };
                    }, Histogram.prototype.getValuesByFrequencies = function(sourceValues, frequencies, identities) {
                        var values = [];
                        return sourceValues.forEach(function(item, index) {
                            var frequency = 1, value = Number(item);
                            value = isNaN(value) ? 0 : value, frequencies && frequencies[index] && !isNaN(frequencies[index]) && frequencies[index] > 1 && (frequency = frequencies[index]), 
                            values.push({
                                value: value,
                                frequency: frequency,
                                selectionId: visuals.SelectionId.createWithId(identities[index])
                            });
                        }), values;
                    }, Histogram.prototype.getData = function(values, numericalValues, data, settings, yValueFormatter, xValueFormatter) {
                        var _this = this, minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues), fontSizeInPx = PixelConverter.fromPoint(settings.labelFontSize);
                        return data.map(function(bin, index) {
                            return bin.range = _this.getRange(minValue, maxValue, bin.dx, index), bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, 0 === index, yValueFormatter, xValueFormatter), 
                            bin.selectionIds = _this.getSelectionIds(values, bin, index), bin.labelFontSize = fontSizeInPx, 
                            bin;
                        });
                    }, Histogram.prototype.getRange = function(minValue, maxValue, step, index) {
                        var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
                        return [ leftBorder, rightBorder ];
                    }, Histogram.prototype.getTooltipData = function(value, range, settings, includeLeftBorder, yValueFormatter, xValueFormatter) {
                        return [ {
                            displayName: this.getLegendText(settings),
                            value: yValueFormatter.format(value)
                        }, {
                            displayName: this.TooltipDisplayName,
                            value: this.rangeToString(range, includeLeftBorder, xValueFormatter)
                        } ];
                    }, Histogram.prototype.getSelectionIds = function(values, bin, index) {
                        var _this = this, selectionIds = [];
                        return values.forEach(function(value) {
                            _this.isValueContainedInRange(value, bin, index) && selectionIds.push(value.selectionId);
                        }), selectionIds;
                    }, Histogram.prototype.isValueContainedInRange = function(value, bin, index) {
                        return (0 === index && value.value >= bin.x || value.value > bin.x) && value.value <= bin.x + bin.dx;
                    }, Histogram.prototype.parseSettings = function(dataView) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects, colorHelper, histogramSettings = {};
                        return colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties.dataPoint.fill, Histogram.DefaultHistogramSettings.fillColor), 
                        histogramSettings.displayName = dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName, 
                        objects = this.getObjectsFromDataView(dataView), histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, ""), 
                        histogramSettings.bins = this.getBins(objects), histogramSettings.frequency = this.getFrequency(objects), 
                        histogramSettings.precision = this.getPrecision(objects), histogramSettings.xAxisColor = this.getXAxisColor(objects).solid.color, 
                        histogramSettings.xTitle = this.getXTitle(objects), histogramSettings.yAxisColor = this.getYAxisColor(objects).solid.color, 
                        histogramSettings.yTitle = this.getYTitle(objects), histogramSettings.xPrecision = this.getXPrecision(objects), 
                        histogramSettings.xStyle = this.getXStyle(objects), histogramSettings.xDisplayUnits = this.getXDisplayUnit(objects), 
                        histogramSettings.displayName = this.setLegend(histogramSettings.displayName, histogramSettings.xStyle, histogramSettings.xDisplayUnits), 
                        histogramSettings.yStyle = this.getYStyle(objects), histogramSettings.yDisplayUnits = this.getYDisplayUnit(objects), 
                        histogramSettings.yPrecision = this.getYPrecision(objects), histogramSettings.xShow = this.getXAxisShow(objects), 
                        histogramSettings.yShow = this.getYAxisShow(objects), histogramSettings.yStart = this.getYStart(objects), 
                        histogramSettings.yEnd = this.getYEnd(objects), histogramSettings.yPosition = this.getYPosition(objects), 
                        histogramSettings.labelShow = this.getLabelShow(objects), histogramSettings.labelColor = this.getLabelColor(objects).solid.color, 
                        histogramSettings.labelDisplayUnit = this.getLabelDisplayUnit(objects), histogramSettings.labelPrecision = this.getLabelPrecision(objects), 
                        histogramSettings.labelFontSize = this.getLabelFontSize(objects), histogramSettings;
                    }, Histogram.prototype.setLegend = function(title, style, displayUnit) {
                        var retValue, formatter = ValueFormatter.create({
                            value: displayUnit
                        });
                        switch (style) {
                          case visuals.axisStyle.showTitleOnly:
                            retValue = title;
                            break;

                          case visuals.axisStyle.showUnitOnly:
                            retValue = 0 === displayUnit || 1 === displayUnit ? title : formatter.displayUnit.title;
                            break;

                          case visuals.axisStyle.showBoth:
                            retValue = 0 === displayUnit || 1 === displayUnit ? title : title + " (" + formatter.displayUnit.title + ")";
                        }
                        return retValue;
                    }, Histogram.prototype.getLabelFontSize = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.fontSize, Histogram.DefaultHistogramSettings.labelFontSize);
                    }, Histogram.prototype.getLabelShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.show, Histogram.DefaultHistogramSettings.labelShow);
                    }, Histogram.prototype.getLabelColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.color, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.labelColor
                            }
                        });
                    }, Histogram.prototype.getLabelDisplayUnit = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.labelDisplayUnits, Histogram.DefaultHistogramSettings.labelDisplayUnit);
                    }, Histogram.prototype.getLabelPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.labelPrecision, Histogram.DefaultHistogramSettings.labelPrecision);
                        return precision <= this.MinPrecision ? this.MinPrecision : precision >= this.MaxPrecision ? this.MaxPrecision : precision;
                    }, Histogram.prototype.getXStyle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.style, Histogram.DefaultHistogramSettings.xStyle);
                    }, Histogram.prototype.getXDisplayUnit = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.displayUnits, Histogram.DefaultHistogramSettings.xDisplayUnits);
                    }, Histogram.prototype.getXPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.precision, Histogram.DefaultHistogramSettings.xPrecision);
                        return precision <= this.MinPrecision ? this.MinPrecision : precision >= this.MaxPrecision ? this.MaxPrecision : precision;
                    }, Histogram.prototype.getXAxisShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.show, Histogram.DefaultHistogramSettings.xShow);
                    }, Histogram.prototype.getXAxisColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.xAxisColor
                            }
                        });
                    }, Histogram.prototype.getXTitle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.xAxis.title, Histogram.DefaultHistogramSettings.xTitle);
                    }, Histogram.prototype.getYStyle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.style, Histogram.DefaultHistogramSettings.yStyle);
                    }, Histogram.prototype.getYPosition = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.position, Histogram.DefaultHistogramSettings.yPosition);
                    }, Histogram.prototype.getYAxisShow = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.show, Histogram.DefaultHistogramSettings.yShow);
                    }, Histogram.prototype.getYAxisColor = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.axisColor, {
                            solid: {
                                color: Histogram.DefaultHistogramSettings.yAxisColor
                            }
                        });
                    }, Histogram.prototype.getYStart = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.start, Histogram.DefaultHistogramSettings.yStart);
                    }, Histogram.prototype.getYEnd = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.end, Histogram.DefaultHistogramSettings.yEnd);
                    }, Histogram.prototype.getYDisplayUnit = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.displayUnits, Histogram.DefaultHistogramSettings.yDisplayUnits);
                    }, Histogram.prototype.getYPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.precision, Histogram.DefaultHistogramSettings.yPrecision);
                        return precision <= this.MinPrecision ? this.MinPrecision : precision >= this.MaxPrecision ? this.MaxPrecision : precision;
                    }, Histogram.prototype.getYTitle = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.yAxis.title, Histogram.DefaultHistogramSettings.yTitle);
                    }, Histogram.prototype.getBins = function(objects) {
                        var binsNumber;
                        return binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.bins, Histogram.DefaultHistogramSettings.bins)), 
                        !binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins ? Histogram.DefaultHistogramSettings.bins : binsNumber > this.MaxNumberOfBins ? this.MaxNumberOfBins : binsNumber;
                    }, Histogram.prototype.getFrequency = function(objects) {
                        return powerbi.DataViewObjects.getValue(objects, Histogram.Properties.general.frequency, Histogram.DefaultHistogramSettings.frequency);
                    }, Histogram.prototype.getPrecision = function(objects) {
                        var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties.labels.labelPrecision, Histogram.DefaultHistogramSettings.precision);
                        return precision <= this.MinPrecision ? this.MinPrecision : precision >= this.MaxPrecision ? this.MaxPrecision : precision;
                    }, Histogram.prototype.validateData = function(data) {
                        return data && data.data.some(function(x) {
                            return x.range.some(function(x) {
                                return isNaN(x) || x === 1 / 0 || x === -(1 / 0);
                            });
                        }) ? (this.hostService.setWarnings([ new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues) ]), 
                        !1) : !0;
                    }, Histogram.prototype.update = function(visualUpdateOptions) {
                        if (visualUpdateOptions && visualUpdateOptions.dataViews && visualUpdateOptions.dataViews[0]) {
                            visuals.CartesianChart.InnerPaddingRatio = 1;
                            var dataView = visualUpdateOptions.dataViews[0];
                            if (this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations), 
                            this.setSize(visualUpdateOptions.viewport), this.histogramDataView = this.converter(dataView), 
                            this.validateData(this.histogramDataView) || (this.histogramDataView.data = []), 
                            this.histogramDataView) {
                                this.YLegendSize = this.histogramDataView.settings.yTitle ? 50 : 25, this.XLegendSize = this.histogramDataView.settings.xTitle ? 50 : 25, 
                                this.fixXTicSize(), this.xAxisProperties = this.calculateXAxes(dataView.categorical.categories[0].source, this.textProperties, !1);
                                var ySource = dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values ? dataView.categorical.values[0].source : dataView.categorical.categories[0].source;
                                this.yAxisProperties = this.calculateYAxes(ySource, this.textProperties, !1), this.render(), 
                                visuals.CartesianChart.InnerPaddingRatio = this.oldInnerPaddingRatio, visuals.CartesianChart.MinOrdinalRectThickness = this.oldMinOrdinalRectThickness;
                            }
                        }
                    }, Histogram.prototype.fixXTicSize = function() {
                        if (this.histogramDataView && this.histogramDataView.settings) {
                            var ticLabel = this.histogramDataView.xLabelFormatter.format(this.histogramDataView.settings.maxX), textProperties = {
                                text: ticLabel,
                                fontFamily: this.textProperties.fontFamily,
                                fontSize: this.textProperties.fontSize
                            }, widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            visuals.CartesianChart.MinOrdinalRectThickness = widthOfLabel + 3;
                        }
                    }, Histogram.prototype.setSize = function(viewport) {
                        var height, width;
                        height = viewport.height - this.margin.top - this.margin.bottom, width = viewport.width - this.margin.left - this.margin.right, 
                        this.viewport = {
                            height: height,
                            width: width
                        }, this.updateElements(viewport.height, viewport.width);
                    }, Histogram.prototype.updateElements = function(height, width) {
                        this.root.attr({
                            height: height,
                            width: width
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.legend.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
                    }, Histogram.prototype.shouldShowYOnRight = function() {
                        return this.histogramDataView.settings.yPosition === visuals.yAxisPosition.right;
                    }, Histogram.prototype.columsAndAxesTransform = function(labelWidth) {
                        var constMargin = 20, shiftToRight = this.shouldShowYOnRight() ? 10 : this.histogramDataView.settings.yTitle ? this.margin.left + labelWidth + constMargin : this.margin.left + labelWidth;
                        this.DataLabelMargin = shiftToRight, this.columns.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), 
                        this.axes.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0)), this.axisY.attr("transform", visuals.SVGUtil.translate(this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - this.YLegendSize + .01 : 0, 0)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.XLegendSize));
                    }, Histogram.prototype.render = function() {
                        if (this.histogramDataView && this.histogramDataView.settings) {
                            this.renderAxes();
                            var columnsSelection = this.renderColumns();
                            this.adjustTransformToAxisLabels(), this.renderLegend(), this.histogramDataView.settings.labelShow ? this.renderLabels() : this.main.selectAll(".labels").selectAll("*").remove(), 
                            this.bindSelectionHandler(columnsSelection);
                        }
                    }, Histogram.prototype.adjustTransformToAxisLabels = function() {
                        var maxWidthOfLabael = 0;
                        this.main.selectAll("g.axis").filter(function(d, index) {
                            return 1 === index;
                        }).selectAll("g.tick text").each(function(d, i) {
                            var p = powerbi.TextMeasurementService.getSvgMeasurementProperties(this), textProperties = {
                                text: p.text,
                                fontFamily: p.fontFamily,
                                fontSize: p.fontSize
                            }, widthOfLabel = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            widthOfLabel > maxWidthOfLabael && (maxWidthOfLabael = widthOfLabel);
                        });
                        var constMargin = 70;
                        this.yTitleMargin = this.shouldShowYOnRight() ? this.viewport.width - this.AxisSize - constMargin + this.YLegendSize + maxWidthOfLabael : 0, 
                        this.columsAndAxesTransform(maxWidthOfLabael);
                    }, Histogram.prototype.renderColumns = function() {
                        var widthOfColumn, updateColumnsSelection, _this = this, data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length;
                        return widthOfColumn = countOfValues && (this.viewport.width - this.AxisSize - this.YLegendSize) / countOfValues - this.ColumnPadding, 
                        0 > widthOfColumn && (widthOfColumn = 0), this.widthOfColumn = widthOfColumn, updateColumnsSelection = this.columnsSelection.data(data), 
                        updateColumnsSelection.enter().append("svg:rect"), updateColumnsSelection.attr("x", this.ColumnPadding / 2).attr("width", widthOfColumn).attr("height", function(item) {
                            return _this.getColumnHeight(item, yScale);
                        }).style("fill", this.histogramDataView.settings.fillColor).attr("class", Histogram.Column["class"]).attr("transform", function(item, index) {
                            return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5);
                        }), countOfValues && updateColumnsSelection.classed(Histogram.Column["class"]), 
                        updateColumnsSelection.exit().remove(), this.renderTooltip(updateColumnsSelection), 
                        updateColumnsSelection;
                    }, Histogram.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Histogram.prototype.getColumnHeight = function(column, y) {
                        var height = this.viewport.height - this.XLegendSize - y(column.y);
                        return height > 0 ? height : this.MinColumnHeight;
                    }, Histogram.prototype.renderAxes = function() {
                        var xAxis, yAxis, _this = this;
                        xAxis = this.xAxisProperties.axis.tickFormat(function(item) {
                            return _this.histogramDataView.xLabelFormatter.format(item);
                        }).orient("bottom"), yAxis = this.yAxisProperties.axis.orient(this.histogramDataView.settings.yPosition.toLowerCase()).tickFormat(function(item) {
                            return _this.histogramDataView.yLabelFormatter.format(item);
                        });
                        var xShow = this.histogramDataView.settings.xShow, yShow = this.histogramDataView.settings.yShow;
                        xShow ? this.axisX.transition().duration(1).call(xAxis) : this.axisX.selectAll("*").remove(), 
                        yShow ? this.axisY.call(yAxis) : this.axisY.selectAll("*").remove(), this.main.selectAll("g.axis").filter(function(d, index) {
                            return 0 === index;
                        }).selectAll("g.tick text").style({
                            fill: this.histogramDataView.settings.xAxisColor
                        }), this.main.selectAll("g.axis").filter(function(d, index) {
                            return 1 === index;
                        }).selectAll("g.tick text").style({
                            fill: this.histogramDataView.settings.yAxisColor
                        });
                    }, Histogram.prototype.getLabaelLayout = function() {
                        var _this = this, fontSizeInPx = PixelConverter.fromPoint(this.histogramDataView.settings.labelFontSize), settings = this.histogramDataView.settings, dataLabelFormatter = ValueFormatter.create({
                            value: settings.labelDisplayUnit,
                            precision: settings.labelPrecision
                        });
                        return {
                            labelText: function(b) {
                                return dataLabelFormatter.format(b.y).toString();
                            },
                            labelLayout: {
                                x: function(b) {
                                    return _this.DataLabelMargin + _this.histogramDataView.xScale(b.x) + _this.widthOfColumn / 2;
                                },
                                y: function(b) {
                                    return _this.histogramDataView.yScale(b.y) - 5;
                                }
                            },
                            filter: function(b) {
                                return null != b;
                            },
                            style: {
                                fill: settings.labelColor,
                                "font-size": fontSizeInPx
                            }
                        };
                    }, Histogram.prototype.renderLabels = function() {
                        var layout = this.getLabaelLayout(), dataPointsArray = this.histogramDataView.data;
                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPointsArray, this.main, layout, this.viewport);
                    }, Histogram.prototype.rangesToArray = function(data) {
                        return data.reduce(function(previousValue, currentValue, index) {
                            var range;
                            return range = 0 === index ? currentValue.range : currentValue.range.slice(1), previousValue.concat(range);
                        }, []);
                    }, Histogram.prototype.rangeToString = function(range, includeLeftBorder, valueFormatter) {
                        var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                        return leftBracket = includeLeftBorder ? this.IncludeBrackets.left : this.ExcludeBrackets.left, 
                        "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
                    }, Histogram.prototype.renderLegend = function() {
                        var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
                        legendElements = this.main.select(Histogram.Legends.selector).selectAll(Histogram.Legend.selector), 
                        legendSelection = legendElements.data(datalegends), legendSelection.enter().append("svg:text"), 
                        legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                            return item.dx;
                        }).attr("dy", function(item) {
                            return item.dy;
                        }).attr("transform", function(item) {
                            return item.transform;
                        }).attr("class", Histogram.Legend["class"]).text(function(item) {
                            return item.text;
                        }).classed(Histogram.Legend["class"], !0), legendSelection.exit().remove(), this.legend.select("text").style({
                            display: this.histogramDataView.settings.xTitle === !0 ? "block" : "none"
                        }), this.legend.selectAll("text").filter(function(d, index) {
                            return 1 === index;
                        }).style({
                            display: this.histogramDataView.settings.yTitle === !0 ? "block" : "none"
                        });
                    }, Histogram.prototype.getDataLegends = function(settings) {
                        var bottomLegendText = this.getLegendText(settings);
                        return bottomLegendText = this.setLegend(bottomLegendText, settings.yStyle, settings.yDisplayUnits), 
                        [ {
                            transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                            text: settings.displayName,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(this.shouldShowYOnRight() ? this.yTitleMargin : 0, this.viewport.height / 2, 0, 0, 270),
                            text: bottomLegendText,
                            dx: "3em"
                        } ];
                    }, Histogram.prototype.getLegendText = function(settings) {
                        return settings.frequency ? Histogram.FrequencyText : Histogram.DensityText;
                    }, Histogram.prototype.bindSelectionHandler = function(columnsSelection) {
                        var _this = this;
                        this.setSelection(columnsSelection), columnsSelection.on("click", function(data) {
                            _this.selectionManager.clear(), data.selectionIds.forEach(function(selectionId) {
                                _this.selectionManager.select(selectionId, !0).then(function(selectionIds) {
                                    selectionIds.length > 0 ? _this.setSelection(columnsSelection, data) : _this.setSelection(columnsSelection);
                                });
                            }), d3.event.stopPropagation();
                        }), this.root.on("click", function() {
                            _this.selectionManager.clear(), _this.setSelection(columnsSelection);
                        });
                    }, Histogram.prototype.setSelection = function(columnsSelection, data) {
                        columnsSelection.transition().duration(this.durationAnimations).style("fill-opacity", this.MaxOpacity), 
                        data && columnsSelection.filter(function(columnSelection) {
                            return columnSelection !== data;
                        }).transition().duration(this.durationAnimations).style("fill-opacity", this.MinOpacity);
                    }, Histogram.prototype.enumerateObjectInstances = function(options) {
                        var settings, instances = [];
                        if (!this.histogramDataView || !this.histogramDataView.settings) return instances;
                        switch (settings = this.histogramDataView.settings, options.objectName) {
                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    bins: settings.bins,
                                    frequency: settings.frequency
                                }
                            };
                            instances.push(general);
                            break;

                          case "dataPoint":
                            var dataPoint = {
                                objectName: "dataPoint",
                                displayName: "dataPoint",
                                selector: null,
                                properties: {
                                    fill: settings.fillColor
                                }
                            };
                            instances.push(dataPoint);
                            break;

                          case "labels":
                            var labels = {
                                objectName: "labels",
                                displayName: "labels",
                                selector: null,
                                properties: {
                                    show: settings.labelShow,
                                    color: settings.labelColor,
                                    labelDisplayUnits: settings.labelDisplayUnit,
                                    labelPrecision: settings.labelPrecision,
                                    fontSize: settings.labelFontSize
                                }
                            };
                            instances.push(labels);
                            break;

                          case "xAxis":
                            var xAxis = {
                                objectName: "axis",
                                displayName: "X Axis",
                                selector: null,
                                properties: {
                                    show: settings.xShow,
                                    title: settings.xTitle,
                                    style: settings.xStyle,
                                    axisColor: settings.xAxisColor,
                                    displayUnits: settings.xDisplayUnits,
                                    precision: settings.xPrecision
                                }
                            };
                            instances.push(xAxis);
                            break;

                          case "yAxis":
                            var yAxis = {
                                objectName: "axis",
                                displayName: "Y Axis",
                                selector: null,
                                properties: {
                                    show: settings.yShow,
                                    position: settings.yPosition,
                                    start: settings.yStart,
                                    end: settings.yEnd,
                                    title: settings.yTitle,
                                    style: settings.yStyle,
                                    axisColor: settings.yAxisColor,
                                    displayUnits: settings.yDisplayUnits,
                                    precision: settings.yPrecision
                                }
                            };
                            instances.push(yAxis);
                        }
                        return instances;
                    }, Histogram.prototype.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, Histogram.prototype.destroy = function() {
                        this.root = null;
                    }, Histogram.prototype.calculateXAxes = function(source, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forcedXDomain: this.rangesToArray(this.histogramDataView.data),
                            forceMerge: !0,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            trimOrdinalDataOnOverflow: !1
                        }, width = this.viewport.width, axes = this.calculateXAxesProperties(visualOptions, source);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Histogram.prototype.calculateXAxesProperties = function(options, metaDataColumn) {
                        var xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewport.width - this.YLegendSize - this.AxisSize,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString),
                            outerPadding: 0,
                            isScalar: !1,
                            isVertical: !1,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: options.categoryAxisScaleType
                        });
                        return xAxisProperties.axisLabel = this.histogramDataView.settings.displayName, 
                        xAxisProperties;
                    }, Histogram.prototype.calculateYAxes = function(source, textProperties, scrollbarVisible) {
                        var visualOptions = {
                            viewport: this.viewport,
                            margin: this.margin,
                            forceMerge: !0,
                            showCategoryAxisLabel: !0,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            trimOrdinalDataOnOverflow: !1
                        };
                        visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([ this.histogramDataView.settings.yStart, this.histogramDataView.settings.yEnd ], visualOptions.forcedYDomain);
                        var axes = this.calculateYAxesProperties(visualOptions, source);
                        return axes;
                    }, Histogram.prototype.calculateYAxesProperties = function(options, metaDataColumn) {
                        var yAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: this.viewport.height - this.XLegendSize + 5,
                            dataDomain: visuals.AxisHelper.combineDomain(options.forcedYDomain, [ this.histogramDataView.settings.yStart, this.histogramDataView.settings.yEnd ]),
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, Histogram.Properties.general.formatString),
                            outerPadding: this.outerPadding,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !1,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: options.categoryAxisScaleType
                        });
                        return yAxisProperties;
                    }, Histogram.ClassName = "histogram", Histogram.FrequencyText = "Frequency", Histogram.DensityText = "Density", 
                    Histogram.Properties = {
                        general: {
                            bins: {
                                objectName: "general",
                                propertyName: "bins"
                            },
                            frequency: {
                                objectName: "general",
                                propertyName: "frequency"
                            },
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        dataPoint: {
                            fill: {
                                objectName: "dataPoint",
                                propertyName: "fill"
                            }
                        },
                        labels: {
                            show: {
                                objectName: "labels",
                                propertyName: "show"
                            },
                            color: {
                                objectName: "labels",
                                propertyName: "color"
                            },
                            labelDisplayUnits: {
                                objectName: "labels",
                                propertyName: "labelDisplayUnits"
                            },
                            labelPrecision: {
                                objectName: "labels",
                                propertyName: "labelPrecision"
                            },
                            fontSize: {
                                objectName: "labels",
                                propertyName: "fontSize"
                            }
                        },
                        xAxis: {
                            show: {
                                objectName: "xAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "xAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "xAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "xAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "xAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "xAxis",
                                propertyName: "style"
                            }
                        },
                        yAxis: {
                            show: {
                                objectName: "yAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "yAxis",
                                propertyName: "axisColor"
                            },
                            title: {
                                objectName: "yAxis",
                                propertyName: "title"
                            },
                            displayUnits: {
                                objectName: "yAxis",
                                propertyName: "displayUnits"
                            },
                            precision: {
                                objectName: "yAxis",
                                propertyName: "precision"
                            },
                            style: {
                                objectName: "yAxis",
                                propertyName: "style"
                            },
                            start: {
                                objectName: "yAxis",
                                propertyName: "start"
                            },
                            end: {
                                objectName: "yAxis",
                                propertyName: "end"
                            },
                            position: {
                                objectName: "yAxis",
                                propertyName: "position"
                            }
                        }
                    }, Histogram.DefaultHistogramSettings = {
                        frequency: !0,
                        displayName: "Histogram",
                        bins: null,
                        fillColor: "#5f9ea0",
                        precision: 2,
                        xShow: !0,
                        xAxisColor: "#5f9ea0",
                        yAxisColor: "#5f9ea0",
                        xTitle: !0,
                        xDisplayUnits: 0,
                        xPrecision: 2,
                        xStyle: visuals.axisStyle.showTitleOnly,
                        yTitle: !0,
                        yDisplayUnits: 0,
                        yPrecision: 2,
                        yShow: !0,
                        yStyle: visuals.axisStyle.showTitleOnly,
                        yStart: 0,
                        yPosition: visuals.yAxisPosition.left,
                        labelShow: !1,
                        labelColor: "#5f9ea0",
                        labelDisplayUnit: 0,
                        labelPrecision: 2,
                        labelFontSize: 9
                    }, Histogram.Axes = createClassAndSelector("axes"), Histogram.Axis = createClassAndSelector("axis"), 
                    Histogram.Labels = createClassAndSelector("labels"), Histogram.Columns = createClassAndSelector("columns"), 
                    Histogram.Column = createClassAndSelector("column"), Histogram.Legends = createClassAndSelector("legends"), 
                    Histogram.Legend = createClassAndSelector("legend"), Histogram.capabilities = {
                        dataRoles: [ {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }, {
                            name: "Frequency",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Frequency"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Values: {
                                    min: 1,
                                    max: 1
                                },
                                Frequency: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    bind: {
                                        to: "Values"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Frequency"
                                    }
                                }
                            }
                        } ],
                        sorting: {
                            implicit: {
                                clauses: [ {
                                    role: "Values",
                                    direction: 1
                                } ]
                            }
                        },
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    bins: {
                                        displayName: "Bins",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    frequency: {
                                        displayName: "Frequency",
                                        type: {
                                            bool: !0
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            xAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "Axis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: visuals.axisStyle.type
                                        }
                                    }
                                }
                            },
                            yAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axis: {
                                        displayName: "yAxis",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    title: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    displayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        }
                                    },
                                    precision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    style: {
                                        displayName: "Style",
                                        type: {
                                            enumeration: visuals.axisStyle.type
                                        }
                                    },
                                    start: {
                                        displayName: "Start",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "Start",
                                        suppressFormatPainterCopy: !0
                                    },
                                    end: {
                                        displayName: "End",
                                        type: {
                                            numeric: !0
                                        },
                                        placeHolderText: "End",
                                        suppressFormatPainterCopy: !0
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: visuals.yAxisPosition.type
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display Units",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal Places",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, Histogram;
                }();
                samples.Histogram = Histogram;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration, CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector, AxisScale = powerbi.visuals.axisScale, PixelConverter = jsCommon.PixelConverter, MaxXAxisHeight = 40, LabelMargin = 15, DefaultRadius = 5, DefaultStrokeWidth = 1, DefaultDataPointColor = "#00B8AA", MinPrecision = 0, MaxPrecision = 17;
                samples.DotPlotProperties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        labelColor: {
                            objectName: "labels",
                            propertyName: "labelColor"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    categories: {
                        show: {
                            objectName: "categories",
                            propertyName: "show"
                        },
                        fontColor: {
                            objectName: "categories",
                            propertyName: "fontColor"
                        },
                        fontSize: {
                            objectName: "categories",
                            propertyName: "fontSize"
                        }
                    }
                };
                var DotPlot = function() {
                    function DotPlot(options) {
                        this.DefaultMargin = {
                            top: 10,
                            bottom: 10,
                            right: 20,
                            left: 20
                        }, this.durationAnimations = 100, this.scaleType = AxisScale.linear, this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(9)
                        }, this.dotPlotSelectors = {
                            svgPlotSelector: CreateClassAndSelector("dotplot"),
                            plotSelector: CreateClassAndSelector("dotplotSelector"),
                            plotGroupSelector: CreateClassAndSelector("dotplotGroup"),
                            axisSelector: CreateClassAndSelector("axisGraphicsContext"),
                            xAxisSelector: CreateClassAndSelector("x axis"),
                            circleSeletor: CreateClassAndSelector("circleSelector")
                        }, this.DefaultDotPlotSettings = {
                            labelSettings: {
                                show: !0,
                                precision: 2,
                                fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                                displayUnits: 0,
                                labelColor: visuals.dataLabelUtils.defaultLabelColor
                            },
                            categorySettings: {
                                show: !0,
                                fontColor: visuals.LegendData.DefaultLegendLabelFillColor
                            },
                            defaultDataPointColor: DefaultDataPointColor
                        }, options && (options.svg && (this.svg = options.svg), options.animator && (this.animator = options.animator), 
                        this.radius = options.radius || DefaultRadius, this.strokeWidth = options.strokeWidth || DefaultStrokeWidth);
                    }
                    return DotPlot.getTooltipData = function(value) {
                        return [ {
                            displayName: "Value",
                            value: value.toString()
                        } ];
                    }, DotPlot.converter = function(dataView, scale, defaultMargin, defaultSetting, colors, viewport, radius) {
                        var settings, values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, objects = this.getObjectsFromDataView(dataView), defaultColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), categories = dataView.categorical.categories[0].values.map(function(x, i) {
                            return {
                                value: x,
                                selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
                            };
                        });
                        settings = {
                            categorySettings: this.getCategorySettings(objects, defaultSetting),
                            defaultDataPointColor: defaultColor,
                            labelSettings: this.parseSettings(objects, defaultSetting)
                        };
                        for (var categoryColumn = dataView.categorical.categories[0], diameter = 2 * radius + 1, dotsTotalHeight = viewport.height - radius - MaxXAxisHeight, maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1, fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize), yScale = d3.scale.linear().domain([ 0, maxDots ]).range([ dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom ]), _i = 0, values_1 = values; _i < values_1.length; _i++) for (var value = values_1[_i], min = _.min(value.values), max = _.max(value.values), color = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value), length_1 = value.values.length, minDots = min / (max / maxDots), dotsScale = d3.scale.log().domain([ min, max ]).range([ 0 === minDots ? 1 : minDots, maxDots ]).clamp(!0), k = 0; length_1 > k; k++) {
                            for (var y = dotsScale(value.values[k]), dataPoints = [], level = 0; y > level; level++) dataPoints.push({
                                x: scale(categories[k].value) + scale.rangeBand() / 2,
                                y: yScale(level),
                                tooltipInfo: DotPlot.getTooltipData(value.values[k])
                            });
                            var categorySelectionId = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId(), tooltipInfo = DotPlot.getTooltipData(value.values[k]);
                            dataPointsGroup.push({
                                selected: !1,
                                value: value.values[k],
                                label: value.values[k],
                                color: color,
                                identity: categorySelectionId,
                                tooltipInfo: tooltipInfo,
                                dataPoints: dataPoints,
                                labelFontSize: fontSizeInPx
                            });
                        }
                        return {
                            dataPoints: dataPointsGroup,
                            values: dataView.categorical.categories[0].values,
                            displayName: displayName,
                            categories: categories,
                            settings: settings
                        };
                    }, DotPlot.prototype.init = function(options) {
                        var element = options.element;
                        this.behavior = new DotplotBehavior(), this.interactivityService = visuals.createInteractivityService(options.host), 
                        this.radius = DefaultRadius, this.strokeWidth = DefaultStrokeWidth, this.colors = options.style.colorPalette.dataColors, 
                        this.svg = d3.select(element.get(0)).append("svg").classed(this.dotPlotSelectors.svgPlotSelector["class"], !0).style("position", "absolute"), 
                        this.clearCatcher = visuals.appendClearCatcher(this.svg);
                        var axisGraphicsContext = this.svg.append("g").classed(this.dotPlotSelectors.axisSelector["class"], !0);
                        this.dotPlot = this.svg.append("g").classed(this.dotPlotSelectors.plotSelector["class"], !0), 
                        this.xAxis = axisGraphicsContext.append("g").classed(this.dotPlotSelectors.xAxisSelector["class"], !0);
                    }, DotPlot.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
                            var dataView = this.dataView = options.dataViews[0], viewport = options.viewport;
                            if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1 || !dataView.categorical || !dataView.categorical.categories || !dataView.categorical.categories[0]) return void this.clearData();
                            var viewportIn = {
                                height: viewport.height - this.DefaultMargin.top,
                                width: viewport.width - this.DefaultMargin.left
                            };
                            this.svg.style({
                                height: PixelConverter.toString(viewport.height),
                                width: PixelConverter.toString(viewport.width)
                            });
                            var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, !1), data = DotPlot.converter(dataView, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);
                            this.dotPlotDataView = data;
                            var dataPoints = data.dataPoints;
                            this.interactivityService && this.interactivityService.applySelectionStateToData(dataPoints), 
                            this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations), 
                            this.drawDotPlot(dataPoints, data.settings);
                            var dataLabelsSettings = data.settings.labelSettings;
                            if (dataLabelsSettings.show) {
                                var layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);
                                visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);
                            } else visuals.dataLabelUtils.cleanDataLabels(this.svg);
                        }
                    }, DotPlot.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "dataPoint":
                            this.enumerateDataPoints(enumeration, this.dataView);
                            break;

                          case "labels":
                            this.enumerateDataLabels(enumeration, this.dataView);
                            break;

                          case "categories":
                            this.enumerateCategories(enumeration, this.dataView);
                        }
                        return enumeration.complete();
                    }, DotPlot.getObjectsFromDataView = function(dataView) {
                        return dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.objects ? dataView.metadata.objects : null;
                    }, DotPlot.parseSettings = function(objects, defaultDotPlotSettings) {
                        var precision = this.getPrecision(objects, defaultDotPlotSettings);
                        return {
                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),
                            precision: precision,
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),
                            displayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor)
                        };
                    }, DotPlot.getCategorySettings = function(objects, defaultDotPlotSettings) {
                        return {
                            show: powerbi.DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)
                        };
                    }, DotPlot.getPrecision = function(objects, defaultDotPlotSettings) {
                        var precision = powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);
                        return MinPrecision >= precision ? MinPrecision : precision >= MaxPrecision ? MaxPrecision : precision;
                    }, DotPlot.prototype.drawDotPlot = function(data, setting) {
                        var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data), hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                        selection.enter().append("g").attr({
                            stroke: "black",
                            "stroke-width": this.strokeWidth
                        }).style("fill-opacity", function(item) {
                            return visuals.ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, !1);
                        }).classed(this.dotPlotSelectors.plotGroupSelector["class"], !0);
                        var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function(d) {
                            return d.dataPoints;
                        });
                        circleSelection.enter().append("circle").classed(this.dotPlotSelectors.circleSeletor["class"], !0), 
                        circleSelection.attr({
                            cx: function(point) {
                                return point.x;
                            },
                            cy: function(point) {
                                return point.y;
                            },
                            r: this.radius,
                            fill: setting.defaultDataPointColor
                        }), this.renderTooltip(selection), circleSelection.exit().remove(), selection.exit().remove();
                        var interactivityService = this.interactivityService;
                        if (interactivityService) {
                            interactivityService.applySelectionStateToData(data);
                            var behaviorOptions = {
                                columns: selection,
                                clearCatcher: this.clearCatcher,
                                interactivityService: this.interactivityService
                            };
                            interactivityService.bind(data, this.behavior, behaviorOptions);
                        }
                    }, DotPlot.prototype.getEnhanchedDotplotLayout = function(labelSettings, viewport) {
                        var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize), formatter = visuals.valueFormatter.create({
                            format: visuals.valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),
                            precision: labelSettings.precision,
                            value: labelSettings.displayUnits
                        });
                        return {
                            labelText: function(d) {
                                return visuals.dataLabelUtils.getLabelFormattedText({
                                    label: formatter.format(d.label),
                                    fontSize: labelSettings.fontSize,
                                    maxWidth: viewport.width
                                });
                            },
                            labelLayout: {
                                x: function(d) {
                                    return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0;
                                },
                                y: function(d) {
                                    return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0;
                                }
                            },
                            filter: function(d) {
                                return null != d && null != d.label;
                            },
                            style: {
                                fill: labelSettings.categoryLabelColor,
                                "font-size": fontSizeInPx
                            }
                        };
                    }, DotPlot.prototype.enumerateDataLabels = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),
                                fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),
                                labelPrecision: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),
                                labelDisplayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),
                                labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)
                            }
                        });
                    }, DotPlot.prototype.enumerateDataPoints = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, dataPointColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: "Data Points",
                            selector: null,
                            properties: {
                                fill: {
                                    solid: {
                                        color: dataPointColor
                                    }
                                }
                            }
                        });
                    }, DotPlot.prototype.enumerateCategories = function(enumeration, dataView) {
                        var objects = dataView && dataView.metadata ? dataView.metadata.objects : void 0, categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);
                        enumeration.pushInstance({
                            objectName: "categories",
                            displayName: "Categories",
                            selector: null,
                            properties: {
                                show: categoriesSettings.show,
                                fontSize: categoriesSettings.fontSize,
                                fontColor: categoriesSettings.fontColor
                            }
                        });
                    }, DotPlot.prototype.clearData = function() {
                        this.dotPlot.selectAll("*").remove(), this.xAxis.selectAll("*").remove(), visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }, DotPlot.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, DotPlot.prototype.calculateAxes = function(viewportIn, textProperties, scrollbarVisible) {
                        var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0 ? this.dataView.categorical.categories[0] : {
                            source: void 0,
                            values: [ visuals.valueFormatter.format(null) ],
                            identity: void 0
                        }, visualOptions = {
                            viewport: viewportIn,
                            margin: this.DefaultMargin,
                            forcedXDomain: this.dataView.categorical.categories[0].values,
                            forceMerge: !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: this.scaleType,
                            valueAxisScaleType: null,
                            valueAxisDisplayUnits: 0,
                            categoryAxisDisplayUnits: 0,
                            trimOrdinalDataOnOverflow: !1
                        }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, DotPlot.prototype.calculateAxesProperties = function(viewportIn, options, metaDataColumn) {
                        var xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: viewportIn.width,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: visuals.valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),
                            outerPadding: 0,
                            isScalar: !1,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return index;
                            },
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        });
                        return xAxisProperties.axisLabel = "New Label", xAxisProperties;
                    }, DotPlot.prototype.renderAxis = function(height, xAxisProperties, data, duration) {
                        this.xAxis.attr({
                            transform: visuals.SVGUtil.translate(0, height)
                        });
                        var xAxis = xAxisProperties.axis;
                        xAxis.orient("bottom"), this.xAxis.transition().duration(duration).call(xAxis);
                        var xAxisTicks = this.xAxis.selectAll(".tick text");
                        xAxisTicks.data(xAxisProperties.values), xAxisTicks.call(visuals.AxisHelper.LabelLayoutStrategy.clip, xAxisProperties.xLabelMaxWidth, powerbi.TextMeasurementService.svgEllipsis), 
                        xAxisTicks.append("title").text(function(d) {
                            return d;
                        });
                    }, DotPlot.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Values"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            top: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            dataPoint: {
                                displayName: "Data colors",
                                properties: {
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                description: "Display data label options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showSeries: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Color",
                                        description: "Select color for data labels",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    labelDisplayUnits: {
                                        displayName: "Display units",
                                        description: "Select the units (millions, billions, etc.)",
                                        type: {
                                            formatting: {
                                                labelDisplayUnits: !0
                                            }
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelPrecision: {
                                        displayName: "Decimal places",
                                        description: "Select the number of decimal places to display",
                                        placeHolderText: "Auto",
                                        type: {
                                            numeric: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    showAll: {
                                        displayName: "Customize series",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, DotPlot;
                }();
                samples.DotPlot = DotPlot;
                var DotplotBehavior = function() {
                    function DotplotBehavior() {}
                    return DotplotBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.columns = options.columns, this.clearCatcher = options.clearCatcher, this.interactivityService = options.interactivityService, 
                        this.columns.on("click", function(d, i) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        }), options.clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, DotplotBehavior.prototype.renderSelection = function(hasSelection) {
                        var hasHighlights = this.interactivityService.hasSelection();
                        this.columns.style("fill-opacity", function(d) {
                            return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights);
                        });
                    }, DotplotBehavior;
                }();
                samples.DotplotBehavior = DotplotBehavior;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var linkColorType, PixelConverter = jsCommon.PixelConverter;
                !function(linkColorType) {
                    linkColorType.byWeight = "ByWeight", linkColorType.byLinkType = "ByLinkType", linkColorType.interactive = "Interactive", 
                    linkColorType.type = powerbi.createEnumType([ {
                        value: linkColorType.byWeight,
                        displayName: "ByWeight"
                    }, {
                        value: linkColorType.byLinkType,
                        displayName: "ByLinkType"
                    }, {
                        value: linkColorType.interactive,
                        displayName: "Interactive"
                    } ]);
                }(linkColorType || (linkColorType = {})), samples.forceProps = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        color: {
                            objectName: "labels",
                            propertyName: "color"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        }
                    },
                    links: {
                        showArrow: {
                            objectName: "links",
                            propertyName: "showArrow"
                        },
                        showLabel: {
                            objectName: "links",
                            propertyName: "showLabel"
                        },
                        colorLink: {
                            objectName: "links",
                            propertyName: "colorLink"
                        },
                        thickenLink: {
                            objectName: "links",
                            propertyName: "thickenLink"
                        }
                    },
                    nodes: {
                        displayImage: {
                            objectName: "nodes",
                            propertyName: "displayImage"
                        },
                        defaultImage: {
                            objectName: "nodes",
                            propertyName: "defaultImage"
                        },
                        imageUrl: {
                            objectName: "nodes",
                            propertyName: "imageUrl"
                        },
                        imageExt: {
                            objectName: "nodes",
                            propertyName: "imageExt"
                        },
                        nameMaxLength: {
                            objectName: "nodes",
                            propertyName: "nameMaxLength"
                        },
                        highlightReachableLinks: {
                            objectName: "nodes",
                            propertyName: "highlightReachableLinks"
                        }
                    },
                    size: {
                        charge: {
                            objectName: "size",
                            propertyName: "charge"
                        }
                    }
                };
                var ForceGraph = function() {
                    function ForceGraph() {}
                    return Object.defineProperty(ForceGraph.prototype, "margin", {
                        get: function() {
                            return this.marginValue || {
                                left: 0,
                                right: 0,
                                top: 0,
                                bottom: 0
                            };
                        },
                        set: function(value) {
                            this.marginValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewport", {
                        get: function() {
                            return this.viewportValue || {
                                width: 0,
                                height: 0
                            };
                        },
                        set: function(value) {
                            this.viewportValue = $.extend({}, value), this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                        get: function() {
                            return this.viewportInValue || this.viewport;
                        },
                        enumerable: !0,
                        configurable: !0
                    }), ForceGraph.substractMargin = function(viewport, margin) {
                        return {
                            width: Math.max(viewport.width - (margin.left + margin.right), 0),
                            height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                        };
                    }, ForceGraph.prototype.scale1to10 = function(d) {
                        var scale = d3.scale.linear().domain([ this.data.minFiles, this.data.maxFiles ]).rangeRound([ 1, 10 ]).clamp(!0);
                        return scale(d);
                    }, ForceGraph.prototype.getLinkColor = function(d) {
                        switch (this.options.colorLink) {
                          case linkColorType.byWeight:
                            return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;

                          case linkColorType.byLinkType:
                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;
                        }
                        return this.options.defaultLinkColor;
                    }, ForceGraph.prototype.getDefaultOptions = function() {
                        return {
                            showDataLabels: !0,
                            labelColor: visuals.dataLabelUtils.defaultLabelColor,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                            showArrow: !1,
                            showLabel: !1,
                            colorLink: linkColorType.interactive,
                            thickenLink: !0,
                            displayImage: !1,
                            defaultImage: "Home",
                            imageUrl: "",
                            imageExt: ".png",
                            nameMaxLength: 10,
                            highlightReachableLinks: !1,
                            charge: -15,
                            defaultLinkColor: "#bbb",
                            defaultLinkHighlightColor: "#f00",
                            defaultLinkThickness: "1.5px"
                        };
                    }, ForceGraph.prototype.updateOptions = function(objects) {
                        this.options.showDataLabels = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.show, this.options.showDataLabels), 
                        this.options.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.forceProps.labels.color, this.options.labelColor), 
                        this.options.fontSize = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.fontSize, this.options.fontSize), 
                        this.options.showArrow = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showArrow, this.options.showArrow), 
                        this.options.showLabel = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showLabel, this.options.showLabel), 
                        this.options.colorLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.colorLink, this.options.colorLink), 
                        this.options.thickenLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.thickenLink, this.options.thickenLink), 
                        this.options.displayImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.displayImage, this.options.displayImage), 
                        this.options.defaultImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.defaultImage, this.options.defaultImage), 
                        this.options.imageUrl = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageUrl, this.options.imageUrl), 
                        this.options.imageExt = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageExt, this.options.imageExt), 
                        this.options.nameMaxLength = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.nameMaxLength, this.options.nameMaxLength), 
                        this.options.highlightReachableLinks = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks), 
                        this.options.charge = powerbi.DataViewObjects.getValue(objects, samples.forceProps.size.charge, this.options.charge), 
                        (this.options.charge >= 0 || this.options.charge < -100) && (this.options.charge = this.getDefaultOptions().charge);
                    }, ForceGraph.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "labels":
                            this.enumerateLabels(enumeration);
                            break;

                          case "links":
                            this.enumerateLinks(enumeration);
                            break;

                          case "nodes":
                            this.enumerateNodes(enumeration);
                            break;

                          case "size":
                            this.enumerateSize(enumeration);
                        }
                        return enumeration.complete();
                    }, ForceGraph.prototype.enumerateLabels = function(enumeration) {
                        var labels, options;
                        this.options && this.options && (options = this.options, labels = {
                            objectName: "labels",
                            displayName: "Labels",
                            selector: null,
                            properties: {
                                show: options.showDataLabels,
                                fontSize: options.fontSize,
                                color: options.labelColor
                            }
                        }, enumeration.pushInstance(labels));
                    }, ForceGraph.prototype.enumerateLinks = function(enumeration) {
                        var links, options;
                        this.options && (options = this.options, links = {
                            objectName: "links",
                            displayName: "Links",
                            selector: null,
                            properties: {
                                showArrow: options.showArrow,
                                colorLink: options.colorLink,
                                showLabel: options.showLabel,
                                thickenLink: options.thickenLink
                            }
                        }, enumeration.pushInstance(links));
                    }, ForceGraph.prototype.enumerateNodes = function(enumeration) {
                        var nodes, options;
                        this.options && (options = this.options, nodes = {
                            objectName: "nodes",
                            displayName: "Nodes",
                            selector: null,
                            properties: {
                                displayImage: options.displayImage,
                                defaultImage: options.defaultImage,
                                imageUrl: options.imageUrl,
                                imageExt: options.imageExt,
                                nameMaxLength: options.nameMaxLength,
                                highlightReachableLinks: options.highlightReachableLinks
                            }
                        }, enumeration.pushInstance(nodes));
                    }, ForceGraph.prototype.enumerateSize = function(enumeration) {
                        var size, options;
                        this.options && (options = this.options, size = {
                            objectName: "size",
                            displayName: "Size",
                            selector: null,
                            properties: {
                                charge: options.charge
                            }
                        }, enumeration.pushInstance(size));
                    }, ForceGraph.converter = function(dataView, colors) {
                        var rows, categorical = dataView.categorical, nodes = {}, minFiles = Number.MAX_VALUE, maxFiles = 0, linkedByName = {}, links = [], linkDataPoints = {}, linkTypeCount = 0, sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1, tooltipInfo = [], formatStringProp = samples.forceProps.general.formatString;
                        if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) for (var metadataColumns = dataView.metadata.columns, i = 0; i < metadataColumns.length; i++) {
                            var col = metadataColumns[i];
                            col.roles && (col.roles.Source ? sourceCol = i : col.roles.Target ? targetCol = i : col.roles.Weight ? weightCol = i : col.roles.LinkType ? linkTypeCol = i : col.roles.SourceType ? sourceTypeCol = i : col.roles.TargetType && (targetTypeCol = i));
                        }
                        if (dataView && dataView.table && (rows = dataView.table.rows), 0 > sourceCol || 0 > targetCol) return {
                            nodes: {},
                            links: [],
                            minFiles: 0,
                            maxFiles: 0,
                            linkedByName: {},
                            linkTypes: {}
                        };
                        var categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp), categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp), weightFormatString = visuals.valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, !0);
                        return rows.forEach(function(item) {
                            linkedByName[item[sourceCol] + "," + item[targetCol]] = 1;
                            var source = nodes[item[sourceCol]] || (nodes[item[sourceCol]] = {
                                name: item[sourceCol],
                                image: sourceTypeCol > 0 ? item[sourceTypeCol] : "",
                                adj: {}
                            }), target = nodes[item[targetCol]] || (nodes[item[targetCol]] = {
                                name: item[targetCol],
                                image: targetTypeCol > 0 ? item[targetTypeCol] : "",
                                adj: {}
                            });
                            source.adj[target.name] = 1, target.adj[source.name] = 1, tooltipInfo = [ {
                                displayName: dataView.metadata.columns[0].displayName,
                                value: visuals.valueFormatter.format(source.name, categorySourceFormatString)
                            }, {
                                displayName: dataView.metadata.columns[1].displayName,
                                value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)
                            } ], weightCol > 0 && tooltipInfo.push({
                                displayName: dataView.metadata.columns[2].displayName,
                                value: visuals.valueFormatter.format(item[weightCol], weightFormatString)
                            });
                            var link = {
                                source: source,
                                target: target,
                                filecount: weightCol > 0 ? item[weightCol] : 0,
                                type: linkTypeCol > 0 ? item[linkTypeCol] : "",
                                tooltipInfo: tooltipInfo
                            };
                            linkTypeCol > 0 && (linkDataPoints[item[linkTypeCol]] || (linkDataPoints[item[linkTypeCol]] = {
                                label: item[linkTypeCol],
                                color: colors.getColorByIndex(linkTypeCount++).value
                            })), link.filecount < minFiles && (minFiles = link.filecount), link.filecount > maxFiles && (maxFiles = link.filecount), 
                            links.push(link);
                        }), {
                            nodes: nodes,
                            links: links,
                            minFiles: minFiles,
                            maxFiles: maxFiles,
                            linkedByName: linkedByName,
                            linkTypes: linkDataPoints
                        };
                    }, ForceGraph.prototype.init = function(options) {
                        this.root = d3.select(options.element.get(0)), this.forceLayout = d3.layout.force(), 
                        this.colors = options.style.colorPalette.dataColors, this.options = this.getDefaultOptions();
                    }, ForceGraph.prototype.update = function(options) {
                        var _this = this;
                        if (options.dataViews && !(options.dataViews.length < 1) && (this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors), 
                        this.data)) {
                            options.dataViews[0].metadata && options.dataViews[0].metadata.objects && this.updateOptions(options.dataViews[0].metadata.objects), 
                            this.viewport = options.viewport;
                            var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                            this.root.selectAll("svg").remove();
                            var svg = this.root.append("svg").attr("width", this.viewport.width).attr("height", this.viewport.height).classed(ForceGraph.VisualClassName, !0);
                            this.forceLayout.gravity(100 * k).links(this.data.links).size([ this.viewport.width, this.viewport.height ]).linkDistance(100).charge(this.options.charge / k).on("tick", this.tick()), 
                            this.updateNodes(), this.forceLayout.start(), this.paths = svg.selectAll(".link").data(this.forceLayout.links()).enter().append("path").attr("class", "link").attr("id", function(d, i) {
                                return "linkid_" + i;
                            }).attr("stroke-width", function(d) {
                                return _this.options.thickenLink ? _this.scale1to10(d.filecount) : _this.options.defaultLinkThickness;
                            }).style("stroke", function(d) {
                                return _this.getLinkColor(d);
                            }).style("fill", function(d) {
                                return _this.options.showArrow ? _this.getLinkColor(d) : void 0;
                            }).on("mouseover", this.fadePath(.3, this.options.defaultLinkHighlightColor)).on("mouseout", this.fadePath(1, this.options.defaultLinkColor)), 
                            visuals.TooltipManager.addTooltip(this.paths, function(tooltipEvent) {
                                return tooltipEvent.data.tooltipInfo;
                            }), this.options.showLabel && svg.selectAll(".linklabelholder").data(this.forceLayout.links()).enter().append("g").attr("class", "linklabelholder").append("text").attr("class", "linklabel").attr("y", "-12").attr("text-anchor", "middle").style("fill", "#000").append("textPath").attr("xlink:href", function(d, i) {
                                return "#linkid_" + i;
                            }).attr("startOffset", "25%").text(function(d) {
                                return _this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount;
                            }), this.nodes = svg.selectAll(".node").data(this.forceLayout.nodes()).enter().append("g").attr("class", "node").call(this.forceLayout.drag).on("mouseover", this.fadeNode(.3, this.options.defaultLinkHighlightColor)).on("mouseout", this.fadeNode(1, this.options.defaultLinkColor)).on("mousedown", function() {
                                return d3.event.stopPropagation();
                            }).attr("drag-resize-disabled", !0), this.options.displayImage ? this.nodes.append("image").attr("xlink:href", function(d) {
                                return d.image && "" !== d.image ? _this.options.imageUrl + d.image + _this.options.imageExt : _this.options.defaultImage && "" !== _this.options.defaultImage ? _this.options.imageUrl + _this.options.defaultImage + _this.options.imageExt : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=";
                            }).attr("x", "-12px").attr("y", "-12px").attr("width", "24px").attr("height", "24px") : this.nodes.append("circle").attr("r", function(d) {
                                return d.weight < 5 ? 5 : d.weight;
                            }), this.options.showDataLabels && this.nodes.append("text").attr({
                                x: 12,
                                dy: ".35em"
                            }).style({
                                fill: this.options.labelColor,
                                "font-size": PixelConverter.fromPoint(this.options.fontSize)
                            }).text(function(d) {
                                return d.name ? d.name.length > _this.options.nameMaxLength ? d.name.substr(0, _this.options.nameMaxLength) : d.name : "";
                            });
                        }
                    }, ForceGraph.prototype.updateNodes = function() {
                        var oldNodes = this.forceLayout.nodes();
                        this.forceLayout.nodes(d3.values(this.data.nodes)), this.forceLayout.nodes().forEach(function(node, i) {
                            oldNodes[i] && (node.x = oldNodes[i].x, node.y = oldNodes[i].y, node.px = oldNodes[i].px, 
                            node.py = oldNodes[i].py, node.weight = oldNodes[i].weight);
                        });
                    }, ForceGraph.prototype.tick = function() {
                        var _this = this, viewport = this.viewportIn, maxWidth = 20 * viewport.width, maxHeight = 20 * viewport.height, limitX = function(x) {
                            return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x));
                        }, limitY = function(y) {
                            return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y));
                        }, getPath = this.options.showArrow ? function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0 1," + d.target.x + "," + d.target.y + "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                        } : function(d) {
                            d.source.x = limitX(d.source.x), d.source.y = limitY(d.source.y), d.target.x = limitX(d.target.x), 
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
                        };
                        return function() {
                            _this.paths.each(function() {
                                this.parentNode.insertBefore(this, this);
                            }), _this.paths.attr("d", getPath), _this.nodes.attr("transform", function(d) {
                                return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")";
                            });
                        };
                    }, ForceGraph.prototype.fadePath = function(opacity, highlight) {
                        var _this = this;
                        if (this.options.colorLink === linkColorType.interactive) return function(d) {
                            _this.paths.style("stroke-opacity", function(o) {
                                return o.source === d.source && o.target === d.target ? 1 : opacity;
                            }), _this.paths.style("stroke", function(o) {
                                return o.source === d.source && o.target === d.target ? highlight : _this.options.defaultLinkColor;
                            });
                        };
                    }, ForceGraph.prototype.isReachable = function(a, b) {
                        if (a.name === b.name) return !0;
                        if (this.data.linkedByName[a.name + "," + b.name]) return !0;
                        var visited = {};
                        for (var name_1 in this.data.nodes) visited[name_1] = !1;
                        visited[a.name] = !0;
                        var stack = [];
                        for (stack.push(a.name); stack.length > 0; ) {
                            var cur = stack.pop(), node = this.data.nodes[cur];
                            for (var nb in node.adj) {
                                if (nb === b.name) return !0;
                                visited[nb] || (visited[nb] = !0, stack.push(nb));
                            }
                        }
                        return !1;
                    }, ForceGraph.prototype.fadeNode = function(opacity, highlight) {
                        var _this = this;
                        if (this.options.colorLink === linkColorType.interactive) {
                            var isConnected = function(a, b) {
                                return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name;
                            };
                            return function(d) {
                                var that = _this;
                                _this.nodes.style("stroke-opacity", function(o) {
                                    var thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;
                                    return this.setAttribute("fill-opacity", thisOpacity), thisOpacity;
                                }), _this.paths.style("stroke-opacity", function(o) {
                                    return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) : o.source === d || o.target === d) ? 1 : opacity;
                                }), _this.paths.style("stroke", function(o) {
                                    return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) : o.source === d || o.target === d) ? highlight : _this.options.defaultLinkColor;
                                });
                            };
                        }
                    }, ForceGraph.prototype.destroy = function() {
                        this.root = null;
                    }, ForceGraph.VisualClassName = "forceGraph", ForceGraph.capabilities = {
                        dataRoles: [ {
                            name: "Source",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Source"
                        }, {
                            name: "Target",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Target"
                        }, {
                            name: "Weight",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Weight"
                        }, {
                            name: "LinkType",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "LinkType",
                            description: "Links can be colored by link types"
                        }, {
                            name: "SourceType",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "SourceType",
                            description: "Source type represents the image name for source entities"
                        }, {
                            name: "TargetType",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "TargetType",
                            description: "Target type represents the image name for target entities"
                        } ],
                        objects: {
                            general: {
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Data labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    color: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            links: {
                                displayName: "Links",
                                properties: {
                                    showArrow: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Arrow"
                                    },
                                    showLabel: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Label",
                                        description: "Displays weight on links"
                                    },
                                    colorLink: {
                                        type: {
                                            enumeration: linkColorType.type
                                        },
                                        displayName: "Color"
                                    },
                                    thickenLink: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Thickness",
                                        description: "Thickenss of links represents weight"
                                    }
                                }
                            },
                            nodes: {
                                displayName: "Nodes",
                                properties: {
                                    displayImage: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Image",
                                        description: "Images are loaded from image url + source or target type + image extension"
                                    },
                                    defaultImage: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Default image"
                                    },
                                    imageUrl: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image url"
                                    },
                                    imageExt: {
                                        type: {
                                            text: !0
                                        },
                                        displayName: "Image extension"
                                    },
                                    nameMaxLength: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Max name length",
                                        description: "Max length of the name of entities displayed"
                                    },
                                    highlightReachableLinks: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Highlight all reachable links",
                                        description: "In interactive mode, whether a node's all reachable links will be highlighted"
                                    }
                                }
                            },
                            size: {
                                displayName: "Size",
                                properties: {
                                    charge: {
                                        type: {
                                            numeric: !0
                                        },
                                        displayName: "Charge",
                                        description: "The larger the negative charge the more apart the entities, must be negative but greater than -100"
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Source: {
                                    max: 1
                                },
                                Target: {
                                    max: 1
                                },
                                Weight: {
                                    max: 1
                                },
                                LinkType: {
                                    max: 1
                                },
                                SourceType: {
                                    max: 1
                                },
                                TargetType: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Source"
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Target"
                                        }
                                    }, {
                                        bind: {
                                            to: "Weight"
                                        }
                                    }, {
                                        bind: {
                                            to: "LinkType"
                                        }
                                    }, {
                                        bind: {
                                            to: "SourceType"
                                        }
                                    }, {
                                        bind: {
                                            to: "TargetType"
                                        }
                                    } ]
                                },
                                rowCount: {
                                    preferred: {
                                        min: 1
                                    }
                                }
                            }
                        } ],
                        suppressDefaultTitle: !0
                    }, ForceGraph;
                }();
                samples.ForceGraph = ForceGraph;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, PixelConverter = jsCommon.PixelConverter, PercentFormat = "0.00 %;-0.00 %;0.00 %", MillisecondsInADay = 864e5, MillisecondsInWeek = 6048e5, MillisecondsInAMonth = 2629746e3, MillisecondsInAYear = 31556952e3;
                samples.DefaultDateType = "Week";
                var dateTypeSelector, ChartLineHeight = 40, PaddingTasks = 5;
                !function(dateTypeSelector) {
                    dateTypeSelector.day = "Day", dateTypeSelector.week = "Week", dateTypeSelector.month = "Month", 
                    dateTypeSelector.year = "Year", dateTypeSelector.type = powerbi.createEnumType([ {
                        value: dateTypeSelector.day,
                        displayName: "Day"
                    }, {
                        value: dateTypeSelector.week,
                        displayName: "Week"
                    }, {
                        value: dateTypeSelector.month,
                        displayName: "Month"
                    }, {
                        value: dateTypeSelector.year,
                        displayName: "Year"
                    } ]);
                }(dateTypeSelector = samples.dateTypeSelector || (samples.dateTypeSelector = {})), 
                samples.GanttChartProps = {
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        },
                        position: {
                            objectName: "legend",
                            propertyName: "position"
                        },
                        showTitle: {
                            objectName: "legend",
                            propertyName: "showTitle"
                        },
                        titleText: {
                            objectName: "legend",
                            propertyName: "titleText"
                        },
                        labelColor: {
                            objectName: "legend",
                            propertyName: "labelColor"
                        },
                        fontSize: {
                            objectName: "legend",
                            propertyName: "fontSize"
                        }
                    },
                    taskCompletion: {
                        fill: {
                            objectName: "taskCompletion",
                            propertyName: "fill"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    taskLabels: {
                        show: {
                            objectName: "taskLabels",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "taskLabels",
                            propertyName: "fill"
                        },
                        fontSize: {
                            objectName: "taskLabels",
                            propertyName: "fontSize"
                        },
                        width: {
                            objectName: "taskLabels",
                            propertyName: "width"
                        }
                    },
                    taskResource: {
                        show: {
                            objectName: "taskResource",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "taskResource",
                            propertyName: "fill"
                        },
                        fontSize: {
                            objectName: "taskResource",
                            propertyName: "fontSize"
                        }
                    },
                    ganttDateType: {
                        type: {
                            objectName: "ganttDateType",
                            propertyName: "type"
                        }
                    }
                };
                var Selectors;
                !function(Selectors) {
                    var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                    Selectors.ClassName = CreateClassAndSelector("gantt"), Selectors.Chart = CreateClassAndSelector("chart"), 
                    Selectors.ChartLine = CreateClassAndSelector("chart-line"), Selectors.Body = CreateClassAndSelector("gantt-body"), 
                    Selectors.AxisGroup = CreateClassAndSelector("axis"), Selectors.Domain = CreateClassAndSelector("domain"), 
                    Selectors.AxisTick = CreateClassAndSelector("tick"), Selectors.Tasks = CreateClassAndSelector("tasks"), 
                    Selectors.SingleTask = CreateClassAndSelector("task"), Selectors.TaskRect = CreateClassAndSelector("task-rect"), 
                    Selectors.TaskProgress = CreateClassAndSelector("task-progress"), Selectors.TaskResource = CreateClassAndSelector("task-resource"), 
                    Selectors.SingleMilestone = CreateClassAndSelector("milestone"), Selectors.TaskLabels = CreateClassAndSelector("task-labels"), 
                    Selectors.TaskLines = CreateClassAndSelector("task-lines"), Selectors.SingleTaskLine = CreateClassAndSelector("task-line"), 
                    Selectors.Label = CreateClassAndSelector("label"), Selectors.LegendItems = CreateClassAndSelector("legendItem"), 
                    Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
                }(Selectors || (Selectors = {}));
                var Gantt = function() {
                    function Gantt() {
                        this.textProperties = {
                            fontFamily: "wf_segoe-ui_normal",
                            fontSize: jsCommon.PixelConverter.toString(9)
                        }, this.margin = {
                            top: 50,
                            right: 40,
                            bottom: 40,
                            left: 10
                        };
                    }
                    return Gantt.getMaxTaskOpacity = function() {
                        return Gantt.DefaultValues.MaxTaskOpacity;
                    }, Gantt.getMinTaskOpacity = function() {
                        return Gantt.DefaultValues.MinTaskOpacity;
                    }, Gantt.prototype.init = function(options) {
                        var element = options.element;
                        this.style = options.style, this.body = d3.select(element.get(0)), this.hostServices = options.host, 
                        this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend, 
                        this.interactivityService = visuals.createInteractivityService(this.hostServices), 
                        this.createViewport(element), this.updateChartSize(options.viewport), this.behavior = new GanttChartBehavior(), 
                        this.colors = options.style.colorPalette.dataColors, this.data = {
                            legendData: null,
                            series: null,
                            showLegend: null
                        };
                    }, Gantt.prototype.createViewport = function(element) {
                        this.ganttDiv = this.body.append("div").classed(Selectors.Body["class"], !0), this.ganttSvg = this.ganttDiv.append("svg").classed(Selectors.ClassName["class"], !0), 
                        this.clearCatcher = visuals.appendClearCatcher(this.ganttSvg), this.axisGroup = this.ganttSvg.append("g").classed(Selectors.AxisGroup["class"], !0), 
                        this.lineGroup = this.ganttSvg.append("g").classed(Selectors.TaskLines["class"], !0), 
                        this.chartGroup = this.ganttSvg.append("g").classed(Selectors.Chart["class"], !0), 
                        this.taskGroup = this.chartGroup.append("g").classed(Selectors.Tasks["class"], !0), 
                        this.legend = visuals.createLegend(element.children(Selectors.Body.selector), this.isInteractiveChart, this.interactivityService, !0, visuals.LegendPosition.Top);
                    }, Gantt.prototype.clearViewport = function() {
                        this.body.selectAll(Selectors.LegendItems.selector).remove(), this.body.selectAll(Selectors.LegendTitle.selector).remove(), 
                        this.axisGroup.selectAll(Selectors.AxisTick.selector).remove(), this.axisGroup.selectAll(Selectors.Domain.selector).remove(), 
                        this.lineGroup.selectAll("*").remove(), this.chartGroup.selectAll(Selectors.ChartLine.selector).remove(), 
                        this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
                    }, Gantt.prototype.updateChartSize = function(viewport) {
                        this.ganttDiv.style({
                            height: PixelConverter.toString(viewport.height),
                            width: PixelConverter.toString(viewport.width)
                        });
                    }, Gantt.prototype.createSeries = function(objects, tasks) {
                        var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill), taskGroup = _.groupBy(tasks, function(t) {
                            return t.taskType;
                        }), taskTypes = Gantt.getAllTasksTypes(this.dataView), series = _.map(taskTypes.types, function(type) {
                            return {
                                tasks: taskGroup[type],
                                fill: colorHelper.getColorForMeasure(objects, type),
                                name: type,
                                identity: visuals.SelectionId.createWithMeasure(type),
                                selected: !1
                            };
                        });
                        return series;
                    }, Gantt.converter = function(dataView, colorPalette) {
                        var taskLabelsShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.show, !0), taskLabelsColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor), taskLabelsFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize), taskLabelsWidth = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0), taskProgressColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor), taskResourceColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor), taskResourceFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize), taskResourceShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.show, !0), dateType = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType), taskTypes = Gantt.getAllTasksTypes(dataView), colorHelper = new visuals.ColorHelper(colorPalette, samples.GanttChartProps.dataPoint.fill), legendData = {
                            fontSize: Gantt.DefaultValues.LegendFontSize,
                            dataPoints: [],
                            title: taskTypes.typeName
                        };
                        legendData.dataPoints = _.map(taskTypes.types, function(type) {
                            return {
                                label: type,
                                color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
                                icon: visuals.LegendIcon.Circle,
                                selected: !1,
                                identity: visuals.SelectionId.createWithMeasure(type)
                            };
                        });
                        var settings = {
                            taskLabelsShow: taskLabelsShow,
                            taskLabelsColor: taskLabelsColor,
                            taskLabelsFontSize: taskLabelsFontSize,
                            taskLabelsWidth: taskLabelsWidth,
                            taskProgressColor: taskProgressColor,
                            taskResourceShow: taskResourceShow,
                            taskResourceColor: taskResourceColor,
                            taskResourceFontSize: taskResourceFontSize,
                            legendData: legendData,
                            taskTypes: taskTypes,
                            dateType: dateType
                        };
                        return settings;
                    }, Gantt.prototype.parseSettings = function(dataView) {
                        if (!dataView || !dataView.metadata || !dataView.metadata.columns) return null;
                        for (var dateFormat = "d", numberFormat = "#", _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                            var dvColumn = _a[_i];
                            if (dataView.categorical.categories) for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
                                var dvCategory = _c[_b];
                                this.hasRole(dvCategory.source, "StartDate") && (dateFormat = dvColumn.format);
                            }
                        }
                        return {
                            startDateFormatter: visuals.valueFormatter.create({
                                format: dateFormat
                            }),
                            durationFormatter: visuals.valueFormatter.create({
                                format: numberFormat
                            }),
                            completionFormatter: visuals.valueFormatter.create({
                                format: PercentFormat,
                                value: 1,
                                allowFormatBeautification: !0
                            })
                        };
                    }, Gantt.prototype.isValidDate = function(date) {
                        return "[object Date]" !== Object.prototype.toString.call(date) ? !1 : !isNaN(date.getTime());
                    }, Gantt.prototype.convertToDecimal = function(number) {
                        return number >= 0 && 1 >= number ? number : number / 100;
                    }, Gantt.prototype.createTasks = function(dataView, formatters) {
                        var _this = this, columnSource = dataView.table.columns, data = dataView.table.rows, categories = dataView.categorical.categories[0], colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);
                        return data.map(function(child, index) {
                            var dateString = _this.getTaskProperty(columnSource, child, "StartDate");
                            dateString = _this.isValidDate(dateString) ? dateString : new Date(Date.now());
                            var duration = _this.getTaskProperty(columnSource, child, "Duration"), completionValue = _this.getTaskProperty(columnSource, child, "Completion"), completion = _this.convertToDecimal(completionValue);
                            completion = 1 >= completion ? completion : 1;
                            var taskType = _this.getTaskProperty(columnSource, child, "Legend"), tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType), task = {
                                id: index,
                                name: _this.getTaskProperty(columnSource, child, "Task"),
                                start: dateString ? dateString : new Date(Date.now()),
                                duration: duration > 0 ? duration : 1,
                                end: null,
                                completion: completion > 0 ? completion : 0,
                                resource: _this.getTaskProperty(columnSource, child, "Resource"),
                                taskType: taskType,
                                color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
                                tooltipInfo: null,
                                description: "",
                                identity: visuals.SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),
                                selected: !1
                            };
                            return task.end = d3.time.day.offset(task.start, task.duration), task.tooltipInfo = _this.getTooltipInfo(task, formatters), 
                            task;
                        });
                    }, Gantt.getAllTasksTypes = function(dataView) {
                        var taskTypes, types = [], groupName = "", data = dataView.table.rows, index = _.findIndex(dataView.table.columns, function(col) {
                            return col.roles.hasOwnProperty("Legend");
                        });
                        return -1 !== index && (groupName = dataView.table.columns[index].displayName, types = _.unique(data, function(d) {
                            return d[index];
                        }).map(function(d) {
                            return d[index];
                        })), taskTypes = {
                            typeName: groupName,
                            types: types
                        };
                    }, Gantt.prototype.getTooltipInfo = function(task, formatters, timeInterval) {
                        void 0 === timeInterval && (timeInterval = "Days");
                        var tooltipDataArray = [];
                        return task.taskType && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[0].name,
                            value: task.taskType
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[1].name,
                            value: task.name
                        }), isNaN(task.start.getDate()) || tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[2].name,
                            value: formatters.startDateFormatter.format(task.start.toLocaleDateString())
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[3].name,
                            value: formatters.durationFormatter.format(task.duration) + " " + timeInterval
                        }), tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[4].name,
                            value: formatters.completionFormatter.format(task.completion)
                        }), task.resource && tooltipDataArray.push({
                            displayName: Gantt.capabilities.dataRoles[5].name,
                            value: task.resource
                        }), tooltipDataArray;
                    }, Gantt.prototype.getTaskProperty = function(columnSource, child, propertyName) {
                        if (!(child && columnSource && columnSource.length > 0 && columnSource[0].roles)) return null;
                        var index = columnSource.indexOf(columnSource.filter(function(x) {
                            return x.roles[propertyName];
                        })[0]);
                        return -1 !== index ? child[index] : null;
                    }, Gantt.prototype.hasRole = function(column, name) {
                        var roles = column.roles;
                        return roles && roles[name];
                    }, Gantt.prototype.isChartHasTask = function(dataView) {
                        if (dataView.table && dataView.table.columns) for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (this.hasRole(column, "Task")) return !0;
                        }
                        return !1;
                    }, Gantt.prototype.renderLegend = function(legendData) {
                        if (legendData) {
                            if (this.legendObjectProperties) {
                                visuals.LegendData.update(legendData, this.legendObjectProperties);
                                var position;
                                position = this.legendObjectProperties[visuals.legendProps.position], position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            }
                            var viewport = this.viewport;
                            this.legend.drawLegend(legendData, {
                                height: viewport.height,
                                width: viewport.width
                            }), visuals.Legend.positionChartArea(this.ganttSvg, this.legend);
                        }
                    }, Gantt.prototype.parseLegendProperties = function(dataView) {
                        return dataView && dataView.metadata ? void (this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {})) : void (this.legendObjectProperties = {});
                    }, Gantt.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var dataView = options.dataViews[0];
                            if (!this.isChartHasTask(dataView) || 0 === options.dataViews[0].table.rows.length) return void this.clearViewport();
                            this.dataView = dataView;
                            var viewport = options.viewport;
                            this.viewport = viewport, this.updateChartSize(viewport);
                            var viewModel = Gantt.converter(dataView, this.colors), formatters = this.parseSettings(dataView), tasks = this.createTasks(dataView, formatters);
                            if (this.parseLegendProperties(dataView), this.renderLegend(viewModel.legendData), 
                            this.data.series = this.createSeries(dataView.metadata.objects, tasks), this.viewModel = viewModel, 
                            this.interactivityService && (this.interactivityService.applySelectionStateToData(tasks), 
                            this.interactivityService.applySelectionStateToData(this.data.series)), tasks.length > 0) {
                                var tasksSortedByStartDate = _.sortBy(tasks, function(t) {
                                    return t.start;
                                }), tasksSortedByEndDate = _.sortBy(tasks, function(t) {
                                    return t.end;
                                }), dateTypeMilliseconds = this.getDateType(), startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);
                                ticks = 0 === ticks || 1 === ticks ? 2 : ticks;
                                var axisLength = 50 * ticks;
                                this.ganttSvg.attr({
                                    height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),
                                    width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)
                                });
                                var viewportIn = {
                                    height: viewport.height,
                                    width: axisLength
                                }, xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, !1);
                                if (this.timeScale = xAxisProperties.scale, this.renderAxis(xAxisProperties, 200), 
                                this.renderTasks(tasks), this.createMilestoneLine(tasks), this.updateTaskLabels(tasks, viewModel.taskLabelsWidth), 
                                this.updateElementsPositions(viewport, this.margin), this.interactivityService) {
                                    var behaviorOptions = {
                                        clearCatcher: this.clearCatcher,
                                        taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
                                        legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
                                        interactivityService: this.interactivityService
                                    };
                                    this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
                                }
                            }
                        }
                    }, Gantt.prototype.getDateType = function() {
                        var milliSeconds = MillisecondsInWeek;
                        switch (this.viewModel.dateType) {
                          case "Day":
                            milliSeconds = MillisecondsInADay;
                            break;

                          case "Week":
                            milliSeconds = MillisecondsInWeek;
                            break;

                          case "Month":
                            milliSeconds = MillisecondsInAMonth;
                            break;

                          case "Year":
                            milliSeconds = MillisecondsInAYear;
                        }
                        return milliSeconds;
                    }, Gantt.prototype.calculateAxes = function(viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
                        var dataTypeDatetime = powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Date), category = {
                            displayName: "StartDate",
                            queryName: "StartDate",
                            type: dataTypeDatetime,
                            index: 0
                        }, visualOptions = {
                            viewport: viewportIn,
                            margin: this.margin,
                            forcedXDomain: [ startDate, endDate ],
                            forceMerge: !1,
                            showCategoryAxisLabel: !1,
                            showValueAxisLabel: !1,
                            categoryAxisScaleType: powerbi.visuals.axisScale.linear,
                            valueAxisScaleType: null,
                            valueAxisDisplayUnits: 0,
                            categoryAxisDisplayUnits: 0,
                            trimOrdinalDataOnOverflow: !1,
                            forcedTickCount: ticksCount
                        }, width = viewportIn.width, axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
                        return axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties), 
                        axes.willLabelsWordBreak = !axes.willLabelsFit && !scrollbarVisible && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties), 
                        axes;
                    }, Gantt.prototype.calculateAxesProperties = function(viewportIn, options, axisLength, metaDataColumn) {
                        var xAxisProperties = visuals.AxisHelper.createAxis({
                            pixelSpan: viewportIn.width,
                            dataDomain: options.forcedXDomain,
                            metaDataColumn: metaDataColumn,
                            formatString: Gantt.DefaultValues.ganttFormatString,
                            outerPadding: 0,
                            isScalar: !0,
                            isVertical: !1,
                            forcedTickCount: options.forcedTickCount,
                            useTickIntervalForDisplayUnits: !0,
                            isCategoryAxis: !0,
                            getValueFn: function(index, type) {
                                return visuals.valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);
                            },
                            scaleType: options.categoryAxisScaleType,
                            axisDisplayUnits: options.categoryAxisDisplayUnits
                        });
                        return xAxisProperties.axisLabel = metaDataColumn.displayName, xAxisProperties;
                    }, Gantt.prototype.renderAxis = function(xAxisProperties, duration) {
                        var xAxis = xAxisProperties.axis;
                        xAxis.orient("bottom"), this.axisGroup.transition().duration(duration).call(xAxis);
                    }, Gantt.prototype.updateTaskLabels = function(tasks, width) {
                        var axisLabel, _this = this, taskLineCoordinateX = 15, taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : !0, taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor, taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;
                        taskLabelsShow ? (axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks), 
                        axisLabel.enter().append("text").classed(Selectors.Label["class"], !0), axisLabel.attr({
                            x: taskLineCoordinateX,
                            y: function(task, i) {
                                return _this.getTaskLabelCoordinateY(task.id);
                            },
                            fill: taskLabelsColor,
                            "stroke-width": 1
                        }).style("font-size", PixelConverter.fromPoint(taskLabelsFontSize)).text(function(task) {
                            return task.name;
                        }), axisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width - 20, powerbi.TextMeasurementService.svgEllipsis), 
                        axisLabel.append("title").text(function(task) {
                            return task.name;
                        }), axisLabel.exit().remove()) : this.lineGroup.selectAll(Selectors.Label.selector).remove();
                    }, Gantt.prototype.renderTasks = function(tasks) {
                        var _this = this, taskSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks), taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor, taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : !0, padding = 4, taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor, taskResourceFontSize = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;
                        taskSelection.enter().append("g").classed(Selectors.SingleTask["class"], !0);
                        var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function(d) {
                            return [ d ];
                        });
                        taskRect.enter().append("rect").classed(Selectors.TaskRect["class"], !0), taskRect.classed(Selectors.TaskRect["class"], !0).attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id);
                            },
                            width: function(task) {
                                return _this.taskDurationToWidth(task);
                            },
                            height: function() {
                                return _this.getBarHeight();
                            }
                        }).style("fill", function(task) {
                            return task.color;
                        }), taskRect.exit().remove();
                        var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function(d) {
                            return [ d ];
                        });
                        if (taskProgress.enter().append("rect").classed(Selectors.TaskProgress["class"], !0), 
                        taskProgress.attr({
                            x: function(task) {
                                return _this.timeScale(task.start);
                            },
                            y: function(task) {
                                return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2;
                            },
                            width: function(task) {
                                return _this.setTaskProgress(task);
                            },
                            height: Gantt.DefaultValues.ProgressBarHeight
                        }).style("fill", taskProgressColor), taskProgress.exit().remove(), taskResourceShow) {
                            var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function(d) {
                                return [ d ];
                            });
                            taskResource.enter().append("text").classed(Selectors.TaskResource["class"], !0), 
                            taskResource.attr({
                                x: function(task) {
                                    return _this.timeScale(task.end) + padding;
                                },
                                y: function(task) {
                                    return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 + padding;
                                }
                            }).text(function(task) {
                                return task.resource;
                            }).style({
                                fill: taskResourceColor,
                                "font-size": PixelConverter.fromPoint(taskResourceFontSize)
                            }).call(visuals.AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, powerbi.TextMeasurementService.svgEllipsis), 
                            taskResource.exit().remove();
                        } else taskSelection.selectAll(Selectors.TaskResource.selector).remove();
                        visuals.TooltipManager.addTooltip(taskSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), taskSelection.exit().remove();
                    }, Gantt.prototype.onClearSelection = function() {
                        this.selectionManager.clear();
                    }, Gantt.prototype.getTaskLabelCoordinateY = function(taskIndex) {
                        var fontSize = +this.getTaskLabelFontSize();
                        return ChartLineHeight * taskIndex + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
                    }, Gantt.prototype.setTaskProgress = function(task) {
                        var fraction = task.completion / 1, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
                        return progress;
                    }, Gantt.prototype.getBarYCoordinate = function(lineNumber) {
                        return ChartLineHeight * lineNumber + PaddingTasks;
                    }, Gantt.prototype.getBarHeight = function() {
                        return ChartLineHeight / 1.5;
                    }, Gantt.prototype.taskDurationToWidth = function(task) {
                        return this.timeScale(task.end) - this.timeScale(task.start);
                    }, Gantt.prototype.getTooltipForMilstoneLine = function(timestamp, milestoneTitle) {
                        var stringDate = new Date(timestamp).toDateString(), tooltip = [ {
                            displayName: milestoneTitle,
                            value: stringDate
                        } ];
                        return tooltip;
                    }, Gantt.prototype.createMilestoneLine = function(tasks, milestoneTitle, timestamp) {
                        void 0 === milestoneTitle && (milestoneTitle = "Today"), void 0 === timestamp && (timestamp = Date.now());
                        var line = [ {
                            x1: this.timeScale(timestamp),
                            y1: 0,
                            x2: this.timeScale(timestamp),
                            y2: this.getMilestoneLineLength(tasks.length),
                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
                        } ], chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
                        chartLineSelection.enter().append("line").classed(Selectors.ChartLine["class"], !0), 
                        chartLineSelection.attr({
                            x1: function(line) {
                                return line.x1;
                            },
                            y1: function(line) {
                                return line.y1;
                            },
                            x2: function(line) {
                                return line.x2;
                            },
                            y2: function(line) {
                                return line.y2;
                            },
                            tooltipInfo: function(line) {
                                return line.tooltipInfo;
                            }
                        }), visuals.TooltipManager.addTooltip(chartLineSelection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        }), chartLineSelection.exit().remove();
                    }, Gantt.prototype.updateElementsPositions = function(viewport, margin) {
                        var viewModel = this.viewModel;
                        this.axisGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15)), 
                        this.chartGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top)), 
                        this.lineGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                    }, Gantt.prototype.getMilestoneLineLength = function(numOfTasks) {
                        return numOfTasks * ChartLineHeight;
                    }, Gantt.prototype.getTaskLabelFontSize = function() {
                        return powerbi.DataViewObjects.getValue(this.dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);
                    }, Gantt.prototype.enumerateLegendOptions = function(enumeration, objects) {
                        enumeration.pushInstance({
                            displayName: samples.GanttChartProps.legend.show.objectName,
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.show, !0),
                                position: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.position, !0),
                                showTitle: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.showTitle, !0),
                                titleText: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.titleText, ""),
                                labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),
                                fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)
                            },
                            objectName: samples.GanttChartProps.legend.show.objectName
                        });
                    }, Gantt.prototype.enumerateDataPoints = function(enumeration, objects) {
                        var taskSeries = this.data.series;
                        taskSeries.forEach(function(item) {
                            enumeration.pushInstance({
                                objectName: "dataPoint",
                                displayName: item.name,
                                selector: visuals.ColorHelper.normalizeSelector(item.identity.getSelector(), !1),
                                properties: {
                                    fill: {
                                        solid: {
                                            color: item.fill
                                        }
                                    }
                                }
                            });
                        });
                    }, Gantt.prototype.enumerateTaskCompletion = function(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)
                            },
                            objectName: samples.GanttChartProps.taskCompletion.fill.objectName
                        });
                    }, Gantt.prototype.enumerateTaskLabels = function(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.show, !0),
                                fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),
                                fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),
                                width: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth)
                            },
                            objectName: samples.GanttChartProps.taskLabels.show.objectName
                        });
                    }, Gantt.prototype.enumerateDataLabels = function(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.show, !0),
                                fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),
                                fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)
                            },
                            objectName: samples.GanttChartProps.taskResource.show.objectName
                        });
                    }, Gantt.prototype.enumerateDateType = function(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                type: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType)
                            },
                            objectName: samples.GanttChartProps.ganttDateType.type.objectName
                        });
                    }, Gantt.prototype.enumerateObjectInstances = function(options) {
                        var dataView = this.dataView;
                        if (dataView) {
                            var enumeration = new visuals.ObjectEnumerationBuilder();
                            switch (options.objectName) {
                              case "legend":
                                this.enumerateLegendOptions(enumeration, dataView.metadata.objects);
                                break;

                              case "dataPoint":
                                this.enumerateDataPoints(enumeration, dataView.metadata.objects);
                                break;

                              case "taskLabels":
                                this.enumerateTaskLabels(enumeration, dataView.metadata.objects);
                                break;

                              case "taskCompletion":
                                this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);
                                break;

                              case "taskResource":
                                this.enumerateDataLabels(enumeration, dataView.metadata.objects);
                                break;

                              case "ganttDateType":
                                this.enumerateDateType(enumeration, dataView.metadata.objects);
                            }
                            return enumeration.complete();
                        }
                    }, Gantt.DefaultValues = {
                        AxisTickSize: 6,
                        LabelFontSize: 9,
                        LegendFontSize: 8,
                        LegendLabelColor: "#000000",
                        MaxTaskOpacity: 1,
                        MinTaskOpacity: .4,
                        ProgressBarHeight: 4,
                        ProgressColor: "#000000",
                        ResourceFontSize: 9,
                        ResourceWidth: 100,
                        TaskColor: "#00B099",
                        TaskLabelColor: "#000000",
                        TaskLabelWidth: 110,
                        TaskLineWidth: 15,
                        TaskResourceColor: "#000000",
                        ganttFormatString: "MMM dd"
                    }, Gantt.capabilities = {
                        dataRoles: [ {
                            name: "Legend",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend"
                        }, {
                            name: "Task",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Task"
                        }, {
                            name: "StartDate",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Start Date"
                        }, {
                            name: "Duration",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Duration",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Completion",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "% Completion",
                            requiredTypes: [ {
                                numeric: !0
                            }, {
                                integer: !0
                            } ]
                        }, {
                            name: "Resource",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Resource"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 0
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 1,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 0
                                },
                                Completion: {
                                    min: 0,
                                    max: 0
                                },
                                Resource: {
                                    min: 0,
                                    max: 0
                                }
                            }, {
                                Legend: {
                                    min: 0,
                                    max: 1
                                },
                                Task: {
                                    min: 0,
                                    max: 1
                                },
                                StartDate: {
                                    min: 0,
                                    max: 1
                                },
                                Duration: {
                                    min: 0,
                                    max: 1
                                },
                                Completion: {
                                    min: 0,
                                    max: 1
                                },
                                Resource: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            table: {
                                rows: {
                                    select: [ {
                                        "for": {
                                            "in": "Legend"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Task"
                                        }
                                    }, {
                                        "for": {
                                            "in": "StartDate"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Duration"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Completion"
                                        }
                                    }, {
                                        "for": {
                                            "in": "Resource"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        sorting: {
                            "default": {}
                        },
                        objects: {
                            legend: {
                                displayName: "Legend",
                                description: "Display legend options",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        description: "Select the location for the legend",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        description: "Display a title for legend symbols",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        description: "Title text",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            taskLabels: {
                                displayName: "Category Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Fill",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    },
                                    width: {
                                        displayName: "Width",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            taskCompletion: {
                                displayName: "Task Completion",
                                properties: {
                                    show: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Completion Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            taskResource: {
                                displayName: "Data Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fill: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Font Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            },
                            ganttDateType: {
                                displayName: "Gantt Date Type",
                                properties: {
                                    type: {
                                        displayName: "Type",
                                        type: {
                                            enumeration: dateTypeSelector.type
                                        }
                                    }
                                }
                            }
                        }
                    }, Gantt;
                }();
                samples.Gantt = Gantt;
                var GanttChartBehavior = function() {
                    function GanttChartBehavior() {}
                    return GanttChartBehavior.prototype.bindEvents = function(options, selectionHandler) {
                        this.options = options;
                        var clearCatcher = options.clearCatcher;
                        options.taskSelection.on("click", function(d) {
                            selectionHandler.handleSelection(d, d3.event.ctrlKey), d3.event.stopPropagation();
                        }), clearCatcher.on("click", function() {
                            selectionHandler.handleClearSelection();
                        });
                    }, GanttChartBehavior.prototype.renderSelection = function(hasSelection) {
                        var options = this.options, ganttMaxOpacity = Gantt.getMaxTaskOpacity(), ganttMinOpacity = Gantt.getMinTaskOpacity();
                        options.taskSelection.style("opacity", function(d) {
                            return hasSelection && !d.selected ? ganttMinOpacity : ganttMaxOpacity;
                        });
                    }, GanttChartBehavior;
                }();
                samples.GanttChartBehavior = GanttChartBehavior;
                var GanttChartWarning = function() {
                    function GanttChartWarning() {}
                    return Object.defineProperty(GanttChartWarning.prototype, "code", {
                        get: function() {
                            return "GanttChartWarning";
                        },
                        enumerable: !0,
                        configurable: !0
                    }), GanttChartWarning.prototype.getMessages = function(resourceProvider) {
                        var visualMessage, message = "This visual requires task value", titleKey = "", detailKey = "";
                        return visualMessage = {
                            message: message,
                            title: resourceProvider.get(titleKey),
                            detail: resourceProvider.get(detailKey)
                        };
                    }, GanttChartWarning;
                }();
                samples.GanttChartWarning = GanttChartWarning;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi, __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector, SelectionManager = visuals.utility.SelectionManager, px = jsCommon.PixelConverter.toString, pt = jsCommon.PixelConverter.fromPoint, fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;
                samples.Months = powerbi.createEnumType([ {
                    value: 1,
                    displayName: "January"
                }, {
                    value: 2,
                    displayName: "February"
                }, {
                    value: 3,
                    displayName: "March"
                }, {
                    value: 4,
                    displayName: "April"
                }, {
                    value: 5,
                    displayName: "May"
                }, {
                    value: 6,
                    displayName: "June"
                }, {
                    value: 7,
                    displayName: "July"
                }, {
                    value: 8,
                    displayName: "August"
                }, {
                    value: 9,
                    displayName: "September"
                }, {
                    value: 10,
                    displayName: "October"
                }, {
                    value: 11,
                    displayName: "November"
                }, {
                    value: 12,
                    displayName: "December"
                } ]), samples.WeekDays = powerbi.createEnumType([ {
                    value: 0,
                    displayName: "Sunday"
                }, {
                    value: 1,
                    displayName: "Monday"
                }, {
                    value: 2,
                    displayName: "Tuesday"
                }, {
                    value: 3,
                    displayName: "Wednesday"
                }, {
                    value: 4,
                    displayName: "Thursday"
                }, {
                    value: 5,
                    displayName: "Friday"
                }, {
                    value: 6,
                    displayName: "Saturday"
                } ]), function(GranularityType) {
                    GranularityType[GranularityType.year = 0] = "year", GranularityType[GranularityType.quarter = 1] = "quarter", 
                    GranularityType[GranularityType.month = 2] = "month", GranularityType[GranularityType.week = 3] = "week", 
                    GranularityType[GranularityType.day = 4] = "day";
                }(samples.GranularityType || (samples.GranularityType = {}));
                var GranularityType = samples.GranularityType, SelectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillSelected"
                }, UnselectedCellColorProp = {
                    objectName: "cells",
                    propertyName: "fillUnselected"
                }, TimeRangeColorProp = {
                    objectName: "rangeHeader",
                    propertyName: "fontColor"
                }, TimeRangeSizeProp = {
                    objectName: "rangeHeader",
                    propertyName: "textSize"
                }, TimeRangeShowProp = {
                    objectName: "rangeHeader",
                    propertyName: "show"
                }, LabelsColorProp = {
                    objectName: "labels",
                    propertyName: "fontColor"
                }, LabelsSizeProp = {
                    objectName: "labels",
                    propertyName: "textSize"
                }, LabelsShowProp = {
                    objectName: "labels",
                    propertyName: "show"
                }, CalendarMonthProp = {
                    objectName: "calendar",
                    propertyName: "month"
                }, CalendarDayProp = {
                    objectName: "calendar",
                    propertyName: "day"
                }, WeekDayProp = {
                    objectName: "weekDay",
                    propertyName: "day"
                }, GranularityNames = [ {
                    granularityType: GranularityType.year,
                    name: "year"
                }, {
                    granularityType: GranularityType.quarter,
                    name: "quarter"
                }, {
                    granularityType: GranularityType.month,
                    name: "month"
                }, {
                    granularityType: GranularityType.week,
                    name: "week"
                }, {
                    granularityType: GranularityType.day,
                    name: "day"
                } ], TimelineGranularity = function() {
                    function TimelineGranularity() {
                        this.datePeriods = [];
                    }
                    return TimelineGranularity.prototype.shortMonthName = function(date) {
                        return date.toString().split(" ")[1];
                    }, TimelineGranularity.prototype.resetDatePeriods = function() {
                        this.datePeriods = [];
                    }, TimelineGranularity.prototype.getDatePeriods = function() {
                        return this.datePeriods;
                    }, TimelineGranularity.prototype.getExtendedLabel = function() {
                        return this.extendedLabel;
                    }, TimelineGranularity.prototype.setExtendedLabel = function(extendedLabel) {
                        this.extendedLabel = extendedLabel;
                    }, TimelineGranularity.prototype.createLabels = function(granularity) {
                        var lastDatePeriod, labels = [];
                        return _.map(this.datePeriods, function(x) {
                            !_.isEmpty(labels) && granularity.sameLabel(x, lastDatePeriod) || (lastDatePeriod = x, 
                            labels.push(granularity.generateLabel(x)));
                        }), labels;
                    }, TimelineGranularity.prototype.addDate = function(date, identifierArray) {
                        var datePeriods = this.getDatePeriods(), lastDatePeriod = datePeriods[datePeriods.length - 1];
                        0 !== datePeriods.length && _.isEqual(lastDatePeriod.identifierArray, identifierArray) ? lastDatePeriod.endDate = date : (datePeriods.length > 0 && (lastDatePeriod.endDate = date), 
                        datePeriods.push({
                            identifierArray: identifierArray,
                            startDate: date,
                            endDate: date,
                            week: this.determineWeek(date),
                            year: this.determineYear(date),
                            fraction: 1,
                            index: datePeriods.length
                        }));
                    }, TimelineGranularity.prototype.setNewEndDate = function(date) {
                        _.last(this.datePeriods).endDate = date;
                    }, TimelineGranularity.prototype.splitPeriod = function(index, newFraction, newDate) {
                        var oldDatePeriod = this.datePeriods[index];
                        oldDatePeriod.fraction -= newFraction;
                        var newDateObject = {
                            identifierArray: oldDatePeriod.identifierArray,
                            startDate: newDate,
                            endDate: oldDatePeriod.endDate,
                            week: this.determineWeek(newDate),
                            year: this.determineYear(newDate),
                            fraction: newFraction,
                            index: oldDatePeriod.index + oldDatePeriod.fraction
                        };
                        oldDatePeriod.endDate = newDate, this.datePeriods.splice(index + 1, 0, newDateObject);
                    }, TimelineGranularity.prototype.previousMonth = function(month) {
                        return month > 0 ? month - 1 : 11;
                    }, TimelineGranularity.prototype.nextMonth = function(month) {
                        return 11 > month ? month + 1 : 0;
                    }, TimelineGranularity.prototype.countWeeks = function(startDate, endDate) {
                        var totalDays;
                        if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate()) totalDays = endDate.getDate() - startDate.getDate(); else {
                            totalDays = endDate.getDate() - 1;
                            for (var lastMonth = this.nextMonth(startDate.getMonth()), month = endDate.getMonth(); month !== lastMonth; ) totalDays += new Date(endDate.getFullYear(), month, 0).getDate(), 
                            month = this.previousMonth(month);
                            totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
                        }
                        return 1 + Math.floor(totalDays / 7);
                    }, TimelineGranularity.prototype.determineWeek = function(date) {
                        var year = date.getFullYear();
                        this.inPreviousYear(date) && year--;
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year), weeks = this.countWeeks(dateOfFirstWeek, date);
                        return [ weeks, year ];
                    }, TimelineGranularity.prototype.inPreviousYear = function(date) {
                        var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
                        return dateOfFirstWeek > date;
                    }, TimelineGranularity.prototype.determineYear = function(date) {
                        var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
                        return date.getFullYear() - (date >= firstDay ? 0 : 1);
                    }, TimelineGranularity;
                }();
                samples.TimelineGranularity = TimelineGranularity;
                var DayGranularity = function(_super) {
                    function DayGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(DayGranularity, _super), DayGranularity.prototype.getType = function() {
                        return GranularityType.day;
                    }, DayGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getDate(), date.getFullYear() ];
                    }, DayGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
                    }, DayGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: this.shortMonthName(datePeriod.startDate) + " " + datePeriod.startDate.getDate() + " - " + datePeriod.year,
                            text: datePeriod.startDate.getDate().toString(),
                            id: datePeriod.index
                        };
                    }, DayGranularity;
                }(TimelineGranularity);
                samples.DayGranularity = DayGranularity;
                var MonthGranularity = function(_super) {
                    function MonthGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(MonthGranularity, _super), MonthGranularity.prototype.getType = function() {
                        return GranularityType.month;
                    }, MonthGranularity.prototype.splitDate = function(date) {
                        return [ this.shortMonthName(date), date.getFullYear() ];
                    }, MonthGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
                    }, MonthGranularity.prototype.generateLabel = function(datePeriod) {
                        var shortMonthName = this.shortMonthName(datePeriod.startDate);
                        return {
                            title: shortMonthName,
                            text: shortMonthName,
                            id: datePeriod.index
                        };
                    }, MonthGranularity;
                }(TimelineGranularity);
                samples.MonthGranularity = MonthGranularity;
                var WeekGranularity = function(_super) {
                    function WeekGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(WeekGranularity, _super), WeekGranularity.prototype.getType = function() {
                        return GranularityType.week;
                    }, WeekGranularity.prototype.splitDate = function(date) {
                        return this.determineWeek(date);
                    }, WeekGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
                    }, WeekGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Week " + datePeriod.week[0] + " - " + datePeriod.week[1],
                            text: "W" + datePeriod.week[0],
                            id: datePeriod.index
                        };
                    }, WeekGranularity;
                }(TimelineGranularity);
                samples.WeekGranularity = WeekGranularity;
                var QuarterGranularity = function(_super) {
                    function QuarterGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(QuarterGranularity, _super), QuarterGranularity.prototype.quarterText = function(date) {
                        for (var quarter = 3, year = date.getFullYear(); date < Timeline.calendar.getQuarterStartDate(year, quarter); ) quarter > 0 ? quarter-- : (quarter = 3, 
                        year--);
                        return quarter++, "Q" + quarter;
                    }, QuarterGranularity.prototype.getType = function() {
                        return GranularityType.quarter;
                    }, QuarterGranularity.prototype.splitDate = function(date) {
                        return [ this.quarterText(date), date.getFullYear() ];
                    }, QuarterGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate) && firstDatePeriod.year === secondDatePeriod.year;
                    }, QuarterGranularity.prototype.generateLabel = function(datePeriod) {
                        var quarter = this.quarterText(datePeriod.startDate);
                        return {
                            title: quarter + " " + datePeriod.year,
                            text: quarter,
                            id: datePeriod.index
                        };
                    }, QuarterGranularity;
                }(TimelineGranularity);
                samples.QuarterGranularity = QuarterGranularity;
                var YearGranularity = function(_super) {
                    function YearGranularity() {
                        _super.apply(this, arguments);
                    }
                    return __extends(YearGranularity, _super), YearGranularity.prototype.getType = function() {
                        return GranularityType.year;
                    }, YearGranularity.prototype.splitDate = function(date) {
                        return [ date.getFullYear() ];
                    }, YearGranularity.prototype.sameLabel = function(firstDatePeriod, secondDatePeriod) {
                        return firstDatePeriod.year === secondDatePeriod.year;
                    }, YearGranularity.prototype.generateLabel = function(datePeriod) {
                        return {
                            title: "Year " + datePeriod.year,
                            text: datePeriod.year.toString(),
                            id: datePeriod.index
                        };
                    }, YearGranularity;
                }(TimelineGranularity);
                samples.YearGranularity = YearGranularity;
                var TimelineGranularityData = function() {
                    function TimelineGranularityData(startDate, endDate) {
                        this.granularities = [], this.setDatesRange(startDate, endDate);
                        var lastDate = this.dates[this.dates.length - 1];
                        this.endingDate = TimelineGranularityData.nextDay(lastDate);
                    }
                    return TimelineGranularityData.previousDay = function(date) {
                        var prevDay = new Date(date.getTime());
                        return prevDay.setDate(prevDay.getDate() - 1), prevDay;
                    }, TimelineGranularityData.nextDay = function(date) {
                        var nextDay = new Date(date.getTime());
                        return nextDay.setDate(nextDay.getDate() + 1), nextDay;
                    }, TimelineGranularityData.prototype.setDatesRange = function(startDate, endDate) {
                        this.dates = [];
                        for (var date = startDate; endDate >= date; ) this.dates.push(date), date = TimelineGranularityData.nextDay(date);
                    }, TimelineGranularityData.prototype.addGranularity = function(granularity) {
                        granularity.resetDatePeriods();
                        for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
                            var date = _a[_i], identifierArray = granularity.splitDate(date);
                            granularity.addDate(date, identifierArray);
                        }
                        granularity.setNewEndDate(this.endingDate), this.granularities.push(granularity);
                    }, TimelineGranularityData.prototype.getGranularity = function(index) {
                        return this.granularities[index];
                    }, TimelineGranularityData.prototype.createGranularities = function() {
                        this.granularities = [], this.addGranularity(new YearGranularity()), this.addGranularity(new QuarterGranularity()), 
                        this.addGranularity(new MonthGranularity()), this.addGranularity(new WeekGranularity()), 
                        this.addGranularity(new DayGranularity());
                    }, TimelineGranularityData.prototype.createLabels = function() {
                        var _this = this;
                        this.granularities.forEach(function(x) {
                            x.setExtendedLabel({
                                dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
                                weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
                                monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
                                quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
                                yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : []
                            });
                        });
                    }, TimelineGranularityData;
                }();
                samples.TimelineGranularityData = TimelineGranularityData;
                var Utils = function() {
                    function Utils() {}
                    return Utils.getStartSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                    }, Utils.getEndSelectionDate = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                    }, Utils.getEndSelectionPeriod = function(timelineData) {
                        return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                    }, Utils.getCellColor = function(d, timelineData, cellFormat) {
                        var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                        return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;
                    }, Utils.getGranularityType = function(granularityName) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.name === granularityName;
                        });
                        return GranularityNames[index].granularityType;
                    }, Utils.getGranularityName = function(granularity) {
                        var index = _.findIndex(GranularityNames, function(x) {
                            return x.granularityType === granularity;
                        });
                        return GranularityNames[index].name;
                    }, Utils.separateSelection = function(timelineData, startDate, endDate) {
                        var datePeriods = timelineData.currentGranularity.getDatePeriods(), startDateIndex = _.findIndex(datePeriods, function(x) {
                            return startDate < x.endDate;
                        }), endDateIndex = _.findIndex(datePeriods, function(x) {
                            return endDate <= x.endDate;
                        });
                        timelineData.selectionStartIndex = startDateIndex, timelineData.selectionEndIndex = endDateIndex;
                        var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, !0), endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, !1);
                        if (endRatio > 0 && timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate), 
                        startRatio > 0) {
                            var startFration = datePeriods[startDateIndex].fraction - startRatio;
                            timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate), 
                            timelineData.selectionStartIndex++, timelineData.selectionEndIndex++;
                        }
                    }, Utils.getDateRatio = function(datePeriod, date, fromStart) {
                        var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime(), periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                        return 0 === periodDifference ? 0 : dateDifference / periodDifference;
                    }, Utils.timeRangeText = function(timelineData) {
                        var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData)), endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                        return startSelectionDateArray.join(" ") + " - " + endSelectionDateArray.join(" ");
                    }, Utils.dateRangeText = function(datePeriod) {
                        return datePeriod.startDate.toDateString() + " - " + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
                    }, Utils.unseparateSelection = function(datePeriods) {
                        var separationIndex = _.findIndex(datePeriods, function(x) {
                            return x.fraction < 1;
                        });
                        return separationIndex >= 0 ? (datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate, 
                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction, 
                        datePeriods.splice(separationIndex + 1, 1), !0) : !1;
                    }, Utils;
                }();
                samples.Utils = Utils;
                var Calendar = function() {
                    function Calendar(calendarFormat) {
                        var _this = this;
                        this.firstDayOfWeek = calendarFormat.weekDayProperty, this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1, 
                        this.firstDayOfYear = calendarFormat.firstDayProperty, this.dateOfFirstWeek = {}, 
                        this.quarterFirstMonths = [ 0, 3, 6, 9 ].map(function(x) {
                            return x + _this.firstMonthOfYear;
                        });
                    }
                    return Calendar.prototype.getFirstDayOfWeek = function() {
                        return this.firstDayOfWeek;
                    }, Calendar.prototype.getFirstMonthOfYear = function() {
                        return this.firstMonthOfYear;
                    }, Calendar.prototype.getFirstDayOfYear = function() {
                        return this.firstDayOfYear;
                    }, Calendar.prototype.getQuarterStartDate = function(year, quarterIndex) {
                        return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
                    }, Calendar.prototype.isChanged = function(calendarFormat) {
                        return this.firstMonthOfYear !== calendarFormat.firstMonthProperty - 1 || this.firstDayOfYear !== calendarFormat.firstDayProperty || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
                    }, Calendar.prototype.calculateDateOfFirstWeek = function(year) {
                        for (var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear); date.getDay() !== this.firstDayOfWeek; ) date = TimelineGranularityData.nextDay(date);
                        return date;
                    }, Calendar.prototype.getDateOfFirstWeek = function(year) {
                        return this.dateOfFirstWeek[year] || (this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year)), 
                        this.dateOfFirstWeek[year];
                    }, Calendar;
                }();
                samples.Calendar = Calendar;
                var Timeline = function() {
                    function Timeline() {
                        var _this = this;
                        this.requiresNoUpdate = !1, this.foreignSelection = !1, this.selector = [ "Y", "Q", "M", "W", "D" ], 
                        this.timelineMargins = {
                            LeftMargin: 15,
                            RightMargin: 15,
                            TopMargin: 15,
                            BottomMargin: 10,
                            CellWidth: 40,
                            CellHeight: 25,
                            StartXpoint: 10,
                            StartYpoint: 20,
                            ElementWidth: 30,
                            MinCellWidth: 30,
                            MaxCellHeight: 60,
                            PeriodSlicerRectWidth: 15,
                            PeriodSlicerRectHeight: 23
                        }, this.defaultTimelineProperties = {
                            DefaultLabelsShow: !0,
                            TimelineDefaultTextSize: 9,
                            TimelineDefaultCellColor: "#ADD8E6",
                            TimelineDefaultCellColorOut: "#FFFFFF",
                            TimelineDefaultTimeRangeShow: !0,
                            DefaultTimeRangeColor: "#777777",
                            DefaultLabelColor: "#777777",
                            DefaultGranularity: GranularityType.month,
                            DefaultFirstMonth: 1,
                            DefaultFirstDay: 1,
                            DefaultFirstWeekDay: 0
                        }, this.timelineSelectors = {
                            TimelineVisual: createClassAndSelector("Timeline"),
                            SelectionRangeContainer: createClassAndSelector("selectionRangeContainer"),
                            textLabel: createClassAndSelector("label"),
                            LowerTextCell: createClassAndSelector("lowerTextCell"),
                            UpperTextCell: createClassAndSelector("upperTextCell"),
                            UpperTextArea: createClassAndSelector("upperTextArea"),
                            LowerTextArea: createClassAndSelector("lowerTextArea"),
                            RangeTextArea: createClassAndSelector("rangeTextArea"),
                            CellsArea: createClassAndSelector("cellsArea"),
                            CursorsArea: createClassAndSelector("cursorsArea"),
                            MainArea: createClassAndSelector("mainArea"),
                            SelectionCursor: createClassAndSelector("selectionCursor"),
                            Cell: createClassAndSelector("cell"),
                            CellRect: createClassAndSelector("cellRect"),
                            VertLine: createClassAndSelector("timelineVertLine"),
                            TimelineSlicer: createClassAndSelector("timelineSlicer"),
                            PeriodSlicerGranularities: createClassAndSelector("periodSlicerGranularities"),
                            PeriodSlicerSelection: createClassAndSelector("periodSlicerSelection"),
                            PeriodSlicerSelectionRect: createClassAndSelector("periodSlicerSelectionRect"),
                            PeriodSlicerRect: createClassAndSelector("periodSlicerRect")
                        }, this.drag = d3.behavior.drag().origin(function(d) {
                            return d.x = d.selectionIndex * _this.timelineProperties.cellWidth, d;
                        }).on("dragstart", function() {
                            _this.dragstarted();
                        }).on("drag", function(d) {
                            _this.dragged(d);
                        }).on("dragend", function() {
                            _this.dragended();
                        });
                    }
                    return Timeline.prototype.changeGranularity = function(granularity, startDate, endDate) {
                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()) && Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()), 
                        this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity), 
                        Utils.separateSelection(this.timelineData, startDate, endDate);
                    }, Timeline.prototype.init = function(options) {
                        this.hostServices = options.host, this.initialized = !1;
                        var element = options.element;
                        this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.timelineProperties = {
                            element: element,
                            textYPosition: 50,
                            cellsYPosition: 3 * this.timelineMargins.TopMargin + 65,
                            topMargin: this.timelineMargins.TopMargin,
                            bottomMargin: this.timelineMargins.BottomMargin,
                            leftMargin: this.timelineMargins.LeftMargin,
                            startXpoint: this.timelineMargins.StartXpoint,
                            startYpoint: this.timelineMargins.StartYpoint,
                            cellWidth: this.timelineMargins.CellWidth,
                            cellHeight: this.timelineMargins.CellHeight,
                            elementWidth: this.timelineMargins.ElementWidth,
                            rightMargin: this.timelineMargins.RightMargin
                        }, this.body = d3.select(element.get(0)), this.timelineDiv = this.body.append("div"), 
                        this.svg = this.timelineDiv.append("svg").attr("width", px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual["class"], !0), 
                        this.clearCatcher = visuals.appendClearCatcher(this.svg), this.clearCatcher.data([ this ]).on("click", function(timeline) {
                            return timeline.clear();
                        }).on("touchstart", function(timeline) {
                            return timeline.clear();
                        }), this.rangeText = this.svg.append("g").classed(this.timelineSelectors.RangeTextArea["class"], !0).append("text"), 
                        this.mainGroupElement = this.svg.append("g").classed(this.timelineSelectors.MainArea["class"], !0), 
                        this.yearLabelsElement = this.mainGroupElement.append("g"), this.quarterLabelsElement = this.mainGroupElement.append("g"), 
                        this.monthLabelsElement = this.mainGroupElement.append("g"), this.weekLabelsElement = this.mainGroupElement.append("g"), 
                        this.dayLabelsElement = this.mainGroupElement.append("g"), this.cellsElement = this.mainGroupElement.append("g").classed(this.timelineSelectors.CellsArea["class"], !0), 
                        this.cursorGroupElement = this.svg.append("g").classed(this.timelineSelectors.CursorsArea["class"], !0);
                    }, Timeline.prototype.clear = function() {
                        this.selectionManager.clear(), this.timelineData && (this.timelineData.selectionStartIndex = 0, 
                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1, 
                        _.any(this.timelineData.timelineDatapoints, function(x) {
                            return x.index % 1 !== 0;
                        }) ? this.selectPeriod(this.timelineData.currentGranularity.getType()) : (Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth), 
                        this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat)), 
                        this.setSelection(this.timelineData));
                    }, Timeline.prototype.drawGranular = function(timelineProperties) {
                        var _this = this, dragPeriodRectState = !1, startXpoint = timelineProperties.startXpoint, startYpoint = timelineProperties.startYpoint, elementWidth = timelineProperties.elementWidth;
                        this.selectorContainer = this.svg.append("g").classed(this.timelineSelectors.TimelineSlicer["class"], !0), 
                        this.selectorContainer.on("mouseleave", function(d) {
                            return dragPeriodRectState = !1;
                        });
                        var fillRect = this.selectorContainer.append("rect"), selectorPeriods = this.selector;
                        fillRect.attr({
                            height: px(1),
                            x: px(startXpoint),
                            y: px(startYpoint + 2),
                            width: px((selectorPeriods.length - 1) * elementWidth)
                        });
                        var fillVertLine = this.selectorContainer.selectAll("vertLines").data(selectorPeriods).enter().append("rect");
                        fillVertLine.classed(this.timelineSelectors.VertLine["class"], !0).attr({
                            x: function(d, index) {
                                return px(startXpoint + index * elementWidth);
                            },
                            y: px(startYpoint),
                            width: px(2),
                            height: px(3)
                        }).style({
                            cursor: "pointer"
                        });
                        var textLabels, text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector).data(selectorPeriods).enter().append("text").classed(this.timelineSelectors.PeriodSlicerGranularities["class"], !0);
                        textLabels = text.text(function(d) {
                            return d;
                        }).attr({
                            x: function(d, index) {
                                return px(startXpoint - 3 + index * elementWidth);
                            },
                            y: px(startYpoint - 3)
                        }), this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection["class"], !0), 
                        this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity)).attr({
                            x: px(startXpoint + 2 * elementWidth),
                            y: px(startYpoint + 17)
                        });
                        var selRects = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector).data(selectorPeriods).enter().append("rect").classed(this.timelineSelectors.PeriodSlicerSelectionRect["class"], !0), clickHandler = function(d, index) {
                            _this.selectPeriod(index), dragPeriodRectState = !0;
                        };
                        selRects.attr({
                            x: function(d, index) {
                                return px(startXpoint - elementWidth / 2 + index * elementWidth);
                            },
                            y: px(3),
                            width: px(elementWidth),
                            height: px(23)
                        }).style({
                            cursor: "pointer"
                        }).on("mousedown", clickHandler).on("touchstart", clickHandler).on("mouseup", function() {
                            return dragPeriodRectState = !1;
                        }).on("touchend", function() {
                            return dragPeriodRectState = !1;
                        }).on("mouseover", function(d, index) {
                            dragPeriodRectState && _this.selectPeriod(index);
                        });
                        var dragPeriodRect = d3.behavior.drag().on("dragstart", function(e, b) {
                            dragPeriodRectState = !0;
                        }).on("dragend", function(e, b) {
                            dragPeriodRectState = !1;
                        });
                        this.periodSlicerRect = this.selectorContainer.append("rect").classed(this.timelineSelectors.PeriodSlicerRect["class"], !0).attr({
                            x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
                            y: px(startYpoint - 16),
                            rx: px(4),
                            width: px(15),
                            height: px(23)
                        }).on("mouseup", function(d) {
                            return dragPeriodRectState = !1;
                        }), this.periodSlicerRect.call(dragPeriodRect);
                    }, Timeline.prototype.redrawPeriod = function(granularity) {
                        var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
                        this.periodSlicerRect.transition().attr("x", px(dx - 7)), this.selectedText.text(Utils.getGranularityName(granularity));
                        var startDate = Utils.getStartSelectionDate(this.timelineData), endDate = Utils.getEndSelectionDate(this.timelineData);
                        this.changeGranularity(granularity, startDate, endDate);
                    }, Timeline.setMeasures = function(labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
                        timelineProperties.cellsYPosition = timelineProperties.textYPosition;
                        var labelSize = fromPointToPixel(labelFormat.sizeProperty);
                        labelFormat.showProperty && (timelineProperties.cellsYPosition += 1.5 * labelSize * (granularityType + 1));
                        var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin), maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount, height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20)), width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
                        timelineProperties.cellHeight = height, timelineProperties.cellWidth = width;
                    }, Timeline.prototype.visualChangeOnly = function(options) {
                        if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata && this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
                            var newObjects_1 = options.dataViews[0].metadata.objects, oldObjects_1 = this.options.dataViews[0].metadata.objects, properties = [ "rangeHeader", "cells", "labels" ], metadataChanged = !properties.every(function(x) {
                                return _.isEqual(newObjects_1 ? newObjects_1[x] : void 0, oldObjects_1 ? oldObjects_1[x] : void 0);
                            });
                            return options.suppressAnimations || metadataChanged;
                        }
                        return !1;
                    }, Timeline.prototype.unavailableType = function(dataViewCategorical) {
                        return !(dataViewCategorical.categories && 1 === dataViewCategorical.categories.length && dataViewCategorical.categories[0].values && 0 !== dataViewCategorical.categories[0].values.length && dataViewCategorical.categories[0].source && dataViewCategorical.categories[0].source.type);
                    }, Timeline.prototype.unavailableChildIdentityField = function(dataViewTree) {
                        return !dataViewTree.root || !dataViewTree.root.childIdentityFields || 0 === dataViewTree.root.childIdentityFields.length;
                    }, Timeline.prototype.createTimelineOptions = function(dataView) {
                        if (this.dataView = dataView, !dataView.categorical || !dataView.metadata || this.unavailableType(dataView.categorical) || !dataView.tree || this.unavailableChildIdentityField(dataView.tree)) return !1;
                        var columnExp = dataView.tree.root.childIdentityFields[0];
                        return this.valueType = columnExp ? columnExp.ref : null, dataView.categorical.categories[0].source.type.dateTime || dataView.categorical.categories[0].source.type.numeric && ("Year" === this.valueType || "Date" === this.valueType) ? (this.values = this.prepareValues(this.dataView.categorical.categories[0].values), 
                        !0) : !1;
                    }, Timeline.prototype.prepareValues = function(values) {
                        values = values.filter(Boolean);
                        for (var i in values) {
                            var item = values[i];
                            if ("String" == typeof item && "Invalid Date" !== String(new Date(item))) return values[i] = new Date(item);
                        }
                        return values;
                    }, Timeline.prototype.createTimelineData = function() {
                        var startDate, endDate;
                        if ("Year" === this.valueType) {
                            var years = this.values;
                            startDate = new Date(_.min(years), 0), endDate = new Date(_.max(years), 11);
                        } else {
                            var dates = this.values;
                            startDate = _.min(dates), endDate = _.max(dates);
                        }
                        if (this.initialized || this.drawGranular(this.timelineProperties), this.initialized) {
                            var actualEndDate = TimelineGranularityData.nextDay(endDate), daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods(), prevStartDate = daysPeriods[0].startDate, prevEndDate = daysPeriods[daysPeriods.length - 1].endDate, changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
                            this.newGranularity = this.timelineData.currentGranularity.getType(), changedSelection ? (this.foreignSelection = !0, 
                            this.changeGranularity(this.newGranularity, startDate, actualEndDate), this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties)) : (prevEndDate > actualEndDate && (endDate = daysPeriods[daysPeriods.length - 1].startDate), 
                            startDate > prevStartDate && (startDate = prevStartDate), this.initialized = !1);
                        }
                        this.initialized || (this.timelineGranularityData = new TimelineGranularityData(startDate, endDate), 
                        this.timelineData = {
                            elementsCount: 0,
                            timelineDatapoints: [],
                            cursorDataPoints: new Array()
                        });
                    }, Timeline.prototype.update = function(options) {
                        var visualChange = this.visualChangeOnly(options);
                        if (this.requiresNoUpdate = this.requiresNoUpdate && !visualChange, this.requiresNoUpdate) return void (this.foreignSelection ? this.foreignSelection = !1 : this.requiresNoUpdate = !1);
                        if (this.options = options, options.dataViews && options.dataViews[0]) {
                            var validOptions = this.createTimelineOptions(options.dataViews[0]);
                            if (!validOptions) return void this.clearData();
                            this.newGranularity = this.defaultTimelineProperties.DefaultGranularity, visualChange || this.createTimelineData(), 
                            this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins), 
                            this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options), 
                            this.initialized = !0;
                        }
                    }, Timeline.prototype.selectPeriod = function(periodNameIndex) {
                        this.redrawPeriod(periodNameIndex), this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins), 
                        this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
                    }, Timeline.isDataNotMatch = function(dataView) {
                        return dataView.categorical.categories.length <= 0 || void 0 === dataView.categorical.categories[0] || void 0 === dataView.categorical.categories[0].identityFields || dataView.categorical.categories[0].identityFields.length <= 0;
                    }, Timeline.converter = function(timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
                        var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                        if (initialized || (timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 0
                        }), timelineData.cursorDataPoints.push({
                            x: 0,
                            selectionIndex: 0,
                            cursorIndex: 1
                        })), initialized && !Timeline.calendar.isChanged(timelineFormat.calendarFormat) || (Timeline.calendar = new Calendar(timelineFormat.calendarFormat), 
                        timelineGranularityData.createGranularities(), timelineGranularityData.createLabels(), 
                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType), 
                        timelineData.selectionStartIndex = 0, timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1), 
                        timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName, 
                        timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0], 
                        dataView.categorical.categories[0].source.type.numeric && (timelineData.columnIdentity.ref = "Date"), 
                        !this.isDataNotMatch(dataView)) {
                            var timelineElements = timelineData.currentGranularity.getDatePeriods();
                            timelineData.elementsCount = timelineElements.length, timelineData.timelineDatapoints = [];
                            for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
                                var currentTimePeriod = timelineElements_1[_i], datapoint = {
                                    index: currentTimePeriod.index,
                                    datePeriod: currentTimePeriod
                                };
                                timelineData.timelineDatapoints.push(datapoint);
                            }
                            var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function(x) {
                                return x.index % 1 === 0;
                            }).length;
                            return Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins), 
                            Timeline.updateCursors(timelineData, timelineProperties.cellWidth), timelineFormat;
                        }
                    }, Timeline.prototype.render = function(timelineData, timelineFormat, timelineProperties, options) {
                        var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function(x) {
                            return x.index % 1 === 0;
                        }).length;
                        this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount, 
                        this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), this.timelineDiv.attr({
                            height: px(options.viewport.height),
                            width: px(options.viewport.width),
                            "drag-resize-disabled": !0
                        }).style({
                            "overflow-x": "auto",
                            "overflow-y": "auto"
                        }), this.svg.attr({
                            height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),
                            width: px(Math.max(0, this.svgWidth))
                        });
                        var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin), translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
                        this.mainGroupElement.attr("transform", translateString), this.selectorContainer.attr("transform", fixedTranslateString), 
                        this.cursorGroupElement.attr("transform", translateString);
                        var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel(), granularityType = this.timelineData.currentGranularity.getType(), yPos = 0, yDiff = 1.5;
                        this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, 0 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, 1 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, 2 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, 3 === granularityType), 
                        yPos += yDiff, this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, 4 === granularityType), 
                        this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations), 
                        this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                    }, Timeline.prototype.renderLabels = function(labels, labelsElement, index, isLast) {
                        var _this = this, labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
                        if (!this.timelineFormat.labelFormat.showProperty) return void labelTextSelection.remove();
                        var labelsGroupSelection = labelTextSelection.data(labels);
                        labelsGroupSelection.enter().append("text").classed(this.timelineSelectors.textLabel["class"], !0), 
                        labelsGroupSelection.text(function(x, id) {
                            if (!isLast && 0 === id && labels.length > 1) {
                                var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty), textProperties = {
                                    text: labels[0].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                }, halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                                textProperties = {
                                    text: labels[1].text,
                                    fontFamily: "arial",
                                    fontSize: fontSize
                                };
                                var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2, diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
                                if (halfFirstTextWidth + halfSecondTextWidth > diff) return "";
                            }
                            var labelFormattedTextOptions = {
                                label: x.text,
                                maxWidth: _this.timelineProperties.cellWidth * (isLast ? .9 : 3),
                                fontSize: _this.timelineFormat.labelFormat.sizeProperty
                            };
                            return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                        }).style("font-size", pt(this.timelineFormat.labelFormat.sizeProperty)).attr({
                            x: function(x) {
                                return (x.id + .5) * _this.timelineProperties.cellWidth;
                            },
                            y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
                            fill: this.timelineFormat.labelFormat.colorProperty
                        }).append("title").text(function(x) {
                            return x.title;
                        }), labelsGroupSelection.exit().remove();
                    }, Timeline.prototype.clearData = function() {
                        this.initialized = !1, this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove(), 
                        this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove(), 
                        this.rangeText.text(""), this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove(), 
                        this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();
                    }, Timeline.updateCursors = function(timelineData, cellWidth) {
                        var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
                        timelineData.cursorDataPoints[0].selectionIndex = startDate.index;
                        var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                        timelineData.cursorDataPoints[1].selectionIndex = endDate.index + endDate.fraction;
                    }, Timeline.fillTimelineFormat = function(objects, timelineProperties) {
                        var timelineFormat = {
                            rangeTextFormat: {
                                showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
                                colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                                sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            cellFormat: {
                                colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
                                colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
                            },
                            labelFormat: {
                                showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                                colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                                sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
                            },
                            calendarFormat: {
                                firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),
                                firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
                                weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
                            }
                        };
                        return timelineFormat;
                    }, Timeline.prototype.fillCells = function(cellFormat) {
                        var _this = this, dataPoints = this.timelineData.timelineDatapoints, cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
                        cellSelection.attr("fill", function(d) {
                            return Utils.getCellColor(d, _this.timelineData, cellFormat);
                        });
                    }, Timeline.prototype.renderCells = function(timelineData, timelineFormat, timelineProperties, suppressAnimations) {
                        var _this = this, allDataPoints = timelineData.timelineDatapoints, totalX = 0, cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
                        cellsSelection.enter().append("rect").classed(this.timelineSelectors.CellRect["class"], !0), 
                        cellsSelection.attr({
                            height: px(timelineProperties.cellHeight),
                            width: function(d) {
                                return px(d.datePeriod.fraction * timelineProperties.cellWidth);
                            },
                            x: function(d) {
                                var value = totalX;
                                return totalX += d.datePeriod.fraction * timelineProperties.cellWidth, px(value);
                            },
                            y: px(timelineProperties.cellsYPosition),
                            id: function(d) {
                                return d.index;
                            }
                        });
                        var clickHandler = function(d, index) {
                            d3.event.preventDefault();
                            var cursorDataPoints = _this.timelineData.cursorDataPoints, keyEvent = d3.event;
                            keyEvent.altKey || keyEvent.shiftKey ? _this.timelineData.selectionEndIndex < index ? (cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction, 
                            timelineData.selectionEndIndex = index) : (cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            timelineData.selectionStartIndex = index) : (timelineData.selectionStartIndex = index, 
                            timelineData.selectionEndIndex = index, cursorDataPoints[0].selectionIndex = d.datePeriod.index, 
                            cursorDataPoints[1].selectionIndex = d.datePeriod.index + d.datePeriod.fraction), 
                            _this.fillCells(timelineFormat.cellFormat), _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition), 
                            _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat), _this.setSelection(timelineData);
                        };
                        cellsSelection.on("click", clickHandler).on("touchstart", clickHandler), this.fillCells(timelineFormat.cellFormat), 
                        cellsSelection.exit().remove();
                    }, Timeline.prototype.dragstarted = function() {
                        this.timelineData.dragging = !0;
                    }, Timeline.prototype.dragged = function(currentCursor) {
                        if (this.timelineData.dragging === !0) {
                            var xScale = 1, container = d3.select(this.timelineSelectors.TimelineVisual.selector);
                            if (container) {
                                var transform = container.style("transform");
                                if (void 0 !== transform && "none" !== transform) {
                                    var str = transform.split("(")[1];
                                    xScale = Number(str.split(", ")[0]);
                                }
                            }
                            var cursorOverElement = this.findCursorOverElement(d3.event.x);
                            if (!cursorOverElement) return;
                            var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
                            0 === currentCursor.cursorIndex && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex && (this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index), 
                            1 === currentCursor.cursorIndex && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex && (this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex, 
                            this.timelineData.cursorDataPoints[1].selectionIndex = currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction), 
                            this.fillCells(this.timelineFormat.cellFormat), this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition), 
                            this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                        }
                    }, Timeline.prototype.findCursorOverElement = function(x) {
                        var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;
                        if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) return {
                            index: 0,
                            datapoint: timelineDatapoints[0]
                        };
                        if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) return {
                            index: length - 1,
                            datapoint: timelineDatapoints[length - 1]
                        };
                        for (var i = 1; length > i; i++) {
                            var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;
                            if (x >= left && right >= x) return {
                                index: i,
                                datapoint: timelineDatapoints[i]
                            };
                        }
                        return null;
                    }, Timeline.prototype.dragended = function() {
                        this.setSelection(this.timelineData);
                    }, Timeline.prototype.renderCursors = function(timelineData, timelineFormat, cellHeight, cellsYPosition) {
                        var _this = this, cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                        return cursorSelection.enter().append("path").classed(this.timelineSelectors.SelectionCursor["class"], !0), 
                        cursorSelection.attr("transform", function(d) {
                            return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition);
                        }).attr({
                            d: d3.svg.arc().innerRadius(0).outerRadius(cellHeight / 2).startAngle(function(d) {
                                return d.cursorIndex * Math.PI + Math.PI;
                            }).endAngle(function(d) {
                                return d.cursorIndex * Math.PI + 2 * Math.PI;
                            })
                        }).call(this.drag), cursorSelection.exit().remove(), cursorSelection;
                    }, Timeline.prototype.renderTimeRangeText = function(timelineData, timeRangeFormat) {
                        var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth, maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;
                        if (timeRangeFormat.showProperty && maxWidth > 0) {
                            var timeRangeText = Utils.timeRangeText(timelineData), labelFormattedTextOptions = {
                                label: timeRangeText,
                                maxWidth: maxWidth,
                                fontSize: timeRangeFormat.sizeProperty
                            }, actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                            this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer["class"], !0), 
                            this.rangeText.attr({
                                x: GranularityNames.length * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
                                y: 40,
                                fill: timeRangeFormat.colorProperty
                            }).style({
                                "font-size": pt(timeRangeFormat.sizeProperty)
                            }).text(actualText).append("title").text(timeRangeText);
                        } else this.rangeText.text("");
                    }, Timeline.prototype.setSelection = function(timelineData) {
                        this.requiresNoUpdate = !0;
                        var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData)), upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1)), filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper), filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr), objects = {
                            merge: [ {
                                objectName: "general",
                                selector: void 0,
                                properties: {
                                    filter: filter
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            data: []
                        });
                    }, Timeline.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder();
                        switch (options.objectName) {
                          case "rangeHeader":
                            this.enumerateRangeHeader(enumeration, this.dataView);
                            break;

                          case "cells":
                            this.enumerateCells(enumeration, this.dataView);
                            break;

                          case "labels":
                            this.enumerateLabels(enumeration, this.dataView);
                            break;

                          case "calendar":
                            this.enumerateCalendar(enumeration, this.dataView);
                            break;

                          case "weekDay":
                            this.enumerateWeekDay(enumeration, this.dataView);
                        }
                        return enumeration.complete();
                    }, Timeline.prototype.enumerateRangeHeader = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "rangeHeader",
                            displayName: "Selection Color",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
                                fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                                textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCells = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "cells",
                            selector: null,
                            properties: {
                                fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
                                fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
                            }
                        });
                    }, Timeline.prototype.enumerateLabels = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "labels",
                            selector: null,
                            properties: {
                                show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                                fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                                textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                            }
                        });
                    }, Timeline.prototype.enumerateCalendar = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "calendar",
                            selector: null,
                            properties: {
                                month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
                                day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1)))
                            }
                        });
                    }, Timeline.prototype.enumerateWeekDay = function(enumeration, dataview) {
                        var objects = dataview && dataview.metadata ? dataview.metadata.objects : void 0;
                        enumeration.pushInstance({
                            objectName: "weekDay",
                            selector: null,
                            properties: {
                                day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))
                            }
                        });
                    }, Timeline.capabilities = {
                        dataRoles: [ {
                            name: "Time",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Time"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Time: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Time"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    select: [ {
                                        bind: {
                                            to: "Time"
                                        }
                                    } ]
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    selected: {
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    filter: {
                                        type: {
                                            filter: {}
                                        },
                                        rule: {
                                            output: {
                                                property: "selected",
                                                selector: [ "Time" ]
                                            }
                                        }
                                    }
                                }
                            },
                            calendar: {
                                displayName: "Fiscal Year Start",
                                properties: {
                                    month: {
                                        displayName: "Month",
                                        type: {
                                            enumeration: samples.Months
                                        }
                                    },
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            weekDay: {
                                displayName: "First Day of Week",
                                properties: {
                                    day: {
                                        displayName: "Day",
                                        type: {
                                            enumeration: samples.WeekDays
                                        }
                                    }
                                }
                            },
                            rangeHeader: {
                                displayName: "Range Header",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            cells: {
                                displayName: "Cells",
                                properties: {
                                    fillSelected: {
                                        displayName: "Selected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fillUnselected: {
                                        displayName: "Unselected cell color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            labels: {
                                displayName: "Labels",
                                properties: {
                                    show: {
                                        displayName: "Show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    fontColor: {
                                        displayName: "Font color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    textSize: {
                                        displayName: "Text Size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, Timeline;
                }();
                samples.Timeline = Timeline;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, jsCommon = window.jsCommon, powerbi = window.powerbi;
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var ValueFormatter = powerbi.visuals.valueFormatter, SelectionManager = visuals.utility.SelectionManager, StreamGraphAxisGraphicsContextClassName = "axisGraphicsContext", StreamGraphXAxisClassName = "x axis", StreamGraphYAxisClassName = "y axis", StreamGraphDefaultAxisColor = "#777", StreamGraphDefaultFontSizeInPoints = 8, DefaultLegendFontSizeInPt = 8, DefaultLegendLabelFillColor = "#666666", StreamGraphDefaultFontFamily = "wf_segoe-ui_normal", StreamGraphDefaultFontWeight = "normal", StreamGraphDefaultSettings = {
                    legendSettings: {
                        show: !0,
                        showTitle: !0,
                        labelColor: DefaultLegendLabelFillColor,
                        titleText: "",
                        fontSize: DefaultLegendFontSizeInPt
                    },
                    categoryAxisSettings: {
                        show: !0,
                        axisColor: StreamGraphDefaultAxisColor,
                        showAxisTitle: !1
                    },
                    valueAxisSettings: {
                        show: !0,
                        axisColor: StreamGraphDefaultAxisColor,
                        showAxisTitle: !1
                    }
                }, StreamGraph = function() {
                    function StreamGraph() {
                        this.margin = {
                            left: 45,
                            right: 20,
                            bottom: 20,
                            top: 20
                        };
                    }
                    return StreamGraph.prototype.converter = function(dataView, colors) {
                        if (!(dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.categories && colors)) return null;
                        for (var valueFormatter, categoryFormatter, catDv = dataView.categorical, grouped = catDv && catDv.values ? catDv.values.grouped() : void 0, values = catDv.values, dataPoints = [], legendData = {
                            dataPoints: [],
                            title: values[0].source.displayName,
                            fontSize: StreamGraphDefaultFontSizeInPoints
                        }, value = 0, i = 0; i < values.length; i++) {
                            var columnGroup = grouped && grouped.length > i && grouped[i].values ? grouped[i] : null;
                            dataPoints.push([]), values[i].source.groupName && legendData.dataPoints.push({
                                label: values[i].source.groupName,
                                color: colors.getColorByIndex(i).value,
                                icon: visuals.LegendIcon.Box,
                                selected: !1,
                                identity: visuals.SelectionId.createWithId(values[i].identity)
                            });
                            for (var k = 0; k < values[i].values.length; k++) {
                                var id = visuals.SelectionIdBuilder.builder().withSeries(dataView.categorical.values, columnGroup).createSelectionId(), y = values[i].values[k];
                                y > value && (value = y), dataPoints[i].push({
                                    x: k,
                                    y: y,
                                    identity: id
                                });
                            }
                        }
                        var streamGraphSettings = this.parseSettings(dataView);
                        return valueFormatter = ValueFormatter.create({
                            format: "g",
                            value: value
                        }), categoryFormatter = ValueFormatter.create({
                            format: ValueFormatter.getFormatString(catDv.categories[0].source, StreamGraph.Properties.general.formatString),
                            value: catDv.categories[0].values
                        }), {
                            dataPoints: dataPoints,
                            legendData: legendData,
                            valueFormatter: valueFormatter,
                            categoryFormatter: categoryFormatter,
                            streamGraphSettings: streamGraphSettings
                        };
                    }, StreamGraph.prototype.parseSettings = function(dataView) {
                        if (!dataView || !dataView.metadata) return StreamGraphDefaultSettings;
                        var objects = dataView.metadata.objects, streamGraphSettings = _.clone(StreamGraphDefaultSettings), categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
                        categoryAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show), 
                        categoryAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor), 
                        categoryAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
                        var valueAxisSettings = streamGraphSettings.valueAxisSettings;
                        return valueAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show), 
                        valueAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor), 
                        valueAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle), 
                        streamGraphSettings;
                    }, StreamGraph.prototype.init = function(options) {
                        var element = options.element;
                        this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.svg = d3.select(element.get(0)).append("svg").classed(StreamGraph.VisualClassName, !0).style("position", "absolute"), 
                        this.axisGraphicsContext = this.svg.append("g").classed(StreamGraphAxisGraphicsContextClassName, !0), 
                        this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, !0), 
                        this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, !0), 
                        this.colors = options.style.colorPalette.dataColors, this.legend = visuals.createLegend(element, !1, null, !0);
                    }, StreamGraph.prototype.update = function(options) {
                        var _this = this;
                        if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) return void this.clearData();
                        this.viewport = {
                            width: Math.max(0, options.viewport.width),
                            height: Math.max(0, options.viewport.height)
                        };
                        var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors);
                        if (!data || !data.dataPoints || !data.dataPoints.length) return void this.clearData();
                        var dataPoints = data.dataPoints;
                        this.renderLegend(data), this.updateViewPort(), this.renderXAxisLabels(), this.renderYAxisLabels();
                        var height = Math.max(0, this.viewport.height - this.margin.top);
                        this.svg.attr({
                            width: this.viewport.width,
                            height: height
                        });
                        var stack = d3.layout.stack();
                        this.getWiggle(dataView) && stack.offset("wiggle");
                        var layers = stack(dataPoints), xScale = d3.scale.linear().domain([ 0, dataPoints[0].length - 1 ]).range([ this.margin.left, this.viewport.width - this.margin.right ]), yScale = d3.scale.linear().domain([ 0, d3.max(layers, function(layer) {
                            return d3.max(layer, function(d) {
                                return d.y0 + d.y;
                            });
                        }) ]).range([ height - this.margin.bottom, this.margin.top ]), area = d3.svg.area().interpolate("basis").x(function(d) {
                            return xScale(d.x);
                        }).y0(function(d) {
                            return yScale(d.y0);
                        }).y1(function(d) {
                            return yScale(d.y0 + d.y);
                        }), selectionManager = this.selectionManager, selection = this.svg.selectAll(StreamGraph.Layer.selector).data(layers);
                        selection.enter().append("path").classed(StreamGraph.Layer["class"], !0), selection.style("fill", function(d, i) {
                            return _this.colors.getColorByIndex(i).value;
                        }).on("click", function(d) {
                            var _this = this;
                            selectionManager.select(d[0].identity).then(function(ids) {
                                ids.length > 0 ? (selection.style("opacity", .5), d3.select(_this).style("opacity", 1)) : selection.style("opacity", 1);
                            });
                        }).transition().duration(duration).attr("d", area), selection.exit().remove(), this.drawAxis(data, xScale, yScale);
                    }, StreamGraph.prototype.drawAxis = function(data, xScale, yScale) {
                        var _this = this, shiftY = this.viewport.height - this.margin.bottom - this.margin.top, shiftX = this.viewport.width - this.margin.left - this.margin.right, xAxis = d3.svg.axis();
                        xAxis.scale(xScale).orient("bottom").tickFormat(function(item, index) {
                            return data.categoryFormatter && (item = data.categoryFormatter.format(item)), null == index || !xAxis.tickValues() || 0 !== index && index !== xAxis.tickValues().length - 1 || (item = powerbi.TextMeasurementService.getTailoredTextOrDefault(StreamGraph.getTextPropertiesFunction(item), 2 * (index ? _this.margin.right : _this.margin.left))), 
                            item;
                        }.bind(xAxis));
                        var yAxis = d3.svg.axis().scale(yScale).orient("left").tickFormat(function(item) {
                            return data.valueFormatter ? data.valueFormatter.format(item) : item;
                        });
                        this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues), this.setMaxTicks(yAxis, shiftY);
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (valueAxisSettings.show) {
                            var axisColor = valueAxisSettings.axisColor;
                            this.yAxis.attr("transform", visuals.SVGUtil.translate(this.margin.left, 0)).call(yAxis), 
                            this.yAxis.selectAll("text").style("fill", axisColor);
                        } else this.yAxis.selectAll("*").remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (categoryAxisSettings.show) {
                            var axisColor = categoryAxisSettings.axisColor;
                            this.xAxis.attr("transform", visuals.SVGUtil.translate(0, shiftY)).call(xAxis), 
                            this.xAxis.selectAll("text").style("fill", axisColor);
                        } else this.xAxis.selectAll("*").remove();
                    }, StreamGraph.prototype.renderYAxisLabels = function() {
                        this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();
                        var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                        if (valueAxisSettings.show) {
                            if (this.margin.left = 45, valueAxisSettings.showAxisTitle) if (this.dataView.categorical.values.source) {
                                var marginLeft_1 = this.margin.left = 65, categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings, isXAxisOn = categoryAxisSettings.show === !0, isXTitleOn = categoryAxisSettings.showAxisTitle === !0, height_1 = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height, yAxisText = this.dataView.categorical.values.source.displayName, yAxisClass_1 = StreamGraph.YAxisLabel["class"], yAxisLabel = this.yAxis.append("text").style("text-anchor", "middle").text(yAxisText).call(function(text) {
                                    text.each(function() {
                                        var text = d3.select(this);
                                        text.attr({
                                            "class": yAxisClass_1,
                                            transform: "rotate(-90)",
                                            y: -marginLeft_1 + 5,
                                            x: -(height_1 / 2),
                                            dy: "1em"
                                        });
                                    });
                                });
                                yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height_1, powerbi.TextMeasurementService.svgEllipsis);
                            } else valueAxisSettings.showAxisTitle = !1;
                        } else this.margin.left = 20;
                    }, StreamGraph.prototype.renderXAxisLabels = function() {
                        this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();
                        var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                        if (categoryAxisSettings.show) {
                            if (this.margin.bottom = 20, categoryAxisSettings.showAxisTitle) if (this.dataView.categorical.categories[0].source) {
                                var marginBottom_1 = this.margin.bottom = 40, valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings, isYAxisOn = valueAxisSettings.show === !0, isYTitleOn = valueAxisSettings.showAxisTitle === !0, width_1 = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width, xAxisText = this.dataView.categorical.categories[0].source.displayName, xAxisClass_1 = StreamGraph.XAxisLabel["class"], xAxisLabel = this.xAxis.append("text").style("text-anchor", "middle").text(xAxisText).call(function(text) {
                                    text.each(function() {
                                        var text = d3.select(this);
                                        text.attr({
                                            "class": xAxisClass_1,
                                            transform: visuals.SVGUtil.translate(width_1 / 2, marginBottom_1 - 5)
                                        });
                                    });
                                });
                                xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width_1, powerbi.TextMeasurementService.svgEllipsis);
                            } else categoryAxisSettings.showAxisTitle = !1;
                        } else this.margin.bottom = 10;
                    }, StreamGraph.prototype.renderLegend = function(streamGraphData) {
                        var legendData = streamGraphData.legendData;
                        if (legendData && this.dataView && this.dataView.metadata) {
                            if (this.legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {}), 
                            this.legendObjectProperties) {
                                visuals.LegendData.update(legendData, this.legendObjectProperties);
                                var position = this.legendObjectProperties[visuals.legendProps.position];
                                position && this.legend.changeOrientation(visuals.LegendPosition[position]);
                            }
                            this.legend.drawLegend(legendData, _.clone(this.viewport)), visuals.Legend.positionChartArea(this.svg, this.legend);
                        }
                    }, StreamGraph.prototype.updateViewPort = function() {
                        var legendMargins = this.legend.getMargins(), legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                        switch (legendPosition) {
                          case visuals.LegendPosition.Top:
                          case visuals.LegendPosition.TopCenter:
                          case visuals.LegendPosition.Bottom:
                          case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;

                          case visuals.LegendPosition.Left:
                          case visuals.LegendPosition.LeftCenter:
                          case visuals.LegendPosition.Right:
                          case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                        }
                    }, StreamGraph.prototype.setMaxTicks = function(axis, maxSize, maxValue) {
                        var maxTicks = void 0 === maxValue ? this.getTicksByAxis(axis).length : Math.min(maxValue, this.getTicksByAxis(axis).length);
                        axis.scale().domain.toString() === d3.scale.linear().domain.toString() ? axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks)) : axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                    }, StreamGraph.prototype.getFittedTickLength = function(axis, maxSize, maxTicks) {
                        for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([ maxTicks ]).length > maxTicks); maxTicks--, 
                        ticks = this.getTicksByAxis(axis)) axis.ticks(maxTicks);
                        return maxTicks;
                    }, StreamGraph.prototype.getFittedTickValues = function(axis, maxSize, maxTicks) {
                        for (var maxWidthOf2Ticks, ticks = this.getTicksByAxis(axis), tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks), currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, 
                        indexes = []) {
                            switch (currentMaxTicks) {
                              case 0:
                                return [];

                              case 1:
                                indexes = [ 0 ];
                                break;

                              case 2:
                                indexes = [ 0, ticks.length - 1 ];
                                break;

                              default:
                                for (var takeEvery = ticks.length / (currentMaxTicks - 1), i = 0; currentMaxTicks - 1 > i; i++) indexes.push(Math.round(takeEvery * i));
                                indexes.push(ticks.length - 1);
                            }
                            var ticksIndexes = indexes.map(function(x) {
                                return [ ticks[x], x ];
                            });
                            if (maxWidthOf2Ticks = maxSize / ticks.length * 2, ticksIndexes.reduce(function(a, b) {
                                return tickPairsWidths.push([ measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks ]), 
                                b;
                            }), !tickPairsWidths.some(function(x) {
                                return x[0] > x[1];
                            })) return ticksIndexes.map(function(x) {
                                return x[0];
                            });
                        }
                        return [];
                    }, StreamGraph.prototype.measureTicks = function(ticks, measureTickFunction) {
                        return ticks.map(function(x) {
                            return measureTickFunction(x);
                        }).reduce(function(a, b) {
                            return a + b;
                        });
                    }, StreamGraph.prototype.getTicksByAxis = function(axis) {
                        var scale = axis.scale(), result = null === axis.tickValues() ? scale.ticks ? scale.ticks.apply(scale, axis.ticks()) : scale.domain() : axis.tickValues();
                        return void 0 === result.length ? [ result ] : result;
                    }, StreamGraph.prototype.getMeasureTickFunction = function(axis, ticks) {
                        var measureFunction = "top" === axis.orient() || "bottom" === axis.orient() ? powerbi.TextMeasurementService.measureSvgTextWidth : powerbi.TextMeasurementService.measureSvgTextHeight, cache = {};
                        return function(x) {
                            return cache[x] ? cache[x] : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                        };
                    }, StreamGraph.getTextPropertiesFunction = function(text) {
                        var fontFamily = StreamGraphDefaultFontFamily, fontSize = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
                        return {
                            text: text,
                            fontFamily: fontFamily,
                            fontSize: fontSize,
                            fontWeight: fontWeight
                        };
                    }, StreamGraph.prototype.getWiggle = function(dataView) {
                        if (dataView && dataView.metadata) {
                            var objects = dataView.metadata.objects;
                            if (objects) {
                                var general = powerbi.DataViewObjects.getObject(objects, "general", void 0);
                                if (general) return general.wiggle;
                            }
                        }
                        return !0;
                    }, StreamGraph.prototype.enumerateValueAxisValues = function(enumeration) {
                        var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "valueAxis",
                            displayName: "Y-Axis",
                            properties: {
                                show: valueAxisSettings.show,
                                showAxisTitle: valueAxisSettings.showAxisTitle,
                                axisColor: valueAxisSettings.axisColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateCategoryAxisValues = function(enumeration) {
                        var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "categoryAxis",
                            displayName: "X-Axis",
                            properties: {
                                show: categoryAxisSettings.show,
                                showAxisTitle: categoryAxisSettings.showAxisTitle,
                                axisColor: categoryAxisSettings.axisColor
                            }
                        });
                    }, StreamGraph.prototype.enumerateLegend = function(enumeration) {
                        var legendSettings = this.legendObjectProperties ? this.legendObjectProperties : {};
                        enumeration.pushInstance({
                            selector: null,
                            objectName: "legend",
                            displayName: "Legend",
                            properties: {
                                show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : !0,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.showTitle, !0),
                                titleText: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.titleText, ""),
                                labelColor: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.labelColor, DefaultLegendLabelFillColor),
                                fontSize: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.fontSize, DefaultLegendFontSizeInPt)
                            }
                        });
                    }, StreamGraph.prototype.clearData = function() {
                        this.svg.selectAll(StreamGraph.Layer.selector).remove(), this.legend.drawLegend({
                            dataPoints: []
                        }, this.viewport), this.yAxis.selectAll("*").remove(), this.xAxis.selectAll("*").remove();
                    }, StreamGraph.prototype.enumerateObjectInstances = function(options) {
                        var enumeration = new visuals.ObjectEnumerationBuilder(), dataView = this.dataView;
                        switch (options.objectName) {
                          case "legend":
                            dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.source && this.enumerateLegend(enumeration);
                            break;

                          case "categoryAxis":
                            this.enumerateCategoryAxisValues(enumeration);
                            break;

                          case "valueAxis":
                            this.enumerateValueAxisValues(enumeration);
                            break;

                          case "general":
                            var general = {
                                objectName: "general",
                                displayName: "General",
                                selector: null,
                                properties: {
                                    wiggle: this.getWiggle(dataView)
                                }
                            };
                            enumeration.pushInstance(general);
                        }
                        return enumeration.complete();
                    }, StreamGraph.VisualClassName = "streamGraph", StreamGraph.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        legend: {
                            show: {
                                objectName: "legend",
                                propertyName: "show"
                            }
                        },
                        categoryAxis: {
                            show: {
                                objectName: "categoryAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "categoryAxis",
                                propertyName: "axisColor"
                            },
                            showAxisTitle: {
                                objectName: "categoryAxis",
                                propertyName: "showAxisTitle"
                            }
                        },
                        valueAxis: {
                            show: {
                                objectName: "valueAxis",
                                propertyName: "show"
                            },
                            axisColor: {
                                objectName: "valueAxis",
                                propertyName: "axisColor"
                            },
                            showAxisTitle: {
                                objectName: "valueAxis",
                                propertyName: "showAxisTitle"
                            }
                        }
                    }, StreamGraph.Layer = {
                        "class": "layer",
                        selector: ".layer"
                    }, StreamGraph.XAxisLabel = {
                        "class": "xAxisLabel",
                        selector: ".xAxisLabel"
                    }, StreamGraph.YAxisLabel = {
                        "class": "yAxisLabel",
                        selector: ".yAxisLabel"
                    }, StreamGraph.MaxNumberOfAxisXValues = 5, StreamGraph.capabilities = {
                        dataRoles: [ {
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Series"
                        }, {
                            name: "Y",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    max: 0
                                }
                            }, {
                                Category: {
                                    max: 1
                                },
                                Series: {
                                    min: 1,
                                    max: 1
                                },
                                Y: {
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Category"
                                    },
                                    dataReductionAlgorithm: {
                                        bottom: {}
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [ {
                                            "for": {
                                                "in": "Y"
                                            }
                                        } ],
                                        dataReductionAlgorithm: {
                                            bottom: {}
                                        }
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: "General",
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    },
                                    wiggle: {
                                        type: {
                                            bool: !0
                                        },
                                        displayName: "Wiggle"
                                    }
                                }
                            },
                            categoryAxis: {
                                displayName: "X-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            valueAxis: {
                                displayName: "Y-Axis",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    showAxisTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    axisColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            legend: {
                                displayName: "Legend",
                                properties: {
                                    show: {
                                        displayName: "show",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    position: {
                                        displayName: "Position",
                                        type: {
                                            enumeration: visuals.legendPosition.type
                                        }
                                    },
                                    showTitle: {
                                        displayName: "Title",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    titleText: {
                                        displayName: "Legend Name",
                                        type: {
                                            text: !0
                                        },
                                        suppressFormatPainterCopy: !0
                                    },
                                    labelColor: {
                                        displayName: "Color",
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    fontSize: {
                                        displayName: "Text Size",
                                        type: {
                                            formatting: {
                                                fontSize: !0
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }, StreamGraph;
                }();
                samples.StreamGraph = StreamGraph;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager, LineDotChart = function() {
                    function LineDotChart() {
                        this.margin = {
                            top: 10,
                            right: 30,
                            bottom: 10,
                            left: 10
                        }, this.LegendSize = 50, this.AxisSize = 30;
                    }
                    return LineDotChart.prototype.init = function(options) {
                        var _this = this;
                        this.hostServices = options.host, this.selectionManager = new SelectionManager({
                            hostServices: this.hostServices
                        }), this.root = d3.select(options.element.get(0)).append("svg").classed(LineDotChart.Identity["class"], !0), 
                        this.root.on("click", function(d) {
                            _this.clearSelection();
                        }), this.main = this.root.append("g"), this.axes = this.main.append("g").classed(LineDotChart.Axes["class"], !0), 
                        this.axisX = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.axisY = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), 
                        this.axisY2 = this.axes.append("g").classed(LineDotChart.Axis["class"], !0), this.legends = this.main.append("g").classed(LineDotChart.Legends["class"], !0), 
                        this.line = this.main.append("g").classed(LineDotChart.Values["class"], !0), this.colors = options.style && options.style.colorPalette ? options.style.colorPalette.dataColors : new visuals.DataColorPalette();
                    }, LineDotChart.prototype.update = function(options) {
                        if (options.dataViews && options.dataViews[0]) {
                            var viewport = options.viewport, model = this.model = this.converter(options.dataViews[0], viewport);
                            this.clearSelection(), this.resize(viewport), this.draw(model);
                        }
                    }, LineDotChart.prototype.destroy = function() {
                        this.root = null;
                    }, LineDotChart.prototype.setIsStopped = function(isstopped) {
                        var objects = {
                            merge: [ {
                                objectName: "misc",
                                selector: void 0,
                                properties: {
                                    isstopped: isstopped
                                }
                            } ]
                        };
                        this.hostServices.persistProperties(objects), this.hostServices.onSelect({
                            data: []
                        });
                    }, LineDotChart.prototype.enumerateObjectInstances = function(options) {
                        var instances = [];
                        if (!this.model || !this.model.settings) return instances;
                        var settings = this.model.settings;
                        switch (options.objectName) {
                          case "lineoptions":
                            var lineoptions = {
                                objectName: "lineoptions",
                                displayName: "lineoptions",
                                selector: null,
                                properties: {
                                    fill: settings.lineFill,
                                    lineThickness: settings.lineThickness
                                }
                            };
                            instances.push(lineoptions);
                            break;

                          case "dotoptions":
                            var dotoptions = {
                                objectName: "dotoptions",
                                displayName: "dotoptions",
                                selector: null,
                                properties: {
                                    color: settings.dotFill,
                                    dotSizeMin: settings.dotSizeMin,
                                    dotSizeMax: settings.dotSizeMax
                                }
                            };
                            instances.push(dotoptions);
                            break;

                          case "counteroptions":
                            var counteroptions = {
                                objectName: "counteroptions",
                                displayName: "counteroptions",
                                selector: null,
                                properties: {
                                    counterTitle: settings.counterTitle
                                }
                            };
                            instances.push(counteroptions);
                            break;

                          case "misc":
                            var misc = {
                                objectName: "misc",
                                displayName: "misc",
                                selector: null,
                                properties: {
                                    isanimated: settings.isanimated,
                                    isstopped: settings.isstopped,
                                    duration: settings.duration
                                }
                            };
                            instances.push(misc);
                        }
                        return instances;
                    }, LineDotChart.prototype.selectDot = function(dotelement, selector) {
                        var dot = d3.select(dotelement);
                        dot.classed("point_selected") ? this.clearSelection() : (selector && this.selectionManager.select(selector), 
                        this.root.classed("filtered", !0), this.line.selectAll("circle.point").classed("point_selected", !1), 
                        d3.select(dotelement).classed("point_selected", !0)), d3.event.stopPropagation();
                    }, LineDotChart.prototype.clearSelection = function() {
                        this.root.classed("filtered", !1), this.root.selectAll("circle.point").classed("point_selected", !1), 
                        this.selectionManager.clear();
                    }, LineDotChart.prototype.converter = function(dataView, viewport) {
                        if (!(dataView.categorical && dataView.categorical.categories && dataView.categorical.categories[0] && dataView.categorical.categories[0].values && dataView.categorical.categories[0].values.length > 0 && dataView.categorical && dataView.categorical.values && dataView.categorical.values[0] && dataView.categorical.values[0].values && dataView.categorical.values[0].values.length > 0)) return null;
                        var metadataColumn, extent, min, max, values = [], that = this, categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, !0);
                        this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                        var formatter, isScalar = !0, settings = this.parseSettings(dataView), effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize), effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize), format = "";
                        values = dataView.categorical.categories[0].values, metadataColumn = dataView.categorical.categories[0].source, 
                        extent = d3.extent(values), this.isDateTime ? (min = extent[0].getTime(), max = extent[1].getTime(), 
                        min = new Date(min), max = new Date(max + .05 * (max - min)), format = "MMM dd yyyy", 
                        formatter = visuals.valueFormatter.create({
                            format: format
                        })) : (min = extent[0], max = extent[1], max += .05 * (max - min), formatter = visuals.valueFormatter.create({
                            value: 0
                        }));
                        var xAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveWidth,
                            dataDomain: [ min, max ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !0,
                            isScalar: isScalar,
                            isVertical: !1,
                            forcedTickCount: void 0,
                            useTickIntervalForDisplayUnits: !0,
                            getValueFn: function(index, type) {
                                return that.isDateTime ? formatter.format(new Date(index)) : index;
                            }
                        });
                        xAxis.formatter = formatter, metadataColumn = dataView.categorical.values[0].source, 
                        values = dataView.categorical.values[0].values, extent = d3.extent(values), min = extent[0], 
                        max = extent[1];
                        for (var selector, result = [], value_sum = 0, value = 0, time = 0, i = 0; i < dataView.categorical.categories[0].values.length; i++) value = dataView.categorical.values[0].values[i], 
                        time = dataView.categorical.categories[0].values[i], value_sum += value, selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]), 
                        result.push({
                            dot: (value - min) / (max - min),
                            value: value,
                            sum: value_sum,
                            time: time,
                            selector: selector
                        });
                        value_sum += .1 * (value_sum - min);
                        var yAxis = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        }), yAxis2 = visuals.AxisHelper.createAxis({
                            pixelSpan: effectiveHeight,
                            dataDomain: [ min, value_sum ],
                            metaDataColumn: metadataColumn,
                            formatString: null,
                            outerPadding: 0,
                            isCategoryAxis: !1,
                            isScalar: !0,
                            isVertical: !0,
                            useTickIntervalForDisplayUnits: !0
                        });
                        return yAxis2.axis.orient("right"), {
                            points: result,
                            settings: settings,
                            xAxis: xAxis,
                            yAxis: yAxis,
                            yAxis2: yAxis2,
                            legends: this.generateAxisLabels(viewport, settings)
                        };
                    }, LineDotChart.prototype.parseSettings = function(dataView) {
                        if (!(dataView && dataView.metadata && dataView.metadata.columns && dataView.metadata.columns[0])) return null;
                        var objects = dataView.metadata.objects, lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill), dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill), xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle, yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
                        dataView.categorical.categories[0] && dataView.categorical.categories[0].source && dataView.categorical.categories[0].source.displayName && dataView.categorical.values[0] && dataView.categorical.values[0].source && dataView.categorical.values[0].source.displayName && (xAxisTitle = dataView.categorical.categories[0].source.displayName, 
                        yAxisTitle = dataView.categorical.values[0].source.displayName);
                        var lineThickness = LineDotChart.DefaultSettings.lineThickness, dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin, dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax, counterTitle = LineDotChart.DefaultSettings.counterTitle, isanimated = LineDotChart.DefaultSettings.isanimated, isstopped = LineDotChart.DefaultSettings.isstopped, duration = LineDotChart.DefaultSettings.duration;
                        return objects && (lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness), 
                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin), 
                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax), 
                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle), 
                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated), 
                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped), 
                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration)), 
                        {
                            xAxisTitle: xAxisTitle,
                            yAxisTitle: yAxisTitle,
                            lineFill: lineFillColorHelper.getColorForMeasure(objects, ""),
                            lineThickness: lineThickness,
                            dotFill: dotFillColorHelper.getColorForMeasure(objects, ""),
                            dotSizeMin: dotSizeMin,
                            dotSizeMax: dotSizeMax,
                            counterTitle: counterTitle,
                            isstopped: isstopped,
                            isanimated: isanimated,
                            duration: duration
                        };
                    }, LineDotChart.prototype.generateAxisLabels = function(viewport, settings) {
                        return [ {
                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, viewport.height - this.margin.top - this.margin.bottom),
                            text: settings.xAxisTitle,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
                            text: settings.yAxisTitle,
                            dx: "3em"
                        } ];
                    }, LineDotChart.prototype.resize = function(viewport) {
                        this.root.attr({
                            height: Math.max(0, viewport.height),
                            width: Math.max(0, viewport.width)
                        }), this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.legends.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top)), 
                        this.line.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axes.attr("transform", visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0)), 
                        this.axisX.attr("transform", visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize)), 
                        this.axisY2.attr("transform", visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
                    }, LineDotChart.prototype.draw = function(model) {
                        var _this = this, that = this;
                        if (this.line.selectAll("*").remove(), this.legends.selectAll("*").remove(), this.axisX.selectAll("*").remove(), 
                        this.axisY.selectAll("*").remove(), this.axisY2.selectAll("*").remove(), model && (this.renderLegends(model), 
                        model && model.points && model.points.length)) {
                            if (this.axisX.call(model.xAxis.axis), this.axisY.call(model.yAxis.axis), this.axisY2.call(model.yAxis2.axis), 
                            model.settings.isanimated) {
                                var playBtn = this.line.append("g").classed("lineDotChart__playBtn", !0).attr("transform", "translate(40, 20)");
                                if (playBtn.append("circle").attr("r", 17), model.settings.isstopped) return playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform", "translate(-4,-8)"), 
                                void playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!1);
                                });
                                playBtn.append("path").attr("d", "M0 2l10 6-10 6z").attr("transform-origin", "center").attr("transform", "translate(6, 8) rotate(180)"), 
                                playBtn.append("rect").attr("width", "2").attr("height", "12").attr("transform", "translate(-7,-6)"), 
                                playBtn.on("click.lineDotChart__playBt", function() {
                                    that.setIsStopped(!0);
                                });
                            }
                            var clip = this.line.append("clipPath").attr("id", "lineClip").append("rect").attr("x", 0).attr("y", 0).attr("width", 1).attr("height", 1e4), line = d3.svg.line().x(function(d) {
                                return model.xAxis.scale(d.time);
                            }).y(function(d) {
                                return model.yAxis.scale(d.sum);
                            }), lineSelection = this.line.selectAll("path.plot").data([ model.points ]);
                            lineSelection.enter().append("path"), lineSelection.classed("plot", !0).attr("stroke", function(d, i) {
                                return model.settings.lineFill;
                            }).attr("stroke-width", model.settings.lineThickness).attr("d", line);
                            var totalLength = lineSelection.node().getTotalLength(), line_left = lineSelection.node().getPointAtLength(0).x, line_right = lineSelection.node().getPointAtLength(totalLength).x;
                            lineSelection.attr("clip-path", "url(" + location.href + "#lineClip)"), model.settings.isanimated ? clip.attr("x", line_left).interrupt().transition().ease("linear").duration(1e3 * model.settings.duration).attr("width", line_right - line_left) : clip.interrupt().attr("x", line_left).attr("width", line_right - line_left), 
                            lineSelection.exit().remove();
                            var point_time = 300, counter_time = 0, lineTipSelection = this.line.selectAll("circle.point").data(model.points), that = this;
                            lineTipSelection.enter().append("circle").attr("fill", model.settings.dotFill).attr("opacity", .77).attr("r", function(d) {
                                return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin);
                            }).classed("point", !0).on("mouseover.point", this.showDataPoint).on("mouseout.point", this.hideDataPoint).on("click.point", function(d) {
                                that.selectDot(this, d.selector);
                            }), model.settings.isanimated ? lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(0.005)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).ease("linear").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(3.4)";
                            }).transition().duration(point_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration) + point_time;
                            }).ease("elastic").attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }) : lineTipSelection.interrupt().attr("transform", function(d) {
                                return "translate(" + model.xAxis.scale(d.time) + " " + model.yAxis.scale(d.sum) + ") scale(1)";
                            }), lineTipSelection.exit().remove();
                            for (var i = 0; i < lineTipSelection[0].length; i++) this.addTooltip(model, lineTipSelection[0][i]);
                            var lineTextSelection = this.line.selectAll("text").data(model.points);
                            lineTextSelection.enter().append("text").classed("text", !0).text(function(d, i) {
                                return model.settings.counterTitle + " " + (i + 1);
                            }).attr("x", line_right - 260).attr("y", 30), model.settings.isanimated ? lineTextSelection.attr("opacity", 0).interrupt().transition().duration(counter_time).delay(function(d, i) {
                                return _this.pointDelay(model.points, i, model.settings.duration);
                            }).attr("transform", "translate(0 0)").attr("opacity", 1).transition().duration(counter_time).delay(function(d, i) {
                                return model.points[i + 1] ? _this.pointDelay(model.points, i + 1, model.settings.duration) : Number.POSITIVE_INFINITY;
                            }).attr("opacity", 0) : lineTextSelection.interrupt().attr("transform", "translate(0 0)").attr("opacity", function(d, i) {
                                return Number(i === model.points.length - 1);
                            }), lineTextSelection.exit().remove();
                        }
                    }, LineDotChart.prototype.pointDelay = function(points, num, animation_duration) {
                        if (!points.length || !points[num] || 0 === num) return 0;
                        if (this.isDateTime) var time = points[num].time, min = points[0].time.getTime(), max = points[points.length - 1].time.getTime(), val = time.getTime(); else var time = points[num].time, min = points[0].time, max = points[points.length - 1].time, val = time;
                        return 1e3 * animation_duration * (val - min) / (max - min);
                    }, LineDotChart.prototype.showDataPoint = function(data, index) {
                        d3.select(this).classed("show", !0);
                    }, LineDotChart.prototype.hideDataPoint = function(data, index) {
                        d3.select(this).classed("show", !1);
                    }, LineDotChart.prototype.addTooltip = function(model, element) {
                        var selection = d3.select(element), data = selection.datum();
                        visuals.TooltipManager.addTooltip(selection, function(event) {
                            return [ {
                                displayName: model.settings.xAxisTitle,
                                value: model.xAxis.formatter.format(data.time)
                            }, {
                                displayName: model.settings.yAxisTitle,
                                value: data.value.toString()
                            } ];
                        });
                    }, LineDotChart.prototype.renderLegends = function(model) {
                        var legendSelection = this.legends.selectAll(LineDotChart.Legend.selector).data(model.legends);
                        legendSelection.enter().append("svg:text"), legendSelection.attr("x", 0).attr("y", 0).attr("dx", function(item) {
                            return item.dx;
                        }).attr("dy", function(item) {
                            return item.dy;
                        }).attr("transform", function(item) {
                            return item.transform;
                        }).text(function(item) {
                            return item.text;
                        }).classed(LineDotChart.Legend["class"], !0), legendSelection.exit().remove();
                    }, LineDotChart.DefaultSettings = {
                        lineFill: "rgb(102, 212, 204)",
                        lineThickness: 3,
                        dotFill: "#005c55",
                        dotSizeMin: 4,
                        dotSizeMax: 38,
                        counterTitle: "Total features",
                        xAxisTitle: "",
                        yAxisTitle: "",
                        duration: 20,
                        isanimated: !0,
                        isstopped: !0
                    }, LineDotChart.capabilities = {
                        dataRoles: [ {
                            name: "Date",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Date"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        dataViewMappings: [ {
                            conditions: [ {
                                Date: {
                                    min: 0,
                                    max: 1
                                },
                                Values: {
                                    min: 0,
                                    max: 1
                                },
                                Labels: {
                                    min: 0,
                                    max: 1
                                }
                            } ],
                            categorical: {
                                categories: {
                                    "for": {
                                        "in": "Date"
                                    },
                                    dataReductionAlgorithm: {
                                        sample: {}
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": "Values"
                                    }
                                }
                            }
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            },
                            lineoptions: {
                                displayName: "Line",
                                properties: {
                                    fill: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    lineThickness: {
                                        displayName: "Thickness",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            dotoptions: {
                                displayName: "Dot",
                                properties: {
                                    color: {
                                        displayName: powerbi.data.createDisplayNameGetter("Visual_Fill"),
                                        type: {
                                            fill: {
                                                solid: {
                                                    color: !0
                                                }
                                            }
                                        }
                                    },
                                    dotSizeMin: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    },
                                    dotSizeMax: {
                                        displayName: "Min size",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            },
                            counteroptions: {
                                displayName: "Counter",
                                properties: {
                                    counterTitle: {
                                        displayName: "Title",
                                        type: {
                                            text: !0
                                        }
                                    }
                                }
                            },
                            misc: {
                                displayName: "Animation",
                                properties: {
                                    isanimated: {
                                        displayName: "Animated",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    isstopped: {
                                        displayName: "Stop on load",
                                        type: {
                                            bool: !0
                                        }
                                    },
                                    duration: {
                                        displayName: "Time",
                                        type: {
                                            numeric: !0
                                        }
                                    }
                                }
                            }
                        }
                    }, LineDotChart.Identity = {
                        "class": "lineDotChart",
                        selector: ".lineDotChart"
                    }, LineDotChart.Axes = {
                        "class": "axes",
                        selector: ".axes"
                    }, LineDotChart.Axis = {
                        "class": "axis",
                        selector: ".axis"
                    }, LineDotChart.Legends = {
                        "class": "legends",
                        selector: ".legends"
                    }, LineDotChart.Legend = {
                        "class": "legend",
                        selector: ".legend"
                    }, LineDotChart.Values = {
                        "class": "line",
                        selector: ".line"
                    }, LineDotChart.Properties = {
                        general: {
                            formatString: {
                                objectName: "general",
                                propertyName: "formatString"
                            }
                        },
                        lineoptions: {
                            fill: {
                                objectName: "lineoptions",
                                propertyName: "fill"
                            },
                            lineThickness: {
                                objectName: "lineoptions",
                                propertyName: "lineThickness"
                            }
                        },
                        dotoptions: {
                            color: {
                                objectName: "dotoptions",
                                propertyName: "color"
                            },
                            dotSizeMin: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMin"
                            },
                            dotSizeMax: {
                                objectName: "dotoptions",
                                propertyName: "dotSizeMax"
                            }
                        },
                        counteroptions: {
                            counterTitle: {
                                objectName: "counteroptions",
                                propertyName: "counterTitle"
                            }
                        },
                        misc: {
                            isanimated: {
                                objectName: "misc",
                                propertyName: "isanimated"
                            },
                            isstopped: {
                                objectName: "misc",
                                propertyName: "isstopped"
                            },
                            duration: {
                                objectName: "misc",
                                propertyName: "duration"
                            }
                        }
                    }, LineDotChart;
                }();
                samples.LineDotChart = LineDotChart;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var samples;
            !function(samples) {
                var SelectionManager = visuals.utility.SelectionManager;
                samples.sunburstRoleNames = {
                    nodes: "Nodes",
                    values: "Values"
                };
                var Sunburst = function() {
                    function Sunburst() {
                        this.total = 0;
                    }
                    return Sunburst.prototype.init = function(options) {
                        var _this = this;
                        this.arc = d3.svg.arc().startAngle(function(d) {
                            return d.x;
                        }).endAngle(function(d) {
                            return d.x + d.dx;
                        }).innerRadius(function(d) {
                            return Math.sqrt(d.y);
                        }).outerRadius(function(d) {
                            return Math.sqrt(d.y + d.dy);
                        }), this.colors = options.style.colorPalette.dataColors, this.selectionManager = new SelectionManager({
                            hostServices: options.host
                        }), this.svg = d3.select(options.element.get(0)).append("svg"), this.svg.classed("mainDrawArea", !0), 
                        this.g = this.svg.append("g"), this.g.classed("container", !0), this.svg.append("text").classed("sunBurstPercentageFixed", !0), 
                        this.svg.on("mousedown", function(d) {
                            _this.svg.selectAll("path").style("opacity", 1), _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0), 
                            _this.selectionManager.clear();
                        });
                    }, Sunburst.setAllUnhide = function(selection) {
                        selection.attr("setUnHide", "true");
                    }, Sunburst.prototype.update = function(options) {
                        if (options.dataViews.length > 0) {
                            var data = this.converter(options.dataViews[0], this.colors);
                            this.viewport = options.viewport, this.updateInternal(data);
                        }
                    }, Sunburst.prototype.updateInternal = function(dataRootNode) {
                        var _this = this;
                        this.svg.attr({
                            height: this.viewport.height,
                            width: this.viewport.width
                        }), this.g.attr("transform", visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                        var radius = Math.min(this.viewport.width, this.viewport.height) / 2, partition = d3.layout.partition().size([ 2 * Math.PI, radius * radius ]).value(function(d) {
                            return d.value;
                        }), path = this.g.datum(dataRootNode).selectAll("path").data(partition.nodes);
                        path.enter().append("path"), path.attr("display", function(d) {
                            return d.depth ? null : "none";
                        }).attr("d", this.arc).style("stroke", "#fff").style("fill", function(d) {
                            return d.color;
                        }).style("fill-rule", "evenodd").on("mousedown", function(d) {
                            d.selector && _this.selectionManager.select(d.selector), d3.selectAll("path").call(Sunburst.setAllUnhide).attr("setUnHide", null), 
                            _this.highlightPath(d, _this, !0);
                            var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed"), percentage = 0 === _this.total ? 0 : (100 * d.total / _this.total).toPrecision(3);
                            percentageFixedText.text(d ? percentage + "%" : ""), percentageFixedText.style("fill", d.color), 
                            _this.onResize(), event.stopPropagation();
                        }), this.renderTooltip(path), path.exit().remove(), this.onResize();
                    }, Sunburst.getTreePath = function(node) {
                        for (var path = [], current = node; current.parent; ) path.unshift(current), current = current.parent;
                        return path;
                    }, Sunburst.prototype.onResize = function() {
                        var width = this.viewport.width, height = this.viewport.height, percentageFixedText = this.svg.select(".sunBurstPercentageFixed"), textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                        percentageFixedText.style("opacity", 1), percentageFixedText.attr("y", height / 2 + 4), 
                        percentageFixedText.attr("x", width / 2 - textWidth / 2);
                    }, Sunburst.prototype.highlightPath = function(d, sunBurst, setUnhide) {
                        var parentsArray = d ? Sunburst.getTreePath(d) : [];
                        sunBurst.svg.selectAll("path").each(function() {
                            "true" !== d3.select(this).attr("setUnHide") && d3.select(this).style("opacity", Sunburst.minOpacity);
                        }), sunBurst.svg.selectAll("path").filter(function(node) {
                            return parentsArray.indexOf(node) >= 0;
                        }).each(function() {
                            d3.select(this).style("opacity", 1), setUnhide === !0 && d3.select(this).attr("setUnHide", "true");
                        });
                    }, Sunburst.prototype.renderTooltip = function(selection) {
                        visuals.TooltipManager.addTooltip(selection, function(tooltipEvent) {
                            return tooltipEvent.data.tooltipInfo;
                        });
                    }, Sunburst.getTooltipData = function(displayName, value) {
                        return [ {
                            displayName: displayName,
                            value: 0 > value ? "" : value.toString()
                        } ];
                    }, Sunburst.prototype.covertTreeNodeToSunBurstNode = function(originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                        var selector;
                        originParentNode.identity && (pathIdentity = pathIdentity.concat([ originParentNode.identity ]), 
                        selector = {
                            data: pathIdentity
                        });
                        var selectionId = 0 === pathIdentity.length ? null : new visuals.SelectionId(selector, !1), valueToSet = originParentNode.values ? originParentNode.values[0].value : 0, newSunNode = {
                            name: originParentNode.name,
                            value: Math.max(valueToSet, 0),
                            selector: selectionId,
                            total: valueToSet
                        };
                        if (originParentNode.value && (newSunNode.color = color ? color : colors.getColor(originParentNode.value).value), 
                        this.total += newSunNode.value, originParentNode.children && originParentNode.children.length > 0) {
                            newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1), newSunNode.children = [];
                            for (var i = 0; i < originParentNode.children.length; i++) {
                                var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                                newSunNode.children.push(newChild), newSunNode.total += newChild.total;
                            }
                        } else newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                        return sunburstParentNode && (newSunNode.parent = sunburstParentNode), newSunNode;
                    }, Sunburst.prototype.converter = function(dataView, colors) {
                        var colorScale = colors.getNewColorScale();
                        this.total = 0;
                        var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], void 0);
                        return root;
                    }, Sunburst.minOpacity = .2, Sunburst.roleNames = {
                        nodes: "Nodes",
                        values: "Values"
                    }, Sunburst.capabilities = {
                        dataRoles: [ {
                            name: Sunburst.roleNames.nodes,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Groups"
                        }, {
                            name: Sunburst.roleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        } ],
                        objects: {
                            general: {
                                displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                                properties: {
                                    formatString: {
                                        type: {
                                            formatting: {
                                                formatString: !0
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        dataViewMappings: [ {
                            conditions: [ {
                                Groups: {
                                    min: 0
                                },
                                Values: {
                                    max: 1
                                }
                            } ],
                            matrix: {
                                rows: {
                                    "for": {
                                        "in": Sunburst.roleNames.nodes
                                    }
                                },
                                values: {
                                    "for": {
                                        "in": Sunburst.roleNames.values
                                    }
                                }
                            }
                        } ]
                    }, Sunburst;
                }();
                samples.Sunburst = Sunburst;
            }(samples = visuals.samples || (visuals.samples = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi);
    window.powerbitests, window.InJs, window.debug, window.jasmine, window.Microsoft;
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var plugins;
            !function(plugins) {
                plugins.sunburstCustom = {
                    name: "sunburstCustom",
                    watermarkKey: "defaultWatermark",
                    capabilities: visuals.samples.Sunburst.capabilities,
                    create: function() {
                        return new visuals.samples.Sunburst();
                    }
                }, plugins.asterPlot = {
                    name: "asterPlot",
                    capabilities: visuals.samples.AsterPlot.capabilities,
                    create: function() {
                        return new visuals.samples.AsterPlot();
                    }
                }, plugins.tornadoChart = {
                    name: "tornadoChart",
                    capabilities: visuals.samples.TornadoChart.capabilities,
                    create: function() {
                        return new visuals.samples.TornadoChart();
                    }
                }, plugins.sankeyDiagram = {
                    name: "sankeyDiagram",
                    capabilities: visuals.samples.SankeyDiagram.capabilities,
                    create: function() {
                        return new visuals.samples.SankeyDiagram();
                    }
                }, plugins.mekkoChart = {
                    name: "mekkoChart",
                    watermarkKey: "mekko",
                    capabilities: visuals.samples.MekkoChart.capabilities,
                    create: function() {
                        return new visuals.samples.MekkoChart({
                            chartType: 0
                        });
                    },
                    customizeQuery: visuals.ColumnChart.customizeQuery,
                    getSortableRoles: function(visualSortableOptions) {
                        return visuals.ColumnChart.getSortableRoles(visualSortableOptions);
                    }
                }, plugins.bulletChart = {
                    name: "bulletChart",
                    capabilities: visuals.samples.BulletChart.capabilities,
                    create: function() {
                        return new visuals.samples.BulletChart();
                    }
                }, plugins.wordCloud = {
                    name: "wordCloud",
                    capabilities: visuals.samples.WordCloud.capabilities,
                    create: function() {
                        return new visuals.samples.WordCloud();
                    }
                }, plugins.chicletSlicer = {
                    name: "chicletSlicer",
                    capabilities: visuals.samples.ChicletSlicer.capabilities,
                    create: function() {
                        return new visuals.samples.ChicletSlicer();
                    }
                }, plugins.chordChart = {
                    name: "chordChart",
                    capabilities: visuals.samples.ChordChart.capabilities,
                    create: function() {
                        return new visuals.samples.ChordChart();
                    }
                }, plugins.enhancedScatterChart = {
                    name: "enhancedScatterChart",
                    capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                    create: function() {
                        return new visuals.samples.EnhancedScatterChart();
                    }
                }, plugins.radarChart = {
                    name: "radarChart",
                    capabilities: visuals.samples.RadarChart.capabilities,
                    create: function() {
                        return new visuals.samples.RadarChart();
                    }
                }, plugins.dotPlot = {
                    name: "dotPlot",
                    capabilities: visuals.samples.DotPlot.capabilities,
                    create: function() {
                        return new visuals.samples.DotPlot();
                    }
                }, plugins.histogram = {
                    name: "histogram",
                    capabilities: visuals.samples.Histogram.capabilities,
                    create: function() {
                        return new visuals.samples.Histogram();
                    }
                }, plugins.timeline = {
                    name: "timeline",
                    capabilities: visuals.samples.Timeline.capabilities,
                    create: function() {
                        return new visuals.samples.Timeline();
                    }
                }, plugins.forceGraph = {
                    name: "forceGraph",
                    capabilities: visuals.samples.ForceGraph.capabilities,
                    create: function() {
                        return new visuals.samples.ForceGraph();
                    }
                }, plugins.gantt = {
                    name: "gantt",
                    capabilities: visuals.samples.Gantt.capabilities,
                    create: function() {
                        return new visuals.samples.Gantt();
                    }
                }, plugins.streamGraph = {
                    name: "streamGraph",
                    capabilities: visuals.samples.StreamGraph.capabilities,
                    create: function() {
                        return new visuals.samples.StreamGraph();
                    }
                }, plugins.lineDotChart = {
                    name: "lineDotChart",
                    capabilities: visuals.samples.LineDotChart.capabilities,
                    create: function() {
                        return new visuals.samples.LineDotChart();
                    }
                }, plugins.dropdownSlicer = {
                    name: "dropdownSlicer",
                    capabilities: visuals.samples.DropdownSlicer.capabilities,
                    create: function() {
                        return new visuals.samples.DropdownSlicer();
                    }
                };
            }(plugins = visuals.plugins || (visuals.plugins = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
}, function(module, exports) {
    var powerbi, powerbi = (window.jsCommon, window.powerbi), __extends = (window.powerbitests, 
    window.InJs, window.debug, window.jasmine, window.Microsoft, this && this.__extends || function(d, b) {
        function __() {
            this.constructor = d;
        }
        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
    });
    !function(powerbi) {
        var visuals;
        !function(visuals) {
            var visualPluginFactory;
            !function(visualPluginFactory) {
                function createCustomVisualPluginService() {
                    return new CustomVisualPluginService();
                }
                var CustomVisualPluginService = function(_super) {
                    function CustomVisualPluginService() {
                        _super.call(this, {}), this.initCustomVisualPlugins();
                    }
                    return __extends(CustomVisualPluginService, _super), CustomVisualPluginService.prototype.getVisuals = function() {
                        var registry = this.customVisualPlugins, names = Object.keys(registry);
                        return names.map(function(name) {
                            return registry[name];
                        });
                    }, CustomVisualPluginService.prototype.getPlugin = function(type) {
                        if (!type) return null;
                        var plugin = this.customVisualPlugins[type];
                        return plugin ? plugin : null;
                    }, CustomVisualPluginService.prototype.capabilities = function(type) {
                        var plugin = this.getPlugin(type);
                        return plugin ? plugin.capabilities : {};
                    }, CustomVisualPluginService.prototype.initCustomVisualPlugins = function() {
                        visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, function() {
                            return new visuals.samples.AsterPlot();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, function() {
                            return new visuals.samples.TornadoChart({
                                animator: new visuals.BaseAnimator()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, function() {
                            return new visuals.samples.SankeyDiagram();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, function() {
                            return new visuals.samples.MekkoChart({
                                chartType: 0,
                                isScrollable: !0,
                                animator: new visuals.WebColumnChartAnimator(),
                                behavior: new visuals.CartesianChartBehavior([ new visuals.ColumnChartWebBehavior() ])
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, function() {
                            return new visuals.samples.BulletChart();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, function() {
                            return new visuals.samples.WordCloud({
                                animator: new visuals.BaseAnimator()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, function() {
                            return new visuals.samples.ChicletSlicer({
                                behavior: new visuals.samples.ChicletSlicerWebBehavior()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, function() {
                            return new visuals.samples.EnhancedScatterChart();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, function() {
                            return new visuals.samples.RadarChart({
                                animator: new visuals.BaseAnimator()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, function() {
                            return new visuals.samples.DotPlot({
                                animator: new visuals.BaseAnimator()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, function() {
                            return new visuals.samples.Histogram({
                                animator: new visuals.BaseAnimator()
                            });
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, function() {
                            return new visuals.samples.ForceGraph();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, function() {
                            return new visuals.samples.Gantt();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, function() {
                            return new visuals.samples.StreamGraph();
                        }), visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dropdownSlicer, function() {
                            return new visuals.samples.DropdownSlicer({
                                behavior: new visuals.samples.DropdownSlicerWebBehavior()
                            });
                        });
                    }, CustomVisualPluginService;
                }(visualPluginFactory.VisualPluginService);
                visualPluginFactory.CustomVisualPluginService = CustomVisualPluginService, visualPluginFactory.createCustomVisualPluginService = createCustomVisualPluginService;
            }(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
        }(visuals = powerbi.visuals || (powerbi.visuals = {}));
    }(powerbi || (powerbi = {}));
} ]);